' Moteur/SHELL CpcdosC+ - Interpreteur commandes

' Par Sebastien FAVIER
' Reecriture le 16/01/2017
' Mise a jour le 27/06/2020

' 27-01-2020	: Modification du texte de GUI/
'					Ajout de la commande ACUTALISER/
' 16-10-2018	: Adaptation 2.1 beta 1.1
' 17-01-2018	: CORRECTION de la commande Fermer/ (Close/ en angais)
'					La fermeture par le Handle, et Thread ID ne fonctionnait pas
'					+ Ajout du parametre SYS/ /BITMAP , /LISTE , /TAILLE , /RECHARGER
' 17-12-2017	: AJOUT du CheckBox/ et de l'effet de survole
'					+ AJOUT de l'effet de survole du bouton
' 16-12-2017	: AJOUT de l'argument DIR/ /B pour afficher les informations breves des repertoires
' 14-12-2017	: AJOUT des parametres SYS/ /OS:NomDeOS pour switcher sur un autre OS
'						Demarrer/ NomDeOS pour demarrer un OS
'						IUG/ /OS:NomDeOS Pour afficher le graphique d'un OS
' 11-12-2017	: CORRECTION des arguments de fonctions qui �taient ressortait toujours en majuscule.
' 06-12-2017	: CORRECTION IMPORTANTE de bugs d'allocation memoire a chaud
'					Ajout des scopes pour separer les bloc de memoires prives
' 22-11-2017	: AJOUT de BarreProgression/ (ProgressBar/ en anglais) et de la propriete .VALEUR (.VALUE en anglais)
' 21-11-2017 	: AJOUT de la commande REP/ (DIR/ en anglais) pour lister le contenu des repertoires avec les filtres '.\*'
' 19-11-2017	: MODIFICATION/OPTIMISATION de la leture des commentaires completement jumpe
'					+ CORRECTION de la lecture des fonctions en commentaires
' 14-11-2017	: CORRECTION de la commande anglaise "TextBlock/" qui n'�tait pas reconnue par le SHELL
'					Modification des varariables des executables "_EXE_**"
' 11-11-2017	: AJOUT (fin) des commandes SUPPRIMER/ RENOMMER/ DOSSIER/ COPIER/
' 07-11-2017	: CORRECTION d'un bug interne lors d'utilisation de variables apr�s l'utilisation d'une commande graphique
'					qui rempla�ait le num�ro de TID par celui de l'objet graphique en cours d'op�ration.
' 19-10-2017	: AJOUT de la possibilite de recuperer le contenu des proprietes graphiques via @#
'					+ Correction le 31-10-2017 en ajoutant le nom de variable apres le '#' et lancer un FIX/
' 19-09-2017	: AJOUT du parametre SYS/ /PROCESSUS pour creer un nouveau processus et donc nouveau PID
' 17-09-2017	: AJOUT des fonctions de fermeture des objets par HANDLE et NOM processus
' 15-09-2017	: AJOUT de la notion du 'handle' pour unifier toutes instance graphiques
' 17-08-2017	: AJOUT des commandes de gestion des ports COM
' 14-08-2017	: AJOUT de la precision evenementielle (Preciser le ou les nom d'evenements)
'					Afin d'optimiser la recherche de fonctions.
' 18-07-2017	: AJOUT de SYS/ /OS avec
'					+ /update pour mettre a jour la liste des OS
'					+ /Liste pour afficher la liste des OS
'					+ /nb pour afficher le nombre d'OS
' 06-07-2017	: CORRECTION d'un probleme de fonctions introuvables declares lies a la case. Elle n'est plus sensible!
' 21-06-2017	: AJOUT du support de la modification des proprietes graphiques pour la fenetre.
' 30-05-2017	: AJOUT de la propriete PARAMETRES pour les fenetres.
'					+ Renommage de la propriete TYPE en PARAMETRES (+picturebox)
' 29-05-2017	: AJOUT des proprietes ICONE et environnement graphique personnalisables depuis EV_GUI.CPC
' 26-05-2017	: AJOUT du support evenementielle du CLIC sur picturebox
' 11-05-2017	: CORRECTIONS Sleeps + "SYS/ /DEBUG"
' 09-05-2017	: CORRECTION de la confusion du thread SERVEUR et CLIENT qui affiche "cr�e" alors que non
' 08-05-2017	: CORRECTION des problemes lie aux niveau de publicites
' 19-04-2017	: Correction du changement de resolution si /MENU = 1
'					+ Le 'recherche en mode standard' encombrant pour le debugage
' 18-04-2017	: Ajout de \#NON-FN et \#NO-FN pour ne pas executer les fonctions /F:
'					+ Correction de l'�cran noir apr�s un stopK/
' 14-04-2017	: Correction de \#PAUSE
' 11-04-2017	: Serveur/ Renvoie '1' s'il a bien ete cree.
' 07-04-2017	: Ajout de la section critique CpcdosC+.
'				: SI/ ajout de '=='
' 23-03-2017	: Jout de la gestion des tableaux
'					+ Creation de tableaux automatiques
' 22-03-2017	: Ajout de FIX/ /TOUCHE /ATOUCHE /KEY /AKEY
' 20-03-2017	: Correction bugs appel de fonctions -> Crash
'					+ Correction bug niveau privacite dans les fonctions
'					+ "double lecture" des lignes vides
'					+ ---> MEGA Optimisation
'					+ Correction Operande vide SI/ "" = ... toujours vraie
'					+ Bug SI/ N= ou !=
' 08-03-2017	: Correction bugs de PID & Cle + Retour valeur @# DANS les fonctions + SI/ != string
' 04-02-2017	: SERVEUR/ & CLIENT/ Ajout de l'attente ou attente en millisecondes d'une reception requete avec /ATTENDRE ou /WAIT
' 02-03-2017	: Ajout de FIX/ /Q
' 01-03-2017	: Ajout de \#PAUSE pour mettre en pause les defilement
' 24-02-2017	: Amelioration des erreurs serveur/ client/
' 23-02-2017	: Correction de la commande "Client/ /envoyer:n Serveur/ /stop:n" qui fonctionnait pas
' 22-02-2017 	: Correction & readaptation de la commande COULEURC/, ECRIRE/ et FONCTION/
' 16-02-2017	: FIX/ on peut mettre autant d'espaces avant "=" et meme sans avant et apres
' 14-02-2017	: Finalisation des commandes SERVEUR/ et CLIENT/


#include "cpcdos.bi"


#define _scope do
#define _end_scope loop while 0

#define _scope_CMD _scope
#define _end_scope_CMD _end_scope

#define _scope_SAUT_COMMANDE _scope
#define _end_scope_SAUT_COMMANDE _end_scope

Sub _SHELL_Cpcdos_OSx__._INIT_CpcdosCP_CMD()
	if CPCDOS_INSTANCE.Utilisateur_Langage = 0 Then
		DEBUG("[SHELL] Initialisation du shell ...",  CPCDOS_INSTANCE.DEBUG_INSTANCE.Ecran, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_SURBRILLE, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.NoCRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.AvecDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_CPCDOS, "")
	else
		DEBUG("[SHELL] Shell intialization...",  CPCDOS_INSTANCE.DEBUG_INSTANCE.Ecran, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_SURBRILLE, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.NoCRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.AvecDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_CPCDOS, "")
	End if
	this.Liste_CMD_FR(1) = "REM/"				: this.Liste_CMD_EN(1) = "REM/"
	this.Liste_CMD_FR(2) = "AIDE/"				: this.Liste_CMD_EN(2) = "HELP/"
	this.Liste_CMD_FR(3) = "CLS/"				: this.Liste_CMD_EN(3) = "CLS/"
	this.Liste_CMD_FR(4) = "TXT/"				: this.Liste_CMD_EN(4) = "TXT/"
	this.Liste_CMD_FR(5) = "FIX/"				: this.Liste_CMD_EN(5) = "SET/"
	this.Liste_CMD_FR(6) = "ALLER/"				: this.Liste_CMD_EN(6) = "GOTO/"
	this.Liste_CMD_FR(7) = "CCP/"				: this.Liste_CMD_EN(7) = "CCP/"
	this.Liste_CMD_FR(8) = "EXE/"				: this.Liste_CMD_EN(8) = "EXE/"
	this.Liste_CMD_FR(9) = "SYS/"				: this.Liste_CMD_EN(9) = "SYS/"
	this.Liste_CMD_FR(10) = "FERMER/"			: this.Liste_CMD_EN(10) = "CLOSE/"
	this.Liste_CMD_FR(11) = "COULEURC/"			: this.Liste_CMD_EN(11) = "COLORF/"
	this.Liste_CMD_FR(12) = "STOPK/"			: this.Liste_CMD_EN(12) = "STOPK/"
	this.Liste_CMD_FR(13) = "SERVEUR/"			: this.Liste_CMD_EN(13) = "SERVER/"
	this.Liste_CMD_FR(14) = "PING/"				: this.Liste_CMD_EN(14) = "PING/"
	this.Liste_CMD_FR(15) = "TELECHARGER/"		: this.Liste_CMD_EN(15) = "DOWNLOAD/"
	this.Liste_CMD_FR(16) = "DOS/"				: this.Liste_CMD_EN(16) = "DOS/"
	this.Liste_CMD_FR(17) = "CMD/"				: this.Liste_CMD_EN(17) = "CMD/"
	this.Liste_CMD_FR(18) = "LOGIN/"			: this.Liste_CMD_EN(18) = "LOGIN/"
	this.Liste_CMD_FR(19) = "OUVRIR/"			: this.Liste_CMD_EN(19) = "OPEN/"
	this.Liste_CMD_FR(20) = "TEXTEBLOC/"		: this.Liste_CMD_EN(20) = "TEXTBLOCK/" ' correction 14/07/2017 avec le 'LOC/'
	this.Liste_CMD_FR(21) = "SI/"				: this.Liste_CMD_EN(21) = "IF/"
	this.Liste_CMD_FR(22) = "FIN/"				: this.Liste_CMD_EN(22) = "END/"
	this.Liste_CMD_FR(23) = "FONCTION/"			: this.Liste_CMD_EN(23) = "FUNCTION/"
	this.Liste_CMD_FR(24) = "ECRIRE/"			: this.Liste_CMD_EN(24) = "WRITE/"
	this.Liste_CMD_FR(25) = "DECLARER/"			: this.Liste_CMD_EN(25) = "DECLARE/"
	this.Liste_CMD_FR(26) = "IUG/"				: this.Liste_CMD_EN(26) = "GUI/"
	this.Liste_CMD_FR(27) = "STOP/"				: this.Liste_CMD_EN(27) = "STOP/"
	this.Liste_CMD_FR(28) = "RETOUR/"			: this.Liste_CMD_EN(28) = "RETURN/"
	this.Liste_CMD_FR(29) = "FENETRE/"			: this.Liste_CMD_EN(29) = "WINDOW/"
	this.Liste_CMD_FR(30) = "CREER/"			: this.Liste_CMD_EN(30) = "CREATE/"
	this.Liste_CMD_FR(31) = "IMAGEBOX/"			: this.Liste_CMD_EN(31) = "PICTUREBOX/"
	this.Liste_CMD_FR(32) = "CLIENT/"			: this.Liste_CMD_EN(32) = "CLIENT/"
	this.Liste_CMD_FR(33) = "COULEURF/"			: this.Liste_CMD_EN(33) = "COLORB/"
	this.Liste_CMD_FR(34) = "BOUTON/"			: this.Liste_CMD_EN(34) = "BUTTON/"
	this.Liste_CMD_FR(35) = "POS/"				: this.Liste_CMD_EN(35) = "LOC/"
	this.Liste_CMD_FR(36) = "DEMARRER/"			: this.Liste_CMD_EN(36) = "START/"
	this.Liste_CMD_FR(37) = "SUPPRIMER/"		: this.Liste_CMD_EN(37) = "DELETE/"
	this.Liste_CMD_FR(38) = "COPIER/"			: this.Liste_CMD_EN(38) = "COPY/"
	this.Liste_CMD_FR(39) = "DEPLACER/"			: this.Liste_CMD_EN(39) = "MOVE/"
	this.Liste_CMD_FR(40) = "RENOMMER/"			: this.Liste_CMD_EN(40) = "RENAME/"
	this.Liste_CMD_FR(41) = "TEXTEBOX/"			: this.Liste_CMD_EN(41) = "TEXTBOX/"
	this.Liste_CMD_FR(42) = "DOSSIER/"			: this.Liste_CMD_EN(42) = "FOLDER/"
	this.Liste_CMD_FR(43) = "REP/"				: this.Liste_CMD_EN(43) = "DIR/"
	this.Liste_CMD_FR(44) = "BARREPROGRESSION/"	: this.Liste_CMD_EN(44) = "PROGRESSBAR/"
	this.Liste_CMD_FR(45) = "MESSAGE/"			: this.Liste_CMD_EN(45) = "MSGBOX/"
	this.Liste_CMD_FR(46) = "CHECKBOX/"			: this.Liste_CMD_EN(46) = "CHECKBOX/"
	this.Liste_CMD_FR(47) = "ACTUALISER/"		: this.Liste_CMD_EN(47) = "REFRESH/"
	this.Liste_CMD_FR(48) = "DECOMPRESSER/"		: this.Liste_CMD_EN(48) = "DECOMPRESS/"
	this.Liste_CMD_FR(49) = "COMPRESSER/"		: this.Liste_CMD_EN(49) = "COMPRESS/"
	' this.Liste_CMD_FR(50) = "fix/"			: this.Liste_CMD_EN(50) = "set/"
	' this.Liste_CMD_FR(51) = "fix/"			: this.Liste_CMD_EN(51) = "set/"
	' this.Liste_CMD_FR(52) = "fix/"			: this.Liste_CMD_EN(52) = "set/"
	' this.Liste_CMD_FR(53) = "fix/"			: this.Liste_CMD_EN(53) = "set/"

	' Proprietes de la GUI toujours a partir de 128. Ce qui laisse 127 Commande cpcdosc+
	this.Liste_CMD_FR(128) = ".COULEURTITRE"	: this.Liste_CMD_EN(128) = ".TITLECOLOR"
	this.Liste_CMD_FR(129) = ".NOM"				: this.Liste_CMD_EN(129) = ".NAME"
	this.Liste_CMD_FR(130) = ".PID"				: this.Liste_CMD_EN(130) = ".PID"
	this.Liste_CMD_FR(131) = ".PARAMETRES"		: this.Liste_CMD_EN(131) = ".PARAMETERS"
	this.Liste_CMD_FR(132) = ".PX"				: this.Liste_CMD_EN(132) = ".PX"
	this.Liste_CMD_FR(133) = ".PY"				: this.Liste_CMD_EN(133) = ".PY"
	this.Liste_CMD_FR(134) = ".TX"				: this.Liste_CMD_EN(134) = ".SX"
	this.Liste_CMD_FR(135) = ".TY"				: this.Liste_CMD_EN(135) = ".SY"
	this.Liste_CMD_FR(136) = ".COULEURFENETRE"	: this.Liste_CMD_EN(136) = ".WINDOWCOLOR"
	this.Liste_CMD_FR(137) = ".TITRE"			: this.Liste_CMD_EN(137) = ".TITLE"
	this.Liste_CMD_FR(138) = ".COULEURFOND"		: this.Liste_CMD_EN(138) = ".BACKCOLOR"
	this.Liste_CMD_FR(139) = ".ICONE"			: this.Liste_CMD_EN(139) = ".ICON"
	this.Liste_CMD_FR(140) = ".IMGTITRE"		: this.Liste_CMD_EN(140) = ".TITLEIMG"
	this.Liste_CMD_FR(141) = ".IMAGE"			: this.Liste_CMD_EN(141) = ".IMAGE"
	this.Liste_CMD_FR(142) = ".OPACITE"			: this.Liste_CMD_EN(142) = ".OPACITY"
	this.Liste_CMD_FR(143) = ".COULEURTEXTE"	: this.Liste_CMD_EN(143) = ".TEXTCOLOR"
	this.Liste_CMD_FR(144) = ".EVENEMENT"		: this.Liste_CMD_EN(144) = ".EVENT"
	this.Liste_CMD_FR(145) = ".TEXTE"			: this.Liste_CMD_EN(145) = ".TEXT"
	this.Liste_CMD_FR(146) = ".HANDLE"			: this.Liste_CMD_EN(146) = ".HANDLE"
	this.Liste_CMD_FR(147) = ".VALEUR"			: this.Liste_CMD_EN(147) = ".VALUE"
	' this.Liste_CMD_FR(148) = ".COULEURFOND"	: this.Liste_CMD_EN(148) = ".BACKCOLOR"
	' this.Liste_CMD_FR(149) = ".COULEURFOND"	: this.Liste_CMD_EN(149) = ".BACKCOLOR"
	' this.Liste_CMD_FR(150) = ".COULEURFOND"	: this.Liste_CMD_EN(150) = ".BACKCOLOR"


	' For index as uinteger = 0 to this.MEMOIRE_CCP.CpcdosCP_Variable_MAXI
		' this.MEMOIRE_CCP.CpcdosCP_Variable_Niveau1_nom(index)	= String(64, 0) ' Procedure
		' this.MEMOIRE_CCP.CpcdosCP_Variable_Niveau2_nom(index)	= String(64, 0) ' application
		' this.MEMOIRE_CCP.CpcdosCP_Variable_Niveau3_nom(index)	= String(64, 0) ' Utilisateur
		' this.MEMOIRE_CCP.CpcdosCP_Variable_Niveau4_nom(index)	= String(64, 0) ' OS
		' this.MEMOIRE_CCP.CpcdosCP_Variable_Niveau5_nom(index)	= String(64, 0) ' Kernel
	' Next index

	' For index as uinteger = 0 to this.MEMOIRE_CCP.CpcdosCP_Variable_MAXI
		' this.MEMOIRE_CCP.CpcdosCP_Variable_Niveau1_Donnees(index)	= String(256, 0) ' Procedure
		' this.MEMOIRE_CCP.CpcdosCP_Variable_Niveau2_Donnees(index)	= String(256, 0) ' application
		' this.MEMOIRE_CCP.CpcdosCP_Variable_Niveau3_Donnees(index)	= String(256, 0) ' Utilisateur
		' this.MEMOIRE_CCP.CpcdosCP_Variable_Niveau4_Donnees(index)	= String(256, 0) ' OS
		' this.MEMOIRE_CCP.CpcdosCP_Variable_Niveau5_Donnees(index)	= String(256, 0) ' Kernel
	' Next index

	' For index as uinteger = 0 to this.MEMOIRE_CCP._MAX_FONCTION_PUBLIC
		' this.MEMOIRE_CCP.TAB_FONCTION_CCP_ARG(index) = 280395
		' this.MEMOIRE_CCP.TAB_FONCTION_CCP_NIV(index) = 280395
		' this.MEMOIRE_CCP.TAB_FONCTION_CCP_NOM(index) = String(256, 0)
		' this.MEMOIRE_CCP.TAB_FONCTION_CCP_SRC(index) = String(256, 0)
	' Next index

	' RAZ

	For index as uinteger = 0 to this.MEMOIRE_CCP.CpcdosCP_Variable_MAXI
		this.MEMOIRE_CCP.CpcdosCP_Variable_Niveau1_nom(index)	= "" ' Procedure
		this.MEMOIRE_CCP.CpcdosCP_Variable_Niveau2_nom(index)	= ""  ' application
		this.MEMOIRE_CCP.CpcdosCP_Variable_Niveau3_nom(index)	= ""  ' Utilisateur
		this.MEMOIRE_CCP.CpcdosCP_Variable_Niveau4_nom(index)	= ""  ' OS
		this.MEMOIRE_CCP.CpcdosCP_Variable_Niveau5_nom(index)	= ""  ' Kernel
	Next index

	For index as uinteger = 0 to this.MEMOIRE_CCP.CpcdosCP_Variable_MAXI
		this.MEMOIRE_CCP.CpcdosCP_Variable_Niveau1_Donnees(index)	= ""  ' Procedure
		this.MEMOIRE_CCP.CpcdosCP_Variable_Niveau2_Donnees(index)	= ""  ' application
		this.MEMOIRE_CCP.CpcdosCP_Variable_Niveau3_Donnees(index)	= ""  ' Utilisateur
		this.MEMOIRE_CCP.CpcdosCP_Variable_Niveau4_Donnees(index)	= ""  ' OS
		this.MEMOIRE_CCP.CpcdosCP_Variable_Niveau5_Donnees(index)	= ""  ' Kernel
	Next index

	For index as uinteger = 0 to this.MEMOIRE_CCP._MAX_FONCTION_PUBLIC
		this.MEMOIRE_CCP.TAB_FONCTION_CCP_ARG(index) = 0
		this.MEMOIRE_CCP.TAB_FONCTION_CCP_NIV(index) = 0
		this.MEMOIRE_CCP.TAB_FONCTION_CCP_CLE(index) = 0
		this.MEMOIRE_CCP.TAB_FONCTION_CCP_NOM(index) = ""
		this.MEMOIRE_CCP.TAB_FONCTION_CCP_SRC(index) = ""
	Next index

	DEBUG("[OK]",  CPCDOS_INSTANCE.DEBUG_INSTANCE.Ecran, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_OK, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.SansDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_CPCDOS, "")
End sub


Function _SHELL_Cpcdos_OSx__.CpcdosCP_SHELL(ByVal _COMMANDE_ as String, byval _CLE_ as double, byval NIVEAU_CCP as integer, byval Param_1 as Integer, byval Param_2 as String) as String
	' Cette fonction permet d'interpreter une commande de syntaxe CpcdosC+ aux fonctionnalites du noyau
	' 	_COMMANDE_	: Commande CpcdosC+
	'	_PID_		: Numero PID du processus
	'	_TID_		: Numero TID du thread associe au processus
	'	Param_1		: ?
	'	Param_2		: ?

	On local Error Goto Intercept_Error

	' Retourne des donnees
	Dim testCMD					as integer
	Dim CommTrouve				as Integer
	Dim VerifierLabel			as Integer = 0
	Dim Numero_de_Ligne 		as Integer = 0
	Dim Nom_Fichier_DBG 		as String = ""
	Dim CommandesAide			as String
	Dim Message_erreur			as String
	Dim RetourVAR				as string
	Dim Commande				as String = _COMMANDE_


	' Recuperer les identifiants uniques
	Dim Auth_Kernel				as uinteger = CPCDOS_INSTANCE.get_id_kernel		(_CLE_)
	Dim Auth_OS					as uinteger = CPCDOS_INSTANCE.get_id_OS			(_CLE_)
	Dim Auth_Utilisateur		as uinteger = CPCDOS_INSTANCE.get_id_Utilisateur(_CLE_)
	Dim Auth_PID				as uinteger = CPCDOS_INSTANCE.get_id_PID		(_CLE_)
	Dim Auth_TID				as uinteger = CPCDOS_INSTANCE.get_id_TID		(_CLE_)

	' Supprimer toutes les espaces et/ou tabulations sur la gauche
	_COMMANDE_ = LTRIM(LTRIM(_COMMANDE_), CHR(09))

	' OPTIMISATION : La syntaxe CpcdosC+ n'a aucune commande faisant moins de 3 caracteres
	If LEN(_COMMANDE_) < 3 Then exit function

	' OPTIMISATION : Si la commande est "REM/" on quitte la fonction
	Scope
		Dim Test_REM as Integer = Instr(Ucase(_COMMANDE_), "REM/")
		Dim Test_CMD as Integer = 0

		' Si elle est presente, on verifie sa syntaxe
		If Test_REM > 0 Then
			IF NOT CCP_Verifier_Syntaxe(_COMMANDE_, Test_REM) > 10 Then Exit Function
		End if

		' Si la ligne commence par // ou par ' alors c'est un commentaire
		IF INSTR(_COMMANDE_, "// ") = 1 OR INSTR(_COMMANDE_, "//" & CHR(09)) = 1 OR INSTR(_COMMANDE_, "///") = 1 OR INSTR(_COMMANDE_, "' ") = 1 OR INSTR(_COMMANDE_, "''") = 1 Then Exit Function
	End Scope

	Commande = _COMMANDE_


	_scope

		Dim Slash_FN_Presend 		as boolean = FALSE
		Dim Non_Remplace 			as integer = 0
		Dim Non_Fonction 			as integer = 0
		Dim Position_CMD 			as integer = 0

		Dim CommPosition			as integer
		Dim TailleComm				as Integer
		Dim AfficherAide 			as Integer = 0 ' 1:Lister 2:Contenu
		Dim Affichage 				as Integer = CPCDOS_INSTANCE.DEBUG_INSTANCE.Ecran
		Dim Niveau_2				as Integer = 2
		Dim NoCMD					as Integer
		Dim Mess_Aide 				as String
		Dim tst_Cap					as String
		Dim CMD_tst					as String
		Dim OnCherche				as String
		Dim EXEC_FONCTION_FICHIER 	as String
		Dim CommLANG(0 to 3) 		as String ' 1:Francais 2:Anglais 3:ByteCode 4:?

		Dim Param					as String

		if Param_1 >= 330 Then
			RetourVAR = Param_2
		Else
			RetourVAR = ""
		end if


		DEBUG("[SHELL CC+] > " & Commande, CPCDOS_INSTANCE.DEBUG_INSTANCE.Ecran, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_Normal, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.AvecDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_CPCDOS, "")

		IF INSTR(Commande, "﻿") > 0 Then ' UTF-8
			Message_erreur = ERRAVT("AVT_079", 0)
			IF CPCDOS_INSTANCE.Utilisateur_Langage = 0 Then
				DEBUG("[CpcdosC+] " & Message_erreur & ". Des erreurs peuvent se produire.", CPCDOS_INSTANCE.DEBUG_INSTANCE.Ecran, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_AVERTISSEMENT, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.AvecDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_CPCDOS, "")
			Else
				DEBUG("[CpcdosC+] " & Message_erreur & ". Error can be requested.", CPCDOS_INSTANCE.DEBUG_INSTANCE.Ecran, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_AVERTISSEMENT, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.AvecDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_CPCDOS, "")
			End if

			testCMD = 1
			CommTrouve = 1
			exit _scope
		ElseIF INSTR(Commande, "��") > 0 Then ' UTF 16 Big Endian
			Message_erreur = ERRAVT("AVT_079", 0)
			IF CPCDOS_INSTANCE.Utilisateur_Langage = 0 Then
				DEBUG("[CpcdosC+] " & Message_erreur & ". Des erreurs peuvent se produire.", CPCDOS_INSTANCE.DEBUG_INSTANCE.Ecran, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_AVERTISSEMENT, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.AvecDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_CPCDOS, "")
			Else
				DEBUG("[CpcdosC+] " & Message_erreur & ". Error can be requested.", CPCDOS_INSTANCE.DEBUG_INSTANCE.Ecran, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_AVERTISSEMENT, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.AvecDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_CPCDOS, "")
			End if

			testCMD = 1
			CommTrouve = 1
			exit _scope
		ElseIF INSTR(Commande, "��") > 0 Then ' UTF 16 Little Endian
			Message_erreur = ERRAVT("AVT_079", 0)
			IF CPCDOS_INSTANCE.Utilisateur_Langage = 0 Then
				DEBUG("[CpcdosC+] " & Message_erreur & ". Des erreurs peuvent se produire.", CPCDOS_INSTANCE.DEBUG_INSTANCE.Ecran, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_AVERTISSEMENT, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.AvecDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_CPCDOS, "")
			Else
				DEBUG("[CpcdosC+] " & Message_erreur & ". Error can be requested.", CPCDOS_INSTANCE.DEBUG_INSTANCE.Ecran, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_AVERTISSEMENT, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.AvecDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_CPCDOS, "")
			End if

			testCMD = 1
			CommTrouve = 1
			exit _scope
		End if


		' Si le parametre \#Non-var est present alors on ne remplace pas la variable
		IF Instr(ucase(Commande), "\#NO") > 0 then
			IF Instr(ucase(Commande), "\#NON-VAR") > 0 then
				Non_Remplace = 1
				Commande = MID(Commande, 1, Instr(ucase(Commande), "\#NON-VAR")-1)
			elseIF Instr(ucase(Commande), "\#NO-VAR") > 0 then
				Non_Remplace = 1
				Commande = MID(Commande, 1, Instr(ucase(Commande), "\#NO-VAR")-1)
			elseIF Instr(ucase(Commande), "\#NO-FN") > 0 then
				Non_Fonction = 1
				Commande = MID(Commande, 1, Instr(ucase(Commande), "\#NO-FN")-1)
			elseIF Instr(ucase(Commande), "\#NON-FN") > 0 then
				Non_Fonction = 1
				Commande = MID(Commande, 1, Instr(ucase(Commande), "\#NON-FN")-1)
			end if
		else
			Non_Remplace = 0
			Non_Fonction = 0
		end if

		' Verifier que le parametre PAUSE est present
		IF Instr(ucase(Commande), "\#PAUSE") > 0 then
			' Verifier qu'il n'y a pas autre chose
			IF RetourVAR = "" Then
				RetourVAR = "#PAUSE"
			End if

			Commande = MID(Commande, 1, Instr(ucase(Commande), "\#PAUSE")-1)
		end if


		' Executer une fonction d'un fichier (DIRECT)
		IF Instr(UCASE(Commande), "##FONCTION=:") > 0 Then
			IF Instr(UCASE(Commande), ":=##") > 10 Then
				Dim Position1 as integer = Instr(UCASE(Commande), "##FONCTION=:") + 12
				Dim Position2 as integer = Instr(UCASE(Commande), ":=##")
				EXEC_FONCTION_FICHIER = MID(Commande, Position1, (Position2) - Position1)
				Commande = Ltrim(Ltrim(MID(Commande, Position2 + 4), chr(09)))
			End if
		End if


		IF Non_Fonction = 0 Then
			dim NePasExec as boolean = false

			' Si c'est une commande qui veut JUSTEMENT creer un thread pour la fonction
			if Instr(UCASE(Commande), "CMD/") > 0 Then
				IF Instr(UCASE(Commande), "/THREAD") > 0 Then
					NePasExec = true
				end if
			end if

			if NePasExec = false Then
				' Demande d'execution d'une fonction d'un fichier CpcdosC+
				IF Instr(UCASE(Commande), "/F:") > 0 AND Instr(UCASE(Commande), "(") > Instr(UCASE(Commande), "/F:") AND Instr(UCASE(Commande), ")") > Instr(UCASE(Commande), "(") Then
					Commande = CCP_Function(Commande, EXEC_FONCTION_FICHIER, _CLE_, NIVEAU_CCP, Param_1, Param_2)
					if mid(Commande, 1, 4) = "ERR_" Then
						return Commande
					end if
				END IF
			End if
		End if

		'
		IF Instr(UCASE(Commande), "/FN:") > 0 AND Instr(UCASE(Commande), "(") > Instr(UCASE(Commande), "/F:") AND Instr(UCASE(Commande), ")") > Instr(UCASE(Commande), "(") Then
			Non_Remplace = 1
			' Slash_FN_Presend = TRUE
		END IF

		' Verifier a nouveau que la commande fait au moins 3 caracteres
		IF LEN(Commande) < 3 Then
			' DEBUG("[SHELL CC+] > Erreur de syntaxe ''" & Commande & "''.", CPCDOS_INSTANCE.DEBUG_INSTANCE.Ecran, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_Normal, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.AvecDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_AFF, RetourVAR)
			CpcdosCP_SHELL = ""
			Exit function
		End if

		' Si il y a 2 '%' alors on va verifier si c'est une variable. Si oui on le remplace (OPTIMISATION)
		If InstrREV(Commande, "%") > Instr(Commande, "%") THEN
			' Remplacer toutes les variables par leur contenu
			IF Non_Remplace = 0 then Commande = CCP_Rempl_VAR(Commande, NIVEAU_CCP, Auth_Kernel, Auth_OS , Auth_Utilisateur, Auth_PID, Auth_TID, RetourVAR)
			if Commande = CPCDOS_INSTANCE._CONTENU_IMPROPABLE then exit _scope ' Variable introuvable
		end if

		' Si on execute une fonction on cree une nouvelle CLE ID APRES avoir charger
		'  le contenu des %variables% en arguments
		' IF NOT EXEC_FONCTION_FICHIER = "" THEN
			' IF CPCDOS_INSTANCE.SYSTEME_INSTANCE.get_DBG_DEBUG() > 0 Then
				' IF CPCDOS_INSTANCE.Utilisateur_Langage = 0 Then
					' DEBUG("[CpcdosC+] Redefinition de la cle d'identification de fonction", Affichage, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_ACTION, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.NoCRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.AvecDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_CPCDOS, RetourVAR)
				' Else
					' DEBUG("[CpcdosC+] Redefinition key ID for function", Affichage, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_ACTION, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.NoCRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.AvecDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_CPCDOS, RetourVAR)
				' End If
			' End if

			' ' Redefinition des cle d'identifications
			' Auth_TID = int(Auth_TID + CPCDOS_INSTANCE.Generer_RND(1, 99))
			' _CLE_ = CPCDOS_INSTANCE.Generer_cle(Auth_Kernel, Auth_OS, Auth_Utilisateur, Auth_PID, Auth_TID)

			' IF CPCDOS_INSTANCE.SYSTEME_INSTANCE.get_DBG_DEBUG() > 0 Then
				' DEBUG("[OK] --> CleID:" & _CLE_ & " [&B" & Bin(_CLE_, 36) & "] -> 0x" & hex(_CLE_, 10) & " (TID:" & Auth_TID & ")", Affichage, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_OK, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.SansDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_CPCDOS, RetourVAR)
			' End if
		' END IF

		' Calculer
		IF Instr(UCASE(Commande), "/C(") > 0 Then Commande = CCP_Calcul(Commande)

		' Verifer si c'est pas un label
		If InstrREV(Commande, ":") > Instr(Commande, ":") Then VerifierLabel = 1
		IF CPCDOS_INSTANCE.SYSTEME_INSTANCE.get_DBG_DEBUG() > 0 Then
			IF CPCDOS_INSTANCE.Utilisateur_Langage = 0 Then
				DEBUG("[CpcdosC+] Tentative d'execution : " & Commande & CRLF & " - CleID:" & Auth_PID & " [&B" & Bin(_CLE_, 36) & "] -> 0x" & hex(Auth_PID, 10) & CRLF & " - Size:" & LEN(Commande) & " bytes" & CRLF & " - Niveau:" & NIVEAU_CCP & CRLF & " - idKernel:" & Auth_Kernel & CRLF & " - idOS:" & Auth_OS & CRLF & " - idUtilisateur:" & Auth_Utilisateur & CRLF & " - PID:" & Auth_PID & CRLF & " - TID:" & Auth_TID, Affichage, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_ACTION, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.AvecDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_CPCDOS, RetourVAR)
			Else
				DEBUG("[CpcdosC+] Ready to executing : " & Commande & CRLF & " - CleID:" & Auth_PID & " [&B" & Bin(_CLE_, 36) & "] -> 0x" & hex(Auth_PID, 10) & CRLF & " - Size:" & LEN(Commande) & " bytes" & CRLF & " - Niveau:" & NIVEAU_CCP & CRLF & " - idKernel:" & Auth_Kernel & CRLF & " - idOS:" & Auth_OS & CRLF & " - idUtilisateur:" & Auth_Utilisateur & CRLF & " - PID:" & Auth_PID & CRLF & " - TID:" & Auth_TID, Affichage, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_ACTION, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.AvecDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_CPCDOS, RetourVAR)
			End if
		End if

		' Verifier a nouveau que la commande fait au moins 3 caracteres
		IF LEN(Commande) < 3 Then
			' DEBUG("[SHELL CC+] > Erreur de syntaxe ''" & Commande & "''.", CPCDOS_INSTANCE.DEBUG_INSTANCE.Ecran, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_Normal, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.AvecDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_AFF, RetourVAR)
			CpcdosCP_SHELL = ""
			Exit function
		End if

		' Ceci ameliore l'aspect du CpcdosC+ en terme de recherche des bonnes commandes
		CMD_tst = UCASE(Commande)
		OnCherche = ""

		' A partir d'ici, nous n'avions plus d'espaces au debut
		'  On cherche donc le prochain espace et on a la CMD!
		Position_CMD = 0

		' Capturer la cmd au la prochaine espace apres '/'
		tst_Cap = MID(CMD_tst, 1, Instr(CMD_tst, CHR(32)) - 1)
		IF NOT tst_Cap = "" then
			IF MID(tst_Cap, 1, 1) = CHR(64) Then ' Caractere '@'
				Position_CMD = Instr(CMD_tst, CHR(32))

				' Chercher le prochain espace apres l'espace precedent
				tst_Cap = MID(CMD_tst, 1, Instr(Position_CMD + 1, CMD_tst, CHR(32)) - 1)
			End if
		Else
			tst_Cap = CMD_tst
		END IF

		for Boucle as integer = 1 to this._MAX_CMD_CCP
			if boucle > this._MAX_CMD_CCP then exit for

			' DEV temporaire: Si commande vide alors on saute
			'  directement aux commandes graphiques
			IF this.Liste_CMD_FR(boucle) = "" AND boucle < 128 Then boucle = 128

			' Chercher la syntaxe Francophone
			IF Instr(tst_Cap, this.Liste_CMD_FR(Boucle)) > 0 Then
				TailleComm = LEN(this.Liste_CMD_FR(Boucle))
				CommPosition = Position_CMD
				OnCherche = Lcase(this.Liste_CMD_FR(Boucle))
				Exit for
			End if

			' Chercher la syntaxe Anglophone
			IF Instr(tst_Cap, this.Liste_CMD_EN(Boucle)) > 0 Then
				TailleComm = LEN(this.Liste_CMD_EN(Boucle))
				CommPosition = Position_CMD
				OnCherche = Lcase(this.Liste_CMD_EN(Boucle))
				Exit for
			End if

		Next Boucle

		' Rien n'a ete trouve, commande invalide!
		IF OnCherche = "" then exit _scope

		IF CPCDOS_INSTANCE.Utilisateur_Langage = 0 Then
			DEBUG("[SHELL CC+] > Execution de : " & Commande, CPCDOS_INSTANCE.DEBUG_INSTANCE.Ecran, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_Normal, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.AvecDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_CPCDOS, RetourVAR)
		Else
			DEBUG("[SHELL CC+] > Executing : " & Commande, CPCDOS_INSTANCE.DEBUG_INSTANCE.Ecran, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_Normal, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.AvecDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_CPCDOS, RetourVAR)
		End if


	_scope_CMD

		' ===============================================================
		'  Commande d'aide permettant d'afficher l'aide d'une commande
		' ===============================================================
		CommLANG(1) = "aide/"
		CommLANG(2) = "help/"
		CommLANG(3) = "\\#//"
		CommTrouve = 0 : NoCMD = 0
		for boucle as integer = 1 to 2
			IF OnCherche = CommLANG(boucle) Then
				NoCMD = 0
				exit for
			Else
				NoCMD = 1
			End if
		Next boucle
		IF CommLANG(1) = OnCherche Then CommTrouve = 1
		IF CommLANG(2) = OnCherche Then CommTrouve = 2
		IF CommTrouve > 0 Then
			Dim Mess_Debug 	as String
			' Tester la syntaxe
			testCMD	= CCP_Verifier_Syntaxe(Commande, CommPosition)
			IF testCMD > 10 Then exit _scope_CMD, _scope
			IF testCMD > 0 then  ' Entre 1-5 = Pas d'affichage via le @, @$ ou @#
				IF testCMD < 6 then
					Affichage = 0
					IF testCMD = 3 Then CpcdosCP_SHELL("FIX/ " & CPCDOS_INSTANCE.DEBUG_INSTANCE.LeRetour & " = \#NULL", _CLE_, NIVEAU_CCP, Param_1, Param_2) : RetourVAR = _CLE_ & "N" & NIVEAU_CCP & "->" & CPCDOS_INSTANCE.DEBUG_INSTANCE.LeRetour
					if testCMD = 2 Then RetourVAR = "$>" & CPCDOS_INSTANCE.DEBUG_INSTANCE.LeRetour ' ajouter une securite ?
				Else
					Affichage = 1
				END IF
			Else
				Affichage = 1
			END IF
			' Recuperer les Parametres
			Param = MID(Commande, CommPosition + TailleComm + 2)

			' ====================================================================

			Mess_Debug	= ""
			IF Param = "" then
				AfficherAide = 1 ' Lister
			else
				IF Param = " " then
					AfficherAide = 1 ' Lister
				ELSE
					AfficherAide = 2 ' Aide de la commande
					Commande = Ltrim(Ltrim(Rtrim(Rtrim(Rtrim(Rtrim(Param), chr(10)), chr(13)), chr(09))), CHR(09))
				END IF
			END IF
			IF CPCDOS_INSTANCE.Utilisateur_Langage = 0 then
				IF AfficherAide = 1 THEN
					Mess_Debug = "** Liste des commandes disponibles **"
				Else
					Mess_Debug = "** Aide pour la commande " & Commande & " **"
					OnCherche = Commande
				END IF
			ELSEIF CPCDOS_INSTANCE.Utilisateur_Langage = 1 then
				IF AfficherAide = 1 THEN
					Mess_Debug = "** Available commands list **"
				Else
					Mess_Debug = "** Help for " & Commande & " command **"
					OnCherche = Commande
				END IF
			END IF
			DEBUG(Mess_Debug, Affichage, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_SURBRILLE, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.SansDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_AFF, RetourVAR)

			' ====================================================================


		End if ' **** AIDE/ ****

	_end_scope_CMD

	_scope_CMD

		' ===============================================================
		'  Commentaire
		' ===============================================================
		CommLANG(1) = "rem/"
		CommLANG(2) = "rem/"
		CommLANG(3) = "\\#//"
		CommTrouve = 0 : NoCMD = 0
		for boucle as integer = 1 to 2
			IF OnCherche = CommLANG(boucle) Then
				NoCMD = 0
				exit for
			Else
				NoCMD = 1
			End if
		Next boucle
		IF NoCMD = 1 then CommLANG(1) = "[F.#).|" : CommLANG(2) = "[F.#).|" : CommLANG(3) = "\\#//"
		rem Afficher la liste des commandes avec anglais / francais
		IF AfficherAide = 1 then
			IF CPCDOS_INSTANCE.Utilisateur_Langage = 0 then
				CommandesAide = CommandesAide & CRLF & " rem/                       Ecrire un commentaire dans le code"
			Else
				CommandesAide = CommandesAide & CRLF & " rem/                       Write a comment in code"
			END IF
		END IF
		IF CommLANG(1) = OnCherche Then CommTrouve = 1
		IF CommLANG(2) = OnCherche Then CommTrouve = 2

		IF CommTrouve > 0 Then ' Afficher l'aide de la commande
			IF AfficherAide = 2 then
				Mess_Aide = ""
				IF CPCDOS_INSTANCE.Utilisateur_Langage = 0 THEN
					Mess_Aide = Mess_Aide & CRLF & "  'REMarque'"
					Mess_Aide = Mess_Aide & CRLF
					Mess_Aide = Mess_Aide & CRLF & "  Fonctionnalit�e :"
					Mess_Aide = Mess_Aide & CRLF & "   Cette commande n'a aucun effet, vous pouvez mettre autant de conneries"
					Mess_Aide = Mess_Aide & CRLF & "   que vous-voulez!"
					Mess_Aide = Mess_Aide & CRLF
					Mess_Aide = Mess_Aide & CRLF & "  Exemple :"
					Mess_Aide = Mess_Aide & CRLF & "   rem/ La ligne en dessou permet d'effacer l'ecran"
					Mess_Aide = Mess_Aide & CRLF & "   ' Ceci fonctionne aussi"
					Mess_Aide = Mess_Aide & CRLF & "   // Mais egalement ceci!"
					Mess_Aide = Mess_Aide & CRLF & "   cls/"
					Mess_Aide = Mess_Aide & CRLF & "   rem/ Bah voila c'est efface!"
					Mess_Aide = Mess_Aide & CRLF
				ELSEIF CPCDOS_INSTANCE.Utilisateur_Langage = 1 THEN
					Mess_Aide = Mess_Aide & CRLF & "  'REMark'"
					Mess_Aide = Mess_Aide & CRLF
					Mess_Aide = Mess_Aide & CRLF & "  Fonctionnality :"
					Mess_Aide = Mess_Aide & CRLF & "   This command hasn't effect, you can put all!"
					Mess_Aide = Mess_Aide & CRLF
					Mess_Aide = Mess_Aide & CRLF & "  Exemple :"
					Mess_Aide = Mess_Aide & CRLF & "   rem/ We will clean screen"
					Mess_Aide = Mess_Aide & CRLF & "   ' This works also"
					Mess_Aide = Mess_Aide & CRLF & "   // But also this!"
					Mess_Aide = Mess_Aide & CRLF & "   cls/"
					Mess_Aide = Mess_Aide & CRLF & "   txt/ Screen was cleaned"
					Mess_Aide = Mess_Aide & CRLF
				END IF
				DEBUG(Mess_Aide, Affichage, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_SURBRILLE, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.SansDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_AFF, RetourVAR)
				testCMD = 0
				AfficherAide = 0
				exit _scope_CMD, _scope
			END IF
			' Tester la syntaxe
			testCMD	= CCP_Verifier_Syntaxe(Commande, CommPosition)
			IF testCMD > 10 Then exit _scope_CMD, _scope

			exit _scope_CMD, _scope
		End if ' **** REM/ ****

	_end_scope_CMD


	_scope_CMD

		' ===============================================================
		'  Commande d'effacement de l'ecran
		' ===============================================================
		CommLANG(1) = "cls/"
		CommLANG(2) = "cls/"
		CommLANG(3) = "\\#//"
		CommTrouve = 0 : NoCMD = 0
		for boucle as integer = 1 to 2
			IF OnCherche = CommLANG(boucle) Then
				NoCMD = 0
				exit for
			Else
				NoCMD = 1
			End if
		Next boucle
		IF NoCMD = 1 then CommLANG(1) = "[F.#).|" : CommLANG(2) = "[F.#).|" : CommLANG(3) = "\\#//"
		rem Afficher la liste des commandes avec anglais / francais
		IF AfficherAide = 1 then
			IF CPCDOS_INSTANCE.Utilisateur_Langage = 0 then
				CommandesAide = CommandesAide & CRLF & " cls/                       Effacer l'�cran console LC"
			Else
				CommandesAide = CommandesAide & CRLF & " cls/                       Clear LC console screen"
			END IF
		END IF
		IF CommLANG(1) = OnCherche Then CommTrouve = 1
		IF CommLANG(2) = OnCherche Then CommTrouve = 2
		IF CommTrouve > 0 Then ' Afficher l'aide de la commande
			IF AfficherAide = 2 then
				Mess_Aide = ""
				IF CPCDOS_INSTANCE.Utilisateur_Langage = 0 THEN
					Mess_Aide = Mess_Aide & CRLF & "  'CLear Screen'"
					Mess_Aide = Mess_Aide & CRLF
					Mess_Aide = Mess_Aide & CRLF & "  Fonctionnalit�e :"
					Mess_Aide = Mess_Aide & CRLF & "   Cette commande permet d'�ffacer l'�cran de la console LC"
					Mess_Aide = Mess_Aide & CRLF
					Mess_Aide = Mess_Aide & CRLF & "  Exemple :"
					Mess_Aide = Mess_Aide & CRLF & "   txt/ Ce texte va disparaitre"
					Mess_Aide = Mess_Aide & CRLF & "   cls/"
					Mess_Aide = Mess_Aide & CRLF & "   txt/ Le texte a disparu"
					Mess_Aide = Mess_Aide & CRLF
					Mess_Aide = Mess_Aide & CRLF & "  Voir aussi : txt/ , couleurf/ , couleurp/"
					Mess_Aide = Mess_Aide & CRLF
				ELSEIF CPCDOS_INSTANCE.Utilisateur_Langage = 1 THEN
					Mess_Aide = Mess_Aide & CRLF & "  'CLear Screen'"
					Mess_Aide = Mess_Aide & CRLF
					Mess_Aide = Mess_Aide & CRLF & "  Fonctionnality :"
					Mess_Aide = Mess_Aide & CRLF & "   This command allow to clear LC console screen"
					Mess_Aide = Mess_Aide & CRLF
					Mess_Aide = Mess_Aide & CRLF & "    LC:[FR] Ligne de Commandes [EN] Commands line (no GUI)"
					Mess_Aide = Mess_Aide & CRLF
					Mess_Aide = Mess_Aide & CRLF & "  Exemple :"
					Mess_Aide = Mess_Aide & CRLF & "   txt/ This text will be deleted"
					Mess_Aide = Mess_Aide & CRLF & "   cls/"
					Mess_Aide = Mess_Aide & CRLF & "   txt/ Text has been deleted"
					Mess_Aide = Mess_Aide & CRLF
					Mess_Aide = Mess_Aide & CRLF & "  See also : txt/ , couleurf/ , couleurp/"
					Mess_Aide = Mess_Aide & CRLF
				END IF

				DEBUG(Mess_Aide, Affichage, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_SURBRILLE, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.SansDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_AFF, RetourVAR)
				testCMD = 0
				AfficherAide = 0
				exit _scope_CMD, _scope
			END IF
			' Tester la syntaxe
			testCMD	= CCP_Verifier_Syntaxe(Commande, CommPosition)
			IF testCMD > 10 Then exit _scope_CMD, _scope
			IF testCMD > 0 then  ' Entre 1-5 = Pas d'affichage via le @, @$ ou @#
				IF testCMD < 6 then
					Affichage = 0
					IF testCMD = 3 Then CpcdosCP_SHELL("FIX/ " & CPCDOS_INSTANCE.DEBUG_INSTANCE.LeRetour & " = \#NULL", _CLE_, NIVEAU_CCP, Param_1, Param_2) : RetourVAR = _CLE_ & "N" & NIVEAU_CCP & "->" & CPCDOS_INSTANCE.DEBUG_INSTANCE.LeRetour
					if testCMD = 2 Then RetourVAR = "$>" & CPCDOS_INSTANCE.DEBUG_INSTANCE.LeRetour ' ajouter une securite ?
				Else
					Affichage = 1
				END IF
			Else
				Affichage = 1
			END IF
			' Recuperer les Parametres
			Param = MID(Commande, CommPosition + TailleComm + 2)

			' ====================================================================

			IF CPCDOS_INSTANCE.SYSTEME_INSTANCE.get_DBG_DEBUG() > 0 Then
				IF CPCDOS_INSTANCE.Utilisateur_Langage = 0 Then
					DEBUG("[CpcdosC+] Effacement de l'ecran", Affichage, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_Normal, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.AvecDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_CPCDOS, RetourVAR)
				Else
					DEBUG("[CpcdosC+] Cleaning screen", Affichage, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_Normal, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.AvecDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_CPCDOS, RetourVAR)
				End if
			END IF


			DIM Trame_GUI_TXTBOX as String = "#GUI_TXTBOX:" ' Textebox --> Console graphique

			' Effacer le textebox si c'est lui qui a fait la demande
			if Instr(Param_2, Trame_GUI_TXTBOX) > 0 Then
				Dim Index_txtbox as integer = Val(Mid(Param_2, Instr(Param_2, Trame_GUI_TXTBOX) + Len(Trame_GUI_TXTBOX)))
				CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__TEXTBOX(Index_txtbox).Texte = ""
			else
				cls 0
			End if

			' ====================================================================

			exit _scope_CMD, _scope
		End if ' **** CLS/ ****

	_end_scope_CMD

	_scope_CMD

		' ===============================================================
		'  Commande d'effacement de l'ecran
		' ===============================================================
		CommLANG(1) = "supprimer/"
		CommLANG(2) = "delete/"
		CommLANG(3) = "\\#//"
		CommTrouve = 0 : NoCMD = 0
		for boucle as integer = 1 to 2
			IF OnCherche = CommLANG(boucle) Then
				NoCMD = 0
				exit for
			Else
				NoCMD = 1
			End if
		Next boucle
		IF NoCMD = 1 then CommLANG(1) = "[F.#).|" : CommLANG(2) = "[F.#).|" : CommLANG(3) = "\\#//"
		rem Afficher la liste des commandes avec anglais / francais
		IF AfficherAide = 1 then
			IF CPCDOS_INSTANCE.Utilisateur_Langage = 0 then
				CommandesAide = CommandesAide & CRLF & " supprimer/                 Supprimer un fichier"
			Else
				CommandesAide = CommandesAide & CRLF & " delete/                    Delete a file"
			END IF
		END IF
		IF CommLANG(1) = OnCherche Then CommTrouve = 1
		IF CommLANG(2) = OnCherche Then CommTrouve = 2
		IF CommTrouve > 0 Then ' Afficher l'aide de la commande
			IF AfficherAide = 2 then
				Mess_Aide = ""
				IF CPCDOS_INSTANCE.Utilisateur_Langage = 0 THEN
					Mess_Aide = Mess_Aide & CRLF & "  'Supprimer'"
					Mess_Aide = Mess_Aide & CRLF
					Mess_Aide = Mess_Aide & CRLF & "  Fonctionnalit�e :"
					Mess_Aide = Mess_Aide & CRLF & "   Cette commande permet de supprimer un fichier d'un support"
					Mess_Aide = Mess_Aide & CRLF
					Mess_Aide = Mess_Aide & CRLF & "  Exemple :"
					Mess_Aide = Mess_Aide & CRLF & "   Supprimer/ MonDossier/MonFichier.log"
					Mess_Aide = Mess_Aide & CRLF & "   Supprimer/ ../fichier.txt"
					Mess_Aide = Mess_Aide & CRLF
					Mess_Aide = Mess_Aide & CRLF & " A savoir que cpcdos supporte les deux formats '\' ou '/'"
					Mess_Aide = Mess_Aide & CRLF
					Mess_Aide = Mess_Aide & CRLF & "  Voir aussi : copier/ , deplacer/ , ouvrir/"
					Mess_Aide = Mess_Aide & CRLF
				ELSEIF CPCDOS_INSTANCE.Utilisateur_Langage = 1 THEN
					Mess_Aide = Mess_Aide & CRLF & "  'Delete'"
					Mess_Aide = Mess_Aide & CRLF
					Mess_Aide = Mess_Aide & CRLF & "  Fonctionnality :"
					Mess_Aide = Mess_Aide & CRLF & "   This command allow to delete a file from device"
					Mess_Aide = Mess_Aide & CRLF
					Mess_Aide = Mess_Aide & CRLF & "  Example :"
					Mess_Aide = Mess_Aide & CRLF & "   Delete/ MyDirectoy/MyFile.log"
					Mess_Aide = Mess_Aide & CRLF & "   delete/ MyFile.cpc"
					Mess_Aide = Mess_Aide & CRLF
					Mess_Aide = Mess_Aide & CRLF & " Good to know that cpcdos can support path formats '\' or '/'"
					Mess_Aide = Mess_Aide & CRLF
					Mess_Aide = Mess_Aide & CRLF & "  See also : copy/ , move/ , open/"
					Mess_Aide = Mess_Aide & CRLF
				END IF

				DEBUG(Mess_Aide, Affichage, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_SURBRILLE, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.SansDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_AFF, RetourVAR)
				testCMD = 0
				AfficherAide = 0
				exit _scope_CMD, _scope
			END IF
			' Tester la syntaxe
			testCMD	= CCP_Verifier_Syntaxe(Commande, CommPosition)
			IF testCMD > 10 Then exit _scope_CMD, _scope
			IF testCMD > 0 then  ' Entre 1-5 = Pas d'affichage via le @, @$ ou @#
				IF testCMD < 6 then
					Affichage = 0
					IF testCMD = 3 Then CpcdosCP_SHELL("FIX/ " & CPCDOS_INSTANCE.DEBUG_INSTANCE.LeRetour & " = \#NULL", _CLE_, NIVEAU_CCP, Param_1, Param_2) : RetourVAR = _CLE_ & "N" & NIVEAU_CCP & "->" & CPCDOS_INSTANCE.DEBUG_INSTANCE.LeRetour
					if testCMD = 2 Then RetourVAR = "$>" & CPCDOS_INSTANCE.DEBUG_INSTANCE.LeRetour ' ajouter une securite ?
				Else
					Affichage = 1
				END IF
			Else
				Affichage = 1
			END IF
			' Recuperer les Parametres
			Param = MID(Commande, CommPosition + TailleComm + 2)

			SCOPE
			' ====================================================================


			IF CPCDOS_INSTANCE.SYSTEME_INSTANCE.get_DBG_DEBUG() > 0 Then
				IF CPCDOS_INSTANCE.Utilisateur_Langage = 0 Then
					DEBUG("[CpcdosC+] Effacement du fichier '" & Param & "'", Affichage, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_Normal, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.AvecDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_CPCDOS, RetourVAR)
				Else
					DEBUG("[CpcdosC+] Deleting file '" & Param & "'", Affichage, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_Normal, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.AvecDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_CPCDOS, RetourVAR)
				End if
			END IF

			' INFO DU 29/09 : Faire une suppression avec l'option securise (plus lent)
			' INDEPENDANCE DOS --> Creer la fonction de suppression de fichier depuis CPinti Core


			Dim Resultat as integer = kill(Param) ' Utilisation Temporaire du CRT0 FreeBasic --> DOS

			If Resultat <> 0 Then
				' ERREUR
				DEBUG("0", Affichage, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_ERREUR, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.SansDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_AFF, RetourVAR)

				Dim Message_erreur as String = ERRAVT("ERR_061", 0)
				IF CPCDOS_INSTANCE.Utilisateur_Langage = 0 Then
					DEBUG("[CpcdosC+] " & Message_erreur & ". '" & Param & "'", Affichage, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_ERREUR, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.AvecDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_CPCDOS, RetourVAR)
				Else
					DEBUG("[CpcdosC+] " & Message_erreur & ". '" & Param & "'", Affichage, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_ERREUR, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.AvecDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_CPCDOS, RetourVAR)
				End if
			Else
				' OK
				DEBUG("OK", Affichage, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_OK, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.SansDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_AFF, RetourVAR)

				IF CPCDOS_INSTANCE.Utilisateur_Langage = 0 Then
					DEBUG("[CpcdosC+] Fichier '" & Param & "' a ete supprime!", Affichage, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_OK, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.AvecDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_CPCDOS, RetourVAR)
				Else
					DEBUG("[CpcdosC+] The file '" & Param & "' has been deleted!", Affichage, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_OK, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.AvecDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_CPCDOS, RetourVAR)
				End if
			End if

			' ====================================================================
			END SCOPE

			exit _scope_CMD, _scope
		End if ' **** SUPPRIMER/ ****

	_end_scope_CMD

	_scope_CMD

		' ===============================================================
		'  Commande d'effacement de l'ecran
		' ===============================================================
		CommLANG(1) = "copier/"
		CommLANG(2) = "copy/"
		CommLANG(3) = "\\#//"
		CommTrouve = 0 : NoCMD = 0
		for boucle as integer = 1 to 2
			IF OnCherche = CommLANG(boucle) Then
				NoCMD = 0
				exit for
			Else
				NoCMD = 1
			End if
		Next boucle
		IF NoCMD = 1 then CommLANG(1) = "[F.#).|" : CommLANG(2) = "[F.#).|" : CommLANG(3) = "\\#//"
		rem Afficher la liste des commandes avec anglais / francais
		IF AfficherAide = 1 then
			IF CPCDOS_INSTANCE.Utilisateur_Langage = 0 then
				CommandesAide = CommandesAide & CRLF & " copier/                    Copier un fichier dans un dossier"
			Else
				CommandesAide = CommandesAide & CRLF & " copy/                      Copy a file in a directory"
			END IF
		END IF
		IF CommLANG(1) = OnCherche Then CommTrouve = 1
		IF CommLANG(2) = OnCherche Then CommTrouve = 2
		IF CommTrouve > 0 Then ' Afficher l'aide de la commande
			IF AfficherAide = 2 then
				Mess_Aide = ""
				IF CPCDOS_INSTANCE.Utilisateur_Langage = 0 THEN
					Mess_Aide = Mess_Aide & CRLF & "  'Copier'"
					Mess_Aide = Mess_Aide & CRLF
					Mess_Aide = Mess_Aide & CRLF & "  Fonctionnalit�e :"
					Mess_Aide = Mess_Aide & CRLF & "   Cette commande permet de copier un fichier source dans un dossier"
					Mess_Aide = Mess_Aide & CRLF
					Mess_Aide = Mess_Aide & CRLF & "  Parametres disponibles :"
					Mess_Aide = Mess_Aide & CRLF & "    /Progression:NomDeVariable -> Stocke le pourcentage de la progression en cours"
					Mess_Aide = Mess_Aide & CRLF & "    /Octets:NomDeVariable -> Stocke le nombre d'octets copie de la progression en cours"
					Mess_Aide = Mess_Aide & CRLF & "    /OctetsParSec:NomDeVariable -> Stocke le nombre d'octets copie par secondes"
					Mess_Aide = Mess_Aide & CRLF
					Mess_Aide = Mess_Aide & CRLF & "  Exemple :"
					Mess_Aide = Mess_Aide & CRLF & "   Copier/ MonDossier/MonFichier.log MonAutreDossier/MonFichier.log"
					Mess_Aide = Mess_Aide & CRLF & "   Copier/ fichier.txt, MonDossier"
					Mess_Aide = Mess_Aide & CRLF
					Mess_Aide = Mess_Aide & CRLF & "  Vous pouvez recuperer le pourcentage de la progression depuis un autre thread"
					Mess_Aide = Mess_Aide & CRLF & "   via une variable de niveau 5 :"
					Mess_Aide = Mess_Aide & CRLF & "    Copier/ Source.txt, Destination.txt /Progression:MaVariable"
					Mess_Aide = Mess_Aide & CRLF & "      --> Et durant la copie, la variable %MaVariable% contient la progression en % de la copie"
					Mess_Aide = Mess_Aide & CRLF
					Mess_Aide = Mess_Aide & CRLF & "  Meme chose pour le nombre d'octets copie :"
					Mess_Aide = Mess_Aide & CRLF & "    Copier/ Source.txt, Destination.txt /Octets:MaVariable"
					Mess_Aide = Mess_Aide & CRLF
					Mess_Aide = Mess_Aide & CRLF & "  Le nombre d'octets par secondes :"
					Mess_Aide = Mess_Aide & CRLF & "    Copier/ Source.txt, Destination.txt /OctetsParSec:MaVariable"
					Mess_Aide = Mess_Aide & CRLF
					Mess_Aide = Mess_Aide & CRLF & "  Ou les 2 ou 3 parametres en meme temps aussi !"
					Mess_Aide = Mess_Aide & CRLF & "    Copier/ Source.txt, Destination.txt /Pogresson:Var1 /octets:Var2 /OctetsParSec:Var3"
					Mess_Aide = Mess_Aide & CRLF
					Mess_Aide = Mess_Aide & CRLF
					Mess_Aide = Mess_Aide & CRLF & " A savoir que cpcdos supporte les deux formats '\' ou '/'"
					Mess_Aide = Mess_Aide & CRLF
					Mess_Aide = Mess_Aide & CRLF & "  Voir aussi : supprimer/ , deplacer/ , ouvrir/"
					Mess_Aide = Mess_Aide & CRLF
				ELSEIF CPCDOS_INSTANCE.Utilisateur_Langage = 1 THEN
					Mess_Aide = Mess_Aide & CRLF & "  'copy'"
					Mess_Aide = Mess_Aide & CRLF
					Mess_Aide = Mess_Aide & CRLF & "  Fonctionnality :"
					Mess_Aide = Mess_Aide & CRLF & "   This command allow to copy a source file"
					Mess_Aide = Mess_Aide & CRLF
					Mess_Aide = Mess_Aide & CRLF & "  Avaiable parameters :"
					Mess_Aide = Mess_Aide & CRLF & "    /Progression:VariableName -> Put actual pourcentage during copy"
					Mess_Aide = Mess_Aide & CRLF & "    /Bytes:VariableName -> Put bytes number during copy"
					Mess_Aide = Mess_Aide & CRLF & "    /BytesBySec:VariableName -> Put number of byte copied by secondes"
					Mess_Aide = Mess_Aide & CRLF
					Mess_Aide = Mess_Aide & CRLF & "  Example :"
					Mess_Aide = Mess_Aide & CRLF & "   Copy/ MyDirectory/MyFile.log MyOtherDirectory/MyFile.log"
					Mess_Aide = Mess_Aide & CRLF & "   Copy/ File.txt, MyDirectory"
					Mess_Aide = Mess_Aide & CRLF
					Mess_Aide = Mess_Aide & CRLF & "  You can get pourcentage during copy from another thread with level 5 variable :"
					Mess_Aide = Mess_Aide & CRLF & "    Copy/ Source.txt, Destination.txt /Progression:MyVariable"
					Mess_Aide = Mess_Aide & CRLF & "      --> And during copy, variable %MyVariable% content the % of the copy"
					Mess_Aide = Mess_Aide & CRLF
					Mess_Aide = Mess_Aide & CRLF & "  Same thing with bytes :"
					Mess_Aide = Mess_Aide & CRLF & "    Copy/ Source.txt, Destination.txt /Bytes:MyVariable"
					Mess_Aide = Mess_Aide & CRLF
					Mess_Aide = Mess_Aide & CRLF & "  Count of byte by seconds :"
					Mess_Aide = Mess_Aide & CRLF & "    Copy/ Source.txt, Destination.txt /BytesBySec:MyVariable"
					Mess_Aide = Mess_Aide & CRLF
					Mess_Aide = Mess_Aide & CRLF & "  Or more parameters in same time!"
					Mess_Aide = Mess_Aide & CRLF & "    Copy/ Source.txt, Destination.txt /Progression:Var1 /Bytes:Var2 /BytesBySec:Var3"
					Mess_Aide = Mess_Aide & CRLF
					Mess_Aide = Mess_Aide & CRLF
					Mess_Aide = Mess_Aide & CRLF & " Good to know that cpcdos can support path formats '\' or '/'"
					Mess_Aide = Mess_Aide & CRLF
					Mess_Aide = Mess_Aide & CRLF & "  See also : delete/ , move/ , open/"
					Mess_Aide = Mess_Aide & CRLF
				END IF

				DEBUG(Mess_Aide, Affichage, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_SURBRILLE, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.SansDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_AFF, RetourVAR)
				testCMD = 0
				AfficherAide = 0
				exit _scope_CMD, _scope
			END IF
			' Tester la syntaxe
			testCMD	= CCP_Verifier_Syntaxe(Commande, CommPosition)
			IF testCMD > 10 Then exit _scope_CMD, _scope
			IF testCMD > 0 then  ' Entre 1-5 = Pas d'affichage via le @, @$ ou @#
				IF testCMD < 6 then
					Affichage = 0
					IF testCMD = 3 Then CpcdosCP_SHELL("FIX/ " & CPCDOS_INSTANCE.DEBUG_INSTANCE.LeRetour & " = \#NULL", _CLE_, NIVEAU_CCP, Param_1, Param_2) : RetourVAR = _CLE_ & "N" & NIVEAU_CCP & "->" & CPCDOS_INSTANCE.DEBUG_INSTANCE.LeRetour
					if testCMD = 2 Then RetourVAR = "$>" & CPCDOS_INSTANCE.DEBUG_INSTANCE.LeRetour ' ajouter une securite ?
				Else
					Affichage = 1
				END IF
			Else
				Affichage = 1
			END IF
			' Recuperer les Parametres
			Param = MID(Commande, CommPosition + TailleComm + 2)
			' ====================================================================
			SCOPE

			Dim Resultat 			as boolean

			Dim PosOctets 			as integer
			Dim PosBytes 			as integer

			Dim PosOctetsParSec		as integer
			Dim PosBytesBySec		as integer

			Dim Priorite_copie		as integer = 0

			Dim Source 				as String
			Dim Destination 		as String

			Dim Var_Progression 	as String
			Dim Var_Octets 			as String
			Dim Var_OctetsParSec 	as String



			Dim PosProgress as integer = Instr(Ucase(Param), " /PROGRESSION:")

			IF NOT INSTR(Param, ",") > 0 Then
				IF CPCDOS_INSTANCE.Utilisateur_Langage = 0 Then
					DEBUG("[CpcdosC+] Pour cette version vous devez separer les arguments par une virgule ',' " & CRLF & "Exemple: COPIER/ FichierA, FichierB", Affichage, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_AVERTISSEMENT, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.AvecDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_AFF, RetourVAR)
				Else
					DEBUG("[CpcdosC+] For this version, you must separate arguments by a comma ','" & CRLF & "Examble: COPY/ FileA, FileB", Affichage, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_AVERTISSEMENT, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.AvecDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_AFF, RetourVAR)
				End if

				exit _scope_CMD, _scope
			End if

			if PosProgress > 0 Then
				IF PosProgress > Instr(Param, ",") Then
					Var_Progression = Rtrim(Rtrim(Ltrim(Ltrim(Mid(Param, PosProgress + 14, Instr(PosProgress + 14, Param & " ", " ") - (PosProgress + 14)), CHR(09))), CHR(09)))

					Param = Param & " "

					' Supprimer le progress
					Param = Mid(Param, 1, PosProgress - 1) & " " & Mid(Param, Instr(PosProgress + 14, Param & " ", " ") + 1)

				Else
					IF CPCDOS_INSTANCE.Utilisateur_Langage = 0 Then
						DEBUG("[CpcdosC+] Veuillez placer l'argument '/PROGRESSION' apres le path de destination ", Affichage, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_AVERTISSEMENT, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.AvecDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_AFF, RetourVAR)
					Else
						DEBUG("[CpcdosC+] Please put '/PROGRESSION' argument after path destination", Affichage, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_AVERTISSEMENT, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.AvecDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_AFF, RetourVAR)
					End if

					exit _scope_CMD, _scope
				End if
			End if

			PosOctets = Instr(Ucase(Param), " /OCTETS:")
			PosBytes  = Instr(Ucase(Param), " /BYTES:")

			if PosOctets > 0 OR PosBytes > 0 Then
				IF PosOctets > Instr(Param, ",") Then
					Var_Octets = Rtrim(Rtrim(Ltrim(Ltrim(Mid(Param, PosOctets + 9, Instr(PosOctets + 9, Param & " ", " ") - (PosOctets + 9)), CHR(09))), CHR(09)))

					Param = Param & " "

					' Supprimer le octets
					Param = Mid(Param, 1, PosOctets - 1) & " " & Mid(Param, Instr(PosOctets + 9, Param & " ", " ") + 1)

				ElseIf PosBytes > Instr(Param, ",") Then
					Var_Octets = Rtrim(Rtrim(Ltrim(Ltrim(Mid(Param, PosBytes + 8, Instr(PosBytes + 8, Param & " ", " ") - (PosBytes + 8)), CHR(09))), CHR(09)))

					Param = Param & " "

					' Supprimer le bytes
					Param = Mid(Param, 1, PosBytes - 1) & " " & Mid(Param, Instr(PosBytes + 8, Param & " ", " ") + 1)

				Else
					IF CPCDOS_INSTANCE.Utilisateur_Langage = 0 Then
						DEBUG("[CpcdosC+] Veuillez placer l'argument '/OCTETS' ou '/BYTES' apres le path de destination ", Affichage, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_AVERTISSEMENT, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.AvecDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_AFF, RetourVAR)
					Else
						DEBUG("[CpcdosC+] Please put '/OCTETS' or '/BYTES' argument after path destination", Affichage, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_AVERTISSEMENT, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.AvecDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_AFF, RetourVAR)
					End if

					exit _scope_CMD, _scope
				End if
			End if

			PosOctetsParSec	= Instr(Ucase(Param), " /OCTETSPARSEC:")
			PosBytesBySec 	= Instr(Ucase(Param), " /BYTESBYSEC:")

			if PosOctetsParSec > 0 OR PosBytesBySec > 0 Then
				IF PosOctetsParSec > Instr(Param, ",") Then
					Var_OctetsParSec = Rtrim(Rtrim(Ltrim(Ltrim(Mid(Param, PosOctetsParSec + 15, Instr(PosOctetsParSec + 15, Param & " ", " ") - (PosOctetsParSec + 15)), CHR(09))), CHR(09)))

					Param = Param & " "

					' Supprimer le OctetsParSec
					Param = Mid(Param, 1, PosOctetsParSec - 1) & " " & Mid(Param, Instr(PosOctetsParSec + 15, Param & " ", " "))

				ElseIf PosBytesBySec > Instr(Param, ",") Then
					Var_OctetsParSec = Rtrim(Rtrim(Ltrim(Ltrim(Mid(Param, PosBytesBySec + 13, Instr(PosBytesBySec + 13, Param & " ", " ") - (PosBytesBySec + 13)), CHR(09))), CHR(09)))

					Param = Param & " "

					' Supprimer le bytesBySec
					Param = Mid(Param, 1, PosBytesBySec - 1) & " " & Mid(Param, Instr(PosBytesBySec + 13, Param & " ", " ") + 1)

				Else
					IF CPCDOS_INSTANCE.Utilisateur_Langage = 0 Then
						DEBUG("[CpcdosC+] Veuillez placer l'argument '/OctetsParSec' ou '/BytesBySec' apres le path de destination ", Affichage, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_AVERTISSEMENT, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.AvecDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_AFF, RetourVAR)
					Else
						DEBUG("[CpcdosC+] Please put '/OctetsParSec' or '/BytesBySec' argument after path destination", Affichage, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_AVERTISSEMENT, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.AvecDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_AFF, RetourVAR)
					End if

					exit _scope_CMD, _scope
				End if
			End if

			' ==== MAX ===
			IF Instr(Ucase(Param), " /PRIORITE:MAX") > 0 Then
				Param = Mid(Param, Instr(Ucase(Param), " /PRIORITE:MAX") - 1)
				Priorite_copie = 3
			End if

			IF Instr(Ucase(Param), " /PRIORITY:MAX") Then
				Param = Mid(Param, Instr(Ucase(Param), " /PRIORITY:MAX") - 1)
				Priorite_copie = 3
			End if

			' ==== STANDARD ===
			IF Instr(Ucase(Param), " /PRIORITY:STD") Then
				Param = Mid(Param, Instr(Ucase(Param), " /PRIORITY:STD") - 1)
				Priorite_copie = 2
			End if

			IF Instr(Ucase(Param), " /PRIORITE:STD") Then
				Param = Mid(Param, Instr(Ucase(Param), " /PRIORITE:STD") - 1)
				Priorite_copie = 2
			End if

			' ==== MINIMAL ====
			IF Instr(Ucase(Param), " /PRIORITY:MIN") Then
				Param = Mid(Param, Instr(Ucase(Param), " /PRIORITY:MIN") - 1)
				Priorite_copie = 1
			End if

			IF Instr(Ucase(Param), " /PRIORITE:MIN") Then
				Param = Mid(Param, Instr(Ucase(Param), " /PRIORITE:MIN") - 1)
				Priorite_copie = 1
			End if

			' ==== AUTOMATISEE SELON LE CPU ===
			IF Instr(Ucase(Param), " /PRIORITY:AUTO") Then
				Param = Mid(Param, Instr(Ucase(Param), " /PRIORITY:AUTO") - 1)
				Priorite_copie = 0
			End if

			IF Instr(Ucase(Param), " /PRIORITE:AUTO") Then
				Param = Mid(Param, Instr(Ucase(Param), " /PRIORITE:AUTO") - 1)
				Priorite_copie = 0
			End if

			Param = Rtrim(Param)

			Source 		 = Rtrim(Rtrim(Ltrim(Ltrim(Mid(Param, 1, Instr(Param, ",") - 1)), CHR(09))), CHR(09))
			Destination  = Rtrim(Rtrim(Ltrim(Ltrim(Mid(Param, Instr(Param, ",") + 1)), CHR(09))), CHR(09))

			IF Not Var_Progression = "" Then
				IF CPCDOS_INSTANCE.SYSTEME_INSTANCE.get_DBG_DEBUG() > 0 Then
					IF CPCDOS_INSTANCE.Utilisateur_Langage = 0 Then
						DEBUG("[CpcdosC+] Copie du fichier '" & Source & "' a '" & Destination & "' (Priorite:" & Priorite_copie & ") ...", Affichage, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_Normal, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.AvecDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_CPCDOS, RetourVAR)
					Else
						DEBUG("[CpcdosC+] File copy '" & Source & "' a '" & Destination & "' (Priority:" & Priorite_copie & ")  ...", Affichage, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_Normal, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.AvecDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_CPCDOS, RetourVAR)
					End if
				END IF
			Else
				IF CPCDOS_INSTANCE.SYSTEME_INSTANCE.get_DBG_DEBUG() > 0 Then
					IF CPCDOS_INSTANCE.Utilisateur_Langage = 0 Then
						DEBUG("[CpcdosC+] Copie du fichier '" & Source & "' a '" & Destination & "' avec " & Var_Progression & " comme indicateur (Priorite:" & Priorite_copie & ") ...", Affichage, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_Normal, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.AvecDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_CPCDOS, RetourVAR)
					Else
						DEBUG("[CpcdosC+] File copy '" & Source & "' a '" & Destination & "' with " & Var_Progression & " like indicator (Priority:" & Priorite_copie & ") ...", Affichage, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_Normal, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.AvecDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_CPCDOS, RetourVAR)
					End if
				END IF
			End if

			Resultat = CPCDOS_INSTANCE.Copier_Fichier(Source, Destination, Priorite_copie, Var_Progression, Var_Octets, Var_OctetsParSec) ' Utilisation Temporaire du CRT0 FreeBasic --> DOS

			If Resultat = false Then
				' ERREUR
				DEBUG("0", Affichage, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_ERREUR, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.SansDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_AFF, RetourVAR)

				Dim Message_erreur as String = ERRAVT("ERR_062", 0)
				IF CPCDOS_INSTANCE.Utilisateur_Langage = 0 Then
					DEBUG("[CpcdosC+] " & Message_erreur & ". '" & Param & "'", Affichage, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_ERREUR, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.AvecDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_CPCDOS, RetourVAR)
				Else
					DEBUG("[CpcdosC+] " & Message_erreur & ". '" & Param & "'", Affichage, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_ERREUR, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.AvecDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_CPCDOS, RetourVAR)
				End if
			Else
				' OK
				DEBUG("OK", Affichage, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_OK, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.SansDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_AFF, RetourVAR)

				IF CPCDOS_INSTANCE.Utilisateur_Langage = 0 Then
					DEBUG("[CpcdosC+] Fichier '" & Param & "' a ete copie!", Affichage, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_OK, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.AvecDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_CPCDOS, RetourVAR)
				Else
					DEBUG("[CpcdosC+] The file '" & Param & "' has been copied!", Affichage, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_OK, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.AvecDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_CPCDOS, RetourVAR)
				End if
			End if

			' ====================================================================
			END SCOPE

			exit _scope_CMD, _scope
		End if ' **** COPIER/ ****

	_end_scope_CMD

	_scope_CMD

		' ===============================================================
		'  Commande de renommage
		' ===============================================================
		CommLANG(1) = "renommer/"
		CommLANG(2) = "rename/"
		CommLANG(3) = "\\#//"
		CommTrouve = 0 : NoCMD = 0
		for boucle as integer = 1 to 2
			IF OnCherche = CommLANG(boucle) Then
				NoCMD = 0
				exit for
			Else
				NoCMD = 1
			End if
		Next boucle
		IF NoCMD = 1 then CommLANG(1) = "[F.#).|" : CommLANG(2) = "[F.#).|" : CommLANG(3) = "\\#//"
		rem Afficher la liste des commandes avec anglais / francais
		IF AfficherAide = 1 then
			IF CPCDOS_INSTANCE.Utilisateur_Langage = 0 then
				CommandesAide = CommandesAide & CRLF & " renommer/                  Renommer un fichier ou un dossier"
			Else
				CommandesAide = CommandesAide & CRLF & " rename/                    Rename a file or a directory"
			END IF
		END IF
		IF CommLANG(1) = OnCherche Then CommTrouve = 1
		IF CommLANG(2) = OnCherche Then CommTrouve = 2
		IF CommTrouve > 0 Then ' Afficher l'aide de la commande
			IF AfficherAide = 2 then
				Mess_Aide = ""
				IF CPCDOS_INSTANCE.Utilisateur_Langage = 0 THEN
					Mess_Aide = Mess_Aide & CRLF & "  'Renommer'"
					Mess_Aide = Mess_Aide & CRLF
					Mess_Aide = Mess_Aide & CRLF & "  Fonctionnalit�e :"
					Mess_Aide = Mess_Aide & CRLF & "   Cette commande permet de renommer un fichier source ou un dossier"
					Mess_Aide = Mess_Aide & CRLF
					Mess_Aide = Mess_Aide & CRLF & "  Exemple :"
					Mess_Aide = Mess_Aide & CRLF & "   Renommer/ MonDossier/MonFichier.log, NouveauNom.txt"
					Mess_Aide = Mess_Aide & CRLF & "   Renommer/ dossier/dossier2, MonDossier"
					Mess_Aide = Mess_Aide & CRLF
					Mess_Aide = Mess_Aide & CRLF & " Non disponible pour les dossiers pour cette version"
					Mess_Aide = Mess_Aide & CRLF
					Mess_Aide = Mess_Aide & CRLF & " A savoir que cpcdos supporte les deux formats '\' ou '/'"
					Mess_Aide = Mess_Aide & CRLF
					Mess_Aide = Mess_Aide & CRLF & "  Voir aussi : supprimer/ , deplacer/ , ouvrir/"
					Mess_Aide = Mess_Aide & CRLF
				ELSEIF CPCDOS_INSTANCE.Utilisateur_Langage = 1 THEN
					Mess_Aide = Mess_Aide & CRLF & "  'Rename'"
					Mess_Aide = Mess_Aide & CRLF
					Mess_Aide = Mess_Aide & CRLF & "  Fonctionnality :"
					Mess_Aide = Mess_Aide & CRLF & "   This command allow to rename a source file or directory"
					Mess_Aide = Mess_Aide & CRLF
					Mess_Aide = Mess_Aide & CRLF & "  Example :"
					Mess_Aide = Mess_Aide & CRLF & "   Rename/ MyDirectory/MyFile.log MyNewFile.txt"
					Mess_Aide = Mess_Aide & CRLF & "   Rename/ Folder, NewFolder"
					Mess_Aide = Mess_Aide & CRLF
					Mess_Aide = Mess_Aide & CRLF & "  !! Not avaiable for folder for this version !!"
					Mess_Aide = Mess_Aide & CRLF
					Mess_Aide = Mess_Aide & CRLF & " Good to know that cpcdos can support path formats '\' or '/'"
					Mess_Aide = Mess_Aide & CRLF
					Mess_Aide = Mess_Aide & CRLF & "  See also : delete/ , move/ , open/"
					Mess_Aide = Mess_Aide & CRLF
				END IF

				DEBUG(Mess_Aide, Affichage, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_SURBRILLE, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.SansDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_AFF, RetourVAR)
				testCMD = 0
				AfficherAide = 0
				exit _scope_CMD, _scope
			END IF
			' Tester la syntaxe
			testCMD	= CCP_Verifier_Syntaxe(Commande, CommPosition)
			IF testCMD > 10 Then exit _scope_CMD, _scope
			IF testCMD > 0 then  ' Entre 1-5 = Pas d'affichage via le @, @$ ou @#
				IF testCMD < 6 then
					Affichage = 0
					IF testCMD = 3 Then CpcdosCP_SHELL("FIX/ " & CPCDOS_INSTANCE.DEBUG_INSTANCE.LeRetour & " = \#NULL", _CLE_, NIVEAU_CCP, Param_1, Param_2) : RetourVAR = _CLE_ & "N" & NIVEAU_CCP & "->" & CPCDOS_INSTANCE.DEBUG_INSTANCE.LeRetour
					if testCMD = 2 Then RetourVAR = "$>" & CPCDOS_INSTANCE.DEBUG_INSTANCE.LeRetour ' ajouter une securite ?
				Else
					Affichage = 1
				END IF
			Else
				Affichage = 1
			END IF
			' Recuperer les Parametres
			Param = MID(Commande, CommPosition + TailleComm + 2)

			SCOPE
			' ====================================================================

			Dim Resultat as boolean

			Dim Source 		as String
			Dim Destination as String



			Param = Rtrim(Param)



			IF NOT INSTR(Param, ",") > 0 Then
				IF CPCDOS_INSTANCE.Utilisateur_Langage = 0 Then
					DEBUG("[CpcdosC+] Pour cette version vous devez separer les arguments par une virgule ',' " & CRLF & "Exemple: COPIER/ FichierA, FichierB", Affichage, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_AVERTISSEMENT, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.AvecDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_AFF, RetourVAR)
				Else
					DEBUG("[CpcdosC+] For this version, you must separate arguments by a comma ','" & CRLF & "Examble: COPY/ FileA, FileB", Affichage, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_AVERTISSEMENT, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.AvecDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_AFF, RetourVAR)
				End if

				exit _scope_CMD, _scope
			End if

			Source 		 = Rtrim(Rtrim(Ltrim(Ltrim(Mid(Param, 1, Instr(Param, ",") - 1)), CHR(09))), CHR(09))
			Destination  = Rtrim(Rtrim(Ltrim(Ltrim(Mid(Param, Instr(Param, ",") + 1)), CHR(09))), CHR(09))


			IF CPCDOS_INSTANCE.SYSTEME_INSTANCE.get_DBG_DEBUG() > 0 Then
				IF CPCDOS_INSTANCE.Utilisateur_Langage = 0 Then
					DEBUG("[CpcdosC+] Renommage du fichier '" & Source & "' a '" & Destination & "' ...", Affichage, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_Normal, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.AvecDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_CPCDOS, RetourVAR)
				Else
					DEBUG("[CpcdosC+] File renaming '" & Source & "' to '" & Destination & "' ...", Affichage, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_Normal, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.AvecDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_CPCDOS, RetourVAR)
				End if
			END IF


			Resultat = CPCDOS_INSTANCE.Renommer_Fichier(Source, Destination) ' Utilisation Temporaire du CRT0 FreeBasic --> DOS

			If Resultat = false Then
				' ERREUR
				DEBUG("0", Affichage, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_ERREUR, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.SansDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_AFF, RetourVAR)

				Dim Message_erreur as String = ERRAVT("ERR_062", 0)
				IF CPCDOS_INSTANCE.Utilisateur_Langage = 0 Then
					DEBUG("[CpcdosC+] " & Message_erreur & ". '" & Param & "'", Affichage, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_ERREUR, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.AvecDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_CPCDOS, RetourVAR)
				Else
					DEBUG("[CpcdosC+] " & Message_erreur & ". '" & Param & "'", Affichage, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_ERREUR, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.AvecDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_CPCDOS, RetourVAR)
				End if
			Else
				' OK
				DEBUG("OK", Affichage, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_OK, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.SansDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_AFF, RetourVAR)

				IF CPCDOS_INSTANCE.Utilisateur_Langage = 0 Then
					DEBUG("[CpcdosC+] Fichier '" & Param & "' a ete renomme!", Affichage, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_OK, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.AvecDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_CPCDOS, RetourVAR)
				Else
					DEBUG("[CpcdosC+] The file '" & Param & "' has been renamed!", Affichage, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_OK, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.AvecDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_CPCDOS, RetourVAR)
				End if
			End if

			' ====================================================================
			END SCOPE

			exit _scope_CMD, _scope
		End if ' **** RENOMMER/ ****

	_end_scope_CMD

	_scope_CMD

		' ===============================================================
		'  Commande de creation dossier
		' ===============================================================
		CommLANG(1) = "dossier/"
		CommLANG(2) = "folder/"
		CommLANG(3) = "\\#//"
		CommTrouve = 0 : NoCMD = 0
		for boucle as integer = 1 to 2
			IF OnCherche = CommLANG(boucle) Then
				NoCMD = 0
				exit for
			Else
				NoCMD = 1
			End if
		Next boucle
		IF NoCMD = 1 then CommLANG(1) = "[F.#).|" : CommLANG(2) = "[F.#).|" : CommLANG(3) = "\\#//"
		rem Afficher la liste des commandes avec anglais / francais
		IF AfficherAide = 1 then
			IF CPCDOS_INSTANCE.Utilisateur_Langage = 0 then
				CommandesAide = CommandesAide & CRLF & " dossier/                   Creer un repertoire"
			Else
				CommandesAide = CommandesAide & CRLF & " folder/                    Create a folder"
			END IF
		END IF
		IF CommLANG(1) = OnCherche Then CommTrouve = 1
		IF CommLANG(2) = OnCherche Then CommTrouve = 2
		IF CommTrouve > 0 Then ' Afficher l'aide de la commande
			IF AfficherAide = 2 then
				Mess_Aide = ""
				IF CPCDOS_INSTANCE.Utilisateur_Langage = 0 THEN
					Mess_Aide = Mess_Aide & CRLF & "  'dossier'"
					Mess_Aide = Mess_Aide & CRLF
					Mess_Aide = Mess_Aide & CRLF & "  Fonctionnalit�e :"
					Mess_Aide = Mess_Aide & CRLF & "   Cette commande permet de creer un repertoire de maniere complete"
					Mess_Aide = Mess_Aide & CRLF & "    par exemple si vous voulez creer le dossier A, puis le dossier B"
					Mess_Aide = Mess_Aide & CRLF & "    dans A puis le dossier C dans B, vous pouvez tout specifier en 1 ligne"
					Mess_Aide = Mess_Aide & CRLF
					Mess_Aide = Mess_Aide & CRLF & "  Exemples"
					Mess_Aide = Mess_Aide & CRLF & "   Creer un simple repertoire dans le dossier relatif :"
					Mess_Aide = Mess_Aide & CRLF & "    dossier/ MonRepertoire"
					Mess_Aide = Mess_Aide & CRLF
					Mess_Aide = Mess_Aide & CRLF & "   Creer le repertoire MonDossier1 puis MonDossier2 puis MonDossier3 :"
					Mess_Aide = Mess_Aide & CRLF & "   Dossier/ MonDossier1/MonDossier2/MonDossier3"
					Mess_Aide = Mess_Aide & CRLF
					Mess_Aide = Mess_Aide & CRLF
					Mess_Aide = Mess_Aide & CRLF & " A savoir que cpcdos supporte les deux formats '\' ou '/'"
					Mess_Aide = Mess_Aide & CRLF
					Mess_Aide = Mess_Aide & CRLF & "  Voir aussi : supprimer/ , deplacer/ , ouvrir/"
					Mess_Aide = Mess_Aide & CRLF
				ELSEIF CPCDOS_INSTANCE.Utilisateur_Langage = 1 THEN
					Mess_Aide = Mess_Aide & CRLF & "  'Rename'"
					Mess_Aide = Mess_Aide & CRLF
					Mess_Aide = Mess_Aide & CRLF & "  Fonctionnality :"
					Mess_Aide = Mess_Aide & CRLF & "   This command allow to create a new 'complete' directory"
					Mess_Aide = Mess_Aide & CRLF & "    By example, if you want to create A folder, B folder in A and"
					Mess_Aide = Mess_Aide & CRLF & "    C folder in B, vous can do this with 1 code line"
					Mess_Aide = Mess_Aide & CRLF
					Mess_Aide = Mess_Aide & CRLF & "  Examples"
					Mess_Aide = Mess_Aide & CRLF & "   Create relative directory:"
					Mess_Aide = Mess_Aide & CRLF & "    dossier/ MonRepertoire"
					Mess_Aide = Mess_Aide & CRLF
					Mess_Aide = Mess_Aide & CRLF & "   Create MyFolter1, myfolder2 and Myfolder3"
					Mess_Aide = Mess_Aide & CRLF & "   Dossier/ MyFolder1/myfolder2/Myfolder3"
					Mess_Aide = Mess_Aide & CRLF
					Mess_Aide = Mess_Aide & CRLF & " Good to know that cpcdos can support path formats '\' or '/'"
					Mess_Aide = Mess_Aide & CRLF
					Mess_Aide = Mess_Aide & CRLF & "  See also : delete/ , move/ , open/"
					Mess_Aide = Mess_Aide & CRLF
				END IF

				DEBUG(Mess_Aide, Affichage, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_SURBRILLE, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.SansDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_AFF, RetourVAR)
				testCMD = 0
				AfficherAide = 0
				exit _scope_CMD, _scope
			END IF
			' Tester la syntaxe
			testCMD	= CCP_Verifier_Syntaxe(Commande, CommPosition)
			IF testCMD > 10 Then exit _scope_CMD, _scope
			IF testCMD > 0 then  ' Entre 1-5 = Pas d'affichage via le @, @$ ou @#
				IF testCMD < 6 then
					Affichage = 0
					IF testCMD = 3 Then CpcdosCP_SHELL("FIX/ " & CPCDOS_INSTANCE.DEBUG_INSTANCE.LeRetour & " = \#NULL", _CLE_, NIVEAU_CCP, Param_1, Param_2) : RetourVAR = _CLE_ & "N" & NIVEAU_CCP & "->" & CPCDOS_INSTANCE.DEBUG_INSTANCE.LeRetour
					if testCMD = 2 Then RetourVAR = "$>" & CPCDOS_INSTANCE.DEBUG_INSTANCE.LeRetour ' ajouter une securite ?
				Else
					Affichage = 1
				END IF
			Else
				Affichage = 1
			END IF
			' Recuperer les Parametres
			Param = MID(Commande, CommPosition + TailleComm + 2)

			SCOPE
			' ====================================================================

			Param = Rtrim(Param)

			Dim Resultat 	as boolean
			Dim Source 		as String = Rtrim(Rtrim(Ltrim(Ltrim(Param, CHR(09))), CHR(09)))

			Source = CPCDOS_INSTANCE.SYSTEME_INSTANCE.check_NomAutorise(Source, TRUE, TRUE, FALSE)

			IF CPCDOS_INSTANCE.SYSTEME_INSTANCE.get_DBG_DEBUG() > 0 Then
				IF CPCDOS_INSTANCE.Utilisateur_Langage = 0 Then
					DEBUG("[CpcdosC+] Creation du repertoire '" & Source & "' ...", Affichage, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_Normal, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.AvecDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_CPCDOS, RetourVAR)
				Else
					DEBUG("[CpcdosC+] Creating directory '" & Source & "' ...", Affichage, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_Normal, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.AvecDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_CPCDOS, RetourVAR)
				End if
			END IF

			Resultat = CPCDOS_INSTANCE.SYSTEME_INSTANCE.creer_Repertoire(Source, "")

			If Resultat = false Then
				' ERREUR
				DEBUG("0", Affichage, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_ERREUR, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.SansDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_AFF, RetourVAR)

				Dim Message_erreur as String = ERRAVT("ERR_062", 0)
				IF CPCDOS_INSTANCE.Utilisateur_Langage = 0 Then
					DEBUG("[CpcdosC+] " & Message_erreur & ". '" & Param & "'", Affichage, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_ERREUR, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.AvecDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_CPCDOS, RetourVAR)
				Else
					DEBUG("[CpcdosC+] " & Message_erreur & ". '" & Param & "'", Affichage, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_ERREUR, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.AvecDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_CPCDOS, RetourVAR)
				End if
			Else
				' OK
				DEBUG("OK", Affichage, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_OK, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.SansDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_AFF, RetourVAR)

				IF CPCDOS_INSTANCE.Utilisateur_Langage = 0 Then
					DEBUG("[CpcdosC+] Le dossier '" & Param & "' a ete cree!", Affichage, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_OK, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.AvecDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_CPCDOS, RetourVAR)
				Else
					DEBUG("[CpcdosC+] The folder '" & Param & "' has been created!", Affichage, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_OK, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.AvecDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_CPCDOS, RetourVAR)
				End if
			End if

			' ====================================================================
			END SCOPE

			exit _scope_CMD, _scope
		End if ' **** DOSSIER/ ****

	_end_scope_CMD

	_scope_CMD

		' ===============================================================
		'  Commande de listage repertoire
		' ===============================================================
		CommLANG(1) = "rep/"
		CommLANG(2) = "dir/"
		CommLANG(3) = "\\#//"
		CommTrouve = 0 : NoCMD = 0
		for boucle as integer = 1 to 2
			IF OnCherche = CommLANG(boucle) Then
				NoCMD = 0
				exit for
			Else
				NoCMD = 1
			End if
		Next boucle
		IF NoCMD = 1 then CommLANG(1) = "[F.#).|" : CommLANG(2) = "[F.#).|" : CommLANG(3) = "\\#//"
		rem Afficher la liste des commandes avec anglais / francais
		IF AfficherAide = 1 then
			IF CPCDOS_INSTANCE.Utilisateur_Langage = 0 then
				CommandesAide = CommandesAide & CRLF & " rep/                       Lister le contenu d'un repertoire"
			Else
				CommandesAide = CommandesAide & CRLF & " dir/                       List directory content"
			END IF
		END IF
		IF CommLANG(1) = OnCherche Then CommTrouve = 1
		IF CommLANG(2) = OnCherche Then CommTrouve = 2
		IF CommTrouve > 0 Then ' Afficher l'aide de la commande
			IF AfficherAide = 2 then
				Mess_Aide = ""
				IF CPCDOS_INSTANCE.Utilisateur_Langage = 0 THEN
					Mess_Aide = Mess_Aide & CRLF & "  'rep'"
					Mess_Aide = Mess_Aide & CRLF
					Mess_Aide = Mess_Aide & CRLF & "  Fonctionnalit�e :"
					Mess_Aide = Mess_Aide & CRLF & "   Cette commande permet de lister le contenu d'un repertoire"
					Mess_Aide = Mess_Aide & CRLF & "    Vous pouvez lister les dossier et fichiers presents"
					Mess_Aide = Mess_Aide & CRLF & "     ainsi que leur attributs."
					Mess_Aide = Mess_Aide & CRLF & "    Vous pouvez utiliser les filtres . et *"
					Mess_Aide = Mess_Aide & CRLF
					Mess_Aide = Mess_Aide & CRLF & "   Lister le repertoire courant :"
					Mess_Aide = Mess_Aide & CRLF & "     rep/    ou    rep/ .     ou    rep/ .\"
					Mess_Aide = Mess_Aide & CRLF & "   Lister le contenu d'un autre repertoire :"
					Mess_Aide = Mess_Aide & CRLF & "     Rep/ MonDossier1/MonDossier2"
					Mess_Aide = Mess_Aide & CRLF & "   Lister les fichier avec l'extension .CPC :"
					Mess_Aide = Mess_Aide & CRLF & "     Rep/ MonDossier1/*.cpc"
					Mess_Aide = Mess_Aide & CRLF & "   Lister les fichier qui contient 'f' :"
					Mess_Aide = Mess_Aide & CRLF & "     Rep/ MonDossier1/*f*.*"
					Mess_Aide = Mess_Aide & CRLF
					Mess_Aide = Mess_Aide & CRLF & "   Stocker la liste des fichiers/dossiers dans un tableau indexe :"
					Mess_Aide = Mess_Aide & CRLF & "     Rep/ MonDossier/ /L:MaVariable"
					Mess_Aide = Mess_Aide & CRLF & "     --> La Liste des Fichiers ET Dossiers sont stockes dans le tableau %MaVariable()%"
					Mess_Aide = Mess_Aide & CRLF & "     --> La commande retourne le nombre d'elements indexes est retourne"
					Mess_Aide = Mess_Aide & CRLF
					Mess_Aide = Mess_Aide & CRLF & "   Stocker la liste des Fichiers dans un tableau indexe :"
					Mess_Aide = Mess_Aide & CRLF & "     Rep/ MonDossier/ /F:MaVariable"
					Mess_Aide = Mess_Aide & CRLF & "     --> La Liste des Fichiers sont stockes dans le tableau %MaVariable()%"
					Mess_Aide = Mess_Aide & CRLF & "     --> La commande retourne le nombre d'elements indexes est retourne"
					Mess_Aide = Mess_Aide & CRLF
					Mess_Aide = Mess_Aide & CRLF & "   Stocker la liste des Dossiers dans un tableau indexe :"
					Mess_Aide = Mess_Aide & CRLF & "     Rep/ MonDossier/ /D:MaVariable"
					Mess_Aide = Mess_Aide & CRLF & "     --> La Liste des Dossiers sont stockes dans le tableau %MaVariable()%"
					Mess_Aide = Mess_Aide & CRLF & "     --> La commande retourne le nombre d'elements indexes est retourne"
					Mess_Aide = Mess_Aide & CRLF
					Mess_Aide = Mess_Aide & CRLF & "   Stocker la liste des attributs dans un tableau indexe :"
					Mess_Aide = Mess_Aide & CRLF & "     Rep/ MonDossier/ /A:MaVariable"
					Mess_Aide = Mess_Aide & CRLF & "     --> La Liste des attributs sont stockes dans le tableau %MaVariable()%"
					Mess_Aide = Mess_Aide & CRLF & "     --> La commande retourne le nombre d'elements indexes est retourne"
					Mess_Aide = Mess_Aide & CRLF
					Mess_Aide = Mess_Aide & CRLF & "   Si vous voulez des informations breves, utilisez /B :"
					Mess_Aide = Mess_Aide & CRLF & "     Rep/ MonRepertoire /B     or    Rep/ /B MonRepertoire"
					Mess_Aide = Mess_Aide & CRLF
					Mess_Aide = Mess_Aide & CRLF & " A savoir que cpcdos supporte les deux formats '\' ou '/'"
					Mess_Aide = Mess_Aide & CRLF
					Mess_Aide = Mess_Aide & CRLF & "  Voir aussi : supprimer/ , deplacer/ , ouvrir/ , dossier/"
					Mess_Aide = Mess_Aide & CRLF
				ELSEIF CPCDOS_INSTANCE.Utilisateur_Langage = 1 THEN
					Mess_Aide = Mess_Aide & CRLF & "  'dir'"
					Mess_Aide = Mess_Aide & CRLF
					Mess_Aide = Mess_Aide & CRLF & "  Fonctionnality :"
					Mess_Aide = Mess_Aide & CRLF & "   This command allow to list the directory content"
					Mess_Aide = Mess_Aide & CRLF & "    You can list files, folders and attributes"
					Mess_Aide = Mess_Aide & CRLF & "    You can also use filters . and *"
					Mess_Aide = Mess_Aide & CRLF
					Mess_Aide = Mess_Aide & CRLF & "  List the current directory"
					Mess_Aide = Mess_Aide & CRLF & "    dir/ .   or   dir/ .\"
					Mess_Aide = Mess_Aide & CRLF & "  List the content of another directory"
					Mess_Aide = Mess_Aide & CRLF & "    dir/ MyFolder1/MyFolder2"
					Mess_Aide = Mess_Aide & CRLF & "  List files with .CPC extention:"
					Mess_Aide = Mess_Aide & CRLF & "    Rep/ MonDossier1/*.cpc"
					Mess_Aide = Mess_Aide & CRLF & "  List files with 'f' in file name :"
					Mess_Aide = Mess_Aide & CRLF & "    Rep/ MonDossier1/*f*.*"
					Mess_Aide = Mess_Aide & CRLF
					Mess_Aide = Mess_Aide & CRLF & "   Store Files/Directory in indexed array :"
					Mess_Aide = Mess_Aide & CRLF & "     Dir/ MyFolder/ /L:MyVariable"
					Mess_Aide = Mess_Aide & CRLF & "     --> The Files AND Directory list are stored in %MyVariable()% array"
					Mess_Aide = Mess_Aide & CRLF & "     --> This command return the number of indexed elements"
					Mess_Aide = Mess_Aide & CRLF
					Mess_Aide = Mess_Aide & CRLF & "   Store Files in indexed array :"
					Mess_Aide = Mess_Aide & CRLF & "     Dir/ MyFolder/ /F:MyVariable"
					Mess_Aide = Mess_Aide & CRLF & "     --> The Files list are stored in %MyVariable()% array"
					Mess_Aide = Mess_Aide & CRLF & "     --> This command return the number of indexed elements"
					Mess_Aide = Mess_Aide & CRLF
					Mess_Aide = Mess_Aide & CRLF & "   Store Directory in indexed array :"
					Mess_Aide = Mess_Aide & CRLF & "     Dir/ MyFolder/ /D:MyVariable"
					Mess_Aide = Mess_Aide & CRLF & "     --> The Directory list are stored in %MyVariable()% array"
					Mess_Aide = Mess_Aide & CRLF & "     --> This command return the number of indexed elements"
					Mess_Aide = Mess_Aide & CRLF
					Mess_Aide = Mess_Aide & CRLF & "   Store Attributes in indexed array :"
					Mess_Aide = Mess_Aide & CRLF & "     Dir/ MyFolder/ /A:MyVariable"
					Mess_Aide = Mess_Aide & CRLF & "     --> The Attributes list are stored in %MyVariable()% array"
					Mess_Aide = Mess_Aide & CRLF & "     --> This command return the number of indexed elements"
					Mess_Aide = Mess_Aide & CRLF
					Mess_Aide = Mess_Aide & CRLF & "   If you want brief information, you can use /B :"
					Mess_Aide = Mess_Aide & CRLF & "     Dir/ MyFolder /B     or    Dir/ /B MyFolder"
					Mess_Aide = Mess_Aide & CRLF
					Mess_Aide = Mess_Aide & CRLF & " Good to know that cpcdos can support path formats '\' or '/'"
					Mess_Aide = Mess_Aide & CRLF
					Mess_Aide = Mess_Aide & CRLF & "  See also : delete/ , move/ , open/ , folder/"
					Mess_Aide = Mess_Aide & CRLF
				END IF

				DEBUG(Mess_Aide, Affichage, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_SURBRILLE, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.SansDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_AFF, RetourVAR)
				testCMD = 0
				AfficherAide = 0
				exit _scope_CMD, _scope
			END IF
			' Tester la syntaxe
			testCMD	= CCP_Verifier_Syntaxe(Commande, CommPosition)
			IF testCMD > 10 Then exit _scope_CMD, _scope
			IF testCMD > 0 then  ' Entre 1-5 = Pas d'affichage via le @, @$ ou @#
				IF testCMD < 6 then
					Affichage = 0
					IF testCMD = 3 Then CpcdosCP_SHELL("FIX/ " & CPCDOS_INSTANCE.DEBUG_INSTANCE.LeRetour & " = \#NULL", _CLE_, NIVEAU_CCP, Param_1, Param_2) : RetourVAR = _CLE_ & "N" & NIVEAU_CCP & "->" & CPCDOS_INSTANCE.DEBUG_INSTANCE.LeRetour
					if testCMD = 2 Then RetourVAR = "$>" & CPCDOS_INSTANCE.DEBUG_INSTANCE.LeRetour ' ajouter une securite ?
				Else
					Affichage = 1
				END IF
			Else
				Affichage = 1
			END IF
			' Recuperer les Parametres
			Param = MID(Commande, CommPosition + TailleComm + 2)
			SCOPE
			' ====================================================================

			Param = Rtrim(Param)

			Dim Affichage_Breve as boolean
			Dim Source 			as String
			Dim CPY_Source		as String

			Dim SourceRecherche as String
			Dim Source_exe_path as String

			IF Instr(Ucase(Param), "/B") > 0 Then
				' Enlever l'argument
				Param = Mid(Param, 1, Instr(Ucase(Param), "/B") - 1) & Mid(Param, Instr(Ucase(Param), "/B") + 3)

				Affichage_Breve = True
			End if

			IF Instr(Ucase(Param), "/L:") > 0 Then
				' Lister les Fichier/Dossiers dans un tableau CpcdosC+
				Dim NomVariable as String = Rtrim(Rtrim(Ltrim(Ltrim(Mid(Param, Instr(Ucase(Param), "/L:") + 3), CHR(09))), CHR(09)))
				Param = Mid(Param, 1, Instr(Ucase(Param), "/L:") - 1)



			ElseIF Instr(Ucase(Param), "/F:") > 0 Then
				' Lister les Fichier dans un tableau CpcdosC+
				Dim NomVariable as String = Rtrim(Rtrim(Ltrim(Ltrim(Mid(Param, Instr(Ucase(Param), "/F:") + 3), CHR(09))), CHR(09)))
				Param = Mid(Param, 1, Instr(Ucase(Param), "/F:") - 1)


			ElseIF Instr(Ucase(Param), "/D:") > 0 Then
				' Lister les Dossiers dans un tableau CpcdosC+
				Dim NomVariable as String = Rtrim(Rtrim(Ltrim(Ltrim(Mid(Param, Instr(Ucase(Param), "/D:") + 3), CHR(09))), CHR(09)))
				Param = Mid(Param, 1, Instr(Ucase(Param), "/D:") - 1)


			ElseIF Instr(Ucase(Param), "/A:") > 0 Then
				' Lister les Attributs dans un tableau CpcdosC+
				Dim NomVariable as String = Rtrim(Rtrim(Ltrim(Ltrim(Mid(Param, Instr(Ucase(Param), "/A:") + 3), CHR(09))), CHR(09)))
				Param = Mid(Param, 1, Instr(Ucase(Param), "/A:") - 1)


			End if

			Source 			= Rtrim(Rtrim(Ltrim(Ltrim(Param, CHR(09))), CHR(09)))
			CPY_Source		= CPCDOS_INSTANCE.SYSTEME_INSTANCE.check_NomAutorise(Source, TRUE, TRUE, FALSE)



			IF Instr(CPY_Source, "\") > 0 Then
				' Ex: REP/ Dossier\    ou   REP/ Dossier\*.*
				'  --> REP/ Dossier\*.*
				SourceRecherche = Mid(Source, InstrREV(CPY_Source, "\") +1)

				If SourceRecherche = "" Then SourceRecherche = "\*.*"

				IF NOT Instr(CPCDOS_INSTANCE.SYSTEME_INSTANCE.check_NomAutorise(SourceRecherche, TRUE, TRUE, FALSE), "_") > 0 Then
					SourceRecherche = "\*.*"
				Else
					Source = Mid(Source, 1, InstrREV(CPY_Source, "\") -1)
					IF NOT Instr(SourceRecherche, "\") > 0 Then SourceRecherche = "\" & SourceRecherche
				End if

			Else
				' Ex: REP/ .
				' --> REP/ .\*.*
				IF Len(CPY_Source) = 1 Then
					IF CPY_Source = "." Then
						SourceRecherche = ".\*.*"
						Source = ""
					Else
						SourceRecherche = ".\*.*"
						Source = ""
					End if
				Else
					' EX: REP/
					' --> REP/ *.*
					SourceRecherche = "\*.*"
					' Source = ""
				End if
			End if

			' Si rien n'a ete precise
			if Source = "" Then
				' Si on ne precise rien, alors c'est le dossier courant dans l'executable
				Source_exe_path = UCASE(CPCDOS_INSTANCE.SHELLCCP_INSTANCE.CCP_Lire_Variable("_EXE_PATH_F_", 2, _CLE_))

				' Verifier si la variable existe
				if Source_exe_path = Ucase(CPCDOS_INSTANCE._CONTENU_IMPROPABLE) Then Source_exe_path = ""

				' Optimisation
				IF NOT Source_exe_path = "" Then
					Source = Source_exe_path
					Source = CPCDOS_INSTANCE.SYSTEME_INSTANCE.check_NomAutorise(Source_exe_path, TRUE, TRUE, FALSE)


					IF CPCDOS_INSTANCE.SYSTEME_INSTANCE.get_DBG_DEBUG() > 0 Then
						IF CPCDOS_INSTANCE.Utilisateur_Langage = 0 Then
							DEBUG("[CpcdosC+] Recuperation du contenu du repertoire '" & Source & "' avec les filtres '" & SourceRecherche & "' ...", Affichage, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_Normal, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.AvecDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_CPCDOS, RetourVAR)
						Else
							DEBUG("[CpcdosC+] Getting '" & Source & "' directory content with '" & SourceRecherche & "' filters ...", Affichage, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_Normal, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.AvecDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_CPCDOS, RetourVAR)
						End if
					END IF

				Else
					Source = "."
					IF CPCDOS_INSTANCE.SYSTEME_INSTANCE.get_DBG_DEBUG() > 0 Then
						IF CPCDOS_INSTANCE.Utilisateur_Langage = 0 Then
							DEBUG("[CpcdosC+] Recuperation du contenu du repertoire CPCDOS avec les filtres '" & SourceRecherche & "' ...", Affichage, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_Normal, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.AvecDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_CPCDOS, RetourVAR)
						Else
							DEBUG("[CpcdosC+] Getting CPCDOS directory content with '" & SourceRecherche & "' filters ...", Affichage, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_Normal, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.AvecDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_CPCDOS, RetourVAR)
						End if
					END IF
				End if
			Else
				IF CPCDOS_INSTANCE.SYSTEME_INSTANCE.get_DBG_DEBUG() > 0 Then
					IF CPCDOS_INSTANCE.Utilisateur_Langage = 0 Then
						DEBUG("[CpcdosC+] Recuperation du contenu du repertoire '" & Source & "' avec les filtres '" & SourceRecherche & "' ...", Affichage, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_Normal, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.AvecDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_CPCDOS, RetourVAR)
					Else
						DEBUG("[CpcdosC+] Getting '" & Source & "' directory content with '" & SourceRecherche & "' filters ...", Affichage, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_Normal, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.AvecDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_CPCDOS, RetourVAR)
					End if
				END IF
			End if

			scope
				Dim instance_FICHER_DOSSIER_ as _FICHER_DOSSIER_
				Dim Resultat as Boolean = CPCDOS_INSTANCE.SYSTEME_INSTANCE.lister_Repertoire(Source, SourceRecherche, instance_FICHER_DOSSIER_)

				If instance_FICHER_DOSSIER_.Est_OK = False Then
					' ERREUR
					DEBUG("0", Affichage, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_ERREUR, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.SansDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_AFF, RetourVAR)

					Dim Message_erreur as String = ERRAVT("ERR_064", 0)
					IF CPCDOS_INSTANCE.Utilisateur_Langage = 0 Then
						DEBUG("[CpcdosC+] " & Message_erreur & ". '" & Param & "'", Affichage, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_ERREUR, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.AvecDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_CPCDOS, RetourVAR)
					Else
						DEBUG("[CpcdosC+] " & Message_erreur & ". '" & Param & "'", Affichage, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_ERREUR, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.AvecDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_CPCDOS, RetourVAR)
					End if
					exit _scope_CMD, _scope
				Else
					Dim TailleCH 		as integer
					Dim TailleFichier 	as uinteger
					Dim TailleFinal 	as uinteger
					Dim TexteTaille 	as String
					Dim as String octets, kilo, mega, giga, tera
					Dim Resultat_chaine as String = ""

					Dim TexteTaille_FINAL as String

					' OK

					IF Affichage_Breve = False Then
						If CPCDOS_INSTANCE.Utilisateur_Langage = 0 Then
							Resultat_chaine += " Contenu du repertoire '" & Source & "' :" & CRLF
						Else
							Resultat_chaine += " Directory content '" & Source & "' :" & CRLF
						End if
					End if


					' Afficher la bonne taille (Octets, Kilos, Mega, Giga)

					IF CPCDOS_INSTANCE.Utilisateur_Langage = 0 Then
						octets = "o"
						kilo = "ko"
						mega = "mo"
						giga = "go"
						tera = "to"
					Else
						octets = "b"
						kilo = "kb"
						mega = "mb"
						giga = "gb"
						tera = "tb"
					End if

					for b as integer = 1 to instance_FICHER_DOSSIER_.nb_Elements

						if instance_FICHER_DOSSIER_.attributs_Elements(b).EstUnDossier = True Then

							TexteTaille = ""

							' Calculer la taille de la chaine pour enlever des espaces
							TailleCH = ((8 + 1 + 3) + 16) - len("[" & instance_FICHER_DOSSIER_.liste_Elements(b) & "]")

							' Ajouter le nom + l'attribut dossier
							IF Affichage_Breve = False Then
								Resultat_chaine += " - [" & instance_FICHER_DOSSIER_.liste_Elements(b) & "]" & SPACE(TailleCH) & " <D"
							Else
								Resultat_chaine += "[" & instance_FICHER_DOSSIER_.liste_Elements(b) & "] <D"
							End if
						Else
							' Calculer la taille de la chaine pour enlever des espaces
							TailleCH = ((8 + 1 + 3) + 16) - len(instance_FICHER_DOSSIER_.liste_Elements(b))

							' Recuperer la taille du fichier et le convertir en KiloOctets
							TailleFichier = instance_FICHER_DOSSIER_.attributs_Elements(b).taille

							' Incrmenter la taille total
							TailleFinal += TailleFichier

							Scope

								' Attribuer l'unite correspondante a la taille
								IF TailleFichier < 1 Then
									' Fichier VIDE
									TexteTaille = "0 " & octets
								Else
									IF (TailleFichier/1024^4) < 1 Then ' Tera
										IF (TailleFichier/1024^3) < 1 Then ' Giga
											IF (TailleFichier/1024^2) < 1 Then ' Mega
												IF (TailleFichier/1024) < 1 Then ' Kilo
													TexteTaille = TailleFichier & " " & octets ' OCTETS
												Else
													TexteTaille = Left(str(TailleFichier/1024), instr(str(TailleFichier/1024), ".") + 3) & " " & kilo ' KILOS
												End if
											Else
												TexteTaille = Left(str(TailleFichier/1024^2), instr(str(TailleFichier/1024^2), ".") + 3) & " " & mega ' MEGA
											End if
										Else
											TexteTaille = Left(str(TailleFichier/1024^3), instr(str(TailleFichier/1024^3), ".") + 3) & " " & giga ' GIGA
										End if
									Else
										TexteTaille = Left(str(TailleFichier/1024^4), instr(str(TailleFichier/1024^4), ".") + 3) & " " & tera ' TERA
									End if
								End if
							End Scope

							' Ajouter le nom + l'attribut fichier
							IF Affichage_Breve = False Then
								Resultat_chaine += " - " & instance_FICHER_DOSSIER_.liste_Elements(b) & SPACE(TailleCH) & " <F"
							Else
								Resultat_chaine += instance_FICHER_DOSSIER_.liste_Elements(b) & " <F"
							End if
						end if

						' ** Ajouter les autres attributs **

						' Lecture Seule
						if instance_FICHER_DOSSIER_.attributs_Elements(b).attrib_ReadOnly = True Then Resultat_chaine += ",r"

						' Cache
						if instance_FICHER_DOSSIER_.attributs_Elements(b).attrib_Hidden = True Then Resultat_chaine += ",h"

						' Systeme
						if instance_FICHER_DOSSIER_.attributs_Elements(b).attrib_System = True Then Resultat_chaine += ",s"

						' Archive
						if instance_FICHER_DOSSIER_.attributs_Elements(b).attrib_Archive = True Then Resultat_chaine += ",a"

						' Normal
						if instance_FICHER_DOSSIER_.attributs_Elements(b).attrib_Normal = True Then Resultat_chaine += ",n"


						' Ajouter un retour chariot
						IF Affichage_Breve = False Then
							Resultat_chaine += "> " & SPACE(15 - (instance_FICHER_DOSSIER_.attributs_Elements(b).attrib_Nombre * 2 + 2)) & TexteTaille & CRLF
						Else
							Resultat_chaine += "> " & TexteTaille & CRLF
						End if
					next b



					' Attribuer l'unite correspondante a la taille
					IF TailleFinal < 1 Then
						' Fichier VIDE
						TexteTaille_FINAL = "0 " & octets
					Else
						IF (TailleFinal/1024^4) < 1 Then ' Tera
							IF (TailleFinal/1024^3) < 1 Then ' Giga
								IF (TailleFinal/1024^2) < 1 Then ' Mega
									IF (TailleFinal/1024) < 1 Then ' Kilo
										TexteTaille_FINAL = TailleFinal & " " & octets ' OCTETS
									Else
										TexteTaille_FINAL = Left(str(TailleFinal/1024), instr(str(TailleFinal/1024), ".") + 3) & " " & kilo ' KILOS
									End if
								Else
									TexteTaille_FINAL = Left(str(TailleFinal/1024^2), instr(str(TailleFinal/1024^2), ".") + 3) & " " & mega ' MEGA
								End if
							Else
								TexteTaille_FINAL = Left(str(TailleFinal/1024^3), instr(str(TailleFinal/1024^3), ".") + 3) & " " & giga ' GIGA
							End if
						Else
							TexteTaille_FINAL = Left(str(TailleFinal/1024^4), instr(str(TailleFinal/1024^4), ".") + 3) & " " & tera ' TERA
						End if
					End if

					IF Affichage_Breve = False Then
						If CPCDOS_INSTANCE.Utilisateur_Langage = 0 Then
							Resultat_chaine += " " & instance_FICHER_DOSSIER_.nb_Dossiers & " dossier(s)" & " " & instance_FICHER_DOSSIER_.nb_Fichiers & " fichier(s) " & _
													" Total : " & instance_FICHER_DOSSIER_.nb_Elements & " element(s) " & TexteTaille_FINAL
						Else
							Resultat_chaine += " " & instance_FICHER_DOSSIER_.nb_Dossiers & " folder(s)" & " " & instance_FICHER_DOSSIER_.nb_Fichiers & " file(s) " & _
													" Total : " & instance_FICHER_DOSSIER_.nb_Elements & " element(s) " & TexteTaille_FINAL
						End if
					Else
						Resultat_chaine += "-> D:" & instance_FICHER_DOSSIER_.nb_Dossiers & " F:" & instance_FICHER_DOSSIER_.nb_Fichiers & _
													" T:" & instance_FICHER_DOSSIER_.nb_Elements & " S:" & TexteTaille_FINAL
					End if

					DEBUG(Resultat_chaine, Affichage, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_Normal, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.SansDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_AFF, RetourVAR)
				End if
			End scope

			' ====================================================================
			END SCOPE

			exit _scope_CMD, _scope
		End if ' **** DIR/ ****

	_end_scope_CMD

	_scope_CMD

		' ===============================================================
		'  Commande pour afficher du texte a l'ecran
		' ===============================================================
		CommLANG(1) = "txt/"
		CommLANG(2) = "txt/"
		CommLANG(3) = "\\#//"
		CommTrouve = 0 : NoCMD = 0
		for boucle as integer = 1 to 2
			IF OnCherche = CommLANG(boucle) Then
				NoCMD = 0
				exit for
			Else
				NoCMD = 1
			End if
		Next boucle
		IF NoCMD = 1 then CommLANG(1) = "[F.#).|" : CommLANG(2) = "[F.#).|" : CommLANG(3) = "\\#//"

		rem Afficher la liste des commandes avec anglais / francais
		IF AfficherAide = 1 then
			IF CPCDOS_INSTANCE.Utilisateur_Langage = 0 then
				CommandesAide = CommandesAide & CRLF & " txt/                       Ecrire du texte"
			Else
				CommandesAide = CommandesAide & CRLF & " txt/                       Write text"
			END IF
		END IF
		IF CommLANG(1) = OnCherche Then CommTrouve = 1
		IF CommLANG(2) = OnCherche Then CommTrouve = 2
		IF CommTrouve > 0 Then
			IF AfficherAide = 2 then
				Mess_Aide = ""
				IF CPCDOS_INSTANCE.Utilisateur_Langage = 0 THEN
					Mess_Aide = Mess_Aide & CRLF & "  'TeXTe'"
					Mess_Aide = Mess_Aide & CRLF
					Mess_Aide = Mess_Aide & CRLF & "  Fonctionnalit�e :"
					Mess_Aide = Mess_Aide & CRLF & "   Cette commande permet d'afficher du texte sur la console LC"
					Mess_Aide = Mess_Aide & CRLF & "   ou sur une sortie redirig�e " & CHR(34) & "@#Ma_Variable" & CHR(34) & " ou " & CHR(34) & "@$Mon_Fichier.abc" & CHR(34) & CRLF
					Mess_Aide = Mess_Aide & CRLF
					Mess_Aide = Mess_Aide & CRLF & "  Exemple :"
					Mess_Aide = Mess_Aide & CRLF & "   txt/ Hello world!"
					Mess_Aide = Mess_Aide & CRLF & "   @#Toto txt/ Hello tata!"
					Mess_Aide = Mess_Aide & CRLF & "   txt/ %toto%"
					Mess_Aide = Mess_Aide & CRLF
					Mess_Aide = Mess_Aide & CRLF & "   txt/ Salut/#R"
					Mess_Aide = Mess_Aide & CRLF & "   txt/  Humain /#R"
					Mess_Aide = Mess_Aide & CRLF
					Mess_Aide = Mess_Aide & CRLF & "  Sortie :"
					Mess_Aide = Mess_Aide & CRLF & "   Hello world!"
					Mess_Aide = Mess_Aide & CRLF & "   Salut Humain"
					Mess_Aide = Mess_Aide & CRLF
					Mess_Aide = Mess_Aide & CRLF & " Remarque: Utilisez \#PAUSE a la fin de ligne pour defiler le texte"
					Mess_Aide = Mess_Aide & CRLF & "            avec une touche. Et ECHAP pour tout afficher."
					Mess_Aide = Mess_Aide & CRLF
					Mess_Aide = Mess_Aide & CRLF & "  Voir aussi : fix/ , couleurf/ , couleurp/"
					Mess_Aide = Mess_Aide & CRLF
				ELSEIF CPCDOS_INSTANCE.Utilisateur_Langage = 1 THEN
					Mess_Aide = Mess_Aide & CRLF & "  'TeXT'"
					Mess_Aide = Mess_Aide & CRLF
					Mess_Aide = Mess_Aide & CRLF & "  Fonctionnality :"
					Mess_Aide = Mess_Aide & CRLF & "   This command allow to display text on LC console"
					Mess_Aide = Mess_Aide & CRLF & "   or in an directed ouput " & CHR(34) & "@#Ma_Variable" & CHR(34) & " ou " & CHR(34) & "@$Mon_Fichier.abc" & CHR(34) & CRLF
					Mess_Aide = Mess_Aide & CRLF
					Mess_Aide = Mess_Aide & CRLF & "    LC:[FR] Ligne de Commandes [EN] Commands line (no GUI)"
					Mess_Aide = Mess_Aide & CRLF
					Mess_Aide = Mess_Aide & CRLF & "  Exemple :"
					Mess_Aide = Mess_Aide & CRLF & "   txt/ Hello world!"
					Mess_Aide = Mess_Aide & CRLF & "   @#Toto txt/ Hello tata!"
					Mess_Aide = Mess_Aide & CRLF & "   txt/ %toto%"
					Mess_Aide = Mess_Aide & CRLF
					Mess_Aide = Mess_Aide & CRLF & "   txt/ Hi/#R"
					Mess_Aide = Mess_Aide & CRLF & "   txt/  Human /#R"
					Mess_Aide = Mess_Aide & CRLF & "  Results :"
					Mess_Aide = Mess_Aide & CRLF & "   Hello world!"
					Mess_Aide = Mess_Aide & CRLF & "   Hello world!"
					Mess_Aide = Mess_Aide & CRLF
					Mess_Aide = Mess_Aide & CRLF & "  See also : fix/ , couleurf/ , couleurp/"
					Mess_Aide = Mess_Aide & CRLF
				END IF
				DEBUG(Mess_Aide, Affichage, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_SURBRILLE, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.SansDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_AFF, RetourVAR)
				testCMD = 0
				AfficherAide = 0
				exit _scope_CMD, _scope
			END IF
			' Tester la syntaxe
			testCMD	= CCP_Verifier_Syntaxe(Commande, CommPosition)
			IF testCMD > 10 Then exit _scope_CMD, _scope
			IF testCMD > 0 then  ' Entre 1-5 = Pas d'affichage via le @, @$ ou @#
				IF testCMD < 6 then
					Affichage = 0
					IF testCMD = 3 Then CpcdosCP_SHELL("FIX/ " & CPCDOS_INSTANCE.DEBUG_INSTANCE.LeRetour & " = \#NULL", _CLE_, NIVEAU_CCP, Param_1, Param_2) : RetourVAR = _CLE_ & "N" & NIVEAU_CCP & "->" & CPCDOS_INSTANCE.DEBUG_INSTANCE.LeRetour
					if testCMD = 2 Then RetourVAR = "$>" & CPCDOS_INSTANCE.DEBUG_INSTANCE.LeRetour ' ajouter une securite ?
				Else
					Affichage = 1
				END IF
			Else
				Affichage = 1
			END IF

			' Recuperer les Parametres
			Param = MID(Commande, CommPosition + TailleComm + 2)
			SCOPE
			' ====================================================================

			Dim TXT_CRLF				as Integer
			Dim TXT_Date				as Integer
			Dim TXT_Couleur				as Integer

			TXT_CRLF 	= CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF
			TXT_Date 	= CPCDOS_INSTANCE.DEBUG_INSTANCE.SansDate
			TXT_Couleur = CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_Normal

			IF Instr(UCASE(Param), "/#R") > 0 Then
				Param = MID(Param, 1, Instr(UCASE(Param), "/#R") - 1) ' /#R pour que le texte reste sur la ligne
				TXT_CRLF = CPCDOS_INSTANCE.DEBUG_INSTANCE.NoCRLF
			End if
			IF Instr(UCASE(Param), "/#DEBUG") > 0 Then
				Param = MID(Param, 1, Instr(UCASE(Param), "/#DEBUG") - 1) ' /#DEBUG pour obtenir les info de debuggage
				TXT_Date = CPCDOS_INSTANCE.DEBUG_INSTANCE.AvecDate
			End if
			' Recuperer les Parametres

			DEBUG(Param, Affichage, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, TXT_Couleur, 0, TXT_CRLF, TXT_Date, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_AFF, RetourVAR)

			' ====================================================================
			END SCOPE

			exit _scope_CMD, _scope
		End if ' **** TXT/ ****


	_end_scope_CMD


	_scope_CMD

		' ===============================================================
		'  Commande pour fixer une variable CpcdosC+
		' ===============================================================
		CommLANG(1) = "fix/"
		CommLANG(2) = "set/"
		CommLANG(3) = "\\#//"
		CommTrouve = 0 : NoCMD = 0
		for boucle as integer = 1 to 2
			IF OnCherche = CommLANG(boucle) Then
				NoCMD = 0
				exit for
			Else
				NoCMD = 1
			End if
		Next boucle
		IF NoCMD = 1 then CommLANG(1) = "[F.#).|" : CommLANG(2) = "[F.#).|" : CommLANG(3) = "\\#//"
		rem Afficher la liste des commandes avec anglais / francais
		IF AfficherAide = 1 then
			IF CPCDOS_INSTANCE.Utilisateur_Langage = 0 then
				CommandesAide = CommandesAide & CRLF & " fix/                       Cree ou modifie une variable ou de(s) tableau(x)"
			Else
				CommandesAide = CommandesAide & CRLF & " set/                       Create or modify a variable or array(s)"
			END IF
		END IF

		IF CommLANG(1) = OnCherche Then CommTrouve = 1
		IF CommLANG(2) = OnCherche Then CommTrouve = 2

		IF CommTrouve > 0 Then
			IF AfficherAide = 2 then
				Mess_Aide = ""
				IF CPCDOS_INSTANCE.Utilisateur_Langage = 0 THEN
					Mess_Aide = Mess_Aide & CRLF & "  'FIXer'"
					Mess_Aide = Mess_Aide & CRLF
					Mess_Aide = Mess_Aide & CRLF & "  Fonctionnalit�e :"
					Mess_Aide = Mess_Aide & CRLF & "   Cette commande permet de creer ou modifier une variable ou de(s) tableau(x)"
					Mess_Aide = Mess_Aide & CRLF
					Mess_Aide = Mess_Aide & CRLF & "  Exemple simple :"
					Mess_Aide = Mess_Aide & CRLF & "   fix/ Ma_Variable = Johann"
					Mess_Aide = Mess_Aide & CRLF & "   txt/ Salut %Ma_variable% !"
					Mess_Aide = Mess_Aide & CRLF & "  Supprimer une variable/tableau:"
					Mess_Aide = Mess_Aide & CRLF & "   fix/ /S Ma_variable"
					Mess_Aide = Mess_Aide & CRLF & "  Poser une question a l'utilisateur:"
					Mess_Aide = Mess_Aide & CRLF & "   fix/ /q Ma_Variable"
					Mess_Aide = Mess_Aide & CRLF & "  Attendre la pression d'une touche (bloquant) :"
					Mess_Aide = Mess_Aide & CRLF & "   fix/ /atouche Ma_Variable"
					Mess_Aide = Mess_Aide & CRLF & "  Recuperer le contenu du buffer du clavier (non bloquant)"
					Mess_Aide = Mess_Aide & CRLF & "   fix/ /touche Ma_Variable"
					Mess_Aide = Mess_Aide & CRLF
					Mess_Aide = Mess_Aide & CRLF & "  Exemple tableau :"
					Mess_Aide = Mess_Aide & CRLF & "   fix/ Mon_Tableau[0] = Toto"
					Mess_Aide = Mess_Aide & CRLF & "   fix/ Mon_Tableau[1] = Tata"
					Mess_Aide = Mess_Aide & CRLF & "   fix/ Mon_Tableau[2] = titi"
					Mess_Aide = Mess_Aide & CRLF & "   txt/ Contenu du tableau 1:%Mon_Tableau[0]% 2:%Mon_Tableau[1]% 3:%Mon_Tableau[2]% "
					Mess_Aide = Mess_Aide & CRLF
					Mess_Aide = Mess_Aide & CRLF & "  Sortie :"
					Mess_Aide = Mess_Aide & CRLF & "   Contenu du tableau 1:Toto 2:Tata 3:titi"
					Mess_Aide = Mess_Aide & CRLF
					Mess_Aide = Mess_Aide & CRLF & " A savoir: Les nom de variables contenant " & CHR(34) & "_, ., -, $, /, \, (, ), [, ], ~, &, #, ^, @" & CHR(34) & " sont autorises"
					Mess_Aide = Mess_Aide & CRLF
					Mess_Aide = Mess_Aide & CRLF & "  Voir aussi : txt/ , ccp/"
					Mess_Aide = Mess_Aide & CRLF
				ELSEIF CPCDOS_INSTANCE.Utilisateur_Langage = 1 THEN
					Mess_Aide = Mess_Aide & CRLF & "  Fonctionnality :"
					Mess_Aide = Mess_Aide & CRLF & "   This command allow to create a variable or array(s)"
					Mess_Aide = Mess_Aide & CRLF
					Mess_Aide = Mess_Aide & CRLF & "  Simple exemple :"
					Mess_Aide = Mess_Aide & CRLF & "   set/ My_Variable = Johann"
					Mess_Aide = Mess_Aide & CRLF & "   txt/ Hi %My_variable% !"
					Mess_Aide = Mess_Aide & CRLF & "  Delete variable/array:"
					Mess_Aide = Mess_Aide & CRLF & "   set/ /S My_variable"
					Mess_Aide = Mess_Aide & CRLF & "  Asking user :"
					Mess_Aide = Mess_Aide & CRLF & "   set/ /q My_Variable"
					Mess_Aide = Mess_Aide & CRLF & "   Wait key press (Blocking):"
					Mess_Aide = Mess_Aide & CRLF & "   set/ /wkey My_Variable"
					Mess_Aide = Mess_Aide & CRLF & "   Ckeck keyboard buffer content (no blocking):"
					Mess_Aide = Mess_Aide & CRLF & "   set/ /key My_Variable"
					Mess_Aide = Mess_Aide & CRLF
					Mess_Aide = Mess_Aide & CRLF & "  Exemple tableau :"
					Mess_Aide = Mess_Aide & CRLF & "   set/ My_Array[0] = Toto"
					Mess_Aide = Mess_Aide & CRLF & "   set/ My_Array[1] = Tata"
					Mess_Aide = Mess_Aide & CRLF & "   set/ My_Array[2] = titi"
					Mess_Aide = Mess_Aide & CRLF & "   txt/ Array content 1:%My_Array[0]% 2:%My_Array[1]% 3:%My_Array[2]% "
					Mess_Aide = Mess_Aide & CRLF
					Mess_Aide = Mess_Aide & CRLF & "  Results :"
					Mess_Aide = Mess_Aide & CRLF & "   Array content 1:Toto 2:Tata 3:titi"
					Mess_Aide = Mess_Aide & CRLF
					Mess_Aide = Mess_Aide & CRLF & " To know: Variable names contenting " & CHR(34) & "_, ., -, $, /, \, (, ), [, ], ~, &, #, ^, @" & CHR(34) & " are authorized"
					Mess_Aide = Mess_Aide & CRLF
					Mess_Aide = Mess_Aide & CRLF & "  See also : txt/ , ccp/"
					Mess_Aide = Mess_Aide & CRLF
				END IF
				DEBUG(Mess_Aide, Affichage, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_SURBRILLE, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.SansDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_AFF, RetourVAR)
				testCMD = 0
				AfficherAide = 0
				exit _scope_CMD, _scope
			END IF
			' Tester la syntaxe
			testCMD	= CCP_Verifier_Syntaxe(Commande, CommPosition)
			IF testCMD > 10 Then exit _scope_CMD, _scope
			IF testCMD > 0 then  ' Entre 1-5 = Pas d'affichage via le @, @$ ou @#
				IF testCMD < 6 then
					Affichage = 0
					IF testCMD = 3 Then CpcdosCP_SHELL("FIX/ " & CPCDOS_INSTANCE.DEBUG_INSTANCE.LeRetour & " = \#NULL", _CLE_, NIVEAU_CCP, Param_1, Param_2) : RetourVAR = _CLE_ & "N" & NIVEAU_CCP & "->" & CPCDOS_INSTANCE.DEBUG_INSTANCE.LeRetour
					if testCMD = 2 Then RetourVAR = "$>" & CPCDOS_INSTANCE.DEBUG_INSTANCE.LeRetour ' ajouter une securite ?
				Else
					Affichage = 1
				END IF
			Else
				Affichage = 1
			END IF
			' Recuperer les Parametres
			Param = MID(Commande, CommPosition + TailleComm + 2)

			SCOPE
			' ====================================================================

			Dim RapidAdd				as Boolean = false
			Dim PosPP					as Integer = 0
			Dim PosMM					as Integer = 0
			Dim PosEgale 				as Integer = 0 ' 587
			Dim PosSupprimer 			as Integer = 0 ' 571
			Dim PosATouche_EN 			as Integer = 0
			Dim PosTouche_EN 			as Integer = 0
			Dim PosQuestion	 			as Integer = 0
			Dim PosATouche	 			as Integer = 0
			Dim PosTouche	 			as Integer = 0

			Dim index 					as integer = 0

			Dim Nom_Variable_a_FIXER 	as String
			Dim Donnees_Variables_de_FIX as String

			PosEgale = instr(Param, "=")

			PosPP = instr(UCASE(Param), "++") ' Ajouter +1 a une variable
			PosMM = instr(UCASE(Param), "--") ' Ajouter -1 a une variable
			if PosPP > 0 OR PosMM > 0 Then RapidAdd = true

			PosQuestion = instr(UCASE(Param), "/Q") ' Poser une question a l'utilisateur
			IF PosQuestion > 0 then
				if instr(UCASE(Param), "/Q ") > 0 Then
					if PosEgale > 0 then ' si = est present
						if PosQuestion < PosEgale then ' et qu'il soit apres le /s
							if instr(UCASE(Param), " /Q ") > PosQuestion then
								Message_erreur = ERRAVT("AVT_056", 0)
								DEBUG("[CpcdosC+] " & Message_erreur & " " & CHR(34) & Commande & CHR(34) & ".", Affichage, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_AVERTISSEMENT, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.SansDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_AFF, RetourVAR)
								exit _scope_CMD, _scope
							end if
						else
							PosQuestion = 0
						END IF
					END IF
				ELSE
					if PosEgale > 0 then ' si = est present
						if PosQuestion < PosEgale then ' et qu'il soit apres le /s
							Message_erreur = ERRAVT("AVT_049", 0)
							DEBUG("[CpcdosC+] " & Message_erreur & " " & CHR(34) & Commande & CHR(34) & ".", Affichage, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_AVERTISSEMENT, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.SansDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_AFF, RetourVAR)
							exit _scope_CMD, _scope
						else
							PosQuestion = 0
						END IF
					END IF
				END IF
			End if

			PosATouche = instr(UCASE(Param), "/ATOUCHE") ' Attendre la pression d'une touche
			IF PosATouche > 0 then
				if instr(UCASE(Param), "/ATOUCHE ") > 0 Then
					if PosEgale > 0 then ' si = est present
						if PosATouche < PosEgale then ' et qu'il soit apres le /s
							if instr(UCASE(Param), " /ATOUCHE ") > PosATouche then
								Message_erreur = ERRAVT("AVT_056", 0)
								DEBUG("[CpcdosC+] " & Message_erreur & " " & CHR(34) & Commande & CHR(34) & ".", Affichage, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_AVERTISSEMENT, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.SansDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_AFF, RetourVAR)
								exit _scope_CMD, _scope
							end if
						else
							PosATouche = 0
						END IF
					END IF
				ELSE
					if PosEgale > 0 then ' si = est present
						if PosATouche < PosEgale then ' et qu'il soit apres le /s
							Message_erreur = ERRAVT("AVT_049", 0)
							DEBUG("[CpcdosC+] " & Message_erreur & " " & CHR(34) & Commande & CHR(34) & ".", Affichage, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_AVERTISSEMENT, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.SansDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_AFF, RetourVAR)
							exit _scope_CMD, _scope
						else
							PosATouche = 0
						END IF
					END IF
				END IF
			End if

			PosTouche = instr(UCASE(Param), "/TOUCHE") ' Ckecker le contenu du buffer
			IF PosTouche > 0 then
				if instr(UCASE(Param), "/TOUCHE ") > 0 Then
					if PosEgale > 0 then ' si = est present
						if PosTouche < PosEgale then ' et qu'il soit apres le /TOUCHE
							if instr(UCASE(Param), " /TOUCHE ") > PosTouche then
								Message_erreur = ERRAVT("AVT_056", 0)
								DEBUG("[CpcdosC+] " & Message_erreur & " " & CHR(34) & Commande & CHR(34) & ".", Affichage, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_AVERTISSEMENT, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.SansDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_AFF, RetourVAR)
								exit _scope_CMD, _scope
							end if
						else
							PosTouche = 0
						END IF
					END IF
				ELSE
					if PosEgale > 0 then ' si = est present
						if PosTouche < PosEgale then ' et qu'il soit apres le /s
							Message_erreur = ERRAVT("AVT_049", 0)
							DEBUG("[CpcdosC+] " & Message_erreur & " " & CHR(34) & Commande & CHR(34) & ".", Affichage, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_AVERTISSEMENT, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.SansDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_AFF, RetourVAR)
							exit _scope_CMD, _scope
						else
							PosTouche = 0
						END IF
					END IF
				END IF
			End if

			PosATouche_EN = instr(UCASE(Param), "/WKEY") ' Attendre la pression d'une touche
			IF PosATouche_EN > 0 then
				if instr(UCASE(Param), "/WKEY ") > 0 Then
					if PosEgale > 0 then ' si = est present
						if PosATouche_EN < PosEgale then ' et qu'il soit apres le /WKEY
							if instr(UCASE(Param), " /WKEY ") > PosATouche_EN then
								Message_erreur = ERRAVT("AVT_056", 0)
								DEBUG("[CpcdosC+] " & Message_erreur & " " & CHR(34) & Commande & CHR(34) & ".", Affichage, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_AVERTISSEMENT, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.SansDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_AFF, RetourVAR)
								exit _scope_CMD, _scope
							end if
						else
							PosATouche_EN = 0
						END IF
					END IF
				ELSE
					if PosEgale > 0 then ' si = est present
						if PosATouche_EN < PosEgale then ' et qu'il soit apres le /s
							Message_erreur = ERRAVT("AVT_049", 0)
							DEBUG("[CpcdosC+] " & Message_erreur & " " & CHR(34) & Commande & CHR(34) & ".", Affichage, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_AVERTISSEMENT, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.SansDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_AFF, RetourVAR)
							exit _scope_CMD, _scope
						else
							PosATouche_EN = 0
						END IF
					END IF
				END IF
			End if

			PosTouche_EN = instr(UCASE(Param), "/KEY") ' Ckecker le contenu du buffer
			IF PosTouche_EN > 0 then
				if instr(UCASE(Param), "/KEY ") > 0 Then
					if PosEgale > 0 then ' si = est present
						if PosTouche_EN < PosEgale then ' et qu'il soit apres le /KEY
							if instr(UCASE(Param), " /KEY ") > PosTouche_EN then
								Message_erreur = ERRAVT("AVT_056", 0)
								DEBUG("[CpcdosC+] " & Message_erreur & " " & CHR(34) & Commande & CHR(34) & ".", Affichage, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_AVERTISSEMENT, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.SansDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_AFF, RetourVAR)
								exit _scope_CMD, _scope
							end if
						else
							PosTouche_EN = 0
						END IF
					END IF
				ELSE
					if PosEgale > 0 then ' si = est present
						if PosTouche_EN < PosEgale then ' et qu'il soit apres le /s
							Message_erreur = ERRAVT("AVT_049", 0)
							DEBUG("[CpcdosC+] " & Message_erreur & " " & CHR(34) & Commande & CHR(34) & ".", Affichage, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_AVERTISSEMENT, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.SansDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_AFF, RetourVAR)
							exit _scope_CMD, _scope
						else
							PosTouche_EN = 0
						END IF
					END IF
				END IF
			End if

			PosSupprimer = instr(UCASE(Param), "/S") ' Supprimer une variable
			IF PosSupprimer > 0 then
				if instr(UCASE(Param), "/S ") > 0 Then
					if PosEgale > 0 then ' si = est present
						if PosSupprimer < PosEgale then ' et qu'il soit apres le /s
							if instr(UCASE(Param), " /S ") > PosSupprimer then
								Message_erreur = ERRAVT("AVT_049", 0)
								DEBUG("[CpcdosC+] " & Message_erreur & " " & CHR(34) & Commande & CHR(34) & ".", Affichage, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_AVERTISSEMENT, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.SansDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_AFF, RetourVAR)
								exit _scope_CMD, _scope
							end if
						else
							PosSupprimer = 0
						end if
					end if
				ELSE
					if PosEgale > 0 then ' si = est present
						if PosEgale > PosSupprimer then
							Message_erreur = ERRAVT("AVT_049", 0)
							DEBUG("[CpcdosC+] " & Message_erreur & " " & CHR(34) & Commande & CHR(34) & ".", Affichage, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_AVERTISSEMENT, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.SansDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_AFF, RetourVAR)
							exit _scope_CMD, _scope
						else
							PosSupprimer = 0
						end if
					END IF
				End if
			End if


			' Gerer le probleme de placement du signe '='
			If PosEgale > 0 then
				if instr(Param, "=") > 0 Then
					if instr(Param, "=") > PosEgale then
						Message_erreur = ERRAVT("AVT_048", 0)
						DEBUG("[CpcdosC+] " & Message_erreur & " " & CHR(34) & Commande & CHR(34) & ".", Affichage, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_AVERTISSEMENT, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.SansDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_AFF, RetourVAR)
						exit _scope_CMD, _scope
					end if
				ELSE
					Message_erreur = ERRAVT("AVT_048", 0)
					DEBUG("[CpcdosC+] " & Message_erreur & " " & CHR(34) & Commande & CHR(34) & ".", Affichage, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_AVERTISSEMENT, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.SansDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_AFF, RetourVAR)
					exit _scope_CMD, _scope
				END IF
			End if

			' Si l'utilisateur rentre tard le soir d'une soir�e bien arros�e et
			' compl�tement torch� entre une commande du type :
			' fix/ /s mariable = contenu wtf
			if PosEgale > PosSupprimer THEN
				IF PosEgale > 0 then
					IF PosSupprimer > 0 Then
						Message_erreur = ERRAVT("AVT_049", 0)
						DEBUG("[CpcdosC+] " & Message_erreur & " " & CHR(34) & Commande & CHR(34) & ".", Affichage, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_AVERTISSEMENT, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.SansDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_AFF, RetourVAR)
						exit _scope_CMD, _scope
					End if
				End if
			End if

			if PosEgale > PosQuestion THEN
				IF PosEgale > 0 then
					IF PosQuestion > 0 Then
						Message_erreur = ERRAVT("AVT_048", 0)
						DEBUG("[CpcdosC+] " & Message_erreur & " " & CHR(34) & Commande & CHR(34) & ".", Affichage, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_AVERTISSEMENT, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.SansDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_AFF, RetourVAR)
						exit _scope_CMD, _scope
					End if
				End if
			End if

			if PosEgale > PosTouche THEN
				IF PosEgale > 0 then
					IF PosTouche > 0 Then
						Message_erreur = ERRAVT("AVT_048", 0)
						DEBUG("[CpcdosC+] " & Message_erreur & " " & CHR(34) & Commande & CHR(34) & ".", Affichage, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_AVERTISSEMENT, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.SansDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_AFF, RetourVAR)
						exit _scope_CMD, _scope
					End if
				End if
			End if

			if PosEgale > PosATouche THEN
				IF PosEgale > 0 then
					IF PosATouche > 0 Then
						Message_erreur = ERRAVT("AVT_048", 0)
						DEBUG("[CpcdosC+] " & Message_erreur & " " & CHR(34) & Commande & CHR(34) & ".", Affichage, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_AVERTISSEMENT, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.SansDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_AFF, RetourVAR)
						exit _scope_CMD, _scope
					End if
				End if
			End if

			if PosEgale > PosTouche_EN THEN
				IF PosEgale > 0 then
					IF PosTouche_EN > 0 Then
						Message_erreur = ERRAVT("AVT_048", 0)
						DEBUG("[CpcdosC+] " & Message_erreur & " " & CHR(34) & Commande & CHR(34) & ".", Affichage, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_AVERTISSEMENT, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.SansDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_AFF, RetourVAR)
						exit _scope_CMD, _scope
					End if
				End if
			End if

			' Si variable++ variable--
			if PosEgale < 1 AND PosATouche < 1 AND PosTouche_EN < 1 AND PosQuestion < 1 AND PosSupprimer < 1 Then
				if RapidAdd = true Then
					Dim VariableCalc as double
					Dim VariableCalc_STR as String

					' Il s'agit d'un ++
					If PosPP > 0 Then
						VariableCalc_STR = RTRIM(RTRIM(RTRIM(LTRIM(LTRIM(MID(Param, 1, PosPP - 1), CHR(09)))), chr(13)), chr(10))
						if len(VariableCalc_STR) > 0 Then
							VariableCalc = Val(CPCDOS_INSTANCE.SHELLCCP_INSTANCE.CCP_Lire_Variable(VariableCalc_STR, Niveau_2, _CLE_))

							VariableCalc += 1

							CpcdosCP_SHELL = CpcdosCP_SHELL("FIX/ " & VariableCalc_STR & " = " & VariableCalc, _CLE_, Niveau_2, Param_1, Param_2)
						Else
							IF CPCDOS_INSTANCE.Utilisateur_Langage = 0 then
								DEBUG("[CpcdosC+] Impossible d'additionner. " & CHR(34) & Commande & CHR(34) & ".", Affichage, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_AVERTISSEMENT, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.SansDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_AFF, RetourVAR)
							Else
								DEBUG("[CpcdosC+] Unable to add " & CHR(34) & Commande & CHR(34) & ".", Affichage, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_AVERTISSEMENT, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.SansDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_AFF, RetourVAR)
							End if
						End if

						exit _scope_CMD, _scope

					' Il s'agit d'un --
					ElseIf PosMM > 0 Then
						VariableCalc_STR = RTRIM(RTRIM(RTRIM(LTRIM(LTRIM(MID(Param, 1, PosMM - 1), CHR(09)))), chr(13)), chr(10))
						if len(VariableCalc_STR) > 0 Then
							VariableCalc = Val(CPCDOS_INSTANCE.SHELLCCP_INSTANCE.CCP_Lire_Variable(VariableCalc_STR, Niveau_2, _CLE_))

							VariableCalc -= 1

							CpcdosCP_SHELL = CpcdosCP_SHELL("FIX/ " & VariableCalc_STR & " = " & VariableCalc, _CLE_, Niveau_2, Param_1, Param_2)
						Else
							IF CPCDOS_INSTANCE.Utilisateur_Langage = 0 then
								DEBUG("[CpcdosC+] Impossible de soustraire. " & CHR(34) & Commande & CHR(34) & ".", Affichage, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_AVERTISSEMENT, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.SansDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_AFF, RetourVAR)
							Else
								DEBUG("[CpcdosC+] Unable to substract. " & CHR(34) & Commande & CHR(34) & ".", Affichage, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_AVERTISSEMENT, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.SansDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_AFF, RetourVAR)
							End if
						End if

					End if

					exit _scope_CMD, _scope
				Else
					Message_erreur = ERRAVT("AVT_083", 0)
					DEBUG("[CpcdosC+] " & Message_erreur & " " & CHR(34) & Commande & CHR(34) & ".", Affichage, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_AVERTISSEMENT, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.SansDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_AFF, RetourVAR)
					exit _scope_CMD, _scope
				End if
			End if

			IF PosTouche > 0 OR PosTouche_EN > 0 Then
				' Si on veut juste le contenu du buffer
				dim VariableQuestion as string
				Dim KeyBuffer as String

				IF PosTouche > 0 Then
					VariableQuestion = RTRIM(RTRIM(RTRIM(LTRIM(LTRIM(MID(Param, PosTouche + 8), CHR(09)))), chr(13)), chr(10))
				Elseif PosTouche_EN > 0 Then
					VariableQuestion = RTRIM(RTRIM(RTRIM(LTRIM(LTRIM(MID(Param, PosTouche + 5), CHR(09)))), chr(13)), chr(10))
				else
					DEBUG("[CpcdosC+] ERR IND_1.", Affichage, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_AVERTISSEMENT, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.SansDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_AFF, RetourVAR)
					exit _scope_CMD, _scope
				End if

				KeyBuffer = Inkey

				if KeyBuffer = "" then KeyBuffer = "\#NULL"

				CpcdosCP_SHELL = CpcdosCP_SHELL("FIX/ " & VariableQuestion & " = " & KeyBuffer, _CLE_, Niveau_2, Param_1, Param_2)

				exit _scope_CMD, _scope
			End if

			if PosQuestion > 0 OR PosATouche > 0 OR PosATouche_EN > 0 then
				' Si un veut une reponse de la part de l'utilisateur
				' Si on est en graphique, un messagebox apparait, si on est en console le message console apparait
				dim VariableQuestion as string


				' On recupere la variable en supprimant les espace et TABs
				IF PosATouche > 0 Then
					VariableQuestion = RTRIM(RTRIM(RTRIM(LTRIM(LTRIM(MID(Param, PosATouche + 9), CHR(09)))), chr(13)), chr(10))
				ElseIf PosATouche_EN > 0 Then
					VariableQuestion = RTRIM(RTRIM(RTRIM(LTRIM(LTRIM(MID(Param, PosATouche_EN + 6), CHR(09)))), chr(13)), chr(10))
				Elseif PosQuestion > 0 Then
					VariableQuestion = RTRIM(RTRIM(RTRIM(LTRIM(LTRIM(MID(Param, PosQuestion + 3), CHR(09)))), chr(13)), chr(10))
				else
					DEBUG("[CpcdosC+] ERR IND_2.", Affichage, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_AVERTISSEMENT, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.SansDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_AFF, RetourVAR)
					exit _scope_CMD, _scope
				End if

				' Faire sorte que quand on est en mode console, si une 2eme application
				' utilise cette commande, elle se met en pause.
				CPCDOS_INSTANCE.CONSOLE_INSTANCE.FIXQuestion 			= VariableQuestion
				CPCDOS_INSTANCE.CONSOLE_INSTANCE.FIXQuestion_TOCK 		= 0
				CPCDOS_INSTANCE.CONSOLE_INSTANCE.FIXQuestion_CLE_ 		= _CLE_
				CPCDOS_INSTANCE.CONSOLE_INSTANCE.FIXQuestion_NIVEAU_CCP = NIVEAU_CCP
				CPCDOS_INSTANCE.CONSOLE_INSTANCE.FIXQuestion_Param_1 	= Param_1
				CPCDOS_INSTANCE.CONSOLE_INSTANCE.FIXQuestion_Param_2 	= Param_2

				' Vider le contenu du buffer
				CPCDOS_INSTANCE.CONSOLE_INSTANCE.Buffer_commande = ""

				scope


					' Creer une instance de _STRUCT_THREAD_Cpcdos_OSx__, remplir le donnees
					Dim _TID_Console_QUESTION as uinteger
					Dim INSTANCE_STRUCT_THREAD as _STRUCT_THREAD_Cpcdos_OSx__
					' Remplir la structure
					INSTANCE_STRUCT_THREAD.Nom 		= "THREAD__GetTouche"			' Nom du thread
					INSTANCE_STRUCT_THREAD.Fonction = @THREAD__GetTouche			' Adresse memoire
					INSTANCE_STRUCT_THREAD.PROC_ID 	= Auth_PID						' PID du processus parent
					INSTANCE_STRUCT_THREAD.OS_ID	= CPCDOS_INSTANCE.get_id_OS()	' ID de l'OS
					INSTANCE_STRUCT_THREAD.THREAD_ID= Auth_TID
					INSTANCE_STRUCT_THREAD.USER_ID	= CPCDOS_INSTANCE.get_id_Utilisateur()	' ID de l'user
					INSTANCE_STRUCT_THREAD.KERNEL_ID= Auth_Kernel						' ID du kernel

					INSTANCE_STRUCT_THREAD.Priorite = _PRIORITE_THRD_ASSEZ_HAUTE
					INSTANCE_STRUCT_THREAD.handle	= 0								' Argument pour CPinti Core
					INSTANCE_STRUCT_THREAD.ARG_CP	= NULL							' Argument pour CPinti Core
					INSTANCE_STRUCT_THREAD.ARG_1 	= NULL
					INSTANCE_STRUCT_THREAD.ARG_2 	= NULL
					INSTANCE_STRUCT_THREAD.ARG_3	= NULL
					INSTANCE_STRUCT_THREAD.ARG_4	= NULL
					INSTANCE_STRUCT_THREAD.ARG_5 	= NULL
					INSTANCE_STRUCT_THREAD.ARG_6 	= NULL


					IF PosQuestion > 0 Then
						INSTANCE_STRUCT_THREAD.ARG_1 	= cast(any ptr, 2)
						INSTANCE_STRUCT_THREAD.Nom = INSTANCE_STRUCT_THREAD.Nom & "_QUESTION"
					ElseIf PosATouche > 0 OR PosATouche_EN > 0 Then
						INSTANCE_STRUCT_THREAD.ARG_1 	= cast(any ptr, 1)
						INSTANCE_STRUCT_THREAD.Nom = INSTANCE_STRUCT_THREAD.Nom & "_KEY"
					End if

					INSTANCE_STRUCT_THREAD.ARG_2 = cast(any ptr, @POS) 		' Position curseur X
					INSTANCE_STRUCT_THREAD.ARG_3 = cast(any ptr, @CSRLIN) 	' Position curseur Y

					scope
						' Creer le thread temporaire grace a la structure ci-dessus
						_TID_Console_QUESTION = CPCDOS_INSTANCE.Creer_thread(INSTANCE_STRUCT_THREAD)
						' On bloque le thread tant que FIXQuestion n'est pas null
						while(CPCDOS_INSTANCE.CONSOLE_INSTANCE.FIXQuestion = VariableQuestion)
							doevents(50000)
						Wend

						' On ferme le thread qui a permi taper sur la console
						CPCDOS_INSTANCE.Fermer_thread(Auth_PID, _TID_Console_QUESTION, false)

					End scope

				End scope

				exit _scope_CMD, _scope
			End if

			IF PosEgale > 0 then
				Dim PtitSautNomValide as integer
				Dim PremiereParenthese as integer = 0
				Dim DeuxiemeParenthese as integer = 0
				' Si on arrive la, c'est que le placement de '=' est OK! :-)
				' Recuperer le nom de variable
				Nom_Variable_a_FIXER = RTRIM(LTRIM(LTRIM(MID(Param, 1, PosEgale - 1)), CHR(09))) ' Supprimer ESPACES et tabulations


				' Verifier caractere par caractere s'il respecte le nom de variable type cpcdosc+
				For BoucleChercherValideNomVariable as integer = 1 to 255
					PtitSautNomValide = 0
					IF BoucleChercherValideNomVariable = 35 Then PtitSautNomValide = 1 ' #
					IF BoucleChercherValideNomVariable = 36 Then PtitSautNomValide = 1 ' $
					IF BoucleChercherValideNomVariable = 38 Then PtitSautNomValide = 1 ' &
					IF BoucleChercherValideNomVariable = 40 Then PtitSautNomValide = 1 ' (
					IF BoucleChercherValideNomVariable = 41 Then PtitSautNomValide = 1 ' )
					IF BoucleChercherValideNomVariable >= 45 Then
						IF BoucleChercherValideNomVariable <= 57 Then
							PtitSautNomValide = 1  ' - . / 0 1 2 3 4 5 6 7 8 9
						End if
					End if
					IF BoucleChercherValideNomVariable >= 64 Then
						IF BoucleChercherValideNomVariable <= 95 Then
							PtitSautNomValide = 1  ' @, A-Z (majuscule), [, \, ], ^
						End if
					End if
					IF BoucleChercherValideNomVariable >= 97 Then
						IF BoucleChercherValideNomVariable <= 122 Then
							PtitSautNomValide = 1  ' a-z (minuscules)
						End if
					End if
					IF BoucleChercherValideNomVariable = 126 Then PtitSautNomValide = 1 ' ~
					'								Si 1 seule des 2 parentheses est presente
					IF PtitSautNomValide = 0 then
						IF INSTR(UCASE(Nom_Variable_a_FIXER), " A ") > 0 OR INSTR(UCASE(Nom_Variable_a_FIXER), " TO ") > 0 OR INSTR(UCASE(Nom_Variable_a_FIXER), "..") > 0 Then
						ELSE
							If Instr(Nom_Variable_a_FIXER, chr(BoucleChercherValideNomVariable)) > 0 Then
								Message_erreur = ERRAVT("AVT_048", 0)
								IF CPCDOS_INSTANCE.Utilisateur_Langage = 0 then
									DEBUG("[CpcdosC+] " & Message_erreur & ". Caractere invalide '" & chr(BoucleChercherValideNomVariable) &"'. Commande:" & CHR(34) & Commande & CHR(34) & ".", Affichage, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_AVERTISSEMENT, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.AvecDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_AFF, RetourVAR)
									exit _scope_CMD, _scope
								Else
									DEBUG("[CpcdosC+] " & Message_erreur & ". Invalid character '" & chr(BoucleChercherValideNomVariable) &"' Command:" & CHR(34) & Commande & CHR(34) & ".", Affichage, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_AVERTISSEMENT, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.AvecDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_AFF, RetourVAR)
									exit _scope_CMD, _scope
								End if
							End if
						End if
					End if
				Next BoucleChercherValideNomVariable

				' Si c'est un tableau et ce qui a entre les parentheses n'est pas un chiffres
				'  mais une varaible, alors on remplace ce nom de variable par son contenu
				PremiereParenthese = INSTR(Nom_Variable_a_FIXER, "[")

				IF PremiereParenthese > 0 Then
					DeuxiemeParenthese = INSTR(Nom_Variable_a_FIXER, "]")
					' Si la premi�re parenthese '[' est bien avant la deuxieme ']'
					if PremiereParenthese >= DeuxiemeParenthese Then
						Message_erreur = ERRAVT("AVT_073", 0)
						IF CPCDOS_INSTANCE.Utilisateur_Langage = 0 Then
							DEBUG("[AVT_073]:" & Message_erreur & " votre nom de variable '" & Nom_Variable_a_FIXER & "'", CPCDOS_INSTANCE.DEBUG_INSTANCE.Ecran, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_AVERTISSEMENT, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.SansDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_AFF, RetourVAR)
						Else
							DEBUG("[AVT_073]:" & Message_erreur & " your variable name '" & Nom_Variable_a_FIXER & "'", CPCDOS_INSTANCE.DEBUG_INSTANCE.Ecran, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_AVERTISSEMENT, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.SansDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_AFF, RetourVAR)
						End if
						exit _scope_CMD, _scope
					End if
				End if

				' Maintenant qu'on a le nom de variable recupere, on recupere ce qu'il y a apres '='
				Donnees_Variables_de_FIX = MID(Param, PosEgale + 1)

				' S'il y a 1 espace, alors le conderer comme un espacement sur la syntaxe
				'  le 2eme sera pris en compte s'il est aussi present
				IF MID(Donnees_Variables_de_FIX, 1, 1) = " " THEN Donnees_Variables_de_FIX = MID(Donnees_Variables_de_FIX, 2)

				IF INSTR(UCASE(Nom_Variable_a_FIXER), " A ") > 0 OR INSTR(UCASE(Nom_Variable_a_FIXER), " TO ") > 0 OR INSTR(UCASE(Nom_Variable_a_FIXER), "..") > 0Then

					Dim PremierNombre as Integer
					Dim DeuxiemeNombre as Integer
					Dim NombreBoucle as integer

					Dim Crochet_1 as integer = INSTR(Nom_Variable_a_FIXER, "[")
					Dim Crochet_2 as integer = INSTRREV(Nom_Variable_a_FIXER, "]")

					Dim Jusqu_A as integer = INSTR(UCASE(Nom_Variable_a_FIXER), " A ")
					Dim Jusqu_TO as integer = INSTR(UCASE(Nom_Variable_a_FIXER), " TO ")
					Dim Jusqu_3PTS as integer = INSTR(UCASE(Nom_Variable_a_FIXER), "..")

					IF Jusqu_A > 0 Then
						' En enlevant les espaces et tab
						PremierNombre = VAL(LTRIM(LTRIM(RTRIM(RTRIM(Mid(Nom_Variable_a_FIXER, Crochet_1 + 1, Jusqu_A - (Crochet_1 + 1)), chr(09))), chr(09))))

						DeuxiemeNombre = VAL(LTRIM(LTRIM(RTRIM(RTRIM(Mid(Nom_Variable_a_FIXER, Jusqu_A+2 + 1, Crochet_2 - (Jusqu_A+2 + 1)), chr(09))), chr(09))))

					ElseIf Jusqu_TO > 0 Then

						PremierNombre = VAL(LTRIM(LTRIM(RTRIM(RTRIM(Mid(Nom_Variable_a_FIXER, Crochet_1 + 1, Jusqu_TO - (Crochet_1 + 1)), chr(09))), chr(09))))

						DeuxiemeNombre = VAL(LTRIM(LTRIM(RTRIM(RTRIM(Mid(Nom_Variable_a_FIXER, Jusqu_TO+3 + 1, Crochet_2 - (Jusqu_TO+3 + 1)), chr(09))), chr(09))))
					ElseIf Jusqu_3PTS > 0 Then

						PremierNombre = VAL(LTRIM(LTRIM(RTRIM(RTRIM(Mid(Nom_Variable_a_FIXER, Crochet_1 + 1, Jusqu_3PTS - (Crochet_1 + 1)), chr(09))), chr(09))))

						DeuxiemeNombre = VAL(LTRIM(LTRIM(RTRIM(RTRIM(Mid(Nom_Variable_a_FIXER, Jusqu_3PTS+1 + 1, Crochet_2 - (Jusqu_3PTS+1 + 1)), chr(09))), chr(09))))

					End if

					Nom_Variable_a_FIXER = LTRIM(LTRIM(RTRIM(RTRIM(MID(Nom_Variable_a_FIXER, 1, Crochet_1 - 1)), CHR(09))), CHR(09))
					NombreBoucle = DeuxiemeNombre - PremierNombre

					' Si il a mis du genre [5 a 20]
					if NombreBoucle > 0 Then
						For Index_Boucle as integer = PremierNombre to DeuxiemeNombre
							' Creer en boucle le tableau mais avec le contenu souhaite !
							IF CPCDOS_INSTANCE.SYSTEME_INSTANCE.get_DBG_DEBUG() > 0 Then
								IF CPCDOS_INSTANCE.Utilisateur_Langage = 0 Then
									DEBUG("[CpcdosC+] Creation de la variable " & Nom_Variable_a_FIXER & CRLF & " - CleID:" & _CLE_ & " [&B" & Bin(_CLE_, 36) & "] -> 0x" & hex(_CLE_, 10) & CRLF & " - Taille:" & LEN(Donnees_Variables_de_FIX) & " octets" & CRLF & " - Niveau:" & NIVEAU_CCP & CRLF & " - idKernel:" & Auth_Kernel & CRLF & " - idOS:" & Auth_OS & CRLF & " - idUtilisateur:" & Auth_Utilisateur & CRLF & " - PID:" & Auth_PID & CRLF & " - TID:" & Auth_TID, Affichage, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_ACTION, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.AvecDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_CPCDOS, RetourVAR)
								Else
									DEBUG("[CpcdosC+] Creating variable " & Nom_Variable_a_FIXER & CRLF & " - CleID:" & _CLE_ & " [&B" & Bin(_CLE_, 36) & "] -> 0x" & hex(Auth_PID, 10) & CRLF & " - Size:" & LEN(Donnees_Variables_de_FIX) & " bytes" & CRLF & " - Niveau:" & NIVEAU_CCP & CRLF & " - idKernel:" & Auth_Kernel & CRLF & " - idOS:" & Auth_OS & CRLF & " - idUtilisateur:" & Auth_Utilisateur & CRLF & " - PID:" & Auth_PID & CRLF & " - TID:" & Auth_TID, Affichage, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_ACTION, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.AvecDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_CPCDOS, RetourVAR)
								End if
							END IF
							index = Gest_variables_ENREG (Nom_Variable_a_FIXER & "[" & Index_Boucle & "]", Donnees_Variables_de_FIX, NIVEAU_CCP, Auth_Kernel, Auth_OS, Auth_Utilisateur, Auth_PID, Auth_TID)
							IF CPCDOS_INSTANCE.SYSTEME_INSTANCE.get_DBG_DEBUG() > 0 Then
								IF CPCDOS_INSTANCE.Utilisateur_Langage = 0 Then
									DEBUG("[CpcdosC+] Creation de la variable [OK] -> [0x" & hex(index, 8) & "]", Affichage, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_VALIDATION, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.AvecDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_CPCDOS, RetourVAR)
								Else
									DEBUG("[CpcdosC+] Creating variable [OK] -> [0x" & hex(index, 8) & "]" , Affichage, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_VALIDATION, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.AvecDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_CPCDOS, RetourVAR)
								End if
							END IF
						Next Index_Boucle

					' Si il a mis du genre [20 a 5]
					Elseif NombreBoucle < 0 Then
						For Index_Boucle as integer = DeuxiemeNombre to PremierNombre
							' Creer en boucle le tableau mais avec le contenu souhaite !
							IF CPCDOS_INSTANCE.SYSTEME_INSTANCE.get_DBG_DEBUG() > 0 Then
								IF CPCDOS_INSTANCE.Utilisateur_Langage = 0 Then
									DEBUG("[CpcdosC+] Creation de la variable " & Nom_Variable_a_FIXER & CRLF & " - CleID:" & _CLE_ & " [&B" & Bin(_CLE_, 36) & "] -> 0x" & hex(_CLE_, 10) & CRLF & " - Taille:" & LEN(Donnees_Variables_de_FIX) & " octets" & CRLF & " - Niveau:" & NIVEAU_CCP & CRLF & " - idKernel:" & Auth_Kernel & CRLF & " - idOS:" & Auth_OS & CRLF & " - idUtilisateur:" & Auth_Utilisateur & CRLF & " - PID:" & Auth_PID & CRLF & " - TID:" & Auth_TID, Affichage, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_ACTION, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.AvecDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_CPCDOS, RetourVAR)
								Else
									DEBUG("[CpcdosC+] Creating variable " & Nom_Variable_a_FIXER & CRLF & " - CleID:" & _CLE_ & " [&B" & Bin(_CLE_, 36) & "] -> 0x" & hex(Auth_PID, 10) & CRLF & " - Size:" & LEN(Donnees_Variables_de_FIX) & " bytes" & CRLF & " - Niveau:" & NIVEAU_CCP & CRLF & " - idKernel:" & Auth_Kernel & CRLF & " - idOS:" & Auth_OS & CRLF & " - idUtilisateur:" & Auth_Utilisateur & CRLF & " - PID:" & Auth_PID & CRLF & " - TID:" & Auth_TID, Affichage, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_ACTION, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.AvecDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_CPCDOS, RetourVAR)
								End if
							END IF
							index = Gest_variables_ENREG (Nom_Variable_a_FIXER & "[" & PremierNombre-(Index_Boucle-DeuxiemeNombre) & "]", Donnees_Variables_de_FIX, NIVEAU_CCP, Auth_Kernel, Auth_OS, Auth_Utilisateur, Auth_PID, Auth_TID)
							IF CPCDOS_INSTANCE.SYSTEME_INSTANCE.get_DBG_DEBUG() > 0 Then
								IF CPCDOS_INSTANCE.Utilisateur_Langage = 0 Then
									DEBUG("[CpcdosC+] Creation de la variable [OK] -> [0x" & hex(index, 8) & "]", Affichage, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_VALIDATION, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.AvecDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_CPCDOS, RetourVAR)
								Else
									DEBUG("[CpcdosC+] Creating variable [OK] -> [0x" & hex(index, 8) & "]" , Affichage, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_VALIDATION, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.AvecDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_CPCDOS, RetourVAR)
								End if
							END IF
						Next Index_Boucle
					Else
						IF CPCDOS_INSTANCE.Utilisateur_Langage = 0 Then
							DEBUG("[CpcdosC+] L'index du tableau ne peut etre nul.", Affichage, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_AVERTISSEMENT, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.AvecDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_CPCDOS, RetourVAR)
						Else
							DEBUG("[CpcdosC+] Index array can't be null." , Affichage, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_AVERTISSEMENT, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.AvecDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_CPCDOS, RetourVAR)
						End if
						exit _scope_CMD, _scope
					End if
					exit _scope_CMD, _scope
				End if

				IF CPCDOS_INSTANCE.SYSTEME_INSTANCE.get_DBG_DEBUG() > 0 Then
					IF CPCDOS_INSTANCE.Utilisateur_Langage = 0 Then
						DEBUG("[CpcdosC+] Creation de la variable " & Nom_Variable_a_FIXER & CRLF & " - CleID:" & _CLE_ & " [&B" & Bin(_CLE_, 36) & "] -> 0x" & hex(_CLE_, 10) & CRLF & " - Taille:" & LEN(Donnees_Variables_de_FIX) & " octets" & CRLF & " - Niveau:" & NIVEAU_CCP & CRLF & " - idKernel:" & Auth_Kernel & CRLF & " - idOS:" & Auth_OS & CRLF & " - idUtilisateur:" & Auth_Utilisateur & CRLF & " - PID:" & Auth_PID & CRLF & " - TID:" & Auth_TID, Affichage, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_ACTION, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.AvecDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_CPCDOS, RetourVAR)
					Else
						DEBUG("[CpcdosC+] Creating variable " & Nom_Variable_a_FIXER & CRLF & " - CleID:" & _CLE_ & " [&B" & Bin(_CLE_, 36) & "] -> 0x" & hex(Auth_PID, 10) & CRLF & " - Size:" & LEN(Donnees_Variables_de_FIX) & " bytes" & CRLF & " - Niveau:" & NIVEAU_CCP & CRLF & " - idKernel:" & Auth_Kernel & CRLF & " - idOS:" & Auth_OS & CRLF & " - idUtilisateur:" & Auth_Utilisateur & CRLF & " - PID:" & Auth_PID & CRLF & " - TID:" & Auth_TID, Affichage, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_ACTION, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.AvecDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_CPCDOS, RetourVAR)
					End if
				END IF
				index = Gest_variables_ENREG (Nom_Variable_a_FIXER, Donnees_Variables_de_FIX, NIVEAU_CCP, Auth_Kernel, Auth_OS, Auth_Utilisateur, Auth_PID, Auth_TID)
				IF CPCDOS_INSTANCE.SYSTEME_INSTANCE.get_DBG_DEBUG() > 0 Then
					IF CPCDOS_INSTANCE.Utilisateur_Langage = 0 Then
						DEBUG("[CpcdosC+] Creation de la variable [OK] -> [0x" & hex(index, 8) & "]", Affichage, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_VALIDATION, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.AvecDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_CPCDOS, RetourVAR)
					Else
						DEBUG("[CpcdosC+] Creating variable [OK] -> [0x" & hex(index, 8) & "]" , Affichage, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_VALIDATION, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.AvecDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_CPCDOS, RetourVAR)
					End if
				END IF
				exit _scope_CMD, _scope
			ELSEIF PosSupprimer > 0 Then
				' Si le Parametre /S est present, on supprime la variable
				' Recuperer le nom de variable
				Nom_Variable_a_FIXER = RTRIM(LTRIM(LTRIM(MID(Param, PosSupprimer + 3)), CHR(09)))

				' On supprime d'un element a un autre
				IF INSTR(UCASE(Nom_Variable_a_FIXER), " A ") > 0 OR INSTR(UCASE(Nom_Variable_a_FIXER), " TO ") > 0 OR INSTR(UCASE(Nom_Variable_a_FIXER), "..") > 0 Then

					Dim PremierNombre as Integer
					Dim DeuxiemeNombre as Integer
					Dim NombreBoucle as integer

					Dim Crochet_1 as integer = INSTR(Nom_Variable_a_FIXER, "[")
					Dim Crochet_2 as integer = INSTRREV(Nom_Variable_a_FIXER, "]")

					Dim Jusqu_A as integer = INSTR(UCASE(Nom_Variable_a_FIXER), " A ")
					Dim Jusqu_TO as integer = INSTR(UCASE(Nom_Variable_a_FIXER), " TO ")
					Dim Jusqu_3PTS as integer = INSTR(UCASE(Nom_Variable_a_FIXER), "..")

					IF Jusqu_A > 0 Then
						' En enlevant les espaces et tab
						PremierNombre = VAL(LTRIM(LTRIM(RTRIM(RTRIM(Mid(Nom_Variable_a_FIXER, Crochet_1 + 1, Jusqu_A - (Crochet_1 + 1)), chr(09))), chr(09))))

						DeuxiemeNombre = VAL(LTRIM(LTRIM(RTRIM(RTRIM(Mid(Nom_Variable_a_FIXER, Jusqu_A+2 + 1, Crochet_2 - (Jusqu_A+2 + 1)), chr(09))), chr(09))))

					ElseIf Jusqu_TO > 0 Then

						PremierNombre = VAL(LTRIM(LTRIM(RTRIM(RTRIM(Mid(Nom_Variable_a_FIXER, Crochet_1 + 1, Jusqu_TO - (Crochet_1 + 1)), chr(09))), chr(09))))

						DeuxiemeNombre = VAL(LTRIM(LTRIM(RTRIM(RTRIM(Mid(Nom_Variable_a_FIXER, Jusqu_TO+3 + 1, Crochet_2 - (Jusqu_TO+3 + 1)), chr(09))), chr(09))))
					ElseIf Jusqu_3PTS > 0 Then

						PremierNombre = VAL(LTRIM(LTRIM(RTRIM(RTRIM(Mid(Nom_Variable_a_FIXER, Crochet_1 + 1, Jusqu_3PTS - (Crochet_1 + 1)), chr(09))), chr(09))))

						DeuxiemeNombre = VAL(LTRIM(LTRIM(RTRIM(RTRIM(Mid(Nom_Variable_a_FIXER, Jusqu_3PTS+1 + 1, Crochet_2 - (Jusqu_3PTS+1 + 1)), chr(09))), chr(09))))
					End if

					Nom_Variable_a_FIXER = LTRIM(LTRIM(RTRIM(RTRIM(MID(Nom_Variable_a_FIXER, 1, Crochet_1 - 1)), CHR(09))), CHR(09))
					NombreBoucle = DeuxiemeNombre - PremierNombre

					Donnees_Variables_de_FIX = "\#NULL"

					' Si il a mis du genre [5 a 20]
					if NombreBoucle > 0 Then
						For Index_Boucle as integer = PremierNombre to DeuxiemeNombre
							' Creer en boucle le tableau mais avec le contenu souhaite !
							IF CPCDOS_INSTANCE.SYSTEME_INSTANCE.get_DBG_DEBUG() > 0 Then
								IF CPCDOS_INSTANCE.Utilisateur_Langage = 0 Then
									DEBUG("[CpcdosC+] Suppression de la variable " & Nom_Variable_a_FIXER & CRLF & " - CleID:" & Auth_PID & " [&B" & Bin(Auth_PID, 28) & "] -> 0x" & hex(Auth_PID, 7) & CRLF & " - Buffer:" & LEN(Commande) & " octets" & CRLF & " - Niveau:" & NIVEAU_CCP & CRLF & " - idKernel:" & Auth_Kernel & CRLF & " - idOS:" & Auth_OS & CRLF & " - idUtilisateur:" & Auth_Utilisateur & CRLF & " - PID:" & Auth_PID & CRLF & " - TID:" & Auth_TID, Affichage, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_Normal, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.AvecDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_CPCDOS, RetourVAR)
								Else
									DEBUG("[CpcdosC+] Deleting variable " & Nom_Variable_a_FIXER & CRLF & " - CleID:" & Auth_PID & " [&B" & Bin(Auth_PID, 28) & "] -> 0x" & hex(Auth_PID, 7) & CRLF & " - Buffer:" & LEN(Commande) & " octets" & CRLF & " - Niveau:" & NIVEAU_CCP & CRLF & " - idKernel:" & Auth_Kernel & CRLF & " - idOS:" & Auth_OS & CRLF & " - idUtilisateur:" & Auth_Utilisateur & CRLF & " - PID:" & Auth_PID & CRLF & " - TID:" & Auth_TID, Affichage, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_Normal, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.AvecDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_CPCDOS, RetourVAR)
								End if
							END IF
							IF Gest_variables_Suppr(Nom_Variable_a_FIXER & "[" & Index_Boucle & "]", NIVEAU_CCP, Auth_Kernel, Auth_OS, Auth_Utilisateur, Auth_PID, Auth_TID) = 0 Then
								Message_erreur = ERRAVT("AVT_008", 0)
								DEBUG("[CpcdosC+] " & Message_erreur & " " & CHR(34) & Nom_Variable_a_FIXER & CHR(34) & " dans " & CHR(34) & Commande & CHR(34), Affichage, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_AVERTISSEMENT, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.SansDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_AFF, RetourVAR)
								exit _scope_CMD, _scope
							End if
						Next Index_Boucle

					' Si il a mis du genre [20 a 5]
					Elseif NombreBoucle < 0 Then
						For Index_Boucle as integer = DeuxiemeNombre to PremierNombre
							' Creer en boucle le tableau mais avec le contenu souhaite !
							IF CPCDOS_INSTANCE.SYSTEME_INSTANCE.get_DBG_DEBUG() > 0 Then
								IF CPCDOS_INSTANCE.Utilisateur_Langage = 0 Then
									DEBUG("[CpcdosC+] Kernel > Suppression de la variable " & Nom_Variable_a_FIXER & CRLF & " - CleID:" & Auth_PID & " [&B" & Bin(Auth_PID, 28) & "] -> 0x" & hex(Auth_PID, 7) & CRLF & " - Buffer:" & LEN(Commande) & " octets" & CRLF & " - Niveau:" & NIVEAU_CCP & CRLF & " - idKernel:" & Auth_Kernel & CRLF & " - idOS:" & Auth_OS & CRLF & " - idUtilisateur:" & Auth_Utilisateur & CRLF & " - PID:" & Auth_PID & CRLF & " - TID:" & Auth_TID, Affichage, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_Normal, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.AvecDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_CPCDOS, RetourVAR)
								Else
									DEBUG("[CpcdosC+] Kernel > Deleting variable " & Nom_Variable_a_FIXER & CRLF & " - CleID:" & Auth_PID & " [&B" & Bin(Auth_PID, 28) & "] -> 0x" & hex(Auth_PID, 7) & CRLF & " - Buffer:" & LEN(Commande) & " octets" & CRLF & " - Niveau:" & NIVEAU_CCP & CRLF & " - idKernel:" & Auth_Kernel & CRLF & " - idOS:" & Auth_OS & CRLF & " - idUtilisateur:" & Auth_Utilisateur & CRLF & " - PID:" & Auth_PID & CRLF & " - TID:" & Auth_TID, Affichage, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_Normal, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.AvecDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_CPCDOS, RetourVAR)
								End if
							End if
							IF Gest_variables_Suppr(Nom_Variable_a_FIXER & "[" & PremierNombre-(Index_Boucle-DeuxiemeNombre) & "]", NIVEAU_CCP, Auth_Kernel, Auth_OS, Auth_Utilisateur, Auth_PID, Auth_TID) = 0 Then
								Message_erreur = ERRAVT("AVT_008", 0)
								DEBUG("[CpcdosC+] " & Message_erreur & " " & CHR(34) & Nom_Variable_a_FIXER & CHR(34) & " dans " & CHR(34) & Commande & CHR(34), Affichage, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_AVERTISSEMENT, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.SansDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_AFF, RetourVAR)
								exit _scope_CMD, _scope
							End if
						Next Index_Boucle
					Else
						IF CPCDOS_INSTANCE.Utilisateur_Langage = 0 Then
							DEBUG("[CpcdosC+] L'index du tableau ne peut etre nul.", Affichage, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_AVERTISSEMENT, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.AvecDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_CPCDOS, RetourVAR)
						Else
							DEBUG("[CpcdosC+] Index array can't be null." , Affichage, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_AVERTISSEMENT, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.AvecDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_CPCDOS, RetourVAR)
						End if
						exit _scope_CMD, _scope
					End if
					exit _scope_CMD, _scope
				End if


				IF instr(Nom_Variable_a_FIXER, " ") > 0 Then ' Il y a des espaces!
					Message_erreur = ERRAVT("AVT_049", 0)
					DEBUG("[CpcdosC+] " & Message_erreur & " " & CHR(34) & Commande & CHR(34) & ".", Affichage, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_AVERTISSEMENT, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.SansDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_AFF, RetourVAR)
					exit _scope_CMD, _scope
				END If


				' On supprime tout le tableau ---> Il faut connaitre la taille :/ (son debut et sa fin))
				' IF INSTR(Nom_Variable_a_FIXER, "[]") > 0 Then

				' Nom de variable recupere, maintenant on la supprime!
				IF CPCDOS_INSTANCE.SYSTEME_INSTANCE.get_DBG_DEBUG() > 0 Then
					IF CPCDOS_INSTANCE.Utilisateur_Langage = 0 Then
						DEBUG("[CpcdosC+] Suppression de la variable " & Nom_Variable_a_FIXER & CRLF & " - CleID:" & Auth_PID & " [&B" & Bin(Auth_PID, 28) & "] -> 0x" & hex(Auth_PID, 7) & CRLF & " - Buffer:" & LEN(Commande) & " octets" & CRLF & " - Niveau:" & NIVEAU_CCP & CRLF & " - idKernel:" & Auth_Kernel & CRLF & " - idOS:" & Auth_OS & CRLF & " - idUtilisateur:" & Auth_Utilisateur & CRLF & " - PID:" & Auth_PID & CRLF & " - TID:" & Auth_TID, Affichage, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_Normal, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.AvecDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_CPCDOS, RetourVAR)
					Else
						DEBUG("[CpcdosC+] Deleting variable " & Nom_Variable_a_FIXER & CRLF & " - CleID:" & Auth_PID & " [&B" & Bin(Auth_PID, 28) & "] -> 0x" & hex(Auth_PID, 7) & CRLF & " - Buffer:" & LEN(Commande) & " octets" & CRLF & " - Niveau:" & NIVEAU_CCP & CRLF & " - idKernel:" & Auth_Kernel & CRLF & " - idOS:" & Auth_OS & CRLF & " - idUtilisateur:" & Auth_Utilisateur & CRLF & " - PID:" & Auth_PID & CRLF & " - TID:" & Auth_TID, Affichage, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_Normal, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.AvecDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_CPCDOS, RetourVAR)
					End if
				END IF
				IF Gest_variables_Suppr(Nom_Variable_a_FIXER, NIVEAU_CCP, Auth_Kernel, Auth_OS, Auth_Utilisateur, Auth_PID, Auth_TID) = 0 Then
					Message_erreur = ERRAVT("AVT_008", 0)
					DEBUG("[CpcdosC+] " & Message_erreur & " " & CHR(34) & Nom_Variable_a_FIXER & CHR(34) & " dans " & CHR(34) & Commande & CHR(34), Affichage, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_AVERTISSEMENT, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.SansDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_AFF, RetourVAR)
					exit _scope_CMD, _scope
				End if
			Else
				Nom_Variable_a_FIXER = RTRIM(LTRIM(LTRIM(MID(Param, 1)), CHR(09))) ' Supprimer ESPACES et tabulations

				IF INSTR(UCASE(Nom_Variable_a_FIXER), " A ") > 0 OR INSTR(UCASE(Nom_Variable_a_FIXER), " TO ") > 0 OR INSTR(UCASE(Nom_Variable_a_FIXER), "..") > 0 Then

					Dim PremierNombre as Integer
					Dim DeuxiemeNombre as Integer
					Dim NombreBoucle as integer

					Dim Crochet_1 as integer = INSTR(Nom_Variable_a_FIXER, "[")
					Dim Crochet_2 as integer = INSTRREV(Nom_Variable_a_FIXER, "]")

					Dim Jusqu_A as integer = INSTR(UCASE(Nom_Variable_a_FIXER), " A ")
					Dim Jusqu_TO as integer = INSTR(UCASE(Nom_Variable_a_FIXER), " TO ")
					Dim Jusqu_3PTS as integer = INSTR(UCASE(Nom_Variable_a_FIXER), "..")

					IF Jusqu_A > 0 Then
						' En enlevant les espaces et tab
						PremierNombre = VAL(LTRIM(LTRIM(RTRIM(RTRIM(Mid(Nom_Variable_a_FIXER, Crochet_1 + 1, Jusqu_A - (Crochet_1 + 1)), chr(09))), chr(09))))

						DeuxiemeNombre = VAL(LTRIM(LTRIM(RTRIM(RTRIM(Mid(Nom_Variable_a_FIXER, Jusqu_A+2 + 1, Crochet_2 - (Jusqu_A+2 + 1)), chr(09))), chr(09))))

					ElseIf Jusqu_TO > 0 Then

						PremierNombre = VAL(LTRIM(LTRIM(RTRIM(RTRIM(Mid(Nom_Variable_a_FIXER, Crochet_1 + 1, Jusqu_TO - (Crochet_1 + 1)), chr(09))), chr(09))))

						DeuxiemeNombre = VAL(LTRIM(LTRIM(RTRIM(RTRIM(Mid(Nom_Variable_a_FIXER, Jusqu_TO+3 + 1, Crochet_2 - (Jusqu_TO+3 + 1)), chr(09))), chr(09))))
					ElseIf Jusqu_3PTS > 0 Then

						PremierNombre = VAL(LTRIM(LTRIM(RTRIM(RTRIM(Mid(Nom_Variable_a_FIXER, Crochet_1 + 1, Jusqu_3PTS - (Crochet_1 + 1)), chr(09))), chr(09))))

						DeuxiemeNombre = VAL(LTRIM(LTRIM(RTRIM(RTRIM(Mid(Nom_Variable_a_FIXER, Jusqu_3PTS+1 + 1, Crochet_2 - (Jusqu_3PTS+1 + 1)), chr(09))), chr(09))))
					End if

					Nom_Variable_a_FIXER = LTRIM(LTRIM(RTRIM(RTRIM(MID(Nom_Variable_a_FIXER, 1, Crochet_1 - 1)), CHR(09))), CHR(09))
					NombreBoucle = DeuxiemeNombre - PremierNombre

					Donnees_Variables_de_FIX = "\#NULL"

					' Si il a mis du genre [5 a 20]
					if NombreBoucle > 0 Then
						For Index_Boucle as integer = PremierNombre to DeuxiemeNombre
							' Creer en boucle le tableau mais avec le contenu souhaite !
							IF CPCDOS_INSTANCE.SYSTEME_INSTANCE.get_DBG_DEBUG() > 0 Then
								IF CPCDOS_INSTANCE.Utilisateur_Langage = 0 Then
									DEBUG("[CpcdosC+] Creation de la variable " & Nom_Variable_a_FIXER & CRLF & " - CleID:" & Auth_PID & " [&B" & Bin(_CLE_, 36) & "] -> 0x" & hex(_CLE_, 10) & CRLF & " - Taille:" & LEN(Donnees_Variables_de_FIX) & " octets" & CRLF & " - Niveau:" & NIVEAU_CCP & CRLF & " - idKernel:" & Auth_Kernel & CRLF & " - idOS:" & Auth_OS & CRLF & " - idUtilisateur:" & Auth_Utilisateur & CRLF & " - PID:" & Auth_PID & CRLF & " - TID:" & Auth_TID, Affichage, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_ACTION, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.AvecDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_CPCDOS, RetourVAR)
								Else
									DEBUG("[CpcdosC+] Creating variable " & Nom_Variable_a_FIXER & CRLF & " - CleID:" & Auth_PID & " [&B" & Bin(_CLE_, 36) & "] -> 0x" & hex(Auth_PID, 10) & CRLF & " - Size:" & LEN(Donnees_Variables_de_FIX) & " bytes" & CRLF & " - Niveau:" & NIVEAU_CCP & CRLF & " - idKernel:" & Auth_Kernel & CRLF & " - idOS:" & Auth_OS & CRLF & " - idUtilisateur:" & Auth_Utilisateur & CRLF & " - PID:" & Auth_PID & CRLF & " - TID:" & Auth_TID, Affichage, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_ACTION, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.AvecDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_CPCDOS, RetourVAR)
								End if
							END IF
							index = Gest_variables_ENREG (Nom_Variable_a_FIXER & "[" & Index_Boucle & "]", Donnees_Variables_de_FIX, NIVEAU_CCP, Auth_Kernel, Auth_OS, Auth_Utilisateur, Auth_PID, Auth_TID)
							IF CPCDOS_INSTANCE.SYSTEME_INSTANCE.get_DBG_DEBUG() > 0 Then
								IF CPCDOS_INSTANCE.Utilisateur_Langage = 0 Then
									DEBUG("[CpcdosC+] Creation de la variable [OK] -> [0x" & hex(index, 8) & "]", Affichage, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_VALIDATION, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.AvecDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_CPCDOS, RetourVAR)
								Else
									DEBUG("[CpcdosC+] Creating variable [OK] -> [0x" & hex(index, 8) & "]" , Affichage, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_VALIDATION, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.AvecDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_CPCDOS, RetourVAR)
								End if
							END IF
						Next Index_Boucle

					' Si il a mis du genre [20 a 5]
					Elseif NombreBoucle < 0 Then
						For Index_Boucle as integer = DeuxiemeNombre to PremierNombre
							' Creer en boucle le tableau mais avec le contenu souhaite !
							IF CPCDOS_INSTANCE.SYSTEME_INSTANCE.get_DBG_DEBUG() > 0 Then
								IF CPCDOS_INSTANCE.Utilisateur_Langage = 0 Then
									DEBUG("[CpcdosC+] Creation de la variable " & Nom_Variable_a_FIXER & CRLF & " - CleID:" & Auth_PID & " [&B" & Bin(_CLE_, 36) & "] -> 0x" & hex(_CLE_, 10) & CRLF & " - Taille:" & LEN(Donnees_Variables_de_FIX) & " octets" & CRLF & " - Niveau:" & NIVEAU_CCP & CRLF & " - idKernel:" & Auth_Kernel & CRLF & " - idOS:" & Auth_OS & CRLF & " - idUtilisateur:" & Auth_Utilisateur & CRLF & " - PID:" & Auth_PID & CRLF & " - TID:" & Auth_TID, Affichage, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_ACTION, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.AvecDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_CPCDOS, RetourVAR)
								Else
									DEBUG("[CpcdosC+] Creating variable " & Nom_Variable_a_FIXER & CRLF & " - CleID:" & Auth_PID & " [&B" & Bin(_CLE_, 36) & "] -> 0x" & hex(Auth_PID, 10) & CRLF & " - Size:" & LEN(Donnees_Variables_de_FIX) & " bytes" & CRLF & " - Niveau:" & NIVEAU_CCP & CRLF & " - idKernel:" & Auth_Kernel & CRLF & " - idOS:" & Auth_OS & CRLF & " - idUtilisateur:" & Auth_Utilisateur & CRLF & " - PID:" & Auth_PID & CRLF & " - TID:" & Auth_TID, Affichage, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_ACTION, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.AvecDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_CPCDOS, RetourVAR)
								End if
							END IF
							index = Gest_variables_ENREG (Nom_Variable_a_FIXER & "[" & PremierNombre-(Index_Boucle-DeuxiemeNombre) & "]", Donnees_Variables_de_FIX, NIVEAU_CCP, Auth_Kernel, Auth_OS, Auth_Utilisateur, Auth_PID, Auth_TID)
							IF CPCDOS_INSTANCE.SYSTEME_INSTANCE.get_DBG_DEBUG() > 0 Then
								IF CPCDOS_INSTANCE.Utilisateur_Langage = 0 Then
									DEBUG("[CpcdosC+] Creation de la variable [OK] -> [0x" & hex(index, 8) & "]", Affichage, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_VALIDATION, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.AvecDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_CPCDOS, RetourVAR)
								Else
									DEBUG("[CpcdosC+] Creating variable [OK] -> [0x" & hex(index, 8) & "]" , Affichage, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_VALIDATION, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.AvecDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_CPCDOS, RetourVAR)
								End if
							END IF
						Next Index_Boucle
					Else
						IF CPCDOS_INSTANCE.Utilisateur_Langage = 0 Then
							DEBUG("[CpcdosC+] L'index du tableau ne peut etre nul.", Affichage, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_AVERTISSEMENT, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.AvecDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_CPCDOS, RetourVAR)
						Else
							DEBUG("[CpcdosC+] Index array can't be null." , Affichage, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_AVERTISSEMENT, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.AvecDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_CPCDOS, RetourVAR)
						End if
						exit _scope_CMD, _scope
					End if
					exit _scope_CMD, _scope
				End if
			End if

			' ====================================================================
			END SCOPE
			exit _scope_CMD, _scope
		End if ' **** FIX/ ****

	_end_scope_CMD


	_scope_CMD

		' ===============================================================
		'  Commande pour demarrer un OS
		' ===============================================================
		CommLANG(1) = "demarrer/"
		CommLANG(2) = "start/"
		CommLANG(3) = "\\#//"
		CommTrouve = 0 : NoCMD = 0
		for boucle as integer = 1 to 2
			IF OnCherche = CommLANG(boucle) Then
				NoCMD = 0
				exit for
			Else
				NoCMD = 1
			End if
		Next boucle
		IF NoCMD = 1 then CommLANG(1) = "[F.#).|" : CommLANG(2) = "[F.#).|" : CommLANG(3) = "\\#//"
		rem Afficher la liste des commandes avec anglais / francais
		IF AfficherAide = 1 then
			IF CPCDOS_INSTANCE.Utilisateur_Langage = 0 then
				CommandesAide = CommandesAide & CRLF & " demarrer/                  Demarrer le ou les systeme(s) d'exploitation installe(s)"
			Else
				CommandesAide = CommandesAide & CRLF & " start/                     Starting installed operating system(s)"
			END IF
		END IF
		IF CommLANG(1) = OnCherche Then CommTrouve = 1
		IF CommLANG(2) = OnCherche Then CommTrouve = 2
		IF CommTrouve > 0 Then ' Afficher l'aide de la commande
			IF AfficherAide = 2 then
				Mess_Aide = ""
				IF CPCDOS_INSTANCE.Utilisateur_Langage = 0 THEN
					Mess_Aide = Mess_Aide & CRLF & "  'DEMARRER'"
					Mess_Aide = Mess_Aide & CRLF
					Mess_Aide = Mess_Aide & CRLF & "  Fonctionnalit�e :"
					Mess_Aide = Mess_Aide & CRLF & "   Cette commande permet d'entamer la premiere etape de demarrage d'un OS."
					Mess_Aide = Mess_Aide & CRLF & "   Les procedures de demarrage se different entre les OS."
					Mess_Aide = Mess_Aide & CRLF & "   Le loader execute en premier est le fichier 'OS/OS.CPC'"
					Mess_Aide = Mess_Aide & CRLF
					Mess_Aide = Mess_Aide & CRLF & "   Il est possible de preciser le nom de l'OS si il y a plus d'un installe."
					Mess_Aide = Mess_Aide & CRLF & "   Si le nom est pas precise, Cpcdos demarrera le premier de la liste 'OS.LST'"
					Mess_Aide = Mess_Aide & CRLF
					Mess_Aide = Mess_Aide & CRLF & "  Exemple :"
					Mess_Aide = Mess_Aide & CRLF & "   Demarrer/"
					Mess_Aide = Mess_Aide & CRLF
					Mess_Aide = Mess_Aide & CRLF & "   Demarrer/ MonOS"
					Mess_Aide = Mess_Aide & CRLF
					Mess_Aide = Mess_Aide & CRLF & "  Voir aussi : "
					Mess_Aide = Mess_Aide & CRLF
				ELSEIF CPCDOS_INSTANCE.Utilisateur_Langage = 1 THEN
					Mess_Aide = Mess_Aide & CRLF & "  'START'"
					Mess_Aide = Mess_Aide & CRLF
					Mess_Aide = Mess_Aide & CRLF & "  Fonctionnality :"
					Mess_Aide = Mess_Aide & CRLF & "   This command allow to launch the fist step for starting OS."
					Mess_Aide = Mess_Aide & CRLF & "   Starting process are different beetween OS."
					Mess_Aide = Mess_Aide & CRLF & "   The loader launch in first the file 'OS/OS.CPC'"
					Mess_Aide = Mess_Aide & CRLF
					Mess_Aide = Mess_Aide & CRLF & "   It's possible to define OS name to start if there are more that 1 installed."
					Mess_Aide = Mess_Aide & CRLF & "   If the name is not defined, Cpcdos will start the first of the list 'OS.LST'"
					Mess_Aide = Mess_Aide & CRLF
					Mess_Aide = Mess_Aide & CRLF & "  Exemple :"
					Mess_Aide = Mess_Aide & CRLF & "   Start/"
					Mess_Aide = Mess_Aide & CRLF
					Mess_Aide = Mess_Aide & CRLF & "   Start/ MyOS"
					Mess_Aide = Mess_Aide & CRLF
					Mess_Aide = Mess_Aide & CRLF & "  See also : "
					Mess_Aide = Mess_Aide & CRLF
				END IF

				DEBUG(Mess_Aide, Affichage, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_SURBRILLE, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.SansDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_AFF, RetourVAR)
				testCMD = 0
				AfficherAide = 0
				exit _scope_CMD, _scope
			END IF
			' Tester la syntaxe
			testCMD	= CCP_Verifier_Syntaxe(Commande, CommPosition)
			IF testCMD > 10 Then exit _scope_CMD, _scope
			IF testCMD > 0 then  ' Entre 1-5 = Pas d'affichage via le @, @$ ou @#
				IF testCMD < 6 then
					Affichage = 0
					IF testCMD = 3 Then CpcdosCP_SHELL("FIX/ " & CPCDOS_INSTANCE.DEBUG_INSTANCE.LeRetour & " = \#NULL", _CLE_, NIVEAU_CCP, Param_1, Param_2) : RetourVAR = _CLE_ & "N" & NIVEAU_CCP & "->" & CPCDOS_INSTANCE.DEBUG_INSTANCE.LeRetour
					if testCMD = 2 Then RetourVAR = "$>" & CPCDOS_INSTANCE.DEBUG_INSTANCE.LeRetour ' ajouter une securite ?
				Else
					Affichage = 1
				END IF
			Else
				Affichage = 1
			END IF
			' Recuperer les Parametres
			Param = MID(Commande, CommPosition + TailleComm + 2)
			SCOPE
			' ====================================================================

			' Tester la presence d'au moins 1 OS !
			if CPCDOS_INSTANCE.get_NombreOSPresent <= 0 Then
				IF CPCDOS_INSTANCE.Utilisateur_Langage = 0 Then
					DEBUG("[CpcdosC+] Aucun systeme d'exploitation present.", Affichage, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_ERREUR, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.SansDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_AFF, RetourVAR)
				Else
					DEBUG("[CpcdosC+] Operating system not found.", Affichage, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_ERREUR, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.SansDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_AFF, RetourVAR)
				End if

			else
				' Il y a au moins 1 OS present, on demarre le premier

				Dim NumeroOS 	as integer = 0
				Dim Retour 		as String
				Dim NomOS 		as String
				Dim PathOS 		as String


				Param = Ltrim(Rtrim(Rtrim(Ltrim(Param)), chr(09)), chr(09))

				' Tester la presence de L'OS
				IF LEN(Param) > 0 Then
					' Il y a un nom d'OS precise
					NumeroOS = CPCDOS_INSTANCE.test_OSPresent(Param)

				Else
					' Si aucun nom precise, alors on recupere le PREMIER OS
					NumeroOS = 0
				End if

				' Si l'OS indique est non present
				if NumeroOS < 0 Then
					IF CPCDOS_INSTANCE.Utilisateur_Langage = 0 Then
						DEBUG("[CpcdosC+] Systeme d'exploitation '" & Param & "' non present.", Affichage, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_ERREUR, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.SansDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_AFF, RetourVAR)
					Else
						DEBUG("[CpcdosC+] Operating system '" & Param & "' not found.", Affichage, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_ERREUR, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.SansDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_AFF, RetourVAR)
					End if
					exit _scope_CMD, _scope
				End if

				' Recuperer les informations de l'OS
				Retour = CPCDOS_INSTANCE.get_OSPresent(NumeroOS)

				' Recuperer le nom de l'OS
				NomOS = MID(Retour, 1, instr(Retour, "PATH:") - 2)

				' Et son Path
				PathOS = MID(Retour, instr(Retour, "PATH:") + 5)


				Scope

					CPCDOS_INSTANCE.SCI_INSTANCE.set_NombreOSenCours(CPCDOS_INSTANCE.SCI_INSTANCE.get_NombreOSenCours() + 1)

					doevents(_PAUSE_CRT + 200) ' Pause CRT CPinticore

					' On genere une nouvelle cle mais avec NumeroOS ce  va permettre par la
					'  suite de separer les espaces memoires par OS
					_CLE_ = CPCDOS_INSTANCE.Generer_cle(Auth_Kernel, NumeroOS, Auth_Utilisateur, Auth_PID, Auth_TID)

					CPCDOS_INSTANCE.SCI_INSTANCE.set_OSid(NumeroOS)

					IF CPCDOS_INSTANCE.Utilisateur_Langage = 0 Then
						DEBUG("[CpcdosC+] Demarrage du systeme d'exploitation '" & NomOS & "' [OS:" & NumeroOS & " ID parent 0x" & HEX(_CLE_, 8) & "]", Affichage, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_OK, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.AvecDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_AFF, RetourVAR)
					Else
						DEBUG("[CpcdosC+] Starting operating system '" & NomOS & "' [OS:" & NumeroOS & " Parent ID 0x" & HEX(_CLE_, 8) & "]", Affichage, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_OK, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.AvecDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_AFF, RetourVAR)
					End if


					CPCDOS_INSTANCE.SHELLCCP_INSTANCE.CpcdosCP_SHELL("exe/ " & PathOS & "\OS.CPC", _CLE_, 5, 330, RetourVAR)

					IF CPCDOS_INSTANCE.Utilisateur_Langage = 0 Then
						DEBUG("[CpcdosC+] Le systeme d'exploitation '" & NomOS & "' finit de demarrer ! [ID parent 0x" & HEX(_CLE_, 8) & "]", Affichage, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_SURBRILLE, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.AvecDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_AFF, RetourVAR)
					Else
						DEBUG("[CpcdosC+] Operating system '" & NomOS & "' finished loading ! [Parent ID 0x" & HEX(_CLE_, 8) & "]", Affichage, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_SURBRILLE, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.AvecDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_AFF, RetourVAR)
					End if
				End scope

			End if

			' ====================================================================
			END SCOPE

			exit _scope_CMD, _scope
		End if ' **** DEMARRER/ ****

	_end_scope_CMD



	_scope_CMD
		' ===============================================================
		'  Commande pour executer l'IUG
		' ===============================================================
		CommLANG(1) = "iug/"
		CommLANG(2) = "gui/"
		CommLANG(3) = "\\#//"
		CommTrouve = 0 : NoCMD = 0

		for boucle as integer = 1 to 2
			IF OnCherche = CommLANG(boucle) Then
				NoCMD = 0
				exit for
			Else
				NoCMD = 1
			End if
		Next boucle
		IF NoCMD = 1 then CommLANG(1) = "[F.#).|" : CommLANG(2) = "[F.#).|" : CommLANG(3) = "\\#//"
		rem Afficher la liste des commandes avec anglais / francais
		IF AfficherAide = 1 then
			IF CPCDOS_INSTANCE.Utilisateur_Langage = 0 then
				CommandesAide = CommandesAide & CRLF & " iug/                       Executer l'interface graphique de Cpcdos"
			Else
				CommandesAide = CommandesAide & CRLF & " gui/                       Launch cpcdos graphic user interface"
			END IF
		END IF

		IF CommLANG(1) = OnCherche Then CommTrouve = 1
		IF CommLANG(2) = OnCherche Then CommTrouve = 2
		IF CommTrouve > 0 Then ' Afficher l'aide de la commande

			IF AfficherAide = 2 then
				Mess_Aide = ""
				IF CPCDOS_INSTANCE.Utilisateur_Langage = 0 THEN
					Mess_Aide = Mess_Aide & CRLF & "  'Interface Utilisateur Graphique'"
					Mess_Aide = Mess_Aide & CRLF
					Mess_Aide = Mess_Aide & CRLF & "  Fonctionnalit�e :"
					Mess_Aide = Mess_Aide & CRLF & "   Cette commande permet d'executer l'interface graphique de Cpcdos"
					Mess_Aide = Mess_Aide & CRLF & "    et d'arreter l'animation du boot screen"
					Mess_Aide = Mess_Aide & CRLF
					Mess_Aide = Mess_Aide & CRLF & "  Exemple :"
					Mess_Aide = Mess_Aide & CRLF & "   iug/"
					Mess_Aide = Mess_Aide & CRLF
					Mess_Aide = Mess_Aide & CRLF & "  Afficher l'IUG d'un autre OS en execution. Exemple 'Toto'"
					Mess_Aide = Mess_Aide & CRLF & "   iug/ /OS:Toto"
					Mess_Aide = Mess_Aide & CRLF
					Mess_Aide = Mess_Aide & CRLF & "  Afficher l'IUG sans OS (Sans OS, celle du noyau)"
					Mess_Aide = Mess_Aide & CRLF & "   iug/ /SANSOS"
					Mess_Aide = Mess_Aide & CRLF
					Mess_Aide = Mess_Aide & CRLF & "  Reduire la GUI (Ouvrir la console)"
					Mess_Aide = Mess_Aide & CRLF & "   iug/ /LC      ou      /CONSOLE"
					Mess_Aide = Mess_Aide & CRLF
					Mess_Aide = Mess_Aide & CRLF & "  Ouvrir la console graphique"
					Mess_Aide = Mess_Aide & CRLF & "   iug/ /LC+     or      /CONSOLE+"
					Mess_Aide = Mess_Aide & CRLF
					Mess_Aide = Mess_Aide & CRLF & "  Afficher la black liste des fonction d'evenements introuvables"
					Mess_Aide = Mess_Aide & CRLF & "   iug/ /display-blacklist-events"
					Mess_Aide = Mess_Aide & CRLF
					Mess_Aide = Mess_Aide & CRLF & "  Remettre a zero la black liste des fonction d'evenements introuvables"
					Mess_Aide = Mess_Aide & CRLF & "   iug/ /reset-blacklist-events"
					Mess_Aide = Mess_Aide & CRLF
					Mess_Aide = Mess_Aide & CRLF & "  Blitter le flux aussi pour les pictures box!"
					Mess_Aide = Mess_Aide & CRLF & "    iug/ /MULTI-PICTUREBOX"
					Mess_Aide = Mess_Aide & CRLF
					Mess_Aide = Mess_Aide & CRLF & "  Voir aussi : "
					Mess_Aide = Mess_Aide & CRLF
				ELSEIF CPCDOS_INSTANCE.Utilisateur_Langage = 1 THEN
					Mess_Aide = Mess_Aide & CRLF & "  'Graphic User Interface'"
					Mess_Aide = Mess_Aide & CRLF
					Mess_Aide = Mess_Aide & CRLF & "  Fonctionnality :"
					Mess_Aide = Mess_Aide & CRLF & "   This command allow to launch graphic interface"
					Mess_Aide = Mess_Aide & CRLF & "    And stop boot screen"
					Mess_Aide = Mess_Aide & CRLF
					Mess_Aide = Mess_Aide & CRLF & "  Exemple :"
					Mess_Aide = Mess_Aide & CRLF & "   gui/"
					Mess_Aide = Mess_Aide & CRLF
					Mess_Aide = Mess_Aide & CRLF & "  Display the GUI from another OS in execution. Example with 'Toto'"
					Mess_Aide = Mess_Aide & CRLF & "   gui/ /OS:Toto"
					Mess_Aide = Mess_Aide & CRLF
					Mess_Aide = Mess_Aide & CRLF & "  Reduce GUI (Open console)"
					Mess_Aide = Mess_Aide & CRLF & "   gui/ /LC     or    /CONSOLE"
					Mess_Aide = Mess_Aide & CRLF
					Mess_Aide = Mess_Aide & CRLF & "  Open GUI console"
					Mess_Aide = Mess_Aide & CRLF & "   gui/ /LC+    or    /CONSOLE+"
					Mess_Aide = Mess_Aide & CRLF
					Mess_Aide = Mess_Aide & CRLF & "  Display black list functions events not found"
					Mess_Aide = Mess_Aide & CRLF & "   gui/ /display-blacklist-events"
					Mess_Aide = Mess_Aide & CRLF
					Mess_Aide = Mess_Aide & CRLF & "  Back to zero, black list functions events not found"
					Mess_Aide = Mess_Aide & CRLF & "   gui/ /reset-blacklist-events"
					Mess_Aide = Mess_Aide & CRLF
					Mess_Aide = Mess_Aide & CRLF & "  Display the without OS GUI (the blank kernel gui)"
					Mess_Aide = Mess_Aide & CRLF & "   gui/ /WITHOUTOS"
					Mess_Aide = Mess_Aide & CRLF
					Mess_Aide = Mess_Aide & CRLF & "   Blitting flux for all picturebox"
					Mess_Aide = Mess_Aide & CRLF & "    gui/ /MULTI-PICTUREBOX"
					Mess_Aide = Mess_Aide & CRLF
					Mess_Aide = Mess_Aide & CRLF & "  See also : "
					Mess_Aide = Mess_Aide & CRLF
				END IF

				DEBUG(Mess_Aide, Affichage, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_SURBRILLE, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.SansDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_AFF, RetourVAR)
				testCMD = 0
				AfficherAide = 0
				exit _scope_CMD, _scope
			END IF
			' Tester la syntaxe
			testCMD	= CCP_Verifier_Syntaxe(Commande, CommPosition)

			IF testCMD > 10 Then exit _scope_CMD, _scope
			IF testCMD > 0 then  ' Entre 1-5 = Pas d'affichage via le @, @$ ou @#
				IF testCMD < 6 then
					Affichage = 0
					IF testCMD = 3 Then CpcdosCP_SHELL("FIX/ " & CPCDOS_INSTANCE.DEBUG_INSTANCE.LeRetour & " = \#NULL", _CLE_, NIVEAU_CCP, Param_1, Param_2) : RetourVAR = _CLE_ & "N" & NIVEAU_CCP & "->" & CPCDOS_INSTANCE.DEBUG_INSTANCE.LeRetour
					if testCMD = 2 Then RetourVAR = "$>" & CPCDOS_INSTANCE.DEBUG_INSTANCE.LeRetour ' ajouter une securite ?
				Else
					Affichage = 1
				END IF
			Else
				Affichage = 1
			END IF

			' Recuperer les Parametres
			Param = MID(Commande, CommPosition + TailleComm + 2)

			SCOPE
			' ====================================================================
			Dim NumeroOS as Integer = Auth_OS

			if CPCDOS_INSTANCE.Thread_BootScreen > 0 Then
				CPCDOS_INSTANCE.Fermer_Thread(CPCDOS_INSTANCE.SYSTEME_INSTANCE._MAIN_PROCESSUS, CPCDOS_INSTANCE.Thread_BootScreen, false)
				CPCDOS_INSTANCE.Thread_BootScreen = 0
				IF CPCDOS_INSTANCE.Utilisateur_Langage = 0 Then
					DEBUG("[CpcdosC+] Fermeture du thread 'Thread_bootscreen' ...", CPCDOS_INSTANCE.DEBUG_INSTANCE.Ecran, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_AVERTISSEMENT, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.SansDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_CPCDOS, "")
				Else
					DEBUG("[CpcdosC+] Closing thread 'Thread_bootscreen' ...", CPCDOS_INSTANCE.DEBUG_INSTANCE.Ecran, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_AVERTISSEMENT, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.SansDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_CPCDOS, "")
				End if

				' Attendre fermeture thread
				doevents(500000)
			End if

			IF CPCDOS_INSTANCE.SYSTEME_INSTANCE.get_DBG_DEBUG() > 0 Then
				IF CPCDOS_INSTANCE.Utilisateur_Langage = 0 Then
					DEBUG("[CpcdosC+] Execution de l'interface graphique (OSid:" & NumeroOS & ") ...", Affichage, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_Normal, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.AvecDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_CPCDOS, RetourVAR)
				Else
					DEBUG("[CpcdosC+] Launching graphic interface (OSid:" & NumeroOS & ") ...", Affichage, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_Normal, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.AvecDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_CPCDOS, RetourVAR)
				End if
			END IF

			IF instr(ucase(Param), "/MULTI-PICTUREBOX") > 0 Then
				CPCDOS_INSTANCE.SCI_INSTANCE.MULTI_PICTUREBOX = 1
			else
				CPCDOS_INSTANCE.SCI_INSTANCE.MULTI_PICTUREBOX = 0
			End if

			' Sans OS
			IF instr(ucase(Param), "/WITHOUTOS") > 0 OR instr(ucase(Param), "/SANSOS") > 0 Then

				DEBUG("Without OS !!!", Affichage, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_Normal, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.AvecDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_CPCDOS, RetourVAR)

				NumeroOS = CPCDOS_INSTANCE._MAX_NOMBRE_OS

				IF CPCDOS_INSTANCE.Utilisateur_Langage = 0 Then
					DEBUG("[CpcdosC+] Lancement de la GUI sans OS [OS:" & NumeroOS & " ID parent 0x" & HEX(_CLE_, 8) & "]", Affichage, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_OK, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.AvecDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_AFF, RetourVAR)
				Else
					DEBUG("[CpcdosC+] Starting without OS GUI [OS:" & NumeroOS & " Parent ID 0x" & HEX(_CLE_, 8) & "]", Affichage, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_OK, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.AvecDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_AFF, RetourVAR)
				End if


				_CLE_ = CPCDOS_INSTANCE.Generer_cle(Auth_Kernel, NumeroOS, Auth_Utilisateur, Auth_PID, Auth_TID)

			End if

			' Line Commande / Ligne de Commandes
			IF instr(ucase(Param), "/LC+") > 0 OR instr(ucase(Param), "/CONSOLE+") > 0 Then
				Param = ""
				IF CPCDOS_INSTANCE.Utilisateur_Langage = 0 Then
					DEBUG("[CpcdosC+] Ouverture d'une console GUI", Affichage, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_ACTION, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.AvecDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_AFF, RetourVAR)
				Else
					DEBUG("[CpcdosC+] Opening GUI console", Affichage, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_ACTION, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.AvecDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_AFF, RetourVAR)
				End if

				CPCDOS_INSTANCE.SHELLCCP_INSTANCE.CpcdosCP_SHELL("exe/ " & CPCDOS_INSTANCE.SHELLCCP_INSTANCE.CCP_Lire_Variable("CPC_GUI.CONSOLE", 4, _CLE_), _CLE_, NIVEAU_CCP, Param_1, Param_2)

				exit _scope_CMD, _scope
			End if

			IF instr(ucase(Param), "/LC") > 0 OR instr(ucase(Param), "/CONSOLE") > 0 Then
				Dim SCR_MODE as integer

				IF CPCDOS_INSTANCE.Utilisateur_Langage = 0 Then
					DEBUG("[CpcdosC+] Passage en mode Lignes de Commandes...", Affichage, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_ACTION, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.AvecDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_AFF, RetourVAR)
				Else
					DEBUG("[CpcdosC+] Going to Console mode...", Affichage, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_ACTION, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.AvecDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_AFF, RetourVAR)
				End if

				SCR_MODE = Val(CPCDOS_INSTANCE.SHELLCCP_INSTANCE.CCP_Lire_Variable("SCR_MODE", 4, _CLE_))

				' Resolution en mode console
				CPCDOS_INSTANCE.SYSTEME_INSTANCE.set_Resolution(SCR_MODE)
				exit _scope_CMD, _scope
			End if

			if instr(ucase(Param), "/DISPLAY-BLACKLIST-EVENTS") > 0 Then
				' Reset la black list des evenements not found

				IF CPCDOS_INSTANCE.Utilisateur_Langage = 0 Then
					DEBUG("[CpcdosC+] Liste des fonction evenements graphiques introuvables :", Affichage, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_Normal, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.SansDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_AFF, RetourVAR)
				Else
					DEBUG("[CpcdosC+] List of not found graphic event functions :", Affichage, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_Normal, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.SansDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_AFF, RetourVAR)
				End if

				dim List_noire as string = CPCDOS_INSTANCE.SCI_INSTANCE.Event_Liste_Noire
				dim fonction as string = ""
				For b as integer = 1 to 128
					fonction = Mid(List_noire, 1, instr(List_noire, ";") - 1)
					List_noire = Mid(List_noire, instr(List_noire, ";") + 1)
					DEBUG(" [" & b &"] " & fonction, Affichage, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_ERREUR, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.SansDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_AFF, RetourVAR)
					if len(List_noire) < 5 Then exit for
				next b

				IF CPCDOS_INSTANCE.Utilisateur_Langage = 0 Then
					DEBUG("[CpcdosC+] Fin de la liste", Affichage, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_Normal, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.SansDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_AFF, RetourVAR)
				Else
					DEBUG("[CpcdosC+] End of list", Affichage, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_Normal, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.SansDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_AFF, RetourVAR)
				End if

				exit _scope_CMD, _scope
			End if

			if instr(ucase(Param), "/RESET-BLACKLIST-EVENTS") > 0 Then
				' Reset la black list des evenements not found

				CPCDOS_INSTANCE.SCI_INSTANCE.Event_Liste_Noire = ""

				IF CPCDOS_INSTANCE.Utilisateur_Langage = 0 Then
					DEBUG("[CpcdosC+] Liste noire des evenements introuvables a ete videe", Affichage, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_OK, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.AvecDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_AFF, RetourVAR)
				Else
					DEBUG("[CpcdosC+] Events black list has been emptied.", Affichage, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_OK, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.AvecDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_AFF, RetourVAR)
				End if

				exit _scope_CMD, _scope
			End if


			IF instr(ucase(Param), "/OS") > 0 Then
				Dim NomOS as String = Mid(Ucase(Param), instr(ucase(Param), "/OS") + 4)

				IF NOT NomOS = "" Then
					NomOS = Ltrim(Rtrim(Rtrim(Ltrim(NomOS)), chr(09)), chr(09))
					NumeroOS = CPCDOS_INSTANCE.test_OSPresent(ucase(NomOS))


					IF NumeroOS <> -1 Then

						_CLE_ = CPCDOS_INSTANCE.Generer_cle(Auth_Kernel, NumeroOS, Auth_Utilisateur, Auth_PID, Auth_TID)


						IF CPCDOS_INSTANCE.Utilisateur_Langage = 0 Then
							DEBUG("[CpcdosC+] Demarrage de la GUI de '" & NomOS & "' [OS:" & NumeroOS & " ID parent 0x" & HEX(_CLE_, 8) & "]", Affichage, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_OK, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.AvecDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_AFF, RetourVAR)
						Else
							DEBUG("[CpcdosC+] Starting '" & NomOS & "' GUI [OS:" & NumeroOS & " Parent ID 0x" & HEX(_CLE_, 8) & "]", Affichage, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_OK, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.AvecDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_AFF, RetourVAR)
						End if

					End if
				Else
					Message_erreur = ERRAVT("ERR_049", 0)
					IF CPCDOS_INSTANCE.Utilisateur_Langage = 0 Then
						DEBUG("[CpcdosC+] ERR_049: " & Message_erreur & ". Nom d'OS non specifie depuis l'argument '/OS'", Affichage, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_ERREUR, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.AvecDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_AFF, RetourVAR)
					Else
						DEBUG("[CpcdosC+] ERR_049: " & Message_erreur & ". No OS name specified from '/OS' argument", Affichage, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_ERREUR, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.AvecDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_AFF, RetourVAR)
					End if
					exit _scope_CMD, _scope
				End if
			Else

				NumeroOS = Auth_OS

				IF CPCDOS_INSTANCE.SCI_INSTANCE.get_NombreOSenCours() > 1 Then
					' S'il y a plusieurs OS, et que le nom n'a pas ete specifie, alors on prend la cle courant

					IF CPCDOS_INSTANCE.Utilisateur_Langage = 0 Then
						DEBUG("[CpcdosC+] " & CPCDOS_INSTANCE.SCI_INSTANCE.get_NombreOSenCours() & " OS en cours, lancement de la GUI de l'OS courant [OS:" & NumeroOS & " ID parent 0x" & HEX(_CLE_, 8) & "]", Affichage, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_OK, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.AvecDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_AFF, RetourVAR)
					Else
						DEBUG("[CpcdosC+] " & CPCDOS_INSTANCE.SCI_INSTANCE.get_NombreOSenCours() & " OS in execution, starting current OS GUI [OS:" & NumeroOS & " ID parent 0x" & HEX(_CLE_, 8) & "]", Affichage, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_OK, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.AvecDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_AFF, RetourVAR)
					End if
				Else
					_CLE_ = CPCDOS_INSTANCE.Generer_cle(Auth_Kernel, NumeroOS, Auth_Utilisateur, Auth_PID, Auth_TID)

					IF CPCDOS_INSTANCE.Utilisateur_Langage = 0 Then
						DEBUG("[CpcdosC+] Aucun OS en cours, lancement de la GUI vide [OS:" & NumeroOS & " ID parent 0x" & HEX(_CLE_, 8) & "]", Affichage, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_OK, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.AvecDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_AFF, RetourVAR)
					Else
						DEBUG("[CpcdosC+] No OS in execution, starting empty OS GUI [OS:" & NumeroOS & " Parent ID 0x" & HEX(_CLE_, 8) & "]", Affichage, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_OK, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.AvecDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_AFF, RetourVAR)
					End if
				End if
			End if



			DEBUG("[CpcdosC+] [OS:" & NumeroOS & " ID parent 0x" & HEX(_CLE_, 8) & "]", Affichage, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_OK, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.AvecDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_AFF, RetourVAR)

			if NumeroOS < 0 Then
				Message_erreur = ERRAVT("ERR_049", 0)
				IF CPCDOS_INSTANCE.Utilisateur_Langage = 0 Then
					DEBUG("[CpcdosC+] ERR_049: " & Message_erreur & ". Nom d'OS non existant depuis l'argument '/OS'", Affichage, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_ERREUR, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.AvecDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_AFF, RetourVAR)
				Else
					DEBUG("[CpcdosC+] ERR_049: " & Message_erreur & ". No existing OS name specified from '/OS' argument", Affichage, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_ERREUR, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.AvecDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_AFF, RetourVAR)
				End if
			else

				if CPCDOS_INSTANCE.SCI_INSTANCE.Initialiser_GUI(0, RetourVAR, _CLE_) = 1 then
					IF CPCDOS_INSTANCE.Utilisateur_Langage = 0 Then
						DEBUG("[CpcdosC+] Interface graphique initialise!", Affichage, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_VALIDATION, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.AvecDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_CPCDOS, RetourVAR)
					Else
						DEBUG("[CpcdosC+] Graphic interface initialised!", Affichage, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_VALIDATION, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.AvecDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_CPCDOS, RetourVAR)
					End if


				else
					Message_erreur = ERRAVT("ERR_049", 0)
					IF CPCDOS_INSTANCE.Utilisateur_Langage = 0 Then
						DEBUG("[CpcdosC+] ERR_049: " & Message_erreur & ". Erreur d'initialisation de l'IUG", Affichage, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_ERREUR, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.AvecDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_AFF, RetourVAR)
					Else
						DEBUG("[CpcdosC+] ERR_049: " & Message_erreur & ". Unable to initialise the GUI", Affichage, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_ERREUR, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.AvecDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_AFF, RetourVAR)
					End if
				end if
			End if ' Si numero OS < 0

			' ====================================================================
			END SCOPE

			exit _scope_CMD, _scope
		End if ' **** IUG/ ****

	_end_scope_CMD

	_scope_CMD

		' ===============================================================
		'  Commande pour creer une fenetre
		' ===============================================================
		CommLANG(1) = "fenetre/"
		CommLANG(2) = "window/"
		CommLANG(3) = "\\#//"
		CommTrouve = 0 : NoCMD = 0
		for boucle as integer = 1 to 2
			IF OnCherche = CommLANG(boucle) Then
				NoCMD = 0
				exit for
			Else
				NoCMD = 1
			End if
		Next boucle
		IF NoCMD = 1 then CommLANG(1) = "[F.#).|" : CommLANG(2) = "[F.#).|" : CommLANG(3) = "\\#//"
		rem Afficher la liste des commandes avec anglais / francais
		IF AfficherAide = 1 then
			IF CPCDOS_INSTANCE.Utilisateur_Langage = 0 then
				CommandesAide = CommandesAide & CRLF & " fenetre/                   Cree une nouvelle instance d'une fenetre graphique"
			Else
				CommandesAide = CommandesAide & CRLF & " window/                    Create new graphic"
			END IF
		END IF
		IF CommLANG(1) = OnCherche Then CommTrouve = 1
		IF CommLANG(2) = OnCherche Then CommTrouve = 2
		IF CommTrouve > 0 Then ' Afficher l'aide de la commande
			IF AfficherAide = 2 then
				Mess_Aide = ""
				IF CPCDOS_INSTANCE.Utilisateur_Langage = 0 THEN
					Mess_Aide = Mess_Aide & CRLF & "  'Fenetre'"
					Mess_Aide = Mess_Aide & CRLF
					Mess_Aide = Mess_Aide & CRLF & "  Fonctionnalit�e :"
					Mess_Aide = Mess_Aide & CRLF & "   Cette commande permet de creer une fenetre graphique sur l'IUG"
					Mess_Aide = Mess_Aide & CRLF
					Mess_Aide = Mess_Aide & CRLF & "  Exemple :"
					Mess_Aide = Mess_Aide & CRLF & "   Fenetre/ Ma_Fenetre"
					Mess_Aide = Mess_Aide & CRLF & "   		.handle				= " & CHR(34) & "" & CHR(34)
					Mess_Aide = Mess_Aide & CRLF & "   		.Titre			= " & CHR(34) & "Ma premiere fenetre" & CHR(34)
					Mess_Aide = Mess_Aide & CRLF & "   		.PX 				= " & CHR(34) & "100" & CHR(34)
					Mess_Aide = Mess_Aide & CRLF & "   		.PY 				= " & CHR(34) & "100" & CHR(34)
					Mess_Aide = Mess_Aide & CRLF & "   		.TX 				= " & CHR(34) & "200" & CHR(34)
					Mess_Aide = Mess_Aide & CRLF & "   		.TY 				= " & CHR(34) & "150" & CHR(34)
					Mess_Aide = Mess_Aide & CRLF & "   		.Parametres			= " & CHR(34) & "1" & CHR(34)
					Mess_Aide = Mess_Aide & CRLF & "   		.CouleurFenetre	= " & CHR(34) & "200,150,250" & CHR(34)
					Mess_Aide = Mess_Aide & CRLF & "   		.CouleurTitre 	= " & CHR(34) & "000,000,000" & CHR(34)
					Mess_Aide = Mess_Aide & CRLF & "   		.CouleurFond		= " & CHR(34) & "220,220,220" & CHR(34)
					Mess_Aide = Mess_Aide & CRLF & "   		.Icone			= " & CHR(34) & "C:\dossier\icone.png" & CHR(34)
					Mess_Aide = Mess_Aide & CRLF & "   		.ImgTitre		= " & CHR(34) & "C:\dossier\BarreDeTitre.png" & CHR(34)
					Mess_Aide = Mess_Aide & CRLF & "   		 Creer/"
					Mess_Aide = Mess_Aide & CRLF & "   Fin/ fenetre"
					Mess_Aide = Mess_Aide & CRLF
					Mess_Aide = Mess_Aide & CRLF & "  Voir aussi : Textebloc/ , Bouton/ , Imagebox/"
					Mess_Aide = Mess_Aide & CRLF
				ELSEIF CPCDOS_INSTANCE.Utilisateur_Langage = 1 THEN
					Mess_Aide = Mess_Aide & CRLF & "  'Window'"
					Mess_Aide = Mess_Aide & CRLF
					Mess_Aide = Mess_Aide & CRLF & "  Fonctionnality :"
					Mess_Aide = Mess_Aide & CRLF & "   This command allow to create new window instance"
					Mess_Aide = Mess_Aide & CRLF
					Mess_Aide = Mess_Aide & CRLF & "  Exemple :"
					Mess_Aide = Mess_Aide & CRLF & "   Window/ My_window"
					' Mess_Aide = Mess_Aide & CRLF & "   		PID				= " & CHR(34) & "" & CHR(34)
					Mess_Aide = Mess_Aide & CRLF & "   		.Title			= " & CHR(34) & "My first window!" & CHR(34)
					Mess_Aide = Mess_Aide & CRLF & "   		.PX 				= " & CHR(34) & "100" & CHR(34)
					Mess_Aide = Mess_Aide & CRLF & "   		.PY 				= " & CHR(34) & "100" & CHR(34)
					Mess_Aide = Mess_Aide & CRLF & "   		.SX 				= " & CHR(34) & "200" & CHR(34)
					Mess_Aide = Mess_Aide & CRLF & "   		.SY 				= " & CHR(34) & "150" & CHR(34)
					Mess_Aide = Mess_Aide & CRLF & "   		.Parameters			= " & CHR(34) & "1" & CHR(34)
					Mess_Aide = Mess_Aide & CRLF & "   		.WindowColor		= " & CHR(34) & "200,150,250" & CHR(34)
					Mess_Aide = Mess_Aide & CRLF & "   		.TitleColor 		= " & CHR(34) & "000,000,000" & CHR(34)
					Mess_Aide = Mess_Aide & CRLF & "   		.BackColor		= " & CHR(34) & "220,220,220" & CHR(34)
					Mess_Aide = Mess_Aide & CRLF & "   		.Icon			= " & CHR(34) & "C:\directory\icon.png" & CHR(34)
					Mess_Aide = Mess_Aide & CRLF & "   		.TitleImg		= " & CHR(34) & "C:\directory\TitleIMG.png" & CHR(34)
					Mess_Aide = Mess_Aide & CRLF & "   		Create/"
					Mess_Aide = Mess_Aide & CRLF & "   End/ Window"
					Mess_Aide = Mess_Aide & CRLF
					Mess_Aide = Mess_Aide & CRLF & "  See also : Button/ , Picturebox/ , Textblock/"
					Mess_Aide = Mess_Aide & CRLF
				END IF

				DEBUG(Mess_Aide, Affichage, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_SURBRILLE, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.SansDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_AFF, RetourVAR)
				testCMD = 0
				AfficherAide = 0
				exit _scope_CMD, _scope
			END IF
			' Tester la syntaxe
			testCMD	= CCP_Verifier_Syntaxe(Commande, CommPosition)
			IF testCMD > 10 Then exit _scope_CMD, _scope
			IF testCMD > 0 then  ' Entre 1-5 = Pas d'affichage via le @, @$ ou @#
				IF testCMD < 6 then
					Affichage = 0
					IF testCMD = 3 Then CpcdosCP_SHELL("FIX/ " & CPCDOS_INSTANCE.DEBUG_INSTANCE.LeRetour & " = \#NULL", _CLE_, NIVEAU_CCP, Param_1, Param_2) : RetourVAR = _CLE_ & "N" & NIVEAU_CCP & "->" & CPCDOS_INSTANCE.DEBUG_INSTANCE.LeRetour
					if testCMD = 2 Then RetourVAR = "$>" & CPCDOS_INSTANCE.DEBUG_INSTANCE.LeRetour ' ajouter une securite ?
				Else
					Affichage = 1
				END IF
			Else
				Affichage = 1
			END IF
			' Recuperer les Parametres
			Param = MID(Commande, CommPosition + TailleComm + 2)
			SCOPE
			' ====================================================================

			' Enlever les espaces et mettre tout en majuscules
			Dim NomFenetre as string = Ucase(LTrim(Ltrim(RTrim(Param), CHR(09))))

			IF INSTR(UCASE(NomFenetre), "/MODIF") > 0 Then
				NomFenetre = MID(NomFenetre, INSTR(UCASE(NomFenetre), "/MODIF") + 7) & "~MODIF#"

				IF CPCDOS_INSTANCE.Utilisateur_Langage = 0 Then
					DEBUG("[CpcdosC+] Mode edition d'une fenetre '" & NomFenetre & "' ...", Affichage, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_Normal, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.AvecDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_AFF, RetourVAR)
				Else
					DEBUG("[CpcdosC+] Window edition mode '" & NomFenetre & "' ...", Affichage, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_Normal, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.AvecDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_AFF, RetourVAR)
				End if
			Else
				IF CPCDOS_INSTANCE.Utilisateur_Langage = 0 Then
					DEBUG("[CpcdosC+] Creation d'une fenetre '" & NomFenetre & "' ...", Affichage, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_Normal, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.AvecDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_AFF, RetourVAR)
				Else
					DEBUG("[CpcdosC+] Creating window '" & NomFenetre & "' ...", Affichage, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_Normal, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.AvecDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_AFF, RetourVAR)
				End if
			End if

			CpcdosCP_SHELL = "IUG:FENETRE_NOM=" & NomFenetre

			' ====================================================================
			END SCOPE
			exit _scope_CMD, _scope
		End if ' **** FENETRE/ ****

	_end_scope_CMD

	_scope_CMD

		' ===============================================================
		'  Commande pour creer une picturebox
		' ===============================================================
		CommLANG(1) = "imagebox/"
		CommLANG(2) = "picturebox/"
		CommLANG(3) = "\\#//"
		CommTrouve = 0 : NoCMD = 0
		for boucle as integer = 1 to 2
			IF OnCherche = CommLANG(boucle) Then
				NoCMD = 0
				exit for
			Else
				NoCMD = 1
			End if
		Next boucle
		IF NoCMD = 1 then CommLANG(1) = "[F.#).|" : CommLANG(2) = "[F.#).|" : CommLANG(3) = "\\#//"
		rem Afficher la liste des commandes avec anglais / francais
		IF AfficherAide = 1 then
			IF CPCDOS_INSTANCE.Utilisateur_Langage = 0 then
				CommandesAide = CommandesAide & CRLF & " image/                     Cree une nouvelle instance d'une picturebox"
			Else
				CommandesAide = CommandesAide & CRLF & " picturebox/                Create new picturebox instance"
			END IF
		END IF
		IF CommLANG(1) = OnCherche Then CommTrouve = 1
		IF CommLANG(2) = OnCherche Then CommTrouve = 2
		IF CommTrouve > 0 Then ' Afficher l'aide de la commande
			IF AfficherAide = 2 then
				Mess_Aide = ""
				IF CPCDOS_INSTANCE.Utilisateur_Langage = 0 THEN
					Mess_Aide = Mess_Aide & CRLF & "  'ImageBox'"
					Mess_Aide = Mess_Aide & CRLF
					Mess_Aide = Mess_Aide & CRLF & "  Fonctionnalit�e :"
					Mess_Aide = Mess_Aide & CRLF & "   Cette commande permet de creer une imagebox dans un No de handle d'une fenetre existante"
					Mess_Aide = Mess_Aide & CRLF & "    exemple avec 12345"
					Mess_Aide = Mess_Aide & CRLF
					Mess_Aide = Mess_Aide & CRLF & "   A savoir qu'en general, le numero de handle (Numero d'objet) d'une fenetre est genere pendant"
					Mess_Aide = Mess_Aide & CRLF & "    l'execution de la commande 'creer/'. Si vous utilisez le numero d'un PID d'une fenetre, votre"
					Mess_Aide = Mess_Aide & CRLF & "    objet graphique sera heberge a l'interieur, et l'emplacement X et Y sera relatif au"
					Mess_Aide = Mess_Aide & CRLF & "     conteneur de la fenetre."
					Mess_Aide = Mess_Aide & CRLF & "   Si vous utilisez le PID d'un processus qui n'a pas de fenetre (Un processus non GUI) votre objet sera"
					Mess_Aide = Mess_Aide & CRLF & "    quand meme cree, et fonctionnel, mais graphiquement parlant, il ne sera pas visible."
					Mess_Aide = Mess_Aide & CRLF
					Mess_Aide = Mess_Aide & CRLF & "  Exemple :"
					Mess_Aide = Mess_Aide & CRLF & "   ImageBox/ Mon_Picture_box"
					Mess_Aide = Mess_Aide & CRLF & "   		.handle				= " & CHR(34) & "12345" & CHR(34)
					Mess_Aide = Mess_Aide & CRLF & "   		.PX 				= " & CHR(34) & "100" & CHR(34)
					Mess_Aide = Mess_Aide & CRLF & "   		.PY 				= " & CHR(34) & "100" & CHR(34)
					Mess_Aide = Mess_Aide & CRLF & "   		.TX 				= " & CHR(34) & "200" & CHR(34)
					Mess_Aide = Mess_Aide & CRLF & "   		.TY 				= " & CHR(34) & "150" & CHR(34)
					Mess_Aide = Mess_Aide & CRLF & "   		.Parametres 				= " & CHR(34) & "1" & CHR(34)
					Mess_Aide = Mess_Aide & CRLF & "   		.CouleurTexte	 	= " & CHR(34) & "000,000,000" & CHR(34)
					Mess_Aide = Mess_Aide & CRLF & "   		.CouleurFond		= " & CHR(34) & "220,220,220" & CHR(34)
					Mess_Aide = Mess_Aide & CRLF & "   		.Image				= " & CHR(34) & "C:\dossier\chien.png" & CHR(34)
					Mess_Aide = Mess_Aide & CRLF & "        Creer/"
					Mess_Aide = Mess_Aide & CRLF & "   Fin/ ImageBox"
					Mess_Aide = Mess_Aide & CRLF
					Mess_Aide = Mess_Aide & CRLF & " Parametre .Parametres :"
					Mess_Aide = Mess_Aide & CRLF & "  IMGAUTO:0  = (Defaut) affichage normale"
					Mess_Aide = Mess_Aide & CRLF & "  IMGAUTO:1  = Permet de definir la taille X, Y du picturebox selon la taille de l'image source"
					Mess_Aide = Mess_Aide & CRLF & "  IMGAUTO:2  = Permet de re-dimentionner la taille d'une image selon les dimentions X, Y du picturebox"
					Mess_Aide = Mess_Aide & CRLF

					Mess_Aide = Mess_Aide & CRLF & "  Voir aussi : Fenetre/ , Bouton/ , Textebloc/"
					Mess_Aide = Mess_Aide & CRLF
				ELSEIF CPCDOS_INSTANCE.Utilisateur_Langage = 1 THEN
					Mess_Aide = Mess_Aide & CRLF & "  'PictureBox'"
					Mess_Aide = Mess_Aide & CRLF
					Mess_Aide = Mess_Aide & CRLF & "  Fonctionnality :"
					Mess_Aide = Mess_Aide & CRLF & "   This command allow to create new picturebox instance in existing window handle (eg:123456789)"
					Mess_Aide = Mess_Aide & CRLF
					Mess_Aide = Mess_Aide & CRLF & "  Exemple :"
					Mess_Aide = Mess_Aide & CRLF & "   Picturebox/ My_picture_box"
					Mess_Aide = Mess_Aide & CRLF & "   		.handle				= " & CHR(34) & "12345" & CHR(34)
					Mess_Aide = Mess_Aide & CRLF & "   		.PX 				= " & CHR(34) & "10" & CHR(34)
					Mess_Aide = Mess_Aide & CRLF & "   		.PY 				= " & CHR(34) & "10" & CHR(34)
					Mess_Aide = Mess_Aide & CRLF & "   		.SX 				= " & CHR(34) & "100" & CHR(34)
					Mess_Aide = Mess_Aide & CRLF & "   		.SY 				= " & CHR(34) & "100" & CHR(34)
					Mess_Aide = Mess_Aide & CRLF & "   		.Parameters 		= " & CHR(34) & "1" & CHR(34)
					Mess_Aide = Mess_Aide & CRLF & "   		.TextColor 			= " & CHR(34) & "000,000,000" & CHR(34)
					Mess_Aide = Mess_Aide & CRLF & "   		.BackColor			= " & CHR(34) & "040,150,220" & CHR(34)
					Mess_Aide = Mess_Aide & CRLF & "   		.Image				= " & CHR(34) & "C:\directory\dog.png" & CHR(34)
					Mess_Aide = Mess_Aide & CRLF & "        Create/"
					Mess_Aide = Mess_Aide & CRLF & "   End/ Picturebox"
					Mess_Aide = Mess_Aide & CRLF
					Mess_Aide = Mess_Aide & CRLF & " .Parameters :"
					Mess_Aide = Mess_Aide & CRLF & "  IMGAUTO:0  = (Default) normal displaying"
					Mess_Aide = Mess_Aide & CRLF & "  IMGAUTO:1  = Allow to define X, Y size with source image"
					Mess_Aide = Mess_Aide & CRLF & "  IMGAUTO:2  = Allow to re-size image with X, Y picturebox size."
					Mess_Aide = Mess_Aide & CRLF
					Mess_Aide = Mess_Aide & CRLF & "  See also : Window/ , Button/ , Textblock/"
					Mess_Aide = Mess_Aide & CRLF
				END IF

				DEBUG(Mess_Aide, Affichage, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_SURBRILLE, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.SansDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_AFF, RetourVAR)
				testCMD = 0
				AfficherAide = 0
				exit _scope_CMD, _scope
			END IF
			' Tester la syntaxe
			testCMD	= CCP_Verifier_Syntaxe(Commande, CommPosition)
			IF testCMD > 10 Then exit _scope_CMD, _scope
			IF testCMD > 0 then  ' Entre 1-5 = Pas d'affichage via le @, @$ ou @#
				IF testCMD < 6 then
					Affichage = 0
					IF testCMD = 3 Then CpcdosCP_SHELL("FIX/ " & CPCDOS_INSTANCE.DEBUG_INSTANCE.LeRetour & " = \#NULL", _CLE_, NIVEAU_CCP, Param_1, Param_2) : RetourVAR = _CLE_ & "N" & NIVEAU_CCP & "->" & CPCDOS_INSTANCE.DEBUG_INSTANCE.LeRetour
					if testCMD = 2 Then RetourVAR = "$>" & CPCDOS_INSTANCE.DEBUG_INSTANCE.LeRetour ' ajouter une securite ?
				Else
					Affichage = 1
				END IF
			Else
				Affichage = 1
			END IF
			' Recuperer les Parametres
			Param = MID(Commande, CommPosition + TailleComm + 2)
			SCOPE
			' ====================================================================

			' Enlever les espaces et mettre tout en majuscules
			Dim NomImageBox as string = Ucase(LTrim(Ltrim(RTrim(Param), CHR(09))))

			IF INSTR(UCASE(NomImageBox), "/MODIF") > 0 Then
				NomImageBox = MID(NomImageBox, INSTR(UCASE(NomImageBox), "/MODIF") + 7) & "~MODIF#"

				IF CPCDOS_INSTANCE.Utilisateur_Langage = 0 Then
					DEBUG("[CpcdosC+] Mode edition d'une picturebox '" & NomImageBox & "' ...", Affichage, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_Normal, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.AvecDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_AFF, RetourVAR)
				Else
					DEBUG("[CpcdosC+] Picturebox edition mode '" & NomImageBox & "' ...", Affichage, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_Normal, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.AvecDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_AFF, RetourVAR)
				End if
			Else
				IF CPCDOS_INSTANCE.Utilisateur_Langage = 0 Then
					DEBUG("[CpcdosC+] Creation d'une picturebox '" & NomImageBox & "' ...", Affichage, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_Normal, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.AvecDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_AFF, RetourVAR)
				Else
					DEBUG("[CpcdosC+] Creating picturebox '" & NomImageBox & "' ...", Affichage, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_Normal, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.AvecDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_AFF, RetourVAR)
				End if
			End if



			CpcdosCP_SHELL = "IUG:PICTUREBOX_NOM=" & NomImageBox

			' ====================================================================
			END SCOPE

			exit _scope_CMD, _scope
		End if ' **** PICTUREBOX/ ****

	_end_scope_CMD

	_scope_CMD

		' ===============================================================
		'  Commande pour creer un bouton
		' ===============================================================
		CommLANG(1) = "bouton/"
		CommLANG(2) = "button/"
		CommLANG(3) = "\\#//"
		CommTrouve = 0 : NoCMD = 0
		for boucle as integer = 1 to 2
			IF OnCherche = CommLANG(boucle) Then
				NoCMD = 0
				exit for
			Else
				NoCMD = 1
			End if
		Next boucle
		IF NoCMD = 1 then CommLANG(1) = "[F.#).|" : CommLANG(2) = "[F.#).|" : CommLANG(3) = "\\#//"
		rem Afficher la liste des commandes avec anglais / francais
		IF AfficherAide = 1 then
			IF CPCDOS_INSTANCE.Utilisateur_Langage = 0 then
				CommandesAide = CommandesAide & CRLF & " bouton/                    Creer une nouvelle instance d'un bouton."
			Else
				CommandesAide = CommandesAide & CRLF & " button/                    Create new button instance."
			END IF
		END IF
		IF CommLANG(1) = OnCherche Then CommTrouve = 1
		IF CommLANG(2) = OnCherche Then CommTrouve = 2
		IF CommTrouve > 0 Then ' Afficher l'aide de la commande
			IF AfficherAide = 2 then
				Mess_Aide = ""
				IF CPCDOS_INSTANCE.Utilisateur_Langage = 0 THEN
					Mess_Aide = Mess_Aide & CRLF & "  'Bouton'"
					Mess_Aide = Mess_Aide & CRLF
					Mess_Aide = Mess_Aide & CRLF & "  Fonctionnalit�e :"
					Mess_Aide = Mess_Aide & CRLF & "   Cette commande permet de creer un bouton graphique dans un No de handle d'une fenetre existante"
					Mess_Aide = Mess_Aide & CRLF & "    exemple avec 12345"
					Mess_Aide = Mess_Aide & CRLF
					Mess_Aide = Mess_Aide & CRLF & "  Exemple :"
					Mess_Aide = Mess_Aide & CRLF & "   Bouton/ Mon_Bouton"
					Mess_Aide = Mess_Aide & CRLF & "   		.handle				= " & CHR(34) & "12345" & CHR(34)
					Mess_Aide = Mess_Aide & CRLF & "   		.Texte				= " & CHR(34) & "Clique moi" & CHR(34)
					Mess_Aide = Mess_Aide & CRLF & "   		.Parametres			= " & CHR(34) & "IMGAUTO:2" & CHR(34)
					Mess_Aide = Mess_Aide & CRLF & "   		.PX 				= " & CHR(34) & "30" & CHR(34)
					Mess_Aide = Mess_Aide & CRLF & "   		.PY 				= " & CHR(34) & "20" & CHR(34)
					Mess_Aide = Mess_Aide & CRLF & "   		.TX 				= " & CHR(34) & "60" & CHR(34)
					Mess_Aide = Mess_Aide & CRLF & "   		.TY 				= " & CHR(34) & "30" & CHR(34)
					Mess_Aide = Mess_Aide & CRLF & "   		.CouleurTexte	 	= " & CHR(34) & "000,000,000" & CHR(34)
					Mess_Aide = Mess_Aide & CRLF & "   		.CouleurFond		= " & CHR(34) & "220,220,220" & CHR(34)
					Mess_Aide = Mess_Aide & CRLF & "   		.Image				= " & CHR(34) & "C:\dossier\image_bouton.png" & CHR(34)
					Mess_Aide = Mess_Aide & CRLF & "        Creer/"
					Mess_Aide = Mess_Aide & CRLF & "   Fin/ Bouton"
					Mess_Aide = Mess_Aide & CRLF
					Mess_Aide = Mess_Aide & CRLF & " Parametre .Parametres :"
					Mess_Aide = Mess_Aide & CRLF & "  IMGAUTO:0  = (Defaut) affichage normale"
					Mess_Aide = Mess_Aide & CRLF & "  IMGAUTO:1  = Permet de definir la taille X, Y du bouton selon la taille de l'image source"
					Mess_Aide = Mess_Aide & CRLF & "  IMGAUTO:2  = Permet de re-dimentionner la taille d'une image selon les dimentions X, Y du bouton"
					Mess_Aide = Mess_Aide & CRLF
					' Mess_Aide = Mess_Aide & CRLF & "  "

					Mess_Aide = Mess_Aide & CRLF & "  Voir aussi : Imagebox/ , fenetre/"
					Mess_Aide = Mess_Aide & CRLF
				ELSEIF CPCDOS_INSTANCE.Utilisateur_Langage = 1 THEN
					Mess_Aide = Mess_Aide & CRLF & "  'Button'"
					Mess_Aide = Mess_Aide & CRLF
					Mess_Aide = Mess_Aide & CRLF & "  Fonctionnality :"
					Mess_Aide = Mess_Aide & CRLF & "   This command allow to create new button instance in existing window handle (eg:12345)"
					Mess_Aide = Mess_Aide & CRLF
					Mess_Aide = Mess_Aide & CRLF & "  Exemple :"
					Mess_Aide = Mess_Aide & CRLF & "   Button/ My_picture_box"
					Mess_Aide = Mess_Aide & CRLF & "   		.handle				= " & CHR(34) & "12345" & CHR(34)
					Mess_Aide = Mess_Aide & CRLF & "   		.text				= " & CHR(34) & "Click me!" & CHR(34)
					Mess_Aide = Mess_Aide & CRLF & "   		.PX 				= " & CHR(34) & "30" & CHR(34)
					Mess_Aide = Mess_Aide & CRLF & "   		.PY 				= " & CHR(34) & "20" & CHR(34)
					Mess_Aide = Mess_Aide & CRLF & "   		.SX 				= " & CHR(34) & "60" & CHR(34)
					Mess_Aide = Mess_Aide & CRLF & "   		.SY 				= " & CHR(34) & "30" & CHR(34)
					Mess_Aide = Mess_Aide & CRLF & "   		.Parameters 		= " & CHR(34) & "IMGAUTO:2" & CHR(34)
					Mess_Aide = Mess_Aide & CRLF & "   		.TextColor 			= " & CHR(34) & "000,000,000" & CHR(34)
					Mess_Aide = Mess_Aide & CRLF & "   		.BackColor			= " & CHR(34) & "220,220,220" & CHR(34)
					Mess_Aide = Mess_Aide & CRLF & "   		.Image				= " & CHR(34) & "C:\directory\button_image.png" & CHR(34)
					Mess_Aide = Mess_Aide & CRLF & "        Create/"
					Mess_Aide = Mess_Aide & CRLF & "   End/ Button"
					Mess_Aide = Mess_Aide & CRLF
					Mess_Aide = Mess_Aide & CRLF & " .Parameters :"
					Mess_Aide = Mess_Aide & CRLF & "  IMGAUTO:0  = (Default) normal displaying"
					Mess_Aide = Mess_Aide & CRLF & "  IMGAUTO:1  = Allow to define X, Y size with source image"
					Mess_Aide = Mess_Aide & CRLF & "  IMGAUTO:2  = Allow to re-size image with X, Y picturebox size."
					Mess_Aide = Mess_Aide & CRLF
					Mess_Aide = Mess_Aide & CRLF & "  See also : picturebox/ , window/ , textblock/"
					Mess_Aide = Mess_Aide & CRLF
				END IF

				DEBUG(Mess_Aide, Affichage, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_SURBRILLE, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.SansDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_AFF, RetourVAR)
				testCMD = 0
				AfficherAide = 0
				exit _scope_CMD, _scope
			END IF
			' Tester la syntaxe
			testCMD	= CCP_Verifier_Syntaxe(Commande, CommPosition)
			IF testCMD > 10 Then exit _scope_CMD, _scope
			IF testCMD > 0 then  ' Entre 1-5 = Pas d'affichage via le @, @$ ou @#
				IF testCMD < 6 then
					Affichage = 0
					IF testCMD = 3 Then CpcdosCP_SHELL("FIX/ " & CPCDOS_INSTANCE.DEBUG_INSTANCE.LeRetour & " = \#NULL", _CLE_, NIVEAU_CCP, Param_1, Param_2) : RetourVAR = _CLE_ & "N" & NIVEAU_CCP & "->" & CPCDOS_INSTANCE.DEBUG_INSTANCE.LeRetour
					if testCMD = 2 Then RetourVAR = "$>" & CPCDOS_INSTANCE.DEBUG_INSTANCE.LeRetour ' ajouter une securite ?
				Else
					Affichage = 1
				END IF
			Else
				Affichage = 1
			END IF
			' Recuperer les Parametres
			Param = MID(Commande, CommPosition + TailleComm + 2)
			SCOPE
			' ====================================================================

			' Enlever les espaces et mettre tout en majuscules
			Dim NomBouton as string = Ucase(LTrim(Ltrim(RTrim(Param), CHR(09))))

			IF INSTR(UCASE(NomBouton), "/MODIF") > 0 Then
				NomBouton = MID(NomBouton, INSTR(UCASE(NomBouton), "/MODIF") + 7) & "~MODIF#"

				IF CPCDOS_INSTANCE.Utilisateur_Langage = 0 Then
					DEBUG("[CpcdosC+] Mode edition d'un bouton '" & NomBouton & "' ...", Affichage, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_Normal, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.AvecDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_AFF, RetourVAR)
				Else
					DEBUG("[CpcdosC+] Button edition mode '" & NomBouton & "' ...", Affichage, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_Normal, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.AvecDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_AFF, RetourVAR)
				End if
			Else
				IF CPCDOS_INSTANCE.Utilisateur_Langage = 0 Then
					DEBUG("[CpcdosC+] Creation d'un bouton '" & NomBouton & "' ...", Affichage, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_Normal, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.AvecDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_AFF, RetourVAR)
				Else
					DEBUG("[CpcdosC+] Creating button '" & NomBouton & "' ...", Affichage, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_Normal, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.AvecDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_AFF, RetourVAR)
				End if
			End if


			CpcdosCP_SHELL = "IUG:BOUTON_NOM=" & NomBouton

			' ====================================================================
			END SCOPE

			exit _scope_CMD, _scope
		End if ' **** BOUTON/ ****

	_end_scope_CMD

	_scope_CMD

		' ===============================================================
		'  Commande pour creer un textebloc
		' ===============================================================
		CommLANG(1) = "textebloc/"
		CommLANG(2) = "textblock/"
		CommLANG(3) = "\\#//"
		CommTrouve = 0 : NoCMD = 0
		for boucle as integer = 1 to 2
			IF OnCherche = CommLANG(boucle) Then
				NoCMD = 0
				exit for
			Else
				NoCMD = 1
			End if
		Next boucle
		IF NoCMD = 1 then CommLANG(1) = "[F.#).|" : CommLANG(2) = "[F.#).|" : CommLANG(3) = "\\#//"
		rem Afficher la liste des commandes avec anglais / francais
		IF AfficherAide = 1 then
			IF CPCDOS_INSTANCE.Utilisateur_Langage = 0 then
				CommandesAide = CommandesAide & CRLF & " textebloc/                 Creer une nouvelle instance d'un bloc de texte."
			Else
				CommandesAide = CommandesAide & CRLF & " textblock/                 Create new textblock instance."
			END IF
		END IF
		IF CommLANG(1) = OnCherche Then CommTrouve = 1
		IF CommLANG(2) = OnCherche Then CommTrouve = 2


		IF CommTrouve > 0 Then ' Afficher l'aide de la commande
			IF AfficherAide = 2 then
				Mess_Aide = ""
				IF CPCDOS_INSTANCE.Utilisateur_Langage = 0 THEN
					Mess_Aide = Mess_Aide & CRLF & "  'TexteBloc'"
					Mess_Aide = Mess_Aide & CRLF
					Mess_Aide = Mess_Aide & CRLF & "  Fonctionnalit�e :"
					Mess_Aide = Mess_Aide & CRLF & "   Cette commande permet de creer graphiquement un bloc de texte pour les applications"
					Mess_Aide = Mess_Aide & CRLF & "    exemple avec un pid de 12345"
					Mess_Aide = Mess_Aide & CRLF
					Mess_Aide = Mess_Aide & CRLF & "  Exemple :"
					Mess_Aide = Mess_Aide & CRLF & "   TexteBloc/ Mon_Texte"
					Mess_Aide = Mess_Aide & CRLF & "   		.handle				= " & CHR(34) & "12345" & CHR(34)
					Mess_Aide = Mess_Aide & CRLF & "   		.Texte				= " & CHR(34) & "Bonjour, voici mon texte%CPC.CRLF%Et hop un retour a la ligne!" & CHR(34)
					Mess_Aide = Mess_Aide & CRLF & "   		.Parametres			= " & CHR(34) & "IMGAUTO:1" & CHR(34)
					Mess_Aide = Mess_Aide & CRLF & "   		.PX 				= " & CHR(34) & "10" & CHR(34)
					Mess_Aide = Mess_Aide & CRLF & "   		.PY 				= " & CHR(34) & "10" & CHR(34)
					Mess_Aide = Mess_Aide & CRLF & "   		.TX 				= " & CHR(34) & "0" & CHR(34) & "  --> Taille X geree par IMGAUTO:1"
					Mess_Aide = Mess_Aide & CRLF & "   		.TY 				= " & CHR(34) & "0" & CHR(34) & "  --> Taille Y geree par IMGAUTO:1"
					Mess_Aide = Mess_Aide & CRLF & "   		.CouleurTexte	 	= " & CHR(34) & "000,000,000" & CHR(34)
					Mess_Aide = Mess_Aide & CRLF & "   		.CouleurFond		= " & CHR(34) & "220,220,220" & CHR(34)
					Mess_Aide = Mess_Aide & CRLF & "        Creer/"
					Mess_Aide = Mess_Aide & CRLF & "   Fin/ TexteBloc"
					Mess_Aide = Mess_Aide & CRLF
					Mess_Aide = Mess_Aide & CRLF & " Parametre .Parametres :"
					Mess_Aide = Mess_Aide & CRLF & "  IMGAUTO:0  = (Defaut) affichage normale, et coupe le texte si plus grand que TX et TY"
					Mess_Aide = Mess_Aide & CRLF & "  IMGAUTO:1  = Permet de definir la taille X, Y du Textebloc selon la taille de l'image source"
					Mess_Aide = Mess_Aide & CRLF & "  IMGAUTO:2  = Permet de re-dimentionner 'non-vectoriellement' la taille du texte selon les dimentions X, Y du textebloc"
					Mess_Aide = Mess_Aide & CRLF & "  BORD:0	 = (Par defaut) affiche pas de bordure autour"
					Mess_Aide = Mess_Aide & CRLF & "  BORD:1	 = Affiche une bordure noire"
					Mess_Aide = Mess_Aide & CRLF & "  BORD:2	 = Affiche le textebloc avec un effet 3D"
					Mess_Aide = Mess_Aide & CRLF

					Mess_Aide = Mess_Aide & CRLF & "  Voir aussi : picturebox/ , bouton/ , fenetre/"
					Mess_Aide = Mess_Aide & CRLF
				ELSEIF CPCDOS_INSTANCE.Utilisateur_Langage = 1 THEN
					Mess_Aide = Mess_Aide & CRLF & "  'Textblock'"
					Mess_Aide = Mess_Aide & CRLF
					Mess_Aide = Mess_Aide & CRLF & "  Fonctionnality :"
					Mess_Aide = Mess_Aide & CRLF & "   This command allow to create new textblock instance in existing window handle (eg:12345)"
					Mess_Aide = Mess_Aide & CRLF
					Mess_Aide = Mess_Aide & CRLF & "  Exemple :"
					Mess_Aide = Mess_Aide & CRLF & "   Textblock/ My_Text"
					Mess_Aide = Mess_Aide & CRLF & "   		.handle				= " & CHR(34) & "12345" & CHR(34)
					Mess_Aide = Mess_Aide & CRLF & "   		.Texte				= " & CHR(34) & "Bonjour, voici mon texte%CPC.CRLF%Et hop un retour a la ligne!" & CHR(34)
					Mess_Aide = Mess_Aide & CRLF & "   		.PX 				= " & CHR(34) & "30" & CHR(34)
					Mess_Aide = Mess_Aide & CRLF & "   		.PY 				= " & CHR(34) & "20" & CHR(34)
					Mess_Aide = Mess_Aide & CRLF & "   		.SX 				= " & CHR(34) & "0" & CHR(34)
					Mess_Aide = Mess_Aide & CRLF & "   		.SY 				= " & CHR(34) & "0" & CHR(34)
					Mess_Aide = Mess_Aide & CRLF & "   		.Parameters 		= " & CHR(34) & "IMGAUTO:1" & CHR(34)
					Mess_Aide = Mess_Aide & CRLF & "   		.TextColor 			= " & CHR(34) & "000,000,000" & CHR(34)
					Mess_Aide = Mess_Aide & CRLF & "   		.BackColor			= " & CHR(34) & "220,220,220" & CHR(34)
					Mess_Aide = Mess_Aide & CRLF & "        Create/"
					Mess_Aide = Mess_Aide & CRLF & "   End/ Textblock"
					Mess_Aide = Mess_Aide & CRLF
					Mess_Aide = Mess_Aide & CRLF & " .Parameters :"
					Mess_Aide = Mess_Aide & CRLF & "  IMGAUTO:0  = (Default) normal displaying"
					Mess_Aide = Mess_Aide & CRLF & "  IMGAUTO:1  = Allow to define X, Y size with source image"
					Mess_Aide = Mess_Aide & CRLF & "  IMGAUTO:2  = Allow to re-size image with X, Y picturebox size."
					Mess_Aide = Mess_Aide & CRLF & "  BORD:0	 = (Default) no border"
					Mess_Aide = Mess_Aide & CRLF & "  BORD:1	 = Display black border"
					Mess_Aide = Mess_Aide & CRLF & "  BORD:2	 = Display textblock with 3D effect"
					Mess_Aide = Mess_Aide & CRLF
					Mess_Aide = Mess_Aide & CRLF & "  See also : picturebox/ , bouton/ , window/"
					Mess_Aide = Mess_Aide & CRLF
				END IF

				DEBUG(Mess_Aide, Affichage, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_SURBRILLE, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.SansDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_AFF, RetourVAR)
				testCMD = 0
				AfficherAide = 0
				exit _scope_CMD, _scope
			END IF
			' Tester la syntaxe
			testCMD	= CCP_Verifier_Syntaxe(Commande, CommPosition)
			IF testCMD > 10 Then exit _scope_CMD, _scope
			IF testCMD > 0 then  ' Entre 1-5 = Pas d'affichage via le @, @$ ou @#
				IF testCMD < 6 then
					Affichage = 0
					IF testCMD = 3 Then CpcdosCP_SHELL("FIX/ " & CPCDOS_INSTANCE.DEBUG_INSTANCE.LeRetour & " = \#NULL", _CLE_, NIVEAU_CCP, Param_1, Param_2) : RetourVAR = _CLE_ & "N" & NIVEAU_CCP & "->" & CPCDOS_INSTANCE.DEBUG_INSTANCE.LeRetour
					if testCMD = 2 Then RetourVAR = "$>" & CPCDOS_INSTANCE.DEBUG_INSTANCE.LeRetour ' ajouter une securite ?
				Else
					Affichage = 1
				END IF
			Else
				Affichage = 1
			END IF
			' Recuperer les Parametres
			Param = MID(Commande, CommPosition + TailleComm + 2)
			SCOPE
			' ====================================================================

			' Enlever les espaces et mettre tout en majuscules
			Dim NomTextebloc as string = Ucase(LTrim(Ltrim(RTrim(Param), CHR(09))))

			IF INSTR(UCASE(NomTextebloc), "/MODIF") > 0 Then
				NomTextebloc = MID(NomTextebloc, INSTR(UCASE(NomTextebloc), "/MODIF") + 7) & "~MODIF#"

				IF CPCDOS_INSTANCE.Utilisateur_Langage = 0 Then
					DEBUG("[CpcdosC+] Mode edition d'un TexteBloc '" & NomTextebloc & "' ...", Affichage, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_Normal, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.AvecDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_AFF, RetourVAR)
				Else
					DEBUG("[CpcdosC+] TextBlock edition mode '" & NomTextebloc & "' ...", Affichage, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_Normal, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.AvecDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_AFF, RetourVAR)
				End if
			Else
				IF CPCDOS_INSTANCE.Utilisateur_Langage = 0 Then
					DEBUG("[CpcdosC+] Creation d'un TexteBloc '" & NomTextebloc & "' ...", Affichage, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_Normal, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.AvecDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_AFF, RetourVAR)
				Else
					DEBUG("[CpcdosC+] Creating TextBlock '" & NomTextebloc & "' ...", Affichage, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_Normal, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.AvecDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_AFF, RetourVAR)
				End if
			End if

			CpcdosCP_SHELL = "IUG:TEXTEBLOC_NOM=" & NomTextebloc

			' ====================================================================
			END SCOPE

			exit _scope_CMD, _scope
		End if ' **** TexteBloc/ ****


	_end_scope_CMD

	_scope_CMD

		' ===============================================================
		'  Commande pour creer un textebox
		' ===============================================================
		CommLANG(1) = "textebox/"
		CommLANG(2) = "textbox/"
		CommLANG(3) = "\\#//"
		CommTrouve = 0 : NoCMD = 0
		for boucle as integer = 1 to 2
			IF OnCherche = CommLANG(boucle) Then
				NoCMD = 0
				exit for
			Else
				NoCMD = 1
			End if
		Next boucle
		IF NoCMD = 1 then CommLANG(1) = "[F.#).|" : CommLANG(2) = "[F.#).|" : CommLANG(3) = "\\#//"
		rem Afficher la liste des commandes avec anglais / francais
		IF AfficherAide = 1 then
			IF CPCDOS_INSTANCE.Utilisateur_Langage = 0 then
				CommandesAide = CommandesAide & CRLF & " textebox/                  Creer une nouvelle instance d'un bloc de texte editable."
			Else
				CommandesAide = CommandesAide & CRLF & " textbox/                   Create new editable text box instance."
			END IF
		END IF
		IF CommLANG(1) = OnCherche Then CommTrouve = 1
		IF CommLANG(2) = OnCherche Then CommTrouve = 2


		IF CommTrouve > 0 Then ' Afficher l'aide de la commande
			IF AfficherAide = 2 then
				Mess_Aide = ""
				IF CPCDOS_INSTANCE.Utilisateur_Langage = 0 THEN
					Mess_Aide = Mess_Aide & CRLF & "  'TexteBloc'"
					Mess_Aide = Mess_Aide & CRLF
					Mess_Aide = Mess_Aide & CRLF & "  Fonctionnalit�e :"
					Mess_Aide = Mess_Aide & CRLF & "   Cette commande permet de creer graphiquement un bloc de texte pour les applications"
					Mess_Aide = Mess_Aide & CRLF & "    exemple avec un handle de 12345"
					Mess_Aide = Mess_Aide & CRLF
					Mess_Aide = Mess_Aide & CRLF & "  Exemple :"
					Mess_Aide = Mess_Aide & CRLF & "   TexteBox/ Mon_TexteBox"
					Mess_Aide = Mess_Aide & CRLF & "   		.handle				= " & CHR(34) & "12345" & CHR(34)
					Mess_Aide = Mess_Aide & CRLF & "   		.Texte				= " & CHR(34) & "Je suis une zone de texte editable" & CHR(34)
					Mess_Aide = Mess_Aide & CRLF & "   		.PX 				= " & CHR(34) & "10" & CHR(34)
					Mess_Aide = Mess_Aide & CRLF & "   		.PY 				= " & CHR(34) & "10" & CHR(34)
					Mess_Aide = Mess_Aide & CRLF & "   		.TX 				= " & CHR(34) & "0" & CHR(34) & "  --> Taille X geree par IMGAUTO:1"
					Mess_Aide = Mess_Aide & CRLF & "   		.TY 				= " & CHR(34) & "0" & CHR(34) & "  --> Taille Y geree par IMGAUTO:1"
					Mess_Aide = Mess_Aide & CRLF & "   		.CouleurTexte	 	= " & CHR(34) & "000,000,000" & CHR(34)
					Mess_Aide = Mess_Aide & CRLF & "   		.CouleurFond		= " & CHR(34) & "220,220,220" & CHR(34)
					Mess_Aide = Mess_Aide & CRLF & "        Creer/"
					Mess_Aide = Mess_Aide & CRLF & "   Fin/ Textebox"
					Mess_Aide = Mess_Aide & CRLF
					Mess_Aide = Mess_Aide & CRLF & " Parametre .Parametres :"
					Mess_Aide = Mess_Aide & CRLF & "  IMGAUTO:0  = (Defaut) affichage normale, et coupe le texte si plus grand que TX et TY"
					Mess_Aide = Mess_Aide & CRLF & "  IMGAUTO:1  = Permet de definir la taille X, Y du Textebloc selon la taille de l'image source"
					Mess_Aide = Mess_Aide & CRLF & "  IMGAUTO:2  = Permet de re-dimentionner 'non-vectoriellement' la taille du texte selon les dimentions X, Y du textebloc"
					Mess_Aide = Mess_Aide & CRLF & "  BORD:0	 = Affiche pas de bordure autour"
					Mess_Aide = Mess_Aide & CRLF & "  BORD:1	 = Affiche une bordure noire"
					Mess_Aide = Mess_Aide & CRLF & "  BORD:2	 = (Par defaut) Affiche le textebloc avec un effet 3D"
					Mess_Aide = Mess_Aide & CRLF

					Mess_Aide = Mess_Aide & CRLF & "  Voir aussi : picturebox/ , bouton/ , fenetre/ , textebloc/"
					Mess_Aide = Mess_Aide & CRLF
				ELSEIF CPCDOS_INSTANCE.Utilisateur_Langage = 1 THEN
					Mess_Aide = Mess_Aide & CRLF & "  'Textblock'"
					Mess_Aide = Mess_Aide & CRLF
					Mess_Aide = Mess_Aide & CRLF & "  Fonctionnality :"
					Mess_Aide = Mess_Aide & CRLF & "   This command allow to create new editable text area in existing window handle (eg:12345)"
					Mess_Aide = Mess_Aide & CRLF
					Mess_Aide = Mess_Aide & CRLF & "  Example :"
					Mess_Aide = Mess_Aide & CRLF & "   Textbox/ My_Textbox"
					Mess_Aide = Mess_Aide & CRLF & "   		.Handle				= " & CHR(34) & "12345" & CHR(34)
					Mess_Aide = Mess_Aide & CRLF & "   		.Texte				= " & CHR(34) & "My editable text area" & CHR(34)
					Mess_Aide = Mess_Aide & CRLF & "   		.PX 				= " & CHR(34) & "30" & CHR(34)
					Mess_Aide = Mess_Aide & CRLF & "   		.PY 				= " & CHR(34) & "20" & CHR(34)
					Mess_Aide = Mess_Aide & CRLF & "   		.SX 				= " & CHR(34) & "0" & CHR(34)
					Mess_Aide = Mess_Aide & CRLF & "   		.SY 				= " & CHR(34) & "0" & CHR(34)
					Mess_Aide = Mess_Aide & CRLF & "   		.Parameters 		= " & CHR(34) & "IMGAUTO:1" & CHR(34)
					Mess_Aide = Mess_Aide & CRLF & "   		.TextColor 			= " & CHR(34) & "000,000,000" & CHR(34)
					Mess_Aide = Mess_Aide & CRLF & "   		.BackColor			= " & CHR(34) & "220,220,220" & CHR(34)
					Mess_Aide = Mess_Aide & CRLF & "        Create/"
					Mess_Aide = Mess_Aide & CRLF & "   End/ Textbox"
					Mess_Aide = Mess_Aide & CRLF
					Mess_Aide = Mess_Aide & CRLF & " .Parameters :"
					Mess_Aide = Mess_Aide & CRLF & "  IMGAUTO:0  = (Default) normal displaying"
					Mess_Aide = Mess_Aide & CRLF & "  IMGAUTO:1  = Allow to define X, Y size with source image"
					Mess_Aide = Mess_Aide & CRLF & "  IMGAUTO:2  = Allow to re-size image with X, Y picturebox size."
					Mess_Aide = Mess_Aide & CRLF & "  BORD:0	 = No border"
					Mess_Aide = Mess_Aide & CRLF & "  BORD:1	 = Display black border"
					Mess_Aide = Mess_Aide & CRLF & "  BORD:2	 = (Default) Display textblock with 3D effect"
					Mess_Aide = Mess_Aide & CRLF
					Mess_Aide = Mess_Aide & CRLF & "  See also : picturebox/ , bouton/ , window/ textbloc/"
					Mess_Aide = Mess_Aide & CRLF
				END IF

				DEBUG(Mess_Aide, Affichage, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_SURBRILLE, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.SansDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_AFF, RetourVAR)
				testCMD = 0
				AfficherAide = 0
				exit _scope_CMD, _scope
			END IF
			' Tester la syntaxe
			testCMD	= CCP_Verifier_Syntaxe(Commande, CommPosition)
			IF testCMD > 10 Then exit _scope_CMD, _scope
			IF testCMD > 0 then  ' Entre 1-5 = Pas d'affichage via le @, @$ ou @#
				IF testCMD < 6 then
					Affichage = 0
					IF testCMD = 3 Then CpcdosCP_SHELL("FIX/ " & CPCDOS_INSTANCE.DEBUG_INSTANCE.LeRetour & " = \#NULL", _CLE_, NIVEAU_CCP, Param_1, Param_2) : RetourVAR = _CLE_ & "N" & NIVEAU_CCP & "->" & CPCDOS_INSTANCE.DEBUG_INSTANCE.LeRetour
					if testCMD = 2 Then RetourVAR = "$>" & CPCDOS_INSTANCE.DEBUG_INSTANCE.LeRetour ' ajouter une securite ?
				Else
					Affichage = 1
				END IF
			Else
				Affichage = 1
			END IF
			' Recuperer les Parametres
			Param = MID(Commande, CommPosition + TailleComm + 2)
			SCOPE
			' ====================================================================

			' Enlever les espaces et mettre tout en majuscules
			Dim NomTextebox as string = Ucase(LTrim(Ltrim(RTrim(Param), CHR(09))))

			IF INSTR(UCASE(NomTextebox), "/MODIF") > 0 Then
				NomTextebox = MID(NomTextebox, INSTR(UCASE(NomTextebox), "/MODIF") + 7) & "~MODIF#"

				IF CPCDOS_INSTANCE.Utilisateur_Langage = 0 Then
					DEBUG("[CpcdosC+] Mode edition d'un TexteBox '" & NomTextebox & "' ...", Affichage, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_Normal, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.AvecDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_AFF, RetourVAR)
				Else
					DEBUG("[CpcdosC+] TextBox edition mode '" & NomTextebox & "' ...", Affichage, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_Normal, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.AvecDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_AFF, RetourVAR)
				End if
			Else
				IF CPCDOS_INSTANCE.Utilisateur_Langage = 0 Then
					DEBUG("[CpcdosC+] Creation d'un TexteBox '" & NomTextebox & "' ...", Affichage, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_Normal, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.AvecDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_AFF, RetourVAR)
				Else
					DEBUG("[CpcdosC+] Creating TextBox '" & NomTextebox & "' ...", Affichage, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_Normal, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.AvecDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_AFF, RetourVAR)
				End if
			End if
			CpcdosCP_SHELL = "IUG:TEXTEBOX_NOM=" & NomTextebox

			' ====================================================================
			END SCOPE

			exit _scope_CMD, _scope
		End if ' **** TexteBox/ ****

	_end_scope_CMD

	_scope_CMD

		' ===============================================================
		'  Commande pour creer une barre de progression
		' ===============================================================
		CommLANG(1) = "barreprogression/"
		CommLANG(2) = "progressbar/"
		CommLANG(3) = "\\#//"
		CommTrouve = 0 : NoCMD = 0
		for boucle as integer = 1 to 2
			IF OnCherche = CommLANG(boucle) Then
				NoCMD = 0
				exit for
			Else
				NoCMD = 1
			End if
		Next boucle
		IF NoCMD = 1 then CommLANG(1) = "[F.#).|" : CommLANG(2) = "[F.#).|" : CommLANG(3) = "\\#//"
		rem Afficher la liste des commandes avec anglais / francais
		IF AfficherAide = 1 then
			IF CPCDOS_INSTANCE.Utilisateur_Langage = 0 then
				CommandesAide = CommandesAide & CRLF & " BarreProgresson/           Cree une nouvelle instance d'une barre de progression"
			Else
				CommandesAide = CommandesAide & CRLF & " ProgressBar/               Create new progress bar instance"
			END IF
		END IF
		IF CommLANG(1) = OnCherche Then CommTrouve = 1
		IF CommLANG(2) = OnCherche Then CommTrouve = 2
		IF CommTrouve > 0 Then ' Afficher l'aide de la commande
			IF AfficherAide = 2 then
				Mess_Aide = ""
				IF CPCDOS_INSTANCE.Utilisateur_Langage = 0 THEN
					Mess_Aide = Mess_Aide & CRLF & "  'BarreProgression'"
					Mess_Aide = Mess_Aide & CRLF
					Mess_Aide = Mess_Aide & CRLF & "  Fonctionnalit�e :"
					Mess_Aide = Mess_Aide & CRLF & "   Cette commande permet de creer une barre de progression dans un No de handle d'une fenetre existante"
					Mess_Aide = Mess_Aide & CRLF & "    exemple avec 12345"
					Mess_Aide = Mess_Aide & CRLF
					Mess_Aide = Mess_Aide & CRLF & "   A savoir qu'en general, le numero de handle (Numero d'objet) d'une fenetre est genere pendant"
					Mess_Aide = Mess_Aide & CRLF & "    l'execution de la commande 'creer/'. Si vous utilisez le numero d'un handle d'une fenetre, votre"
					Mess_Aide = Mess_Aide & CRLF & "    objet graphique sera heberge a l'interieur, et l'emplacement X et Y sera relatif au"
					Mess_Aide = Mess_Aide & CRLF & "     conteneur de la fenetre."
					Mess_Aide = Mess_Aide & CRLF
					Mess_Aide = Mess_Aide & CRLF & "  Exemple :"
					Mess_Aide = Mess_Aide & CRLF & "   BarreProgression/ MaBarreDeProgression"
					Mess_Aide = Mess_Aide & CRLF & "   		.handle				= " & CHR(34) & "12345" & CHR(34)
					Mess_Aide = Mess_Aide & CRLF & "   		.PX 				= " & CHR(34) & "100" & CHR(34)
					Mess_Aide = Mess_Aide & CRLF & "   		.PY 				= " & CHR(34) & "100" & CHR(34)
					Mess_Aide = Mess_Aide & CRLF & "   		.TX 				= " & CHR(34) & "400" & CHR(34)
					Mess_Aide = Mess_Aide & CRLF & "   		.TY 				= " & CHR(34) & "30" & CHR(34)
					Mess_Aide = Mess_Aide & CRLF & "   		.Parametres			= " & CHR(34) & "IMGAUTO:2" & CHR(34)
					Mess_Aide = Mess_Aide & CRLF & "   		.CouleurTexte	 	= " & CHR(34) & "000,000,000" & CHR(34)
					Mess_Aide = Mess_Aide & CRLF & "   		.CouleurFond		= " & CHR(34) & "220,220,220" & CHR(34)
					Mess_Aide = Mess_Aide & CRLF & "   		.Image				= " & CHR(34) & "imagebar.png" & CHR(34)
					Mess_Aide = Mess_Aide & CRLF & "   		.Valeur				= " & CHR(34) & "40" & CHR(34)
					Mess_Aide = Mess_Aide & CRLF & "   		.Texte				= " & CHR(34) & "Progression a 40%" & CHR(34)
					Mess_Aide = Mess_Aide & CRLF & "        Creer/"
					Mess_Aide = Mess_Aide & CRLF & "   Fin/ MaBarreDeProgression"
					Mess_Aide = Mess_Aide & CRLF
					Mess_Aide = Mess_Aide & CRLF & " Parametre .Parametres :"
					Mess_Aide = Mess_Aide & CRLF & "  IMGAUTO:0  = aucun etirement durant la progression (Il faut que l'image soit deja grande)"
					Mess_Aide = Mess_Aide & CRLF & "  IMGAUTO:1  = Permet de definir la taille X, Y de la barre selon la taille de l'image source"
					Mess_Aide = Mess_Aide & CRLF & "  IMGAUTO:2  = (Defaut) permet d'etirer l'image de la barre selon la progression"
					Mess_Aide = Mess_Aide & CRLF

					Mess_Aide = Mess_Aide & CRLF & "  Voir aussi : Fenetre/ , Bouton/ , Textebloc/ , textebox/ "
					Mess_Aide = Mess_Aide & CRLF
				ELSEIF CPCDOS_INSTANCE.Utilisateur_Langage = 1 THEN
					Mess_Aide = Mess_Aide & CRLF & "  'ProgressBar'"
					Mess_Aide = Mess_Aide & CRLF
					Mess_Aide = Mess_Aide & CRLF & "  Fonctionnality :"
					Mess_Aide = Mess_Aide & CRLF & "   This command allow to create new progress bar instance in existing window handle (eg:123456789)"
					Mess_Aide = Mess_Aide & CRLF
					Mess_Aide = Mess_Aide & CRLF & "  Exemple :"
					Mess_Aide = Mess_Aide & CRLF & "   ProgressBar/ MyProgressBar"
					Mess_Aide = Mess_Aide & CRLF & "   		.handle				= " & CHR(34) & "12345" & CHR(34)
					Mess_Aide = Mess_Aide & CRLF & "   		.PX 				= " & CHR(34) & "10" & CHR(34)
					Mess_Aide = Mess_Aide & CRLF & "   		.PY 				= " & CHR(34) & "10" & CHR(34)
					Mess_Aide = Mess_Aide & CRLF & "   		.SX 				= " & CHR(34) & "400" & CHR(34)
					Mess_Aide = Mess_Aide & CRLF & "   		.SY 				= " & CHR(34) & "30" & CHR(34)
					Mess_Aide = Mess_Aide & CRLF & "   		.Parameters 		= " & CHR(34) & "IMGAUTO:2" & CHR(34)
					Mess_Aide = Mess_Aide & CRLF & "   		.TextColor 			= " & CHR(34) & "000,000,000" & CHR(34)
					Mess_Aide = Mess_Aide & CRLF & "   		.BackColor			= " & CHR(34) & "040,150,220" & CHR(34)
					Mess_Aide = Mess_Aide & CRLF & "   		.Value				= " & CHR(34) & "40" & CHR(34)
					Mess_Aide = Mess_Aide & CRLF & "   		.Text				= " & CHR(34) & "Progression 40%" & CHR(34)
					Mess_Aide = Mess_Aide & CRLF & "   		.Image				= " & CHR(34) & "barimage.png" & CHR(34)
					Mess_Aide = Mess_Aide & CRLF & "        Create/"
					Mess_Aide = Mess_Aide & CRLF & "   End/ ProgressBar"
					Mess_Aide = Mess_Aide & CRLF
					Mess_Aide = Mess_Aide & CRLF & " .Parameters :"
					Mess_Aide = Mess_Aide & CRLF & "  IMGAUTO:0  = (Default) No stretching during progression"
					Mess_Aide = Mess_Aide & CRLF & "  IMGAUTO:1  = Allow to define X, Y object size with source image"
					Mess_Aide = Mess_Aide & CRLF & "  IMGAUTO:2  = Allow to stretching source image during progression"
					Mess_Aide = Mess_Aide & CRLF
					Mess_Aide = Mess_Aide & CRLF & "  See also : Window/ , Button/ , Textblock/ , textbox/"
					Mess_Aide = Mess_Aide & CRLF
				END IF

				DEBUG(Mess_Aide, Affichage, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_SURBRILLE, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.SansDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_AFF, RetourVAR)
				testCMD = 0
				AfficherAide = 0
				exit _scope_CMD, _scope
			END IF
			' Tester la syntaxe
			testCMD	= CCP_Verifier_Syntaxe(Commande, CommPosition)
			IF testCMD > 10 Then exit _scope_CMD, _scope
			IF testCMD > 0 then  ' Entre 1-5 = Pas d'affichage via le @, @$ ou @#
				IF testCMD < 6 then
					Affichage = 0
					IF testCMD = 3 Then CpcdosCP_SHELL("FIX/ " & CPCDOS_INSTANCE.DEBUG_INSTANCE.LeRetour & " = \#NULL", _CLE_, NIVEAU_CCP, Param_1, Param_2) : RetourVAR = _CLE_ & "N" & NIVEAU_CCP & "->" & CPCDOS_INSTANCE.DEBUG_INSTANCE.LeRetour
					if testCMD = 2 Then RetourVAR = "$>" & CPCDOS_INSTANCE.DEBUG_INSTANCE.LeRetour ' ajouter une securite ?
				Else
					Affichage = 1
				END IF
			Else
				Affichage = 1
			END IF
			' Recuperer les Parametres
			Param = MID(Commande, CommPosition + TailleComm + 2)
			SCOPE
			' ====================================================================

			' Enlever les espaces et mettre tout en majuscules
			Dim NomProgressBar as string = Ucase(LTrim(Ltrim(RTrim(Param), CHR(09))))

			IF INSTR(UCASE(NomProgressBar), "/MODIF") > 0 Then
				NomProgressBar = MID(NomProgressBar, INSTR(UCASE(NomProgressBar), "/MODIF") + 7) & "~MODIF#"

				IF CPCDOS_INSTANCE.Utilisateur_Langage = 0 Then
					DEBUG("[CpcdosC+] Mode edition d'une barre de progression '" & NomProgressBar & "' ...", Affichage, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_Normal, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.AvecDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_AFF, RetourVAR)
				Else
					DEBUG("[CpcdosC+] Progress bar edition mode '" & NomProgressBar & "' ...", Affichage, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_Normal, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.AvecDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_AFF, RetourVAR)
				End if
			Else
				IF CPCDOS_INSTANCE.Utilisateur_Langage = 0 Then
					DEBUG("[CpcdosC+] Creation d'une barre de progression '" & NomProgressBar & "' ...", Affichage, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_Normal, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.AvecDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_AFF, RetourVAR)
				Else
					DEBUG("[CpcdosC+] Creating progress bar '" & NomProgressBar & "' ...", Affichage, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_Normal, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.AvecDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_AFF, RetourVAR)
				End if
			End if

			CpcdosCP_SHELL = "IUG:PROGRESSBAR_NOM=" & NomProgressBar

			' ====================================================================
			END SCOPE

			exit _scope_CMD, _scope
		End if ' **** ProgressBar/ ****

	_end_scope_CMD

	_scope_CMD

		' ===============================================================
		'  Commande pour creer un checkbox
		' ===============================================================
		CommLANG(1) = "checkbox/"
		CommLANG(2) = "checkbox/"
		CommLANG(3) = "\\#//"
		CommTrouve = 0 : NoCMD = 0
		for boucle as integer = 1 to 2
			IF OnCherche = CommLANG(boucle) Then
				NoCMD = 0
				exit for
			Else
				NoCMD = 1
			End if
		Next boucle
		IF NoCMD = 1 then CommLANG(1) = "[F.#).|" : CommLANG(2) = "[F.#).|" : CommLANG(3) = "\\#//"
		rem Afficher la liste des commandes avec anglais / francais
		IF AfficherAide = 1 then
			IF CPCDOS_INSTANCE.Utilisateur_Langage = 0 then
				CommandesAide = CommandesAide & CRLF & " checkbox/                  Cree une nouvelle instance d'une boite cochable"
			Else
				CommandesAide = CommandesAide & CRLF & " checkbox/                  Create new check box instance"
			END IF
		END IF
		IF CommLANG(1) = OnCherche Then CommTrouve = 1
		IF CommLANG(2) = OnCherche Then CommTrouve = 2
		IF CommTrouve > 0 Then ' Afficher l'aide de la commande
			IF AfficherAide = 2 then
				Mess_Aide = ""
				IF CPCDOS_INSTANCE.Utilisateur_Langage = 0 THEN
					Mess_Aide = Mess_Aide & CRLF & "  'CheckBox'"
					Mess_Aide = Mess_Aide & CRLF
					Mess_Aide = Mess_Aide & CRLF & "  Fonctionnalit�e :"
					Mess_Aide = Mess_Aide & CRLF & "   Cette commande permet de creer une boite cochable dans un No de handle d'une fenetre existante"
					Mess_Aide = Mess_Aide & CRLF & "    exemple avec 12345"
					Mess_Aide = Mess_Aide & CRLF
					Mess_Aide = Mess_Aide & CRLF & "   A savoir qu'en general, le numero de handle (Numero d'objet) d'une fenetre est genere pendant"
					Mess_Aide = Mess_Aide & CRLF & "    l'execution de la commande 'creer/'. Si vous utilisez le numero d'un handle d'une fenetre, votre"
					Mess_Aide = Mess_Aide & CRLF & "    objet graphique sera heberge a l'interieur, et l'emplacement X et Y sera relatif au"
					Mess_Aide = Mess_Aide & CRLF & "     conteneur de la fenetre."
					Mess_Aide = Mess_Aide & CRLF
					Mess_Aide = Mess_Aide & CRLF & "  Exemple :"
					Mess_Aide = Mess_Aide & CRLF & "   CheckBox/ MonCheckbox"
					Mess_Aide = Mess_Aide & CRLF & "   		.handle				= " & CHR(34) & "12345" & CHR(34)
					Mess_Aide = Mess_Aide & CRLF & "   		.Parametres 		= " & CHR(34) & "COL:0 IMGAUTO:1" & CHR(34)
					Mess_Aide = Mess_Aide & CRLF & "   		.PX 				= " & CHR(34) & "100" & CHR(34)
					Mess_Aide = Mess_Aide & CRLF & "   		.PY 				= " & CHR(34) & "100" & CHR(34)
					Mess_Aide = Mess_Aide & CRLF & "   		.TX 				= " & CHR(34) & "0" & CHR(34) & "    gere via 'IMGAUTO:1'"
					Mess_Aide = Mess_Aide & CRLF & "   		.TY 				= " & CHR(34) & "0" & CHR(34) & "    gere via 'IMGAUTO:1'"
					Mess_Aide = Mess_Aide & CRLF & "   		.CouleurTexte	 	= " & CHR(34) & "000,000,000" & CHR(34)
					Mess_Aide = Mess_Aide & CRLF & "   		.CouleurFond		= " & CHR(34) & "220,220,220" & CHR(34)
					Mess_Aide = Mess_Aide & CRLF & "   		.Valeur				= " & CHR(34) & "0" & CHR(34)
					Mess_Aide = Mess_Aide & CRLF & "   		.Texte				= " & CHR(34) & "Cochez-moi !" & CHR(34)
					Mess_Aide = Mess_Aide & CRLF & "        Creer/"
					Mess_Aide = Mess_Aide & CRLF & "   Fin/ CheckBox"
					Mess_Aide = Mess_Aide & CRLF
					Mess_Aide = Mess_Aide & CRLF & " Parametre .Parametres :"
					Mess_Aide = Mess_Aide & CRLF & "  COL:0     = (Par defaut) Ne dessine pas la couleur de fond"
					Mess_Aide = Mess_Aide & CRLF & "  COL:1     = Dessine pas la couleur de fond depuis la propriete '.CouleurFond'"
					Mess_Aide = Mess_Aide & CRLF & "  IMGAUTO:0 = Dimentions gere par .TX et .TY"
					Mess_Aide = Mess_Aide & CRLF & "  IMGAUTO:1 = (By default) Dimentions gere par la taille du texte '.Texte'"
					Mess_Aide = Mess_Aide & CRLF
					Mess_Aide = Mess_Aide & CRLF & "  Voir aussi : Fenetre/ , Bouton/ , Textebloc/ , textebox/ , BarreProgression/"
					Mess_Aide = Mess_Aide & CRLF
				ELSEIF CPCDOS_INSTANCE.Utilisateur_Langage = 1 THEN
					Mess_Aide = Mess_Aide & CRLF & "  'ProgressBar'"
					Mess_Aide = Mess_Aide & CRLF
					Mess_Aide = Mess_Aide & CRLF & "  Fonctionnality :"
					Mess_Aide = Mess_Aide & CRLF & "   This command allow to create new check box instance in existing window handle (eg:123456789)"
					Mess_Aide = Mess_Aide & CRLF
					Mess_Aide = Mess_Aide & CRLF & "  Exemple :"
					Mess_Aide = Mess_Aide & CRLF & "   CheckBox/ MyCheckbox"
					Mess_Aide = Mess_Aide & CRLF & "   		.handle				= " & CHR(34) & "12345" & CHR(34)
					Mess_Aide = Mess_Aide & CRLF & "   		.Parameters 		= " & CHR(34) & "COL:0 IMGAUTO:1" & CHR(34)
					Mess_Aide = Mess_Aide & CRLF & "   		.PX 				= " & CHR(34) & "10" & CHR(34)
					Mess_Aide = Mess_Aide & CRLF & "   		.PY 				= " & CHR(34) & "10" & CHR(34)
					Mess_Aide = Mess_Aide & CRLF & "   		.SX 				= " & CHR(34) & "0" & CHR(34) & "    -> managed by 'IMGAUTO:1'"
					Mess_Aide = Mess_Aide & CRLF & "   		.SY 				= " & CHR(34) & "0" & CHR(34) & "    -> managed by 'IMGAUTO:1'"
					Mess_Aide = Mess_Aide & CRLF & "   		.TextColor 			= " & CHR(34) & "000,000,000" & CHR(34)
					Mess_Aide = Mess_Aide & CRLF & "   		.BackColor			= " & CHR(34) & "040,150,220" & CHR(34)
					Mess_Aide = Mess_Aide & CRLF & "   		.Value				= " & CHR(34) & "0" & CHR(34)
					Mess_Aide = Mess_Aide & CRLF & "   		.Text				= " & CHR(34) & "Check me!" & CHR(34)
					Mess_Aide = Mess_Aide & CRLF & "        Create/"
					Mess_Aide = Mess_Aide & CRLF & "   End/ CheckBox"
					Mess_Aide = Mess_Aide & CRLF
					Mess_Aide = Mess_Aide & CRLF & " .Parameters :"
					Mess_Aide = Mess_Aide & CRLF & "  COL:0     = (By default) No drawing back color"
					Mess_Aide = Mess_Aide & CRLF & "  COL:1     = Draw the back color from '.BackColor' property"
					Mess_Aide = Mess_Aide & CRLF & "  IMGAUTO:0  = Use TX and TY dimentions"
					Mess_Aide = Mess_Aide & CRLF & "  IMGAUTO:1  = Use the text length"
					Mess_Aide = Mess_Aide & CRLF
					Mess_Aide = Mess_Aide & CRLF & "  See also : Window/ , Button/ , Textblock/ , textbox/ , ProgressBar/"
					Mess_Aide = Mess_Aide & CRLF
				END IF

				DEBUG(Mess_Aide, Affichage, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_SURBRILLE, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.SansDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_AFF, RetourVAR)
				testCMD = 0
				AfficherAide = 0
				exit _scope_CMD, _scope
			END IF
			' Tester la syntaxe
			testCMD	= CCP_Verifier_Syntaxe(Commande, CommPosition)
			IF testCMD > 10 Then exit _scope_CMD, _scope
			IF testCMD > 0 then  ' Entre 1-5 = Pas d'affichage via le @, @$ ou @#
				IF testCMD < 6 then
					Affichage = 0
					IF testCMD = 3 Then CpcdosCP_SHELL("FIX/ " & CPCDOS_INSTANCE.DEBUG_INSTANCE.LeRetour & " = \#NULL", _CLE_, NIVEAU_CCP, Param_1, Param_2) : RetourVAR = _CLE_ & "N" & NIVEAU_CCP & "->" & CPCDOS_INSTANCE.DEBUG_INSTANCE.LeRetour
					if testCMD = 2 Then RetourVAR = "$>" & CPCDOS_INSTANCE.DEBUG_INSTANCE.LeRetour ' ajouter une securite ?
				Else
					Affichage = 1
				END IF
			Else
				Affichage = 1
			END IF
			' Recuperer les Parametres
			Param = MID(Commande, CommPosition + TailleComm + 2)
			SCOPE
			' ====================================================================

			' Enlever les espaces et mettre tout en majuscules
			Dim NomCheckBox as string = Ucase(LTrim(Ltrim(RTrim(Param), CHR(09))))

			IF INSTR(UCASE(NomCheckBox), "/MODIF") > 0 Then
				NomCheckBox = MID(NomCheckBox, INSTR(UCASE(NomCheckBox), "/MODIF") + 7) & "~MODIF#"

				IF CPCDOS_INSTANCE.Utilisateur_Langage = 0 Then
					DEBUG("[CpcdosC+] Mode edition d'une barre de progression '" & NomCheckBox & "' ...", Affichage, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_Normal, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.AvecDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_AFF, RetourVAR)
				Else
					DEBUG("[CpcdosC+] Progress bar edition mode '" & NomCheckBox & "' ...", Affichage, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_Normal, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.AvecDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_AFF, RetourVAR)
				End if
			Else
				IF CPCDOS_INSTANCE.Utilisateur_Langage = 0 Then
					DEBUG("[CpcdosC+] Creation d'une barre de progression '" & NomCheckBox & "' ...", Affichage, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_Normal, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.AvecDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_AFF, RetourVAR)
				Else
					DEBUG("[CpcdosC+] Creating progress bar '" & NomCheckBox & "' ...", Affichage, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_Normal, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.AvecDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_AFF, RetourVAR)
				End if
			End if

			CpcdosCP_SHELL = "IUG:CHECKBOX_NOM=" & NomCheckBox

			' ====================================================================
			END SCOPE

			exit _scope_CMD, _scope
		End if ' **** CheckBox/ ****

	_end_scope_CMD

	_scope_CMD

		' ===============================================================
		'  Commande pour rafraichir un objet ou une fenetre
		' ===============================================================
		CommLANG(1) = "actualiser/"
		CommLANG(2) = "refresh/"
		CommLANG(3) = "\\#//"
		CommTrouve = 0 : NoCMD = 0
		for boucle as integer = 1 to 2
			IF OnCherche = CommLANG(boucle) Then
				NoCMD = 0
				exit for
			Else
				NoCMD = 1
			End if
		Next boucle
		IF NoCMD = 1 then CommLANG(1) = "[F.#).|" : CommLANG(2) = "[F.#).|" : CommLANG(3) = "\\#//"
		rem Afficher la liste des commandes avec anglais / francais
		IF AfficherAide = 1 then
			IF CPCDOS_INSTANCE.Utilisateur_Langage = 0 then
				CommandesAide = CommandesAide & CRLF & " actualiser/                Actualise un objet, une fenetre graphique ou l'arriere plan"
			Else
				CommandesAide = CommandesAide & CRLF & " refresh/                   Refresh an GUI object, window or background"
			END IF
		END IF
		IF CommLANG(1) = OnCherche Then CommTrouve = 1
		IF CommLANG(2) = OnCherche Then CommTrouve = 2
		IF CommTrouve > 0 Then ' Afficher l'aide de la commande
			IF AfficherAide = 2 then
				Mess_Aide = ""
				IF CPCDOS_INSTANCE.Utilisateur_Langage = 0 THEN
					Mess_Aide = Mess_Aide & CRLF & "  'Actualiser'"
					Mess_Aide = Mess_Aide & CRLF
					Mess_Aide = Mess_Aide & CRLF & "  Fonctionnalit�e :"
					Mess_Aide = Mess_Aide & CRLF & "   Cette commande permet d'actualiser graphiquement un objet contenu dans une fenetre"
					Mess_Aide = Mess_Aide & CRLF & "    ou bien la fenetre elle meme avec tous ses objets, ou l'arriere plan de l'interface."
					Mess_Aide = Mess_Aide & CRLF
					Mess_Aide = Mess_Aide & CRLF & "   Cette commande est utile dans le cas d'une modification mineure sur un objet"
					Mess_Aide = Mess_Aide & CRLF & "    ou l'arriere plan graphique. Ou bien pour combler d'eventuels problemes."
					Mess_Aide = Mess_Aide & CRLF
					Mess_Aide = Mess_Aide & CRLF & "  Exemple :"
					Mess_Aide = Mess_Aide & CRLF
					Mess_Aide = Mess_Aide & CRLF & "   Actualiser une fenetre via son nom de propriete"
					Mess_Aide = Mess_Aide & CRLF & "     actualiser/ ma_fenetre"
					Mess_Aide = Mess_Aide & CRLF & "   ou via son numero de handle"
					Mess_Aide = Mess_Aide & CRLF & "'    actualiser/ /handle 01234"
					Mess_Aide = Mess_Aide & CRLF
					Mess_Aide = Mess_Aide & CRLF & "   Actualiser un objet graphique via son nom."
					Mess_Aide = Mess_Aide & CRLF & "     /!\ Seulement si la commande se trouve dans le meme TID/PID"
					Mess_Aide = Mess_Aide & CRLF & "     actualiser/ Mon_textebox"
					Mess_Aide = Mess_Aide & CRLF & "   Sinon, il faut actualiser l'objet depuis son numero d'handle"
					Mess_Aide = Mess_Aide & CRLF & "     actualiser/ /handle 1234"
					Mess_Aide = Mess_Aide & CRLF
					Mess_Aide = Mess_Aide & CRLF & "   Actualiser TOUTES les fenetres"
					Mess_Aide = Mess_Aide & CRLF & "     actualiser/ /fenetre"
					Mess_Aide = Mess_Aide & CRLF & "   ou"
					Mess_Aide = Mess_Aide & CRLF & "     actualiser/ /fenetres"
					Mess_Aide = Mess_Aide & CRLF
					Mess_Aide = Mess_Aide & CRLF & "   Actualiser uniquement les fenetres NON FOCUS (En arriere plan)"
					Mess_Aide = Mess_Aide & CRLF & "     actualiser/ /fenetre /nonfocus "
					Mess_Aide = Mess_Aide & CRLF
					Mess_Aide = Mess_Aide & CRLF & "   Actualiser uniquement la fenetre FOCUS (Au premier plan)"
					Mess_Aide = Mess_Aide & CRLF & "     actualiser/ /fenetre /focus"
					Mess_Aide = Mess_Aide & CRLF
					Mess_Aide = Mess_Aide & CRLF & "   Actualiser l'image de fond"
					Mess_Aide = Mess_Aide & CRLF & "     actualiser/ /image"
					Mess_Aide = Mess_Aide & CRLF
					Mess_Aide = Mess_Aide & CRLF & "   Actualiser absolument tout!"
					Mess_Aide = Mess_Aide & CRLF & "     actualiser/ /tout"
					Mess_Aide = Mess_Aide & CRLF
					Mess_Aide = Mess_Aide & CRLF & "  Voir aussi : fermer/"
					Mess_Aide = Mess_Aide & CRLF
				ELSEIF CPCDOS_INSTANCE.Utilisateur_Langage = 1 THEN
					Mess_Aide = Mess_Aide & CRLF & "  'Refresh'"
					Mess_Aide = Mess_Aide & CRLF
					Mess_Aide = Mess_Aide & CRLF & "  Fonctionnality :"
					Mess_Aide = Mess_Aide & CRLF & "   This command allow to refresh graphically an object in a window, or window, or"
					Mess_Aide = Mess_Aide & CRLF & "    background interface"
					Mess_Aide = Mess_Aide & CRLF
					Mess_Aide = Mess_Aide & CRLF & "   This command is useful in the case monor modification on gui object"
					Mess_Aide = Mess_Aide & CRLF & "    or graphic background. Or .. patch eventual problem."
					Mess_Aide = Mess_Aide & CRLF
					Mess_Aide = Mess_Aide & CRLF & "  Example :"
					Mess_Aide = Mess_Aide & CRLF
					Mess_Aide = Mess_Aide & CRLF & "   Refresh window from property name"
					Mess_Aide = Mess_Aide & CRLF & "     refresh/ my_window"
					Mess_Aide = Mess_Aide & CRLF & "   or from his handle number"
					Mess_Aide = Mess_Aide & CRLF & "'    refresh/ /handle 01234"
					Mess_Aide = Mess_Aide & CRLF
					Mess_Aide = Mess_Aide & CRLF & "   Refresh graphic object from his name"
					Mess_Aide = Mess_Aide & CRLF & "     /!\ Seulement si la commande se trouve dans le meme TID/PID"
					Mess_Aide = Mess_Aide & CRLF & "     refresh/ My_Textbox"
					Mess_Aide = Mess_Aide & CRLF & "   Otherwise, you must to use his handle number."
					Mess_Aide = Mess_Aide & CRLF & "     refresh/ /handle 1234"
					Mess_Aide = Mess_Aide & CRLF
					Mess_Aide = Mess_Aide & CRLF & "   Refresh ALL windows"
					Mess_Aide = Mess_Aide & CRLF & "     refresh/ /window"
					Mess_Aide = Mess_Aide & CRLF & "   or"
					Mess_Aide = Mess_Aide & CRLF & "     refresh/ /windows"
					Mess_Aide = Mess_Aide & CRLF
					Mess_Aide = Mess_Aide & CRLF & "   Refresh only NO FOCUS windows (in the background)"
					Mess_Aide = Mess_Aide & CRLF & "     refresh/ /window /nofocus "
					Mess_Aide = Mess_Aide & CRLF
					Mess_Aide = Mess_Aide & CRLF & "   Refresh only FOCUS windows (in foreground)"
					Mess_Aide = Mess_Aide & CRLF & "     refresh/ /window /focus"
					Mess_Aide = Mess_Aide & CRLF
					Mess_Aide = Mess_Aide & CRLF & "   Refresh background image (wallpaper)"
					Mess_Aide = Mess_Aide & CRLF & "     refresh/ /image"
					Mess_Aide = Mess_Aide & CRLF
					Mess_Aide = Mess_Aide & CRLF & "   Refresh ALL !"
					Mess_Aide = Mess_Aide & CRLF & "     refresh/ /all"
					Mess_Aide = Mess_Aide & CRLF
					Mess_Aide = Mess_Aide & CRLF & "  See also : close/"
					Mess_Aide = Mess_Aide & CRLF
				END IF

				DEBUG(Mess_Aide, Affichage, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_SURBRILLE, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.SansDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_AFF, RetourVAR)
				testCMD = 0
				AfficherAide = 0
				exit _scope_CMD, _scope
			END IF
			' Tester la syntaxe
			testCMD	= CCP_Verifier_Syntaxe(Commande, CommPosition)
			IF testCMD > 10 Then exit _scope_CMD, _scope
			IF testCMD > 0 then  ' Entre 1-5 = Pas d'affichage via le @, @$ ou @#
				IF testCMD < 6 then
					Affichage = 0
					IF testCMD = 3 Then CpcdosCP_SHELL("FIX/ " & CPCDOS_INSTANCE.DEBUG_INSTANCE.LeRetour & " = \#NULL", _CLE_, NIVEAU_CCP, Param_1, Param_2) : RetourVAR = _CLE_ & "N" & NIVEAU_CCP & "->" & CPCDOS_INSTANCE.DEBUG_INSTANCE.LeRetour
					if testCMD = 2 Then RetourVAR = "$>" & CPCDOS_INSTANCE.DEBUG_INSTANCE.LeRetour ' ajouter une securite ?
				Else
					Affichage = 1
				END IF
			Else
				Affichage = 1
			END IF
			' Recuperer les Parametres
			Param = MID(Commande, CommPosition + TailleComm + 2)
			SCOPE
			' ====================================================================
			Dim TypeOjetNOM		as String
			Dim Numero_INDEX	as integer = 0
			Dim TypeObjet		as integer = 0
			DIM Numero_Handle 	as integer = 0


			Dim PosNUMhandle as integer = instr(UCASE(Param), "/HANDLE") ' Handle
			Dim PosFenetre as integer = instr(UCASE(Param), "/FENETRE") ' Fenetres
			Dim PosWindow as integer = instr(UCASE(Param), "/WINDOW") ' Fenetres
			Dim PosFocus as integer = instr(UCASE(Param), "/FOCUS") ' Fenetre focus
			Dim PosNonFocus as integer = instr(UCASE(Param), "/NONFOCUS") ' Fenetres non focus
			Dim PosNoFocus as integer = instr(UCASE(Param), "/NOFOCUS") ' Fenetres non focus
			Dim PosImage as integer = instr(UCASE(Param), "/IMAGE") ' Wallpaper
			Dim PosTOUT as integer = instr(UCASE(Param), "/TOUT") ' TOUT
			Dim PosALL as integer = instr(UCASE(Param), "/ALL") ' TOUT

			if PosFenetre > 0 OR PosWindow > 0 Then
				if PosFocus > 0 Then ' Actualiser uniquement la fenetre focus
					' Recuperer l'index de la fenetre focus actuel
					Numero_INDEX = CPCDOS_INSTANCE.SCI_INSTANCE.Fenetre_FOCUS(0)
					TypeObjet = CPCDOS_INSTANCE.SCI_INSTANCE.GUI_TYPE.Fenetre

				elseif PosNonFocus > 0 OR PosNoFocus Then
					' Actualiser tout sauf celui focus
					Numero_INDEX =  CPCDOS_INSTANCE.SCI_INSTANCE.Fenetre_FOCUS(0)
					TypeObjet = CPCDOS_INSTANCE.SCI_INSTANCE.GUI_TYPE.TOUT

				Else
					' Actualiser toutes les fenetres

					Numero_INDEX = 99999
					TypeObjet = CPCDOS_INSTANCE.SCI_INSTANCE.GUI_TYPE.Fenetre
				End if
			ElseIF PosImage > 0 Then
				' Actualiser l'arriere plan

				Numero_INDEX = 99999
				TypeObjet = CPCDOS_INSTANCE.SCI_INSTANCE.GUI_TYPE.Wallpaper

			ElseIF PosTOUT > 0 OR PosALL > 0 Then
				' Actualiser absolument Tout

				Numero_INDEX = 99999
				TypeObjet = CPCDOS_INSTANCE.SCI_INSTANCE.GUI_TYPE.TOUT

			' ===== Numero Handle =====
			ElseIF PosNumHandle > 0 Then ' Numero de handle
				IF Instr(Ucase(Param), "0X") > 0 Then
					' Nombre hexadecimal
					Numero_Handle = Val("&h" & MID(Param, PosNumHandle + 8))
				else
					' Nombre decimal
					Numero_Handle = Val(MID(Param, PosNumHandle + 8))
				End if
			End if

			If Numero_Handle > 0 Then
				' Supprimer l'objet correspondant au handle

				TypeObjet = 0

				' Chercher les fenetres
				For boucle as integer = 1 to CPCDOS_INSTANCE._MAX_GUI_FENETRE
					if CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__FENETRE(boucle).Identification_Objet.Handle = Numero_Handle Then

						' Indiquer que c'est une fenetre qu'on veut supprimer
						TypeObjet = CPCDOS_INSTANCE.SCI_INSTANCE.GUI_TYPE.Fenetre

						' Et son numero d'index
						Numero_INDEX = boucle

						exit for
					End if
				Next boucle


				if TypeObjet = 0 Then

					' Chercher les boutons
					For boucle as integer = 1 to CPCDOS_INSTANCE._MAX_GUI_BOUTON
						if CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__BOUTON(boucle).Identification_Objet.Handle = Numero_Handle Then

							' Indiquer que c'est une fenetre qu'on veut supprimer
							TypeObjet = CPCDOS_INSTANCE.SCI_INSTANCE.GUI_TYPE.Bouton

							' Et son numero d'index
							Numero_INDEX = boucle

							exit for
						End if
					Next boucle

				End if


				if TypeObjet = 0 Then
					' Chercher les picturebox
					For boucle as integer = 1 to CPCDOS_INSTANCE._MAX_GUI_PICTUREBOX
						if CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__PICTUREBOX(boucle).Identification_Objet.Handle = Numero_Handle Then

							' Indiquer que c'est une fenetre qu'on veut supprimer
							TypeObjet = CPCDOS_INSTANCE.SCI_INSTANCE.GUI_TYPE.PICTUREBOX

							' Et son numero d'index
							Numero_INDEX = boucle

							exit for
						End if
					Next boucle

				End if


				if TypeObjet = 0 Then
					' Chercher les textbloc
					For boucle as integer = 1 to CPCDOS_INSTANCE._MAX_GUI_TEXTBLOCK
						if CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__TEXTBLOCK(boucle).Identification_Objet.Handle = Numero_Handle Then

							' Indiquer que c'est une fenetre qu'on veut supprimer
							TypeObjet = CPCDOS_INSTANCE.SCI_INSTANCE.GUI_TYPE.TEXTBLOCK

							' Et son numero d'index
							Numero_INDEX = boucle

							exit for
						End if
					Next boucle

				End if


				if TypeObjet = 0 Then
					' Chercher les TextBox
					For boucle as integer = 1 to CPCDOS_INSTANCE._MAX_GUI_TEXTBOX
						if CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__TEXTBOX(boucle).Identification_Objet.Handle = Numero_Handle Then

							' Indiquer que c'est une fenetre qu'on veut supprimer
							TypeObjet = CPCDOS_INSTANCE.SCI_INSTANCE.GUI_TYPE.TEXTBOX

							' Et son numero d'index
							Numero_INDEX = boucle

							exit for
						End if
					Next boucle
				End if


				if TypeObjet = 0 Then
					' Chercher les checkbox
					For boucle as integer = 1 to CPCDOS_INSTANCE._MAX_GUI_CHECKBOX
						if CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__CHECKBOX(boucle).Identification_Objet.Handle = Numero_Handle Then

							' Indiquer que c'est une fenetre qu'on veut supprimer
							TypeObjet = CPCDOS_INSTANCE.SCI_INSTANCE.GUI_TYPE.CHECKBOX

							' Et son numero d'index
							Numero_INDEX = boucle

							exit for
						End if
					Next boucle
				End if


				if TypeObjet = 0 Then
					' Chercher les Progressbar
					For boucle as integer = 1 to CPCDOS_INSTANCE._MAX_GUI_PROGRESSBAR
						if CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__PROGRESSBAR(boucle).Identification_Objet.Handle = Numero_Handle Then

							' Indiquer que c'est une fenetre qu'on veut supprimer
							TypeObjet = CPCDOS_INSTANCE.SCI_INSTANCE.GUI_TYPE.PROGRESSBAR

							' Et son numero d'index
							Numero_INDEX = boucle

							exit for
						End if
					Next boucle
				End if


			Else
				IF NOT Param = "" Then

					TypeObjet = 0
					' Si les parametres ont quelque chose on cherche par le nom

					' Nettoyer
					Param = Ucase(RTRIM(RTRIM(LTRIM(LTRIM(Param, chr(09))), chr(09))))

					' Chercher les fenetres
					For boucle as integer = 1 to CPCDOS_INSTANCE._MAX_GUI_FENETRE
						if CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__FENETRE(boucle).Identification_Objet.Nom = Param Then

							' Indiquer que c'est une fenetre qu'on veut supprimer
							TypeObjet = CPCDOS_INSTANCE.SCI_INSTANCE.GUI_TYPE.Fenetre

							' Et son numero d'index
							Numero_INDEX = boucle

							exit for
						End if
					Next boucle



					if TypeObjet = 0 Then
						' Chercher les boutons
						For boucle as integer = 1 to CPCDOS_INSTANCE._MAX_GUI_BOUTON
							if CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__BOUTON(boucle).Identification_Objet.Nom = Param Then

								' Indiquer que c'est une fenetre qu'on veut supprimer
								TypeObjet = CPCDOS_INSTANCE.SCI_INSTANCE.GUI_TYPE.Bouton

								' Et son numero d'index
								Numero_INDEX = boucle

								exit for
							End if
						Next boucle
					End if


					if TypeObjet = 0 Then
						' Chercher les picturebox
						For boucle as integer = 1 to CPCDOS_INSTANCE._MAX_GUI_PICTUREBOX
							if CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__PICTUREBOX(boucle).Identification_Objet.Nom = Param Then

								' Indiquer que c'est une fenetre qu'on veut supprimer
								TypeObjet = CPCDOS_INSTANCE.SCI_INSTANCE.GUI_TYPE.PICTUREBOX

								' Et son numero d'index
								Numero_INDEX = boucle

								exit for
							End if
						Next boucle
					End if


					if TypeObjet = 0 Then
						' Chercher les textbloc
						For boucle as integer = 1 to CPCDOS_INSTANCE._MAX_GUI_TEXTBLOCK
							if CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__TEXTBLOCK(boucle).Identification_Objet.Nom = Param Then

								' Indiquer que c'est une fenetre qu'on veut supprimer
								TypeObjet = CPCDOS_INSTANCE.SCI_INSTANCE.GUI_TYPE.TEXTBLOCK

								' Et son numero d'index
								Numero_INDEX = boucle

								exit for
							End if
						Next boucle
					End if


					if TypeObjet = 0 Then
						' Chercher les TextBox
						For boucle as integer = 1 to CPCDOS_INSTANCE._MAX_GUI_TEXTBOX
							if CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__TEXTBOX(boucle).Identification_Objet.Nom = Param Then

								' Indiquer que c'est une fenetre qu'on veut supprimer
								TypeObjet = CPCDOS_INSTANCE.SCI_INSTANCE.GUI_TYPE.TEXTBOX

								' Et son numero d'index
								Numero_INDEX = boucle

								exit for
							End if
						Next boucle
					End if


					if TypeObjet = 0 Then
						' Chercher les checkbox
						For boucle as integer = 1 to CPCDOS_INSTANCE._MAX_GUI_CHECKBOX
							if CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__CHECKBOX(boucle).Identification_Objet.Nom = Param Then

								' Indiquer que c'est une fenetre qu'on veut supprimer
								TypeObjet = CPCDOS_INSTANCE.SCI_INSTANCE.GUI_TYPE.CHECKBOX

								' Et son numero d'index
								Numero_INDEX = boucle

								exit for
							End if
						Next boucle
					End if


					if TypeObjet = 0 Then
						' Chercher les Progressbar
						For boucle as integer = 1 to CPCDOS_INSTANCE._MAX_GUI_PROGRESSBAR
							if CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__PROGRESSBAR(boucle).Identification_Objet.Nom = Param Then

								' Indiquer que c'est une fenetre qu'on veut supprimer
								TypeObjet = CPCDOS_INSTANCE.SCI_INSTANCE.GUI_TYPE.PROGRESSBAR

								' Et son numero d'index
								Numero_INDEX = boucle

								exit for
							End if
						Next boucle
					End if
				Else

					' L'utilisateur n'a rien indique
					Message_erreur = ERRAVT("AVT_078", 0)
					IF CPCDOS_INSTANCE.Utilisateur_Langage = 0 Then
						DEBUG("[CpcdosC+] AVT_078 : " & Message_erreur & ". Veuillez indiquer un nom ou un parametre.", Affichage, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_AVERTISSEMENT, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.AvecDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_CPCDOS, RetourVAR)
					Else
						DEBUG("[CpcdosC+] AVT_078 : " & Message_erreur & ". Please put name or parameter.", Affichage, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_AVERTISSEMENT, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.AvecDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_CPCDOS, RetourVAR)
					End if
					exit _scope_CMD, _scope
				End if
			End if

			' Si on a trouve quelque chose
			if Numero_INDEX > 0 Then
				IF CPCDOS_INSTANCE.SCI_INSTANCE.GUI_Mode = TRUE Then
					If TypeObjet = CPCDOS_INSTANCE.SCI_INSTANCE.GUI_TYPE.TOUT Then
						' Si l'interface graphique est executee

						IF Numero_INDEX = 99999 Then
							' Actualiser absolument TOUT !
							CPCDOS_INSTANCE.SCI_INSTANCE.ActualiserGUI(0, 0)

						Else
							' Actualiser TOUT SAUF UNE fenetre
							CPCDOS_INSTANCE.SCI_INSTANCE.ActualiserGUI(2, Numero_INDEX)
						End if

					ElseIf TypeObjet = CPCDOS_INSTANCE.SCI_INSTANCE.GUI_TYPE.WALLPAPER Then
						' Actualiser l'arriere plan
						CPCDOS_INSTANCE.SCI_INSTANCE.ActualiserGUI(3, 0)

					ElseIf TypeObjet = CPCDOS_INSTANCE.SCI_INSTANCE.GUI_TYPE.Fenetre Then
						' Si l'interface graphique est executee
						IF CPCDOS_INSTANCE.SCI_INSTANCE.GUI_Mode = TRUE Then


							IF Numero_INDEX = 99999 Then
								' Actualiser TOUTES les fenetres

								IF CPCDOS_INSTANCE.SYSTEME_INSTANCE.get_DBG_DEBUG() > 0 Then
									IF CPCDOS_INSTANCE.Utilisateur_Langage = 0 Then
										DEBUG("[CpcdosC+] Actualisation graphique de toutes les fenetres ...", Affichage, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_ACTION, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.AvecDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_AFF, RetourVAR)
									Else
										DEBUG("[CpcdosC+] Refreshing all graphic window ...'", Affichage, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_ACTION, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.AvecDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_AFF, RetourVAR)
									End if
								End if

								CPCDOS_INSTANCE.SCI_INSTANCE.ActualiserGUI(0, Numero_INDEX)
							Else


								IF CPCDOS_INSTANCE.SYSTEME_INSTANCE.get_DBG_DEBUG() > 0 Then
									IF CPCDOS_INSTANCE.Utilisateur_Langage = 0 Then
										DEBUG("[CpcdosC+] Actualisation graphique de la fenetre '" & CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__FENETRE(Numero_INDEX).Identification_Objet.Nom & "' [OSID:" & CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__FENETRE(Numero_INDEX).Identification_Objet.OS_id & " PID:" & CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__FENETRE(Numero_INDEX).Identification_Objet.PID_PARENT & " '" & CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__FENETRE(Numero_INDEX).Identification_Objet.Proc_PARENT & "' TID:" & CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__FENETRE(Numero_INDEX).Identification_Objet.TID_PARENT & " '" & CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__FENETRE(Numero_INDEX).Identification_Objet.Thread_PARENT & " HANDLE:" & CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__FENETRE(Numero_INDEX).Identification_Objet.Handle & " INDEX:" & Numero_INDEX & "]", Affichage, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_ACTION, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.AvecDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_AFF, RetourVAR)
									Else
										DEBUG("[CpcdosC+] Refreshing window graphic '" & CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__FENETRE(Numero_INDEX).Identification_Objet.Nom & "' [OSID:" & CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__FENETRE(Numero_INDEX).Identification_Objet.OS_id & " PID:" & CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__FENETRE(Numero_INDEX).Identification_Objet.PID_PARENT & " '" & CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__FENETRE(Numero_INDEX).Identification_Objet.Proc_PARENT & "' TID:" & CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__FENETRE(Numero_INDEX).Identification_Objet.TID_PARENT & " '" & CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__FENETRE(Numero_INDEX).Identification_Objet.Thread_PARENT & " HANDLE:" & CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__FENETRE(Numero_INDEX).Identification_Objet.Handle & " INDEX:" & Numero_INDEX & "]", Affichage, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_ACTION, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.AvecDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_AFF, RetourVAR)
									End if
								End if

								' Actualiser une fenetre
								CPCDOS_INSTANCE.SCI_INSTANCE.ActualiserGUI(0, Numero_INDEX)
							End if
						End if

					ElseIf TypeObjet = CPCDOS_INSTANCE.SCI_INSTANCE.GUI_TYPE.Bouton Then
						IF CPCDOS_INSTANCE.SYSTEME_INSTANCE.get_DBG_DEBUG() > 0 Then
							IF CPCDOS_INSTANCE.Utilisateur_Langage = 0 Then
								DEBUG("[CpcdosC+] Actualisation graphique du bouton '" & CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__BOUTON(Numero_INDEX).Identification_Objet.Nom & "' [OSID:" & CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__BOUTON(Numero_INDEX).Identification_Objet.OS_id & " PID:" & CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__BOUTON(Numero_INDEX).Identification_Objet.PID_PARENT & " '" & CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__BOUTON(Numero_INDEX).Identification_Objet.Proc_PARENT & "' TID:" & CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__BOUTON(Numero_INDEX).Identification_Objet.TID_PARENT & " '" & CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__BOUTON(Numero_INDEX).Identification_Objet.Thread_PARENT & " HANDLE:" & CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__BOUTON(Numero_INDEX).Identification_Objet.Handle & " INDEX:" & Numero_INDEX & "]", Affichage, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_ACTION, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.AvecDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_AFF, RetourVAR)
							Else
								DEBUG("[CpcdosC+] Refreshing button graphic '" & CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__BOUTON(Numero_INDEX).Identification_Objet.Nom & "' [OSID:" & CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__BOUTON(Numero_INDEX).Identification_Objet.OS_id & " PID:" & CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__BOUTON(Numero_INDEX).Identification_Objet.PID_PARENT & " '" & CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__BOUTON(Numero_INDEX).Identification_Objet.Proc_PARENT & "' TID:" & CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__BOUTON(Numero_INDEX).Identification_Objet.TID_PARENT & " '" & CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__BOUTON(Numero_INDEX).Identification_Objet.Thread_PARENT & " HANDLE:" & CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__BOUTON(Numero_INDEX).Identification_Objet.Handle & " INDEX:" & Numero_INDEX & "]", Affichage, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_ACTION, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.AvecDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_AFF, RetourVAR)
							End if
						End if

						' Actualiser l'objet avec son index et la fenetre dont le numero d'index est dans ses proprietes
						CPCDOS_INSTANCE.SCI_INSTANCE.Creer_Bouton(CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI, Numero_INDEX, CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__BOUTON(Numero_INDEX).Identification_Objet.Index_FNT_PARENT)

					ElseIf TypeObjet = CPCDOS_INSTANCE.SCI_INSTANCE.GUI_TYPE.PictureBox Then
						IF CPCDOS_INSTANCE.SYSTEME_INSTANCE.get_DBG_DEBUG() > 0 Then
							IF CPCDOS_INSTANCE.Utilisateur_Langage = 0 Then
								DEBUG("[CpcdosC+] Actualisation graphique de l'imagebox '" & CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__PICTUREBOX(Numero_INDEX).Identification_Objet.Nom & "' [OSID:" & CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__PICTUREBOX(Numero_INDEX).Identification_Objet.OS_id & " PID:" & CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__PICTUREBOX(Numero_INDEX).Identification_Objet.PID_PARENT & " '" & CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__PICTUREBOX(Numero_INDEX).Identification_Objet.Proc_PARENT & "' TID:" & CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__PICTUREBOX(Numero_INDEX).Identification_Objet.TID_PARENT & " '" & CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__PICTUREBOX(Numero_INDEX).Identification_Objet.Thread_PARENT & " HANDLE:" & CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__PICTUREBOX(Numero_INDEX).Identification_Objet.Handle & " INDEX:" & Numero_INDEX & "]", Affichage, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_ACTION, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.AvecDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_AFF, RetourVAR)
							Else
								DEBUG("[CpcdosC+] Refreshing picturebox graphic '" & CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__PICTUREBOX(Numero_INDEX).Identification_Objet.Nom & "' [OSID:" & CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__PICTUREBOX(Numero_INDEX).Identification_Objet.OS_id & " PID:" & CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__PICTUREBOX(Numero_INDEX).Identification_Objet.PID_PARENT & " '" & CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__PICTUREBOX(Numero_INDEX).Identification_Objet.Proc_PARENT & "' TID:" & CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__PICTUREBOX(Numero_INDEX).Identification_Objet.TID_PARENT & " '" & CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__PICTUREBOX(Numero_INDEX).Identification_Objet.Thread_PARENT & " HANDLE:" & CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__PICTUREBOX(Numero_INDEX).Identification_Objet.Handle & " INDEX:" & Numero_INDEX & "]", Affichage, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_ACTION, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.AvecDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_AFF, RetourVAR)
							End if
						End if

						' Actualiser l'objet avec son index et la fenetre dont le numero d'index est dans ses proprietes
						CPCDOS_INSTANCE.SCI_INSTANCE.Creer_Picturebox(CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI, Numero_INDEX, CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__PICTUREBOX(Numero_INDEX).Identification_Objet.Index_FNT_PARENT)

					ElseIf TypeObjet = CPCDOS_INSTANCE.SCI_INSTANCE.GUI_TYPE.TextBlock Then
						IF CPCDOS_INSTANCE.SYSTEME_INSTANCE.get_DBG_DEBUG() > 0 Then
							IF CPCDOS_INSTANCE.Utilisateur_Langage = 0 Then
								DEBUG("[CpcdosC+] Actualisation graphique du textbloc '" & CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__TEXTBLOCK(Numero_INDEX).Identification_Objet.Nom & "' [OSID:" & CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__TEXTBLOCK(Numero_INDEX).Identification_Objet.OS_id & " PID:" & CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__TEXTBLOCK(Numero_INDEX).Identification_Objet.PID_PARENT & " '" & CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__TEXTBLOCK(Numero_INDEX).Identification_Objet.Proc_PARENT & "' TID:" & CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__TEXTBLOCK(Numero_INDEX).Identification_Objet.TID_PARENT & " '" & CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__TEXTBLOCK(Numero_INDEX).Identification_Objet.Thread_PARENT & " HANDLE:" & CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__TEXTBLOCK(Numero_INDEX).Identification_Objet.Handle & " INDEX:" & Numero_INDEX & "]", Affichage, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_ACTION, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.AvecDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_AFF, RetourVAR)
							Else
								DEBUG("[CpcdosC+] Refreshing textbloc graphic '" & CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__TEXTBLOCK(Numero_INDEX).Identification_Objet.Nom & "' [OSID:" & CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__TEXTBLOCK(Numero_INDEX).Identification_Objet.OS_id & " PID:" & CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__TEXTBLOCK(Numero_INDEX).Identification_Objet.PID_PARENT & " '" & CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__TEXTBLOCK(Numero_INDEX).Identification_Objet.Proc_PARENT & "' TID:" & CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__TEXTBLOCK(Numero_INDEX).Identification_Objet.TID_PARENT & " '" & CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__TEXTBLOCK(Numero_INDEX).Identification_Objet.Thread_PARENT & " HANDLE:" & CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__TEXTBLOCK(Numero_INDEX).Identification_Objet.Handle & " INDEX:" & Numero_INDEX & "]", Affichage, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_ACTION, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.AvecDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_AFF, RetourVAR)
							End if
						End if

						' Actualiser l'objet avec son index et la fenetre dont le numero d'index est dans ses proprietes
						CPCDOS_INSTANCE.SCI_INSTANCE.Creer_TextBlock(CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI, Numero_INDEX, CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__TEXTBLOCK(Numero_INDEX).Identification_Objet.Index_FNT_PARENT)

					ElseIf TypeObjet = CPCDOS_INSTANCE.SCI_INSTANCE.GUI_TYPE.TextBox Then
						IF CPCDOS_INSTANCE.SYSTEME_INSTANCE.get_DBG_DEBUG() > 0 Then
							IF CPCDOS_INSTANCE.Utilisateur_Langage = 0 Then
								DEBUG("[CpcdosC+] Actualisation graphique du textebox '" & CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__TEXTBOX(Numero_INDEX).Identification_Objet.Nom & "' [OSID:" & CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__TEXTBOX(Numero_INDEX).Identification_Objet.OS_id & " PID:" & CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__TEXTBOX(Numero_INDEX).Identification_Objet.PID_PARENT & " '" & CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__TEXTBOX(Numero_INDEX).Identification_Objet.Proc_PARENT & "' TID:" & CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__TEXTBOX(Numero_INDEX).Identification_Objet.TID_PARENT & " '" & CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__TEXTBOX(Numero_INDEX).Identification_Objet.Thread_PARENT & " HANDLE:" & CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__TEXTBOX(Numero_INDEX).Identification_Objet.Handle & " INDEX:" & Numero_INDEX & "]", Affichage, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_ACTION, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.AvecDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_AFF, RetourVAR)
							Else
								DEBUG("[CpcdosC+] Refreshing textbox graphic '" & CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__TEXTBOX(Numero_INDEX).Identification_Objet.Nom & "' [OSID:" & CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__TEXTBOX(Numero_INDEX).Identification_Objet.OS_id & " PID:" & CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__TEXTBOX(Numero_INDEX).Identification_Objet.PID_PARENT & " '" & CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__TEXTBOX(Numero_INDEX).Identification_Objet.Proc_PARENT & "' TID:" & CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__TEXTBOX(Numero_INDEX).Identification_Objet.TID_PARENT & " '" & CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__TEXTBOX(Numero_INDEX).Identification_Objet.Thread_PARENT & " HANDLE:" & CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__TEXTBOX(Numero_INDEX).Identification_Objet.Handle & " INDEX:" & Numero_INDEX & "]", Affichage, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_ACTION, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.AvecDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_AFF, RetourVAR)
							End if
						End if

						' Actualiser l'objet avec son index et la fenetre dont le numero d'index est dans ses proprietes
						CPCDOS_INSTANCE.SCI_INSTANCE.Creer_TextBox(CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI, Numero_INDEX, CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__TEXTBOX(Numero_INDEX).Identification_Objet.Index_FNT_PARENT)

					ElseIf TypeObjet = CPCDOS_INSTANCE.SCI_INSTANCE.GUI_TYPE.ProgressBar Then
						IF CPCDOS_INSTANCE.SYSTEME_INSTANCE.get_DBG_DEBUG() > 0 Then
							IF CPCDOS_INSTANCE.Utilisateur_Langage = 0 Then
								DEBUG("[CpcdosC+] Actualisation graphique de la barre de progression '" & CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__PROGRESSBAR(Numero_INDEX).Identification_Objet.Nom & "' [OSID:" & CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__PROGRESSBAR(Numero_INDEX).Identification_Objet.OS_id & " PID:" & CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__PROGRESSBAR(Numero_INDEX).Identification_Objet.PID_PARENT & " '" & CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__PROGRESSBAR(Numero_INDEX).Identification_Objet.Proc_PARENT & "' TID:" & CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__PROGRESSBAR(Numero_INDEX).Identification_Objet.TID_PARENT & " '" & CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__PROGRESSBAR(Numero_INDEX).Identification_Objet.Thread_PARENT & " HANDLE:" & CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__PROGRESSBAR(Numero_INDEX).Identification_Objet.Handle & " INDEX:" & Numero_INDEX & "]", Affichage, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_ACTION, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.AvecDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_AFF, RetourVAR)
							Else
								DEBUG("[CpcdosC+] Refreshing progressbar graphic '" & CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__PROGRESSBAR(Numero_INDEX).Identification_Objet.Nom & "' [OSID:" & CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__PROGRESSBAR(Numero_INDEX).Identification_Objet.OS_id & " PID:" & CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__PROGRESSBAR(Numero_INDEX).Identification_Objet.PID_PARENT & " '" & CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__PROGRESSBAR(Numero_INDEX).Identification_Objet.Proc_PARENT & "' TID:" & CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__PROGRESSBAR(Numero_INDEX).Identification_Objet.TID_PARENT & " '" & CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__PROGRESSBAR(Numero_INDEX).Identification_Objet.Thread_PARENT & " HANDLE:" & CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__PROGRESSBAR(Numero_INDEX).Identification_Objet.Handle & " INDEX:" & Numero_INDEX & "]", Affichage, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_ACTION, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.AvecDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_AFF, RetourVAR)
							End if
						End if

						' Actualiser l'objet avec son index et la fenetre dont le numero d'index est dans ses proprietes
						CPCDOS_INSTANCE.SCI_INSTANCE.Creer_ProgressBar(CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI, Numero_INDEX, CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__PROGRESSBAR(Numero_INDEX).Identification_Objet.Index_FNT_PARENT)

					ElseIf TypeObjet = CPCDOS_INSTANCE.SCI_INSTANCE.GUI_TYPE.CheckBox Then
						IF CPCDOS_INSTANCE.SYSTEME_INSTANCE.get_DBG_DEBUG() > 0 Then
							IF CPCDOS_INSTANCE.Utilisateur_Langage = 0 Then
								DEBUG("[CpcdosC+] Actualisation graphique du checkbox '" & CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__CHECKBOX(Numero_INDEX).Identification_Objet.Nom & "' [OSID:" & CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__CHECKBOX(Numero_INDEX).Identification_Objet.OS_id & " PID:" & CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__CHECKBOX(Numero_INDEX).Identification_Objet.PID_PARENT & " '" & CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__CHECKBOX(Numero_INDEX).Identification_Objet.Proc_PARENT & "' TID:" & CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__CHECKBOX(Numero_INDEX).Identification_Objet.TID_PARENT & " '" & CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__CHECKBOX(Numero_INDEX).Identification_Objet.Thread_PARENT & " HANDLE:" & CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__CHECKBOX(Numero_INDEX).Identification_Objet.Handle & " INDEX:" & Numero_INDEX & "]", Affichage, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_ACTION, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.AvecDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_AFF, RetourVAR)
							Else
								DEBUG("[CpcdosC+] Refreshing checkbox graphic '" & CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__CHECKBOX(Numero_INDEX).Identification_Objet.Nom & "' [OSID:" & CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__CHECKBOX(Numero_INDEX).Identification_Objet.OS_id & " PID:" & CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__CHECKBOX(Numero_INDEX).Identification_Objet.PID_PARENT & " '" & CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__CHECKBOX(Numero_INDEX).Identification_Objet.Proc_PARENT & "' TID:" & CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__CHECKBOX(Numero_INDEX).Identification_Objet.TID_PARENT & " '" & CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__CHECKBOX(Numero_INDEX).Identification_Objet.Thread_PARENT & " HANDLE:" & CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__CHECKBOX(Numero_INDEX).Identification_Objet.Handle & " INDEX:" & Numero_INDEX & "]", Affichage, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_ACTION, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.AvecDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_AFF, RetourVAR)
							End if
						End if

						' Actualiser l'objet avec son index et la fenetre dont le numero d'index est dans ses proprietes
						CPCDOS_INSTANCE.SCI_INSTANCE.Creer_CheckBox(CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI, Numero_INDEX, CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__CHECKBOX(Numero_INDEX).Identification_Objet.Index_FNT_PARENT)
					End if
				End if
			Else
				' Si on n'a pas trouve quelque chose
				Message_erreur = ERRAVT("AVT_077", 0)
				IF CPCDOS_INSTANCE.Utilisateur_Langage = 0 Then
					DEBUG("[CpcdosC+] AVT_077 : " & Message_erreur & ".", Affichage, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_AVERTISSEMENT, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.AvecDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_CPCDOS, RetourVAR)
				Else
					DEBUG("[CpcdosC+] AVT_077 : " & Message_erreur & ". ", Affichage, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_AVERTISSEMENT, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.AvecDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_CPCDOS, RetourVAR)
				End if
			End if

			' ===================================================================
			END SCOPE

			exit _scope_CMD, _scope
		End if ' **** Actualiser/ ****

	_end_scope_CMD

	_scope_CMD
		' ===============================================================
		'  Commande de decompression
		' ===============================================================
		CommLANG(1) = "decompresser/"
		CommLANG(2) = "decompress/"
		CommLANG(3) = "\\#//"
		CommTrouve = 0 : NoCMD = 0
		for boucle as integer = 1 to 2
			IF OnCherche = CommLANG(boucle) Then
				NoCMD = 0
				exit for
			Else
				NoCMD = 1
			End if
		Next boucle
		IF NoCMD = 1 then CommLANG(1) = "[F.#).|" : CommLANG(2) = "[F.#).|" : CommLANG(3) = "\\#//"
		rem Afficher la liste des commandes avec anglais / francais
		IF AfficherAide = 1 then
			IF CPCDOS_INSTANCE.Utilisateur_Langage = 0 then
				CommandesAide = CommandesAide & CRLF & " decompresser/              Decompresser un fichierZIP"
			Else
				CommandesAide = CommandesAide & CRLF & " decompress/                Decompress an ZIP file"
			END IF
		END IF
		IF CommLANG(1) = OnCherche Then CommTrouve = 1
		IF CommLANG(2) = OnCherche Then CommTrouve = 2
		IF CommTrouve > 0 Then ' Afficher l'aide de la commande
			IF AfficherAide = 2 then
				Mess_Aide = ""
				IF CPCDOS_INSTANCE.Utilisateur_Langage = 0 THEN
					Mess_Aide = Mess_Aide & CRLF & "  'decompresser'"
					Mess_Aide = Mess_Aide & CRLF
					Mess_Aide = Mess_Aide & CRLF & "  Fonctionnalit�e :"
					Mess_Aide = Mess_Aide & CRLF & "   Cette commande permet de decompresser un fichier ZIP, GZ .."
					Mess_Aide = Mess_Aide & CRLF
					Mess_Aide = Mess_Aide & CRLF & "  Exemple :"
					Mess_Aide = Mess_Aide & CRLF & "   decompresser/ MonFichier.zip  (Par defaut dans le dossier TEMP)"
					Mess_Aide = Mess_Aide & CRLF & "   decompresser/ MonFichier.zip MonDossier"
					Mess_Aide = Mess_Aide & CRLF & "   decompresser/ dossier/MonFichier.zip MonDossier/temp"
					Mess_Aide = Mess_Aide & CRLF
					Mess_Aide = Mess_Aide & CRLF & " A savoir que cpcdos supporte les deux formats '\' ou '/'"
					Mess_Aide = Mess_Aide & CRLF
					Mess_Aide = Mess_Aide & CRLF & "  Voir aussi : supprimer/ , deplacer/ , ouvrir/"
					Mess_Aide = Mess_Aide & CRLF
				ELSEIF CPCDOS_INSTANCE.Utilisateur_Langage = 1 THEN
					Mess_Aide = Mess_Aide & CRLF & "  'Decompress'"
					Mess_Aide = Mess_Aide & CRLF
					Mess_Aide = Mess_Aide & CRLF & "  Fonctionnality :"
					Mess_Aide = Mess_Aide & CRLF & "   This command allow to decompress ZIP, gz ... files"
					Mess_Aide = Mess_Aide & CRLF
					Mess_Aide = Mess_Aide & CRLF & "  Example :"
					Mess_Aide = Mess_Aide & CRLF & "   decompress/ MyFile.zip   (By default in the TEMP folder)"
					Mess_Aide = Mess_Aide & CRLF & "   decompress/ MyFile.zip MyFolder"
					Mess_Aide = Mess_Aide & CRLF & "   decompress/ MyFolder/MyFile.zip MyFolder/temp"
					Mess_Aide = Mess_Aide & CRLF
					Mess_Aide = Mess_Aide & CRLF & " Good to know that cpcdos can support path formats '\' or '/'"
					Mess_Aide = Mess_Aide & CRLF
					Mess_Aide = Mess_Aide & CRLF & "  See also : delete/ , move/ , open/"
					Mess_Aide = Mess_Aide & CRLF
				END IF

				DEBUG(Mess_Aide, Affichage, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_SURBRILLE, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.SansDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_AFF, RetourVAR)
				testCMD = 0
				AfficherAide = 0
				exit _scope_CMD, _scope
			END IF
			' Tester la syntaxe
			testCMD	= CCP_Verifier_Syntaxe(Commande, CommPosition)
			IF testCMD > 10 Then exit _scope_CMD, _scope
			IF testCMD > 0 then  ' Entre 1-5 = Pas d'affichage via le @, @$ ou @#
				IF testCMD < 6 then
					Affichage = 0
					IF testCMD = 3 Then CpcdosCP_SHELL("FIX/ " & CPCDOS_INSTANCE.DEBUG_INSTANCE.LeRetour & " = \#NULL", _CLE_, NIVEAU_CCP, Param_1, Param_2) : RetourVAR = _CLE_ & "N" & NIVEAU_CCP & "->" & CPCDOS_INSTANCE.DEBUG_INSTANCE.LeRetour
					if testCMD = 2 Then RetourVAR = "$>" & CPCDOS_INSTANCE.DEBUG_INSTANCE.LeRetour ' ajouter une securite ?
				Else
					Affichage = 1
				END IF
			Else
				Affichage = 1
			END IF
			' Recuperer les Parametres
			Param = MID(Commande, CommPosition + TailleComm + 2)

			SCOPE
			' ====================================================================
			Dim Resultat as integer


			Dim Source 		as String
			Dim Destination as String



			Param = Rtrim(Param)


			IF INSTR(Param, ", ") > 0 Then
				Source 		= Rtrim(Rtrim(Ltrim(Ltrim(Mid(Param, 1, Instr(Param, ", ") - 1)), CHR(09))), CHR(09))
				Destination	= Rtrim(Rtrim(Ltrim(Ltrim(Mid(Param, Instr(Param, ", ") + 2)), CHR(09))), CHR(09))
			else
				IF INSTR(Param, " ") > 0 Then
					Source 		= Rtrim(Rtrim(Ltrim(Ltrim(Mid(Param, 1, Instr(Param, " ") - 1)), CHR(09))), CHR(09))
					Destination	= Rtrim(Rtrim(Ltrim(Ltrim(Mid(Param, Instr(Param, " ") + 1)), CHR(09))), CHR(09))
				else
					Source 		= Rtrim(Rtrim(Ltrim(Ltrim(Param)), CHR(09)), CHR(09))
					Destination = "temp"
				End if
			End if


			IF CPCDOS_INSTANCE.SYSTEME_INSTANCE.get_DBG_DEBUG() > 0 Then
				IF CPCDOS_INSTANCE.Utilisateur_Langage = 0 Then
					DEBUG("[CpcdosC+] Decompression du fichier '" & Source & "' a '" & Destination & "' ...", Affichage, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_Normal, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.AvecDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_CPCDOS, RetourVAR)
				Else
					DEBUG("[CpcdosC+] File uncompressing '" & Source & "' to '" & Destination & "' ...", Affichage, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_Normal, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.AvecDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_CPCDOS, RetourVAR)
				End if
			END IF


			Resultat = CPCDOS_INSTANCE.Fichier_decompress(Source, Destination) ' Utilisation Temporaire du CRT0 FreeBasic --> DOS

			If Resultat < 1 Then
				' ERREUR
				DEBUG("0", Affichage, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_ERREUR, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.SansDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_AFF, RetourVAR)

				Dim Message_erreur as String = ERRAVT("ERR_062", 0)
				IF CPCDOS_INSTANCE.Utilisateur_Langage = 0 Then
					DEBUG("[CpcdosC+] " & Message_erreur & ". '" & Param & "'", Affichage, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_ERREUR, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.AvecDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_CPCDOS, RetourVAR)
				Else
					DEBUG("[CpcdosC+] " & Message_erreur & ". '" & Param & "'", Affichage, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_ERREUR, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.AvecDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_CPCDOS, RetourVAR)
				End if
			Else
				' OK
				DEBUG("OK", Affichage, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_OK, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.SansDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_AFF, RetourVAR)

				IF CPCDOS_INSTANCE.Utilisateur_Langage = 0 Then
					DEBUG("[CpcdosC+] Fichier '" & Param & "' a ete decompresse!", Affichage, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_OK, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.AvecDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_CPCDOS, RetourVAR)
				Else
					DEBUG("[CpcdosC+] The file '" & Param & "' has been uncompressed!", Affichage, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_OK, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.AvecDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_CPCDOS, RetourVAR)
				End if
			End if

			' ====================================================================
			END SCOPE

			exit _scope_CMD, _scope
		End if ' **** UNCOMPRESS/ ****

	_end_scope_CMD


	' =======================================================================================
	'  	*******************                  Propriete GUI             ********************
	' =======================================================================================

	_scope_CMD

		CommLANG(1) = ".titre"
		CommLANG(2) = ".title"
		CommLANG(3) = "\\#//"
		CommTrouve = 0 : NoCMD = 0
		for boucle as integer = 1 to 2
			IF OnCherche = CommLANG(boucle) Then
				NoCMD = 0
				exit for
			Else
				NoCMD = 1
			End if
		Next boucle
		IF NoCMD = 1 then CommLANG(1) = "[F.#).|" : CommLANG(2) = "[F.#).|" : CommLANG(3) = "\\#//"
		rem Afficher la liste des commandes avec anglais / francais
		IF AfficherAide = 1 then
			IF CPCDOS_INSTANCE.Utilisateur_Langage = 0 then
				CommandesAide = CommandesAide & CRLF & "  IUG -> Titre              Donner un titre a une fenetre"
			Else
				CommandesAide = CommandesAide & CRLF & "  GUI -> Title              Put title on Window"
			END IF
		END IF
		IF CommLANG(1) = OnCherche Then CommTrouve = 1
		IF CommLANG(2) = OnCherche Then CommTrouve = 2
		IF CommTrouve > 0 Then ' Afficher l'aide de la commande
			IF AfficherAide = 2 then
				Mess_Aide = ""
				IF CPCDOS_INSTANCE.Utilisateur_Langage = 0 THEN
					Mess_Aide = Mess_Aide & CRLF & "  '.Titre'"
					Mess_Aide = Mess_Aide & CRLF
					Mess_Aide = Mess_Aide & CRLF & "  Fonctionnalit�e :"
					Mess_Aide = Mess_Aide & CRLF & "   Cette commande utilisable uniquement pendant l'incription d'une propriete"
					Mess_Aide = Mess_Aide & CRLF & "    graphique t-elle qu'une fenetre, permet de nommer la barre de titre de la fenetre"
					Mess_Aide = Mess_Aide & CRLF & ""
					Mess_Aide = Mess_Aide & CRLF & "  Exemple :"
					Mess_Aide = Mess_Aide & CRLF & "   -> Voir la commande 'fenetre/'"
					Mess_Aide = Mess_Aide & CRLF
					Mess_Aide = Mess_Aide & CRLF & "  Voir aussi : picturebox/ , textebox/ , textebloc/"
					Mess_Aide = Mess_Aide & CRLF
				ELSEIF CPCDOS_INSTANCE.Utilisateur_Langage = 1 THEN
					Mess_Aide = Mess_Aide & CRLF & "  '.Title'"
					Mess_Aide = Mess_Aide & CRLF
					Mess_Aide = Mess_Aide & CRLF & "  Fonctionnality :"
					Mess_Aide = Mess_Aide & CRLF & "   This command usable only during registering graphic properties, as window"
					Mess_Aide = Mess_Aide & CRLF & "    allow to name title bar of window"
					Mess_Aide = Mess_Aide & CRLF
					Mess_Aide = Mess_Aide & CRLF & "  Exemple :"
					Mess_Aide = Mess_Aide & CRLF & "   -> Seeing 'window/' command"
					Mess_Aide = Mess_Aide & CRLF
					Mess_Aide = Mess_Aide & CRLF & "  See also : picturebox/ , textbox/ , textbloc/"
					Mess_Aide = Mess_Aide & CRLF
				END IF

				DEBUG(Mess_Aide, Affichage, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_SURBRILLE, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.SansDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_AFF, RetourVAR)
				testCMD = 0
				AfficherAide = 0
				exit _scope_CMD, _scope
			END IF
			' Tester la syntaxe
			testCMD	= CCP_Verifier_Syntaxe(Commande, CommPosition)
			IF testCMD > 10 Then exit _scope_CMD, _scope
			IF testCMD > 0 then  ' Entre 1-5 = Pas d'affichage via le @, @$ ou @#
				IF testCMD < 6 then
					Affichage = 0
					IF testCMD = 3 Then CpcdosCP_SHELL("FIX/ " & CPCDOS_INSTANCE.DEBUG_INSTANCE.LeRetour & " = \#NULL", _CLE_, NIVEAU_CCP, Param_1, Param_2) : RetourVAR = _CLE_ & "N" & NIVEAU_CCP & "->" & CPCDOS_INSTANCE.DEBUG_INSTANCE.LeRetour
					if testCMD = 2 Then RetourVAR = "$>" & CPCDOS_INSTANCE.DEBUG_INSTANCE.LeRetour ' ajouter une securite ?
				Else
					Affichage = 1
				END IF
			Else
				Affichage = 1
			END IF
			' Recuperer les Parametres
			Param = MID(Commande, CommPosition + TailleComm + 2)
			SCOPE
			' ====================================================================

			' Retourner le contenu des quotes des proprietes graphiques
			Dim Retour_quotes as String = get_DonneesQuotesPROP_GUI(Param)
				if NOT Instr(Param, CHR(34)) > 0 Then Retour_quotes = "#@#RETOUR-VAL#" & CPCDOS_INSTANCE.DEBUG_INSTANCE.LeRetour

			' Verifier qu'il n'y a pas eu d'erreurs
			IF NOT Retour_quotes = "-1~#ERR" Then
				CpcdosCP_SHELL = "IUG:PROP_TITRE=" & Retour_quotes
			else
				Message_erreur = ERRAVT("AVT_065", 0)
				IF CPCDOS_INSTANCE.Utilisateur_Langage = 0 Then
					DEBUG("[CpcdosC+] AVT_065 : " & Message_erreur & ". Commande:" & Commande, Affichage, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_AVERTISSEMENT, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.AvecDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_AFF, RetourVAR)
				Else
					DEBUG("[CpcdosC+] AVT_065 : " & Message_erreur & ". Commande:" & Commande, Affichage, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_AVERTISSEMENT, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.AvecDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_AFF, RetourVAR)
				End If
			End if

			' ====================================================================
			END SCOPE

			exit _scope_CMD, _scope
		End if ' **** .TITRE ****

	_end_scope_CMD


	_scope_CMD

		' =======================================================================
		CommLANG(1) = ".nom"
		CommLANG(2) = ".name"
		CommLANG(3) = "\\#//"
		CommTrouve = 0 : NoCMD = 0
		for boucle as integer = 1 to 2
			IF OnCherche = CommLANG(boucle) Then
				NoCMD = 0
				exit for
			Else
				NoCMD = 1
			End if
		Next boucle
		IF NoCMD = 1 then CommLANG(1) = "[F.#).|" : CommLANG(2) = "[F.#).|" : CommLANG(3) = "\\#//"
		rem Afficher la liste des commandes avec anglais / francais
		IF AfficherAide = 1 then
			IF CPCDOS_INSTANCE.Utilisateur_Langage = 0 then
				CommandesAide = CommandesAide & CRLF & "  IUG -> nom                Nom du processus / objet"
			Else
				CommandesAide = CommandesAide & CRLF & "  GUI -> name               Process / Object name"
			END IF
		END IF
		IF CommLANG(1) = OnCherche Then CommTrouve = 1
		IF CommLANG(2) = OnCherche Then CommTrouve = 2
		IF CommTrouve > 0 Then ' Afficher l'aide de la commande
			IF AfficherAide = 2 then
				Mess_Aide = ""
				IF CPCDOS_INSTANCE.Utilisateur_Langage = 0 THEN
					Mess_Aide = Mess_Aide & CRLF & "  '.Nom'"
					Mess_Aide = Mess_Aide & CRLF
					Mess_Aide = Mess_Aide & CRLF & "  Fonctionnalit�e :"
					Mess_Aide = Mess_Aide & CRLF & "   Cette commande utilisable uniquement pendant l'incription d'une propriete"
					Mess_Aide = Mess_Aide & CRLF & "    graphique, permet de nommer le nom du processus si vous creez une fenetre"
					Mess_Aide = Mess_Aide & CRLF & "    ou bien le nom d'instance si c'est un objet"
					Mess_Aide = Mess_Aide & CRLF
					Mess_Aide = Mess_Aide & CRLF & "  Exemple :"
					Mess_Aide = Mess_Aide & CRLF & "   -> Voir la commande 'fenetre/'"
					Mess_Aide = Mess_Aide & CRLF
					Mess_Aide = Mess_Aide & CRLF & "  Voir aussi : picturebox/ , textebox/ , textebloc/"
					Mess_Aide = Mess_Aide & CRLF
				ELSEIF CPCDOS_INSTANCE.Utilisateur_Langage = 1 THEN
					Mess_Aide = Mess_Aide & CRLF & "  '.Title'"
					Mess_Aide = Mess_Aide & CRLF
					Mess_Aide = Mess_Aide & CRLF & "  Fonctionnality :"
					Mess_Aide = Mess_Aide & CRLF & "   This command usable only during registering graphic properties, allow to name"
					Mess_Aide = Mess_Aide & CRLF & "    your process if it's a window, and instance name if it's an object."
					Mess_Aide = Mess_Aide & CRLF
					Mess_Aide = Mess_Aide & CRLF & "  Exemple :"
					Mess_Aide = Mess_Aide & CRLF & "   -> Seeing 'window/' command"
					Mess_Aide = Mess_Aide & CRLF
					Mess_Aide = Mess_Aide & CRLF & "  See also : picturebox/ , textbox/ , textbloc/"
					Mess_Aide = Mess_Aide & CRLF
				END IF

				DEBUG(Mess_Aide, Affichage, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_SURBRILLE, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.SansDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_AFF, RetourVAR)
				testCMD = 0
				AfficherAide = 0
				exit _scope_CMD, _scope
			END IF
			' Tester la syntaxe
			testCMD	= CCP_Verifier_Syntaxe(Commande, CommPosition)
			IF testCMD > 10 Then exit _scope_CMD, _scope
			IF testCMD > 0 then  ' Entre 1-5 = Pas d'affichage via le @, @$ ou @#
				IF testCMD < 6 then
					Affichage = 0
					IF testCMD = 3 Then CpcdosCP_SHELL("FIX/ " & CPCDOS_INSTANCE.DEBUG_INSTANCE.LeRetour & " = \#NULL", _CLE_, NIVEAU_CCP, Param_1, Param_2) : RetourVAR = _CLE_ & "N" & NIVEAU_CCP & "->" & CPCDOS_INSTANCE.DEBUG_INSTANCE.LeRetour
					if testCMD = 2 Then RetourVAR = "$>" & CPCDOS_INSTANCE.DEBUG_INSTANCE.LeRetour ' ajouter une securite ?
				Else
					Affichage = 1
				END IF
			Else
				Affichage = 1
			END IF
			' Recuperer les Parametres
			Param = MID(Commande, CommPosition + TailleComm + 2)
			SCOPE
			' ====================================================================

			' Retourner le contenu des quotes des proprietes graphiques
			Dim Retour_quotes as String = get_DonneesQuotesPROP_GUI(Param)
				if NOT Instr(Param, CHR(34)) > 0 Then Retour_quotes = "#@#RETOUR-VAL#" & CPCDOS_INSTANCE.DEBUG_INSTANCE.LeRetour

			' Verifier qu'il n'y a pas eu d'erreurs
			IF NOT Retour_quotes = "-1~#ERR" Then
				CpcdosCP_SHELL = "IUG:PROP_NOM=" & Retour_quotes
			else
				Message_erreur = ERRAVT("AVT_065", 0)
				IF CPCDOS_INSTANCE.Utilisateur_Langage = 0 Then
					DEBUG("[CpcdosC+] AVT_065 : " & Message_erreur & ". Commande:" & Commande, Affichage, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_AVERTISSEMENT, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.AvecDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_AFF, RetourVAR)
				Else
					DEBUG("[CpcdosC+] AVT_065 : " & Message_erreur & ". Commande:" & Commande, Affichage, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_AVERTISSEMENT, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.AvecDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_AFF, RetourVAR)
				End If
			End if

			' ====================================================================
			END SCOPE

			exit _scope_CMD, _scope
		End if ' **** .NOM ****

	_end_scope_CMD

	_scope_CMD

		' =======================================================================
		CommLANG(1) = ".texte"
		CommLANG(2) = ".text"
		CommLANG(3) = "\\#//"
		CommTrouve = 0 : NoCMD = 0
		for boucle as integer = 1 to 2
			IF OnCherche = CommLANG(boucle) Then
				NoCMD = 0
				exit for
			Else
				NoCMD = 1
			End if
		Next boucle
		IF NoCMD = 1 then CommLANG(1) = "[F.#).|" : CommLANG(2) = "[F.#).|" : CommLANG(3) = "\\#//"
		rem Afficher la liste des commandes avec anglais / francais
		IF AfficherAide = 1 then
			IF CPCDOS_INSTANCE.Utilisateur_Langage = 0 then
				CommandesAide = CommandesAide & CRLF & "  IUG -> texte              Texte graphique de l'objet"
			Else
				CommandesAide = CommandesAide & CRLF & "  GUI -> text               Graphic text object"
			END IF
		END IF
		IF CommLANG(1) = OnCherche Then CommTrouve = 1
		IF CommLANG(2) = OnCherche Then CommTrouve = 2
		IF CommTrouve > 0 Then ' Afficher l'aide de la commande
			IF AfficherAide = 2 then
				Mess_Aide = ""
				IF CPCDOS_INSTANCE.Utilisateur_Langage = 0 THEN
					Mess_Aide = Mess_Aide & CRLF & "  '.Texte'"
					Mess_Aide = Mess_Aide & CRLF
					Mess_Aide = Mess_Aide & CRLF & "  Fonctionnalit�e :"
					Mess_Aide = Mess_Aide & CRLF & "   Cette commande utilisable uniquement pendant l'incription d'une propriete"
					Mess_Aide = Mess_Aide & CRLF & "    graphique, permet d'inclure du texte dans une propriete le supportant."
					Mess_Aide = Mess_Aide & CRLF
					Mess_Aide = Mess_Aide & CRLF & "  Exemple :"
					Mess_Aide = Mess_Aide & CRLF & "   -> Voir la commande 'fenetre/' 'imagebox'"
					Mess_Aide = Mess_Aide & CRLF
					Mess_Aide = Mess_Aide & CRLF & "  Voir aussi : picturebox/ , textebox/ , textebloc/"
					Mess_Aide = Mess_Aide & CRLF
				ELSEIF CPCDOS_INSTANCE.Utilisateur_Langage = 1 THEN
					Mess_Aide = Mess_Aide & CRLF & "  '.Text'"
					Mess_Aide = Mess_Aide & CRLF
					Mess_Aide = Mess_Aide & CRLF & "  Fonctionnality :"
					Mess_Aide = Mess_Aide & CRLF & "   This command usable only during registering graphic properties, allow to include"
					Mess_Aide = Mess_Aide & CRLF & "    text in your graphical object who support this."
					Mess_Aide = Mess_Aide & CRLF
					Mess_Aide = Mess_Aide & CRLF & "  Exemple :"
					Mess_Aide = Mess_Aide & CRLF & "   -> Seeing 'window/' command"
					Mess_Aide = Mess_Aide & CRLF
					Mess_Aide = Mess_Aide & CRLF & "  See also : picturebox/ , textbox/ , textbloc/"
					Mess_Aide = Mess_Aide & CRLF
				END IF

				DEBUG(Mess_Aide, Affichage, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_SURBRILLE, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.SansDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_AFF, RetourVAR)
				testCMD = 0
				AfficherAide = 0
				exit _scope_CMD, _scope
			END IF
			' Tester la syntaxe
			testCMD	= CCP_Verifier_Syntaxe(Commande, CommPosition)
			IF testCMD > 10 Then exit _scope_CMD, _scope
			IF testCMD > 0 then  ' Entre 1-5 = Pas d'affichage via le @, @$ ou @#
				IF testCMD < 6 then
					Affichage = 0
					IF testCMD = 3 Then CpcdosCP_SHELL("FIX/ " & CPCDOS_INSTANCE.DEBUG_INSTANCE.LeRetour & " = \#NULL", _CLE_, NIVEAU_CCP, Param_1, Param_2) : RetourVAR = _CLE_ & "N" & NIVEAU_CCP & "->" & CPCDOS_INSTANCE.DEBUG_INSTANCE.LeRetour
					if testCMD = 2 Then RetourVAR = "$>" & CPCDOS_INSTANCE.DEBUG_INSTANCE.LeRetour ' ajouter une securite ?
				Else
					Affichage = 1
				END IF
			Else
				Affichage = 1
			END IF
			' Recuperer les Parametres
			Param = MID(Commande, CommPosition + TailleComm + 2)
			SCOPE
			' ====================================================================

			' Retourner le contenu des quotes des proprietes graphiques
			Dim Retour_quotes as String = get_DonneesQuotesPROP_GUI(Param)
				if NOT Instr(Param, CHR(34)) > 0 Then Retour_quotes = "#@#RETOUR-VAL#" & CPCDOS_INSTANCE.DEBUG_INSTANCE.LeRetour

			' Verifier qu'il n'y a pas eu d'erreurs
			IF NOT Retour_quotes = "-1~#ERR" Then
				CpcdosCP_SHELL = "IUG:PROP_TEXTE=" & Retour_quotes
			else
				Message_erreur = ERRAVT("AVT_065", 0)
				IF CPCDOS_INSTANCE.Utilisateur_Langage = 0 Then
					DEBUG("[CpcdosC+] AVT_065 : " & Message_erreur & ". Commande:" & Commande, Affichage, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_AVERTISSEMENT, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.AvecDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_AFF, RetourVAR)
				Else
					DEBUG("[CpcdosC+] AVT_065 : " & Message_erreur & ". Commande:" & Commande, Affichage, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_AVERTISSEMENT, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.AvecDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_AFF, RetourVAR)
				End If
			End if

			' ====================================================================
			END SCOPE

			exit _scope_CMD, _scope
		End if ' **** .TEXTE ****

	_end_scope_CMD

	_scope_CMD

		' =======================================================================
		CommLANG(1) = ".pid"
		CommLANG(2) = ".pid"
		CommLANG(3) = "\\#//"
		CommTrouve = 0 : NoCMD = 0
		for boucle as integer = 1 to 2
			IF OnCherche = CommLANG(boucle) Then
				NoCMD = 0
				exit for
			Else
				NoCMD = 1
			End if
		Next boucle
		IF NoCMD = 1 then CommLANG(1) = "[F.#).|" : CommLANG(2) = "[F.#).|" : CommLANG(3) = "\\#//"
		rem Afficher la liste des commandes avec anglais / francais
		IF AfficherAide = 1 then
			IF CPCDOS_INSTANCE.Utilisateur_Langage = 0 then
				CommandesAide = CommandesAide & CRLF & "  IUG -> pid                Numero du processus parent/hote"
			Else
				CommandesAide = CommandesAide & CRLF & "  GUI -> pid                Parent/host process number"
			END IF
		END IF
		IF CommLANG(1) = OnCherche Then CommTrouve = 1
		IF CommLANG(2) = OnCherche Then CommTrouve = 2
		IF CommTrouve > 0 Then ' Afficher l'aide de la commande
			IF AfficherAide = 2 then
				Mess_Aide = ""
				IF CPCDOS_INSTANCE.Utilisateur_Langage = 0 THEN
					Mess_Aide = Mess_Aide & CRLF & "  '.ProcessusIDentification'"
					Mess_Aide = Mess_Aide & CRLF
					Mess_Aide = Mess_Aide & CRLF & "  Fonctionnalit�e :"
					Mess_Aide = Mess_Aide & CRLF & "   Cette commande utilisable uniquement pendant l'incription d'une propriete"
					Mess_Aide = Mess_Aide & CRLF & "    graphique, permet de selectionner un processus parent. Ceci vous permet"
					Mess_Aide = Mess_Aide & CRLF & "    d'heberger votre fenetre graphique."
					Mess_Aide = Mess_Aide & CRLF
					Mess_Aide = Mess_Aide & CRLF & "  Si ce parametre est NUL :"
					Mess_Aide = Mess_Aide & CRLF & "   - Pour une fenetre, il prendra le numero de PID parent du thread executif"
					Mess_Aide = Mess_Aide & CRLF & "   - Pour un objet, IDEM, mais seulement si le nuemro de handle correspond a la fenetre."
					Mess_Aide = Mess_Aide & CRLF
					Mess_Aide = Mess_Aide & CRLF & "  Exemple :"
					Mess_Aide = Mess_Aide & CRLF & "   -> Voir la commande 'fenetre/'"
					Mess_Aide = Mess_Aide & CRLF
					Mess_Aide = Mess_Aide & CRLF & "  Voir aussi : picturebox/ , textebox/ , textebloc/"
					Mess_Aide = Mess_Aide & CRLF
				ELSEIF CPCDOS_INSTANCE.Utilisateur_Langage = 1 THEN
					Mess_Aide = Mess_Aide & CRLF & "  '.ProcessIDentification'"
					Mess_Aide = Mess_Aide & CRLF
					Mess_Aide = Mess_Aide & CRLF & "  Fonctionnality :"
					Mess_Aide = Mess_Aide & CRLF & "   This command usable only during registering graphic properties, allow to select"
					Mess_Aide = Mess_Aide & CRLF & "    parent process. This allow you to hosting your window."
					Mess_Aide = Mess_Aide & CRLF
					Mess_Aide = Mess_Aide & CRLF & "  If this parameter is NULL"
					Mess_Aide = Mess_Aide & CRLF & "   - For a window, it takes executive thread PID parent number."
					Mess_Aide = Mess_Aide & CRLF & "   - For an object, IDEM, but only if handle number match with window handle."
					Mess_Aide = Mess_Aide & CRLF
					Mess_Aide = Mess_Aide & CRLF & "  Exemple :"
					Mess_Aide = Mess_Aide & CRLF & "   -> Seeing 'window/' command"
					Mess_Aide = Mess_Aide & CRLF
					Mess_Aide = Mess_Aide & CRLF & "  See also : picturebox/ , textbox/ , textbloc/"
					Mess_Aide = Mess_Aide & CRLF
				END IF

				DEBUG(Mess_Aide, Affichage, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_SURBRILLE, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.SansDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_AFF, RetourVAR)
				testCMD = 0
				AfficherAide = 0
				exit _scope_CMD, _scope
			END IF
			' Tester la syntaxe
			testCMD	= CCP_Verifier_Syntaxe(Commande, CommPosition)
			IF testCMD > 10 Then exit _scope_CMD, _scope
			IF testCMD > 0 then  ' Entre 1-5 = Pas d'affichage via le @, @$ ou @#
				IF testCMD < 6 then
					Affichage = 0
					IF testCMD = 3 Then CpcdosCP_SHELL("FIX/ " & CPCDOS_INSTANCE.DEBUG_INSTANCE.LeRetour & " = \#NULL", _CLE_, NIVEAU_CCP, Param_1, Param_2) : RetourVAR = _CLE_ & "N" & NIVEAU_CCP & "->" & CPCDOS_INSTANCE.DEBUG_INSTANCE.LeRetour
					if testCMD = 2 Then RetourVAR = "$>" & CPCDOS_INSTANCE.DEBUG_INSTANCE.LeRetour ' ajouter une securite ?
				Else
					Affichage = 1
				END IF
			Else
				Affichage = 1
			END IF
			' Recuperer les Parametres
			Param = MID(Commande, CommPosition + TailleComm + 2)
			SCOPE
			' ====================================================================

			' Retourner le contenu des quotes des proprietes graphiques
			Dim Retour_quotes as String = get_DonneesQuotesPROP_GUI(Param)
				if NOT Instr(Param, CHR(34)) > 0 Then Retour_quotes = "#@#RETOUR-VAL#" & CPCDOS_INSTANCE.DEBUG_INSTANCE.LeRetour

			' Verifier qu'il n'y a pas eu d'erreurs
			IF NOT Retour_quotes = "-1~#ERR" Then
				CpcdosCP_SHELL = "IUG:PROP_PID=" & Retour_quotes
			else
				Message_erreur = ERRAVT("AVT_065", 0)
				IF CPCDOS_INSTANCE.Utilisateur_Langage = 0 Then
					DEBUG("[CpcdosC+] AVT_065 : " & Message_erreur & ". Commande:" & Commande, Affichage, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_AVERTISSEMENT, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.AvecDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_AFF, RetourVAR)
				Else
					DEBUG("[CpcdosC+] AVT_065 : " & Message_erreur & ". Commande:" & Commande, Affichage, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_AVERTISSEMENT, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.AvecDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_AFF, RetourVAR)
				End If
			End if

			' ====================================================================
			END SCOPE

			exit _scope_CMD, _scope
		End if ' **** .PID ****

	_end_scope_CMD

	_scope_CMD

		' =======================================================================
		CommLANG(1) = ".handle"
		CommLANG(2) = ".handle"
		CommLANG(3) = "\\#//"
		CommTrouve = 0 : NoCMD = 0
		for boucle as integer = 1 to 2
			IF OnCherche = CommLANG(boucle) Then
				NoCMD = 0
				exit for
			Else
				NoCMD = 1
			End if
		Next boucle
		IF NoCMD = 1 then CommLANG(1) = "[F.#).|" : CommLANG(2) = "[F.#).|" : CommLANG(3) = "\\#//"
		rem Afficher la liste des commandes avec anglais / francais
		IF AfficherAide = 1 then
			IF CPCDOS_INSTANCE.Utilisateur_Langage = 0 then
				CommandesAide = CommandesAide & CRLF & "  IUG -> handle             Numero du processus parent/hote"
			Else
				CommandesAide = CommandesAide & CRLF & "  GUI -> handle             Parent/host process number"
			END IF
		END IF
		IF CommLANG(1) = OnCherche Then CommTrouve = 1
		IF CommLANG(2) = OnCherche Then CommTrouve = 2
		IF CommTrouve > 0 Then ' Afficher l'aide de la commande
			IF AfficherAide = 2 then
				Mess_Aide = ""
				IF CPCDOS_INSTANCE.Utilisateur_Langage = 0 THEN
					Mess_Aide = Mess_Aide & CRLF & "  '.Handle'"
					Mess_Aide = Mess_Aide & CRLF
					Mess_Aide = Mess_Aide & CRLF & "  Fonctionnalit�e :"
					Mess_Aide = Mess_Aide & CRLF & "   Cette commande utilisable uniquement pendant l'incription d'une propriete"
					Mess_Aide = Mess_Aide & CRLF & "    graphique, permet de pr�ciser sous quel numero de handle l'objet devra"
					Mess_Aide = Mess_Aide & CRLF & "    etre heberge. Fonctionne uniquement si le numero handle correspond a une fenetre"
					Mess_Aide = Mess_Aide & CRLF
					Mess_Aide = Mess_Aide & CRLF & "  Si ce parametre est NUL :"
					Mess_Aide = Mess_Aide & CRLF & "   - Pour une fenetre, elle meme heberge sur le handle du bureau"
					Mess_Aide = Mess_Aide & CRLF & "   - Pour un objet, une erreur se produira. Un objet doit etre heberge dans une fenetre."
					Mess_Aide = Mess_Aide & CRLF
					Mess_Aide = Mess_Aide & CRLF & "  Exemple :"
					Mess_Aide = Mess_Aide & CRLF & "   -> Voir la commande 'fenetre/'"
					Mess_Aide = Mess_Aide & CRLF
					Mess_Aide = Mess_Aide & CRLF & "  Voir aussi : picturebox/ , textebox/ , textebloc/"
					Mess_Aide = Mess_Aide & CRLF
				ELSEIF CPCDOS_INSTANCE.Utilisateur_Langage = 1 THEN
					Mess_Aide = Mess_Aide & CRLF & "  '.Handle'"
					Mess_Aide = Mess_Aide & CRLF
					Mess_Aide = Mess_Aide & CRLF & "  Fonctionnality :"
					Mess_Aide = Mess_Aide & CRLF & "   This command usable only during registering graphic properties, allow to select"
					Mess_Aide = Mess_Aide & CRLF & "    handle window (for hosting objects). Works only if handle number match with a window."
					Mess_Aide = Mess_Aide & CRLF
					Mess_Aide = Mess_Aide & CRLF & "  If this parameter is NULL"
					Mess_Aide = Mess_Aide & CRLF & "   - For a window, her will hosted on desktop handle."
					Mess_Aide = Mess_Aide & CRLF & "   - For an object, an error will occur. An object must hosted on window."
					Mess_Aide = Mess_Aide & CRLF
					Mess_Aide = Mess_Aide & CRLF & "  Exemple :"
					Mess_Aide = Mess_Aide & CRLF & "   -> Seeing 'window/' command"
					Mess_Aide = Mess_Aide & CRLF
					Mess_Aide = Mess_Aide & CRLF & "  See also : picturebox/ , textbox/ , textbloc/"
					Mess_Aide = Mess_Aide & CRLF
				END IF

				DEBUG(Mess_Aide, Affichage, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_SURBRILLE, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.SansDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_AFF, RetourVAR)
				testCMD = 0
				AfficherAide = 0
				exit _scope_CMD, _scope
			END IF
			' Tester la syntaxe
			testCMD	= CCP_Verifier_Syntaxe(Commande, CommPosition)
			IF testCMD > 10 Then exit _scope_CMD, _scope
			IF testCMD > 0 then  ' Entre 1-5 = Pas d'affichage via le @, @$ ou @#
				IF testCMD < 6 then
					Affichage = 0
					IF testCMD = 3 Then CpcdosCP_SHELL("FIX/ " & CPCDOS_INSTANCE.DEBUG_INSTANCE.LeRetour & " = \#NULL", _CLE_, NIVEAU_CCP, Param_1, Param_2) : RetourVAR = _CLE_ & "N" & NIVEAU_CCP & "->" & CPCDOS_INSTANCE.DEBUG_INSTANCE.LeRetour
					if testCMD = 2 Then RetourVAR = "$>" & CPCDOS_INSTANCE.DEBUG_INSTANCE.LeRetour ' ajouter une securite ?
				Else
					Affichage = 1
				END IF
			Else
				Affichage = 1
			END IF
			' Recuperer les Parametres
			Param = MID(Commande, CommPosition + TailleComm + 2)
			SCOPE
			' ====================================================================

			' Retourner le contenu des quotes des proprietes graphiques
			Dim Retour_quotes as String = get_DonneesQuotesPROP_GUI(Param)
				if NOT Instr(Param, CHR(34)) > 0 Then Retour_quotes = "#@#RETOUR-VAL#" & CPCDOS_INSTANCE.DEBUG_INSTANCE.LeRetour

			' Verifier qu'il n'y a pas eu d'erreurs
			IF NOT Retour_quotes = "-1~#ERR" Then
				CpcdosCP_SHELL = "IUG:PROP_HANDLE=" & Retour_quotes
			else
				Message_erreur = ERRAVT("AVT_065", 0)
				IF CPCDOS_INSTANCE.Utilisateur_Langage = 0 Then
					DEBUG("[CpcdosC+] AVT_065 : " & Message_erreur & ". Commande:" & Commande, Affichage, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_AVERTISSEMENT, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.AvecDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_AFF, RetourVAR)
				Else
					DEBUG("[CpcdosC+] AVT_065 : " & Message_erreur & ". Commande:" & Commande, Affichage, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_AVERTISSEMENT, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.AvecDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_AFF, RetourVAR)
				End If
			End if

			' ====================================================================
			END SCOPE

			exit _scope_CMD, _scope
		End if ' **** .HANDLE ****

	_end_scope_CMD

	_scope_CMD

		' =======================================================================
		CommLANG(1) = ".valeur"
		CommLANG(2) = ".value"
		CommLANG(3) = "\\#//"
		CommTrouve = 0 : NoCMD = 0
		for boucle as integer = 1 to 2
			IF OnCherche = CommLANG(boucle) Then
				NoCMD = 0
				exit for
			Else
				NoCMD = 1
			End if
		Next boucle
		IF NoCMD = 1 then CommLANG(1) = "[F.#).|" : CommLANG(2) = "[F.#).|" : CommLANG(3) = "\\#//"
		rem Afficher la liste des commandes avec anglais / francais
		IF AfficherAide = 1 then
			IF CPCDOS_INSTANCE.Utilisateur_Langage = 0 then
				CommandesAide = CommandesAide & CRLF & "  IUG -> Valeur             Valeur attendu d'un objet"
			Else
				CommandesAide = CommandesAide & CRLF & "  GUI -> Value              Expected object value"
			END IF
		END IF
		IF CommLANG(1) = OnCherche Then CommTrouve = 1
		IF CommLANG(2) = OnCherche Then CommTrouve = 2
		IF CommTrouve > 0 Then ' Afficher l'aide de la commande
			IF AfficherAide = 2 then
				Mess_Aide = ""
				IF CPCDOS_INSTANCE.Utilisateur_Langage = 0 THEN
					Mess_Aide = Mess_Aide & CRLF & "  '.Valeur'"
					Mess_Aide = Mess_Aide & CRLF
					Mess_Aide = Mess_Aide & CRLF & "  Fonctionnalit�e :"
					Mess_Aide = Mess_Aide & CRLF & "   Cette commande utilisable uniquement pendant l'incription d'une propriete"
					Mess_Aide = Mess_Aide & CRLF & "    graphique, permet de pr�ciser une valeur attendue"
					Mess_Aide = Mess_Aide & CRLF
					Mess_Aide = Mess_Aide & CRLF & "  Si ce parametre est NULL ou non indiquee, par defaut elle sera a '0'"
					Mess_Aide = Mess_Aide & CRLF
					Mess_Aide = Mess_Aide & CRLF & "  Exemple :"
					Mess_Aide = Mess_Aide & CRLF & "   -> Voir la commande 'BarreProgression/'"
					Mess_Aide = Mess_Aide & CRLF
					Mess_Aide = Mess_Aide & CRLF & "  Voir aussi : picturebox/ , textebox/ , textebloc/ , fenetre/ , bouton/"
					Mess_Aide = Mess_Aide & CRLF
				ELSEIF CPCDOS_INSTANCE.Utilisateur_Langage = 1 THEN
					Mess_Aide = Mess_Aide & CRLF & "  '.Value'"
					Mess_Aide = Mess_Aide & CRLF
					Mess_Aide = Mess_Aide & CRLF & "  Fonctionnality :"
					Mess_Aide = Mess_Aide & CRLF & "   This command usable only during registering graphic properties, allow to put"
					Mess_Aide = Mess_Aide & CRLF & "    an expected value"
					Mess_Aide = Mess_Aide & CRLF
					Mess_Aide = Mess_Aide & CRLF & "  If this parameter is NULL, the value will be to '0'"
					Mess_Aide = Mess_Aide & CRLF
					Mess_Aide = Mess_Aide & CRLF & "  Exemple :"
					Mess_Aide = Mess_Aide & CRLF & "   -> Seeing 'ProgressBar/' command"
					Mess_Aide = Mess_Aide & CRLF
					Mess_Aide = Mess_Aide & CRLF & "  See also : picturebox/ , textbox/ , textbloc/ , button/ , window/ "
					Mess_Aide = Mess_Aide & CRLF
				END IF

				DEBUG(Mess_Aide, Affichage, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_SURBRILLE, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.SansDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_AFF, RetourVAR)
				testCMD = 0
				AfficherAide = 0
				exit _scope_CMD, _scope
			END IF
			' Tester la syntaxe
			testCMD	= CCP_Verifier_Syntaxe(Commande, CommPosition)
			IF testCMD > 10 Then exit _scope_CMD, _scope
			IF testCMD > 0 then  ' Entre 1-5 = Pas d'affichage via le @, @$ ou @#
				IF testCMD < 6 then
					Affichage = 0
					IF testCMD = 3 Then CpcdosCP_SHELL("FIX/ " & CPCDOS_INSTANCE.DEBUG_INSTANCE.LeRetour & " = \#NULL", _CLE_, NIVEAU_CCP, Param_1, Param_2) : RetourVAR = _CLE_ & "N" & NIVEAU_CCP & "->" & CPCDOS_INSTANCE.DEBUG_INSTANCE.LeRetour
					if testCMD = 2 Then RetourVAR = "$>" & CPCDOS_INSTANCE.DEBUG_INSTANCE.LeRetour ' ajouter une securite ?
				Else
					Affichage = 1
				END IF
			Else
				Affichage = 1
			END IF
			' Recuperer les Parametres
			Param = MID(Commande, CommPosition + TailleComm + 2)
			SCOPE
			' ====================================================================

			' Retourner le contenu des quotes des proprietes graphiques
			Dim Retour_quotes as String = get_DonneesQuotesPROP_GUI(Param)
				if NOT Instr(Param, CHR(34)) > 0 Then Retour_quotes = "#@#RETOUR-VAL#" & CPCDOS_INSTANCE.DEBUG_INSTANCE.LeRetour

			' Verifier qu'il n'y a pas eu d'erreurs
			IF NOT Retour_quotes = "-1~#ERR" Then
				CpcdosCP_SHELL = "IUG:VALEUR=" & Retour_quotes
			else
				Message_erreur = ERRAVT("AVT_065", 0)
				IF CPCDOS_INSTANCE.Utilisateur_Langage = 0 Then
					DEBUG("[CpcdosC+] AVT_065 : " & Message_erreur & ". Commande:" & Commande, Affichage, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_AVERTISSEMENT, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.AvecDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_AFF, RetourVAR)
				Else
					DEBUG("[CpcdosC+] AVT_065 : " & Message_erreur & ". Commande:" & Commande, Affichage, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_AVERTISSEMENT, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.AvecDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_AFF, RetourVAR)
				End If
			End if

			' ====================================================================
			END SCOPE

			exit _scope_CMD, _scope
		End if ' **** .VALEUR ****

	_end_scope_CMD

	_scope_CMD

		' =======================================================================
		CommLANG(1) = ".parametres"
		CommLANG(2) = ".parameters"
		CommLANG(3) = "\\#//"
		CommTrouve = 0 : NoCMD = 0
		for boucle as integer = 1 to 2
			IF OnCherche = CommLANG(boucle) Then
				NoCMD = 0
				exit for
			Else
				NoCMD = 1
			End if
		Next boucle
		IF NoCMD = 1 then CommLANG(1) = "[F.#).|" : CommLANG(2) = "[F.#).|" : CommLANG(3) = "\\#//"
		rem Afficher la liste des commandes avec anglais / francais
		IF AfficherAide = 1 then
			IF CPCDOS_INSTANCE.Utilisateur_Langage = 0 then
				CommandesAide = CommandesAide & CRLF & "  IUG -> type               Type de fenetre graphique"
			Else
				CommandesAide = CommandesAide & CRLF & "  GUI -> type               Graphic window type"
			END IF
		END IF
		IF CommLANG(1) = OnCherche Then CommTrouve = 1
		IF CommLANG(2) = OnCherche Then CommTrouve = 2
		IF CommTrouve > 0 Then ' Afficher l'aide de la commande
			IF AfficherAide = 2 then
				Mess_Aide = ""
				IF CPCDOS_INSTANCE.Utilisateur_Langage = 0 THEN
					Mess_Aide = Mess_Aide & CRLF & "  '.Parametres'"
					Mess_Aide = Mess_Aide & CRLF
					Mess_Aide = Mess_Aide & CRLF & "  Fonctionnalit�e :"
					Mess_Aide = Mess_Aide & CRLF & "   Cette commande utilisable uniquement pendant l'incription d'une propriete"
					Mess_Aide = Mess_Aide & CRLF & "    graphique, permet d'ajouter des parametres a la creation d'un objet ou fenetre."
					Mess_Aide = Mess_Aide & CRLF
					Mess_Aide = Mess_Aide & CRLF & "  Voici les differents type de fenetres:"
					Mess_Aide = Mess_Aide & CRLF & "   - TYPE:1 : Fenetre normale (PAR DEFAUT)"
					Mess_Aide = Mess_Aide & CRLF & "   - TYPE:2 : Fenetre sans le conteneur visible "
					Mess_Aide = Mess_Aide & CRLF & "   - TYPE:3 : Fenetre sans le bitmap de titre visible"
					Mess_Aide = Mess_Aide & CRLF & "   - TYPE:4 : Fenetre sans le conteneur et le bitmap de titre visible"
					Mess_Aide = Mess_Aide & CRLF & "   - TYPE:5 : Fenetre sans barre de titre"
					Mess_Aide = Mess_Aide & CRLF & "   - TYPE:6 : Fenetre sans barre de titre et sans conteneur visible"
					Mess_Aide = Mess_Aide & CRLF & "   - BORD:1    : Bordure autour de la fenetre. (PAR DEFAUT)"
					Mess_Aide = Mess_Aide & CRLF & "   - BORD:0    : Sans bordure autour de la fenetre"
					Mess_Aide = Mess_Aide & CRLF
					Mess_Aide = Mess_Aide & CRLF & "  Pour un picturebox:"
					Mess_Aide = Mess_Aide & CRLF & "   - IMGAUTO:0 : Affichage normale (PAR DEFAUT)"
					Mess_Aide = Mess_Aide & CRLF & "   - IMGAUTO:1 : Affichage avec les dimentions du picturebox qui s'adaptent a l'image."
					Mess_Aide = Mess_Aide & CRLF & "   - IMGAUTO:2 : Affichage avec les dimentions de l'image qui s'adaptend au picturebox."
					Mess_Aide = Mess_Aide & CRLF
					Mess_Aide = Mess_Aide & CRLF
					Mess_Aide = Mess_Aide & CRLF & "  Exemple :"
					Mess_Aide = Mess_Aide & CRLF & "   -> Voir la commande 'fenetre/'"
					Mess_Aide = Mess_Aide & CRLF
					Mess_Aide = Mess_Aide & CRLF & "  Voir aussi : picturebox/ , textebox/ , textebloc/"
					Mess_Aide = Mess_Aide & CRLF
				ELSEIF CPCDOS_INSTANCE.Utilisateur_Langage = 1 THEN
					Mess_Aide = Mess_Aide & CRLF & "  '.Parameters'"
					Mess_Aide = Mess_Aide & CRLF
					Mess_Aide = Mess_Aide & CRLF & "  Fonctionnality :"
					Mess_Aide = Mess_Aide & CRLF & "   This command usable only during registering graphic properties, allow to choice"
					Mess_Aide = Mess_Aide & CRLF & "    parameters for object or window."
					Mess_Aide = Mess_Aide & CRLF
					Mess_Aide = Mess_Aide & CRLF & "  This is type of window."
					Mess_Aide = Mess_Aide & CRLF & "   - TYPE:1 : Normal window (BY DEFAULT)"
					Mess_Aide = Mess_Aide & CRLF & "   - TYPE:2 : Window without visible contener."
					Mess_Aide = Mess_Aide & CRLF & "   - TYPE:3 : Window without bitmap tible visible."
					Mess_Aide = Mess_Aide & CRLF & "   - TYPE:4 : Window without visible contener and visible bitmap."
					Mess_Aide = Mess_Aide & CRLF & "   - TYPE:5 : Window without title bar."
					Mess_Aide = Mess_Aide & CRLF & "   - TYPE:6 : Window without title bar and without visible contener."
					Mess_Aide = Mess_Aide & CRLF & "   - BORD:1    : Border arround window. (BY DEFAULT)"
					Mess_Aide = Mess_Aide & CRLF & "   - BORD:0    : Without border arround window."
					Mess_Aide = Mess_Aide & CRLF
					Mess_Aide = Mess_Aide & CRLF
					Mess_Aide = Mess_Aide & CRLF & "  For a picturebox"
					Mess_Aide = Mess_Aide & CRLF & "   - IMGAUTO:0 : Normal displaying (BY DEFAULT)"
					Mess_Aide = Mess_Aide & CRLF & "   - IMGAUTO:1 : Displaying with picturebox dimentions who adapts with image dimentions."
					Mess_Aide = Mess_Aide & CRLF & "   - IMGAUTO:2 : Displaying with image dimentions who adapts with picturebox dimentions."
					Mess_Aide = Mess_Aide & CRLF
					Mess_Aide = Mess_Aide & CRLF & "  Exemple :"
					Mess_Aide = Mess_Aide & CRLF & "   -> Seeing 'window/' command"
					Mess_Aide = Mess_Aide & CRLF
					Mess_Aide = Mess_Aide & CRLF & "  See also : picturebox/ , textbox/ , textbloc/"
					Mess_Aide = Mess_Aide & CRLF
				END IF

				DEBUG(Mess_Aide, Affichage, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_SURBRILLE, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.SansDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_AFF, RetourVAR)
				testCMD = 0
				AfficherAide = 0
				exit _scope_CMD, _scope
			END IF
			' Tester la syntaxe
			testCMD	= CCP_Verifier_Syntaxe(Commande, CommPosition)
			IF testCMD > 10 Then exit _scope_CMD, _scope
			IF testCMD > 0 then  ' Entre 1-5 = Pas d'affichage via le @, @$ ou @#
				IF testCMD < 6 then
					Affichage = 0
					IF testCMD = 3 Then CpcdosCP_SHELL("FIX/ " & CPCDOS_INSTANCE.DEBUG_INSTANCE.LeRetour & " = \#NULL", _CLE_, NIVEAU_CCP, Param_1, Param_2) : RetourVAR = _CLE_ & "N" & NIVEAU_CCP & "->" & CPCDOS_INSTANCE.DEBUG_INSTANCE.LeRetour
					if testCMD = 2 Then RetourVAR = "$>" & CPCDOS_INSTANCE.DEBUG_INSTANCE.LeRetour ' ajouter une securite ?
				Else
					Affichage = 1
				END IF
			Else
				Affichage = 1
			END IF
			' Recuperer les Parametres
			Param = MID(Commande, CommPosition + TailleComm + 2)
			SCOPE
			' ====================================================================

			' Retourner le contenu des quotes des proprietes graphiques
			Dim Retour_quotes as String = get_DonneesQuotesPROP_GUI(Param)
				if NOT Instr(Param, CHR(34)) > 0 Then Retour_quotes = "#@#RETOUR-VAL#" & CPCDOS_INSTANCE.DEBUG_INSTANCE.LeRetour

			' Verifier qu'il n'y a pas eu d'erreurs
			IF NOT Retour_quotes = "-1~#ERR" Then
				CpcdosCP_SHELL = "IUG:PROP_TYPE=" & Retour_quotes
			else
				Message_erreur = ERRAVT("AVT_065", 0)
				IF CPCDOS_INSTANCE.Utilisateur_Langage = 0 Then
					DEBUG("[CpcdosC+] AVT_065 : " & Message_erreur & ". Commande:" & Commande, Affichage, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_AVERTISSEMENT, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.AvecDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_AFF, RetourVAR)
				Else
					DEBUG("[CpcdosC+] AVT_065 : " & Message_erreur & ". Commande:" & Commande, Affichage, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_AVERTISSEMENT, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.AvecDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_AFF, RetourVAR)
				End If
			End if

			' ====================================================================
			END SCOPE

			exit _scope_CMD, _scope
		End if ' **** .PARAMETRES ****

	_end_scope_CMD

	_scope_CMD

		' =======================================================================
		CommLANG(1) = ".couleurfenetre"
		CommLANG(2) = ".windowcolor"
		CommLANG(3) = "\\#//"
		CommTrouve = 0 : NoCMD = 0
		for boucle as integer = 1 to 2
			IF OnCherche = CommLANG(boucle) Then
				NoCMD = 0
				exit for
			Else
				NoCMD = 1
			End if
		Next boucle
		IF NoCMD = 1 then CommLANG(1) = "[F.#).|" : CommLANG(2) = "[F.#).|" : CommLANG(3) = "\\#//"
		rem Afficher la liste des commandes avec anglais / francais
		IF AfficherAide = 1 then
			IF CPCDOS_INSTANCE.Utilisateur_Langage = 0 then
				CommandesAide = CommandesAide & CRLF & "  IUG -> couleurfenetre     Couleur de la fenetre"
			Else
				CommandesAide = CommandesAide & CRLF & "  GUI -> windowcolor        Window color"
			END IF
		END IF
		IF CommLANG(1) = OnCherche Then CommTrouve = 1
		IF CommLANG(2) = OnCherche Then CommTrouve = 2
		IF CommTrouve > 0 Then ' Afficher l'aide de la commande
			IF AfficherAide = 2 then
				Mess_Aide = ""
				IF CPCDOS_INSTANCE.Utilisateur_Langage = 0 THEN
					Mess_Aide = Mess_Aide & CRLF & "  '.CouleurFenetre'"
					Mess_Aide = Mess_Aide & CRLF
					Mess_Aide = Mess_Aide & CRLF & "  Fonctionnalit�e :"
					Mess_Aide = Mess_Aide & CRLF & "   Cette commande utilisable uniquement pendant l'incription d'une propriete"
					Mess_Aide = Mess_Aide & CRLF & "    graphique, permet de choisir la couleur de la fenetre de maniere general en RVB."
					Mess_Aide = Mess_Aide & CRLF
					Mess_Aide = Mess_Aide & CRLF & "  Si ce parametre n'est pas specifie, la fenetre sera de couleur grise/blanche."
					Mess_Aide = Mess_Aide & CRLF & "  Vous devez specifier un code de couleur du type RVB avec 3 chiffres pour chaque. Ex:"
					Mess_Aide = Mess_Aide & CRLF & "    CouleurFenetre = " & CHR(34) & "120,050,000" & chr(34)
					Mess_Aide = Mess_Aide & CRLF & "  Meme si la couleur est zero, vous devez specifier 3 chiffres '000'"
					Mess_Aide = Mess_Aide & CRLF
					Mess_Aide = Mess_Aide & CRLF & "  Exemple :"
					Mess_Aide = Mess_Aide & CRLF & "   -> Voir la commande 'fenetre/'"
					Mess_Aide = Mess_Aide & CRLF
					Mess_Aide = Mess_Aide & CRLF & "  Voir aussi : picturebox/ , textebox/ , textebloc/"
					Mess_Aide = Mess_Aide & CRLF
				ELSEIF CPCDOS_INSTANCE.Utilisateur_Langage = 1 THEN
					Mess_Aide = Mess_Aide & CRLF & "  '.WindowColor'"
					Mess_Aide = Mess_Aide & CRLF
					Mess_Aide = Mess_Aide & CRLF & "  Fonctionnality :"
					Mess_Aide = Mess_Aide & CRLF & "   This command usable only during registering graphic properties, allow to choice"
					Mess_Aide = Mess_Aide & CRLF & "    a general window color in RGB."
					Mess_Aide = Mess_Aide & CRLF
					Mess_Aide = Mess_Aide & CRLF & "  If this parameter is not specified, window will be gray/white color. "
					Mess_Aide = Mess_Aide & CRLF & "  You must specify RGB color type with 3 digit for each. ex: "
					Mess_Aide = Mess_Aide & CRLF & "   WindowColor = " & CHR(34) & "120,050,000" & chr(34)
					Mess_Aide = Mess_Aide & CRLF & "   Even if color is zero, you must specify 3 digits '000'"
					Mess_Aide = Mess_Aide & CRLF
					Mess_Aide = Mess_Aide & CRLF & "  Exemple :"
					Mess_Aide = Mess_Aide & CRLF & "   -> Seeing 'window/' command"
					Mess_Aide = Mess_Aide & CRLF
					Mess_Aide = Mess_Aide & CRLF & "  See also : picturebox/ , textbox/ , textbloc/"
					Mess_Aide = Mess_Aide & CRLF
				END IF

				DEBUG(Mess_Aide, Affichage, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_SURBRILLE, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.SansDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_AFF, RetourVAR)
				testCMD = 0
				AfficherAide = 0
				exit _scope_CMD, _scope
			END IF
			' Tester la syntaxe
			testCMD	= CCP_Verifier_Syntaxe(Commande, CommPosition)
			IF testCMD > 10 Then exit _scope_CMD, _scope
			IF testCMD > 0 then  ' Entre 1-5 = Pas d'affichage via le @, @$ ou @#
				IF testCMD < 6 then
					Affichage = 0
					IF testCMD = 3 Then CpcdosCP_SHELL("FIX/ " & CPCDOS_INSTANCE.DEBUG_INSTANCE.LeRetour & " = \#NULL", _CLE_, NIVEAU_CCP, Param_1, Param_2) : RetourVAR = _CLE_ & "N" & NIVEAU_CCP & "->" & CPCDOS_INSTANCE.DEBUG_INSTANCE.LeRetour
					if testCMD = 2 Then RetourVAR = "$>" & CPCDOS_INSTANCE.DEBUG_INSTANCE.LeRetour ' ajouter une securite ?
				Else
					Affichage = 1
				END IF
			Else
				Affichage = 1
			END IF
			' Recuperer les Parametres
			Param = MID(Commande, CommPosition + TailleComm + 2)
			SCOPE
			' ====================================================================

			' Retourner le contenu des quotes des proprietes graphiques
			Dim Retour_quotes as String = get_DonneesQuotesPROP_GUI(Param)
				if NOT Instr(Param, CHR(34)) > 0 Then Retour_quotes = "#@#RETOUR-VAL#" & CPCDOS_INSTANCE.DEBUG_INSTANCE.LeRetour

			' Verifier qu'il n'y a pas eu d'erreurs
			IF NOT Retour_quotes = "-1~#ERR" Then
				CpcdosCP_SHELL = "IUG:PROP_COULEURFENETRE=" & Retour_quotes
			else
				Message_erreur = ERRAVT("AVT_065", 0)
				IF CPCDOS_INSTANCE.Utilisateur_Langage = 0 Then
					DEBUG("[CpcdosC+] AVT_065 : " & Message_erreur & ". Commande:" & Commande, Affichage, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_AVERTISSEMENT, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.AvecDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_AFF, RetourVAR)
				Else
					DEBUG("[CpcdosC+] AVT_065 : " & Message_erreur & ". Commande:" & Commande, Affichage, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_AVERTISSEMENT, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.AvecDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_AFF, RetourVAR)
				End If
			End if

			' ====================================================================
			END SCOPE
			exit _scope_CMD, _scope
		End if ' **** .COULEURFENETRE ****

	_end_scope_CMD

	_scope_CMD

		' =======================================================================
		CommLANG(1) = ".couleurfond"
		CommLANG(2) = ".backcolor"
		CommLANG(3) = "\\#//"
		CommTrouve = 0 : NoCMD = 0
		for boucle as integer = 1 to 2
			IF OnCherche = CommLANG(boucle) Then
				NoCMD = 0
				exit for
			Else
				NoCMD = 1
			End if
		Next boucle
		IF NoCMD = 1 then CommLANG(1) = "[F.#).|" : CommLANG(2) = "[F.#).|" : CommLANG(3) = "\\#//"
		rem Afficher la liste des commandes avec anglais / francais
		IF AfficherAide = 1 then
			IF CPCDOS_INSTANCE.Utilisateur_Langage = 0 then
				CommandesAide = CommandesAide & CRLF & "  IUG -> couleurfond        Couleur du conteneur de la fenetre"
			Else
				CommandesAide = CommandesAide & CRLF & "  GUI -> windowcolor        Window container color"
			END IF
		END IF
		IF CommLANG(1) = OnCherche Then CommTrouve = 1
		IF CommLANG(2) = OnCherche Then CommTrouve = 2
		IF CommTrouve > 0 Then ' Afficher l'aide de la commande
			IF AfficherAide = 2 then
				Mess_Aide = ""
				IF CPCDOS_INSTANCE.Utilisateur_Langage = 0 THEN
					Mess_Aide = Mess_Aide & CRLF & "  '.CouleurFond'"
					Mess_Aide = Mess_Aide & CRLF
					Mess_Aide = Mess_Aide & CRLF & "  Fonctionnalit�e :"
					Mess_Aide = Mess_Aide & CRLF & "   Cette commande utilisable uniquement pendant l'incription d'une propriete"
					Mess_Aide = Mess_Aide & CRLF & "    graphique, permet de choisir la couleur du fond du conteneur de la fenetre."
					Mess_Aide = Mess_Aide & CRLF & "    Le conteneur c'est la ou vont se trouver vos objets graphiques"
					Mess_Aide = Mess_Aide & CRLF
					Mess_Aide = Mess_Aide & CRLF & "  Si ce parametre n'est pas specifie, le fond sera de couleur grise."
					Mess_Aide = Mess_Aide & CRLF & "  Vous devez specifier un code de couleur du type RVB avec 3 chiffres pour chaque. Ex:"
					Mess_Aide = Mess_Aide & CRLF & "    CouleurFenetre = " & CHR(34) & "120,050,000" & chr(34)
					Mess_Aide = Mess_Aide & CRLF & "  Meme si la couleur est zero, vous devez specifier 3 chiffres '000'"
					Mess_Aide = Mess_Aide & CRLF
					Mess_Aide = Mess_Aide & CRLF & "  Exemple :"
					Mess_Aide = Mess_Aide & CRLF & "   -> Voir la commande 'fenetre/'"
					Mess_Aide = Mess_Aide & CRLF
					Mess_Aide = Mess_Aide & CRLF & "  Voir aussi : picturebox/ , textebox/ , textebloc/"
					Mess_Aide = Mess_Aide & CRLF
				ELSEIF CPCDOS_INSTANCE.Utilisateur_Langage = 1 THEN
					Mess_Aide = Mess_Aide & CRLF & "  '.WindowColor'"
					Mess_Aide = Mess_Aide & CRLF
					Mess_Aide = Mess_Aide & CRLF & "  Fonctionnality :"
					Mess_Aide = Mess_Aide & CRLF & "   This command usable only during registering graphic properties, allow to choice"
					Mess_Aide = Mess_Aide & CRLF & "    The color of the window of container."
					Mess_Aide = Mess_Aide & CRLF
					Mess_Aide = Mess_Aide & CRLF & "  If this parameter is not specified, window will be gray color. "
					Mess_Aide = Mess_Aide & CRLF & "  You must specify RGB color type with 3 digit for each. ex: "
					Mess_Aide = Mess_Aide & CRLF & "   WindowColor = " & CHR(34) & "120,050,000" & chr(34)
					Mess_Aide = Mess_Aide & CRLF & "   Even if color is zero, you must specify 3 digits '000'"
					Mess_Aide = Mess_Aide & CRLF
					Mess_Aide = Mess_Aide & CRLF & "  Exemple :"
					Mess_Aide = Mess_Aide & CRLF & "   -> Seeing 'window/' command"
					Mess_Aide = Mess_Aide & CRLF
					Mess_Aide = Mess_Aide & CRLF & "  See also : picturebox/ , textbox/ , textbloc/"
					Mess_Aide = Mess_Aide & CRLF
				END IF

				DEBUG(Mess_Aide, Affichage, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_SURBRILLE, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.SansDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_AFF, RetourVAR)
				testCMD = 0
				AfficherAide = 0
				exit _scope_CMD, _scope
			END IF
			' Tester la syntaxe
			testCMD	= CCP_Verifier_Syntaxe(Commande, CommPosition)
			IF testCMD > 10 Then exit _scope_CMD, _scope
			IF testCMD > 0 then  ' Entre 1-5 = Pas d'affichage via le @, @$ ou @#
				IF testCMD < 6 then
					Affichage = 0
					IF testCMD = 3 Then CpcdosCP_SHELL("FIX/ " & CPCDOS_INSTANCE.DEBUG_INSTANCE.LeRetour & " = \#NULL", _CLE_, NIVEAU_CCP, Param_1, Param_2) : RetourVAR = _CLE_ & "N" & NIVEAU_CCP & "->" & CPCDOS_INSTANCE.DEBUG_INSTANCE.LeRetour
					if testCMD = 2 Then RetourVAR = "$>" & CPCDOS_INSTANCE.DEBUG_INSTANCE.LeRetour ' ajouter une securite ?
				Else
					Affichage = 1
				END IF
			Else
				Affichage = 1
			END IF
			' Recuperer les Parametres
			Param = MID(Commande, CommPosition + TailleComm + 2)
			SCOPE
			' ====================================================================

			' Retourner le contenu des quotes des proprietes graphiques
			Dim Retour_quotes as String = get_DonneesQuotesPROP_GUI(Param)
				if NOT Instr(Param, CHR(34)) > 0 Then Retour_quotes = "#@#RETOUR-VAL#" & CPCDOS_INSTANCE.DEBUG_INSTANCE.LeRetour

			' Verifier qu'il n'y a pas eu d'erreurs
			IF NOT Retour_quotes = "-1~#ERR" Then
				CpcdosCP_SHELL = "IUG:PROP_COULEURFOND=" & Retour_quotes
			else
				Message_erreur = ERRAVT("AVT_065", 0)
				IF CPCDOS_INSTANCE.Utilisateur_Langage = 0 Then
					DEBUG("[CpcdosC+] AVT_065 : " & Message_erreur & ". Commande:" & Commande, Affichage, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_AVERTISSEMENT, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.AvecDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_AFF, RetourVAR)
				Else
					DEBUG("[CpcdosC+] AVT_065 : " & Message_erreur & ". Commande:" & Commande, Affichage, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_AVERTISSEMENT, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.AvecDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_AFF, RetourVAR)
				End If
			End if

			' ====================================================================
			END SCOPE
			exit _scope_CMD, _scope
		End if ' **** .COULEURFOND ****

	_end_scope_CMD

	_scope_CMD

		' =======================================================================
		CommLANG(1) = ".couleurtitre"
		CommLANG(2) = ".titlecolor"
		CommLANG(3) = "\\#//"
		CommTrouve = 0 : NoCMD = 0
		for boucle as integer = 1 to 2
			IF OnCherche = CommLANG(boucle) Then
				NoCMD = 0
				exit for
			Else
				NoCMD = 1
			End if
		Next boucle
		IF NoCMD = 1 then CommLANG(1) = "[F.#).|" : CommLANG(2) = "[F.#).|" : CommLANG(3) = "\\#//"
		rem Afficher la liste des commandes avec anglais / francais
		IF AfficherAide = 1 then
			IF CPCDOS_INSTANCE.Utilisateur_Langage = 0 then
				CommandesAide = CommandesAide & CRLF & "  IUG -> couleurtitre       Couleur du titre de la fenetre"
			Else
				CommandesAide = CommandesAide & CRLF & "  GUI -> windowcolor        Color of title of the windows"
			END IF
		END IF
		IF CommLANG(1) = OnCherche Then CommTrouve = 1
		IF CommLANG(2) = OnCherche Then CommTrouve = 2
		IF CommTrouve > 0 Then ' Afficher l'aide de la commande
			IF AfficherAide = 2 then
				Mess_Aide = ""
				IF CPCDOS_INSTANCE.Utilisateur_Langage = 0 THEN
					Mess_Aide = Mess_Aide & CRLF & "  '.CouleurTitre'"
					Mess_Aide = Mess_Aide & CRLF
					Mess_Aide = Mess_Aide & CRLF & "  Fonctionnalit�e :"
					Mess_Aide = Mess_Aide & CRLF & "   Cette commande utilisable uniquement pendant l'incription d'une propriete"
					Mess_Aide = Mess_Aide & CRLF & "    graphique, permet de choisir la couleur des caracteres du titre de la fenetre"
					Mess_Aide = Mess_Aide & CRLF
					Mess_Aide = Mess_Aide & CRLF & "  Si ce parametre n'est pas specifie, le fond sera de couleur grise."
					Mess_Aide = Mess_Aide & CRLF & "  Vous devez specifier un code de couleur du type RVB avec 3 chiffres pour chaque. Ex:"
					Mess_Aide = Mess_Aide & CRLF & "    CouleurTitre = " & CHR(34) & "120,050,000" & chr(34)
					Mess_Aide = Mess_Aide & CRLF & "  Meme si la couleur est zero, vous devez specifier 3 chiffres '000'"
					Mess_Aide = Mess_Aide & CRLF
					Mess_Aide = Mess_Aide & CRLF & "  Exemple :"
					Mess_Aide = Mess_Aide & CRLF & "   -> Voir la commande 'fenetre/'"
					Mess_Aide = Mess_Aide & CRLF
					Mess_Aide = Mess_Aide & CRLF & "  Voir aussi : picturebox/ , textebox/ , textebloc/"
					Mess_Aide = Mess_Aide & CRLF
				ELSEIF CPCDOS_INSTANCE.Utilisateur_Langage = 1 THEN
					Mess_Aide = Mess_Aide & CRLF & "  '.TitleColor'"
					Mess_Aide = Mess_Aide & CRLF
					Mess_Aide = Mess_Aide & CRLF & "  Fonctionnality :"
					Mess_Aide = Mess_Aide & CRLF & "   This command usable only during registering graphic properties, allow to choice"
					Mess_Aide = Mess_Aide & CRLF & "    the color of title in window title bar."
					Mess_Aide = Mess_Aide & CRLF
					Mess_Aide = Mess_Aide & CRLF & "  If this parameter is not specified, window will be black. "
					Mess_Aide = Mess_Aide & CRLF & "  You must specify RGB color type with 3 digit for each. ex: "
					Mess_Aide = Mess_Aide & CRLF & "   TitleColor = " & CHR(34) & "120,050,000" & chr(34)
					Mess_Aide = Mess_Aide & CRLF & "   Even if color is zero, you must specify 3 digits '000'"
					Mess_Aide = Mess_Aide & CRLF
					Mess_Aide = Mess_Aide & CRLF & "  Exemple :"
					Mess_Aide = Mess_Aide & CRLF & "   -> Seeing 'window/' command"
					Mess_Aide = Mess_Aide & CRLF
					Mess_Aide = Mess_Aide & CRLF & "  See also : picturebox/ , textbox/ , textbloc/"
					Mess_Aide = Mess_Aide & CRLF
				END IF

				DEBUG(Mess_Aide, Affichage, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_SURBRILLE, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.SansDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_AFF, RetourVAR)
				testCMD = 0
				AfficherAide = 0
				exit _scope_CMD, _scope
			END IF
			' Tester la syntaxe
			testCMD	= CCP_Verifier_Syntaxe(Commande, CommPosition)
			IF testCMD > 10 Then exit _scope_CMD, _scope
			IF testCMD > 0 then  ' Entre 1-5 = Pas d'affichage via le @, @$ ou @#
				IF testCMD < 6 then
					Affichage = 0
					IF testCMD = 3 Then CpcdosCP_SHELL("FIX/ " & CPCDOS_INSTANCE.DEBUG_INSTANCE.LeRetour & " = \#NULL", _CLE_, NIVEAU_CCP, Param_1, Param_2) : RetourVAR = _CLE_ & "N" & NIVEAU_CCP & "->" & CPCDOS_INSTANCE.DEBUG_INSTANCE.LeRetour
					if testCMD = 2 Then RetourVAR = "$>" & CPCDOS_INSTANCE.DEBUG_INSTANCE.LeRetour ' ajouter une securite ?
				Else
					Affichage = 1
				END IF
			Else
				Affichage = 1
			END IF
			' Recuperer les Parametres
			Param = MID(Commande, CommPosition + TailleComm + 2)
			SCOPE
			' ====================================================================

			' Retourner le contenu des quotes des proprietes graphiques
			Dim Retour_quotes as String = get_DonneesQuotesPROP_GUI(Param)
				if NOT Instr(Param, CHR(34)) > 0 Then Retour_quotes = "#@#RETOUR-VAL#" & CPCDOS_INSTANCE.DEBUG_INSTANCE.LeRetour

			' Verifier qu'il n'y a pas eu d'erreurs
			IF NOT Retour_quotes = "-1~#ERR" Then
				CpcdosCP_SHELL = "IUG:PROP_COULEURTITRE=" & Retour_quotes
			else
				Message_erreur = ERRAVT("AVT_065", 0)
				IF CPCDOS_INSTANCE.Utilisateur_Langage = 0 Then
					DEBUG("[CpcdosC+] AVT_065 : " & Message_erreur & ". Commande:" & Commande, Affichage, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_AVERTISSEMENT, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.AvecDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_AFF, RetourVAR)
				Else
					DEBUG("[CpcdosC+] AVT_065 : " & Message_erreur & ". Commande:" & Commande, Affichage, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_AVERTISSEMENT, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.AvecDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_AFF, RetourVAR)
				End If
			End if

			' ====================================================================
			END SCOPE
			exit _scope_CMD, _scope
		End if ' **** .COULEURTITRE ****

	_end_scope_CMD

	_scope_CMD

		' =======================================================================
		CommLANG(1) = ".couleurtexte"
		CommLANG(2) = ".textcolor"
		CommLANG(3) = "\\#//"
		CommTrouve = 0 : NoCMD = 0
		for boucle as integer = 1 to 2
			IF OnCherche = CommLANG(boucle) Then
				NoCMD = 0
				exit for
			Else
				NoCMD = 1
			End if
		Next boucle
		IF NoCMD = 1 then CommLANG(1) = "[F.#).|" : CommLANG(2) = "[F.#).|" : CommLANG(3) = "\\#//"
		rem Afficher la liste des commandes avec anglais / francais
		IF AfficherAide = 1 then
			IF CPCDOS_INSTANCE.Utilisateur_Langage = 0 then
				CommandesAide = CommandesAide & CRLF & "  IUG -> couleurtexte       Couleur du titre de la fenetre"
			Else
				CommandesAide = CommandesAide & CRLF & "  GUI -> textcolor          Color of title of the windows"
			END IF
		END IF
		IF CommLANG(1) = OnCherche Then CommTrouve = 1
		IF CommLANG(2) = OnCherche Then CommTrouve = 2
		IF CommTrouve > 0 Then ' Afficher l'aide de la commande
			IF AfficherAide = 2 then
				Mess_Aide = ""
				IF CPCDOS_INSTANCE.Utilisateur_Langage = 0 THEN
					Mess_Aide = Mess_Aide & CRLF & "  '.CouleurTitre'"
					Mess_Aide = Mess_Aide & CRLF
					Mess_Aide = Mess_Aide & CRLF & "  Fonctionnalit�e :"
					Mess_Aide = Mess_Aide & CRLF & "   Cette commande utilisable uniquement pendant l'incription d'une propriete"
					Mess_Aide = Mess_Aide & CRLF & "    graphique, permet de choisir la couleur des caracteres du texte de l'objet"
					Mess_Aide = Mess_Aide & CRLF
					Mess_Aide = Mess_Aide & CRLF & "  Si ce parametre n'est pas specifie, le fond sera de couleur grise."
					Mess_Aide = Mess_Aide & CRLF & "  Vous devez specifier un code de couleur du type RVB avec 3 chiffres pour chaque. Ex:"
					Mess_Aide = Mess_Aide & CRLF & "    CouleurTexte = " & CHR(34) & "120,050,000" & chr(34)
					Mess_Aide = Mess_Aide & CRLF & "  Meme si la couleur est zero, vous devez specifier 3 chiffres '000'"
					Mess_Aide = Mess_Aide & CRLF
					Mess_Aide = Mess_Aide & CRLF
					Mess_Aide = Mess_Aide & CRLF & "  Voir aussi : picturebox/ , textebox/ , textebloc/"
					Mess_Aide = Mess_Aide & CRLF
				ELSEIF CPCDOS_INSTANCE.Utilisateur_Langage = 1 THEN
					Mess_Aide = Mess_Aide & CRLF & "  '.TitleColor'"
					Mess_Aide = Mess_Aide & CRLF
					Mess_Aide = Mess_Aide & CRLF & "  Fonctionnality :"
					Mess_Aide = Mess_Aide & CRLF & "   This command usable only during registering graphic properties, allow to choice"
					Mess_Aide = Mess_Aide & CRLF & "    the color of text in gui object."
					Mess_Aide = Mess_Aide & CRLF
					Mess_Aide = Mess_Aide & CRLF & "  If this parameter is not specified, window will be black. "
					Mess_Aide = Mess_Aide & CRLF & "  You must specify RGB color type with 3 digit for each. ex: "
					Mess_Aide = Mess_Aide & CRLF & "   TextColor = " & CHR(34) & "120,050,000" & chr(34)
					Mess_Aide = Mess_Aide & CRLF & "   Even if color is zero, you must specify 3 digits '000'"
					Mess_Aide = Mess_Aide & CRLF
					Mess_Aide = Mess_Aide & CRLF & "  See also : picturebox/ , textbox/ , textbloc/"
					Mess_Aide = Mess_Aide & CRLF
				END IF

				DEBUG(Mess_Aide, Affichage, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_SURBRILLE, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.SansDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_AFF, RetourVAR)
				testCMD = 0
				AfficherAide = 0
				exit _scope_CMD, _scope
			END IF
			' Tester la syntaxe
			testCMD	= CCP_Verifier_Syntaxe(Commande, CommPosition)
			IF testCMD > 10 Then exit _scope_CMD, _scope
			IF testCMD > 0 then  ' Entre 1-5 = Pas d'affichage via le @, @$ ou @#
				IF testCMD < 6 then
					Affichage = 0
					IF testCMD = 3 Then CpcdosCP_SHELL("FIX/ " & CPCDOS_INSTANCE.DEBUG_INSTANCE.LeRetour & " = \#NULL", _CLE_, NIVEAU_CCP, Param_1, Param_2) : RetourVAR = _CLE_ & "N" & NIVEAU_CCP & "->" & CPCDOS_INSTANCE.DEBUG_INSTANCE.LeRetour
					if testCMD = 2 Then RetourVAR = "$>" & CPCDOS_INSTANCE.DEBUG_INSTANCE.LeRetour ' ajouter une securite ?
				Else
					Affichage = 1
				END IF
			Else
				Affichage = 1
			END IF
			' Recuperer les Parametres
			Param = MID(Commande, CommPosition + TailleComm + 2)
			SCOPE
			' ====================================================================

			' Retourner le contenu des quotes des proprietes graphiques
			Dim Retour_quotes as String = get_DonneesQuotesPROP_GUI(Param)
				if NOT Instr(Param, CHR(34)) > 0 Then Retour_quotes = "#@#RETOUR-VAL#" & CPCDOS_INSTANCE.DEBUG_INSTANCE.LeRetour

			' Verifier qu'il n'y a pas eu d'erreurs
			IF NOT Retour_quotes = "-1~#ERR" Then
				CpcdosCP_SHELL = "IUG:PROP_COULEURTEXTE=" & Retour_quotes
			else
				Message_erreur = ERRAVT("AVT_065", 0)
				IF CPCDOS_INSTANCE.Utilisateur_Langage = 0 Then
					DEBUG("[CpcdosC+] AVT_065 : " & Message_erreur & ". Commande:" & Commande, Affichage, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_AVERTISSEMENT, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.AvecDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_AFF, RetourVAR)
				Else
					DEBUG("[CpcdosC+] AVT_065 : " & Message_erreur & ". Commande:" & Commande, Affichage, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_AVERTISSEMENT, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.AvecDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_AFF, RetourVAR)
				End If
			End if

			' ====================================================================
			END SCOPE
			exit _scope_CMD, _scope
		End if ' **** .COULEURTEXTE ****

	_end_scope_CMD

	_scope_CMD

		' =======================================================================
		CommLANG(1) = ".icone"
		CommLANG(2) = ".icon"
		CommLANG(3) = "\\#//"
		CommTrouve = 0 : NoCMD = 0
		for boucle as integer = 1 to 2
			IF OnCherche = CommLANG(boucle) Then
				NoCMD = 0
				exit for
			Else
				NoCMD = 1
			End if
		Next boucle
		IF NoCMD = 1 then CommLANG(1) = "[F.#).|" : CommLANG(2) = "[F.#).|" : CommLANG(3) = "\\#//"
		rem Afficher la liste des commandes avec anglais / francais
		IF AfficherAide = 1 then
			IF CPCDOS_INSTANCE.Utilisateur_Langage = 0 then
				CommandesAide = CommandesAide & CRLF & "  IUG -> icone              Icone de la fenetre"
			Else
				CommandesAide = CommandesAide & CRLF & "  GUI -> icon               Window icon"
			END IF
		END IF
		IF CommLANG(1) = OnCherche Then CommTrouve = 1
		IF CommLANG(2) = OnCherche Then CommTrouve = 2
		IF CommTrouve > 0 Then ' Afficher l'aide de la commande
			IF AfficherAide = 2 then
				Mess_Aide = ""
				IF CPCDOS_INSTANCE.Utilisateur_Langage = 0 THEN
					Mess_Aide = Mess_Aide & CRLF & "  '.ICONE'"
					Mess_Aide = Mess_Aide & CRLF
					Mess_Aide = Mess_Aide & CRLF & "  Fonctionnalit�e :"
					Mess_Aide = Mess_Aide & CRLF & "   Cette commande utilisable uniquement pendant l'incription d'une propriete"
					Mess_Aide = Mess_Aide & CRLF & "    graphique, permet de choisir une icone representative a la fenetre"
					Mess_Aide = Mess_Aide & CRLF & "   Format PNG, BMP et JPG accepte! Les dimentions recommandes est de 16x16"
					Mess_Aide = Mess_Aide & CRLF & "   Si votre icone ne respecte pas ces dimentions, Cpcdos va l'ajuster automatiquement. "
					Mess_Aide = Mess_Aide & CRLF & "    Oui.. chaque jours, 1 developpeurs sur 3 est touche par de la flemardise..  moi en particulier :P"
					Mess_Aide = Mess_Aide & CRLF & "    et oui, une maladie la plus dangereuse au monde #StopFlemardise.com"
					Mess_Aide = Mess_Aide & CRLF
					Mess_Aide = Mess_Aide & CRLF & "  Si ce parametre n'est pas specifie, ou que l'icone n'est pas disponible l'icone"
					Mess_Aide = Mess_Aide & CRLF & "   par defaut sera ICO_DEF.PNG."
					Mess_Aide = Mess_Aide & CRLF
					Mess_Aide = Mess_Aide & CRLF & "  Exemple :"
					Mess_Aide = Mess_Aide & CRLF & "   -> Voir la commande 'fenetre/'"
					Mess_Aide = Mess_Aide & CRLF
					Mess_Aide = Mess_Aide & CRLF & "  Voir aussi : picturebox/ , textebox/ , textebloc/"
					Mess_Aide = Mess_Aide & CRLF
				ELSEIF CPCDOS_INSTANCE.Utilisateur_Langage = 1 THEN
					Mess_Aide = Mess_Aide & CRLF & "  '.ICON'"
					Mess_Aide = Mess_Aide & CRLF
					Mess_Aide = Mess_Aide & CRLF & "  Fonctionnality :"
					Mess_Aide = Mess_Aide & CRLF & "   This command usable only during registering graphic properties, allow to choice"
					Mess_Aide = Mess_Aide & CRLF & "    the icon of your window. PNG, JPG and BMP formats are accepted! The recommanded"
					Mess_Aide = Mess_Aide & CRLF & "    resolution is 16x16. If this resolution is not respected, Cpcdos will"
					Mess_Aide = Mess_Aide & CRLF & "    re-work automatically for adapting your icon."
					Mess_Aide = Mess_Aide & CRLF
					Mess_Aide = Mess_Aide & CRLF & "  If this parameter is not specified, your window will use default icon ICO_DEF.PNG"
					Mess_Aide = Mess_Aide & CRLF
					Mess_Aide = Mess_Aide & CRLF & "  Exemple :"
					Mess_Aide = Mess_Aide & CRLF & "   -> Seeing 'window/' command"
					Mess_Aide = Mess_Aide & CRLF
					Mess_Aide = Mess_Aide & CRLF & "  See also : picturebox/ , textbox/ , textbloc/"
					Mess_Aide = Mess_Aide & CRLF
				END IF

				DEBUG(Mess_Aide, Affichage, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_SURBRILLE, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.SansDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_AFF, RetourVAR)
				testCMD = 0
				AfficherAide = 0
				exit _scope_CMD, _scope
			END IF
			' Tester la syntaxe
			testCMD	= CCP_Verifier_Syntaxe(Commande, CommPosition)
			IF testCMD > 10 Then exit _scope_CMD, _scope
			IF testCMD > 0 then  ' Entre 1-5 = Pas d'affichage via le @, @$ ou @#
				IF testCMD < 6 then
					Affichage = 0
					IF testCMD = 3 Then CpcdosCP_SHELL("FIX/ " & CPCDOS_INSTANCE.DEBUG_INSTANCE.LeRetour & " = \#NULL", _CLE_, NIVEAU_CCP, Param_1, Param_2) : RetourVAR = _CLE_ & "N" & NIVEAU_CCP & "->" & CPCDOS_INSTANCE.DEBUG_INSTANCE.LeRetour
					if testCMD = 2 Then RetourVAR = "$>" & CPCDOS_INSTANCE.DEBUG_INSTANCE.LeRetour ' ajouter une securite ?
				Else
					Affichage = 1
				END IF
			Else
				Affichage = 1
			END IF
			' Recuperer les Parametres
			Param = MID(Commande, CommPosition + TailleComm + 2)
			SCOPE
			' ====================================================================

			' Retourner le contenu des quotes des proprietes graphiques
			Dim Retour_quotes as String = get_DonneesQuotesPROP_GUI(Param)
				if NOT Instr(Param, CHR(34)) > 0 Then Retour_quotes = "#@#RETOUR-VAL#" & CPCDOS_INSTANCE.DEBUG_INSTANCE.LeRetour

			' Verifier qu'il n'y a pas eu d'erreurs
			IF NOT Retour_quotes = "-1~#ERR" Then
				CpcdosCP_SHELL = "IUG:ICONE=" & Retour_quotes
			else
				Message_erreur = ERRAVT("AVT_065", 0)
				IF CPCDOS_INSTANCE.Utilisateur_Langage = 0 Then
					DEBUG("[CpcdosC+] AVT_065 : " & Message_erreur & ". Commande:" & Commande, Affichage, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_AVERTISSEMENT, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.AvecDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_AFF, RetourVAR)
				Else
					DEBUG("[CpcdosC+] AVT_065 : " & Message_erreur & ". Commande:" & Commande, Affichage, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_AVERTISSEMENT, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.AvecDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_AFF, RetourVAR)
				End If
			End if

			' ====================================================================
			END SCOPE
			exit _scope_CMD, _scope
		End if ' **** .ICONE ****

	_end_scope_CMD

	_scope_CMD

		' =======================================================================
		CommLANG(1) = ".imgtitre"
		CommLANG(2) = ".titleimg"
		CommLANG(3) = "\\#//"
		CommTrouve = 0 : NoCMD = 0
		for boucle as integer = 1 to 2
			IF OnCherche = CommLANG(boucle) Then
				NoCMD = 0
				exit for
			Else
				NoCMD = 1
			End if
		Next boucle
		IF NoCMD = 1 then CommLANG(1) = "[F.#).|" : CommLANG(2) = "[F.#).|" : CommLANG(3) = "\\#//"
		rem Afficher la liste des commandes avec anglais / francais
		IF AfficherAide = 1 then
			IF CPCDOS_INSTANCE.Utilisateur_Langage = 0 then
				CommandesAide = CommandesAide & CRLF & "  IUG -> imgtitre           Image de fond de la barre de titre"
			Else
				CommandesAide = CommandesAide & CRLF & "  GUI -> titleimg           background image of title"
			END IF
		END IF
		IF CommLANG(1) = OnCherche Then CommTrouve = 1
		IF CommLANG(2) = OnCherche Then CommTrouve = 2
		IF CommTrouve > 0 Then ' Afficher l'aide de la commande
			IF AfficherAide = 2 then
				Mess_Aide = ""
				IF CPCDOS_INSTANCE.Utilisateur_Langage = 0 THEN
					Mess_Aide = Mess_Aide & CRLF & "  '.IMGTITRE'"
					Mess_Aide = Mess_Aide & CRLF
					Mess_Aide = Mess_Aide & CRLF & "  Fonctionnalit�e :"
					Mess_Aide = Mess_Aide & CRLF & "   Cette commande utilisable uniquement pendant l'incription d'une propriete"
					Mess_Aide = Mess_Aide & CRLF & "    graphique, permet de choisir votre image de la barre de titre de fond"
					Mess_Aide = Mess_Aide & CRLF & "    de votre fenetre."
					Mess_Aide = Mess_Aide & CRLF & "   Format PNG, BMP et JPG sont acceptes!"

					Mess_Aide = Mess_Aide & CRLF
					Mess_Aide = Mess_Aide & CRLF & "  Si ce parametre n'est pas specifie, la barre sera transparente."
					Mess_Aide = Mess_Aide & CRLF
					Mess_Aide = Mess_Aide & CRLF & "  Exemple :"
					Mess_Aide = Mess_Aide & CRLF & "   -> Voir la commande 'fenetre/'"
					Mess_Aide = Mess_Aide & CRLF
					Mess_Aide = Mess_Aide & CRLF & "  Voir aussi : picturebox/ , textebox/ , textebloc/"
					Mess_Aide = Mess_Aide & CRLF
				ELSEIF CPCDOS_INSTANCE.Utilisateur_Langage = 1 THEN
					Mess_Aide = Mess_Aide & CRLF & "  '.TITLEIMG'"
					Mess_Aide = Mess_Aide & CRLF
					Mess_Aide = Mess_Aide & CRLF & "  Fonctionnality :"
					Mess_Aide = Mess_Aide & CRLF & "   This command usable only during registering graphic properties, allow to choice"
					Mess_Aide = Mess_Aide & CRLF & "    the image background of your title bar of you window."
					Mess_Aide = Mess_Aide & CRLF & "    PNG, JPG and BMP formats are accepted!"
					Mess_Aide = Mess_Aide & CRLF
					Mess_Aide = Mess_Aide & CRLF & "  If this parameter is not specified, the title bar will be transparently"
					Mess_Aide = Mess_Aide & CRLF
					Mess_Aide = Mess_Aide & CRLF & "  Exemple :"
					Mess_Aide = Mess_Aide & CRLF & "   -> Seeing 'window/' command"
					Mess_Aide = Mess_Aide & CRLF
					Mess_Aide = Mess_Aide & CRLF & "  See also : picturebox/ , textbox/ , textbloc/"
					Mess_Aide = Mess_Aide & CRLF
				END IF

				DEBUG(Mess_Aide, Affichage, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_SURBRILLE, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.SansDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_AFF, RetourVAR)
				testCMD = 0
				AfficherAide = 0
				exit _scope_CMD, _scope
			END IF
			' Tester la syntaxe
			testCMD	= CCP_Verifier_Syntaxe(Commande, CommPosition)
			IF testCMD > 10 Then exit _scope_CMD, _scope
			IF testCMD > 0 then  ' Entre 1-5 = Pas d'affichage via le @, @$ ou @#
				IF testCMD < 6 then
					Affichage = 0
					IF testCMD = 3 Then CpcdosCP_SHELL("FIX/ " & CPCDOS_INSTANCE.DEBUG_INSTANCE.LeRetour & " = \#NULL", _CLE_, NIVEAU_CCP, Param_1, Param_2) : RetourVAR = _CLE_ & "N" & NIVEAU_CCP & "->" & CPCDOS_INSTANCE.DEBUG_INSTANCE.LeRetour
					if testCMD = 2 Then RetourVAR = "$>" & CPCDOS_INSTANCE.DEBUG_INSTANCE.LeRetour ' ajouter une securite ?
				Else
					Affichage = 1
				END IF
			Else
				Affichage = 1
			END IF
			' Recuperer les Parametres
			Param = MID(Commande, CommPosition + TailleComm + 2)
			SCOPE
			' ====================================================================

			' Retourner le contenu des quotes des proprietes graphiques
			Dim Retour_quotes as String = get_DonneesQuotesPROP_GUI(Param)
				if NOT Instr(Param, CHR(34)) > 0 Then Retour_quotes = "#@#RETOUR-VAL#" & CPCDOS_INSTANCE.DEBUG_INSTANCE.LeRetour

			' Verifier qu'il n'y a pas eu d'erreurs
			IF NOT Retour_quotes = "-1~#ERR" Then
				CpcdosCP_SHELL = "IUG:IMGTITRE=" & Retour_quotes
			else
				Message_erreur = ERRAVT("AVT_065", 0)
				IF CPCDOS_INSTANCE.Utilisateur_Langage = 0 Then
					DEBUG("[CpcdosC+] AVT_065 : " & Message_erreur & ". Commande:" & Commande, Affichage, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_AVERTISSEMENT, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.AvecDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_AFF, RetourVAR)
				Else
					DEBUG("[CpcdosC+] AVT_065 : " & Message_erreur & ". Commande:" & Commande, Affichage, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_AVERTISSEMENT, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.AvecDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_AFF, RetourVAR)
				End If
			End if

			' ====================================================================
			END SCOPE
			exit _scope_CMD, _scope
		End if ' **** .IMGTITRE ****

	_end_scope_CMD

	_scope_CMD

		' =======================================================================
		CommLANG(1) = ".image"
		CommLANG(2) = ".image"
		CommLANG(3) = "\\#//"
		CommTrouve = 0 : NoCMD = 0
		for boucle as integer = 1 to 2
			IF OnCherche = CommLANG(boucle) Then
				NoCMD = 0
				exit for
			Else
				NoCMD = 1
			End if
		Next boucle
		IF NoCMD = 1 then CommLANG(1) = "[F.#).|" : CommLANG(2) = "[F.#).|" : CommLANG(3) = "\\#//"
		rem Afficher la liste des commandes avec anglais / francais
		IF AfficherAide = 1 then
			IF CPCDOS_INSTANCE.Utilisateur_Langage = 0 then
				CommandesAide = CommandesAide & CRLF & "  IUG -> image              Image du conteneur"
			Else
				CommandesAide = CommandesAide & CRLF & "  GUI -> image              Container image"
			END IF
		END IF
		IF CommLANG(1) = OnCherche Then CommTrouve = 1
		IF CommLANG(2) = OnCherche Then CommTrouve = 2
		IF CommTrouve > 0 Then ' Afficher l'aide de la commande
			IF AfficherAide = 2 then
				Mess_Aide = ""
				IF CPCDOS_INSTANCE.Utilisateur_Langage = 0 THEN
					Mess_Aide = Mess_Aide & CRLF & "  '.IMAGE'"
					Mess_Aide = Mess_Aide & CRLF
					Mess_Aide = Mess_Aide & CRLF & "  Fonctionnalit�e :"
					Mess_Aide = Mess_Aide & CRLF & "   Cette commande utilisable uniquement pendant l'incription d'une propriete"
					Mess_Aide = Mess_Aide & CRLF & "    graphique, permet de choisir votre image du conteneur de votre objet ou "
					Mess_Aide = Mess_Aide & CRLF & "    de votre fenetre."
					Mess_Aide = Mess_Aide & CRLF & "   Format PNG, BMP et JPG sont acceptes!"

					Mess_Aide = Mess_Aide & CRLF
					Mess_Aide = Mess_Aide & CRLF & "  Si ce parametre n'est pas specifie, le conteneur reste neutre"
					Mess_Aide = Mess_Aide & CRLF
					Mess_Aide = Mess_Aide & CRLF & "  Exemple :"
					Mess_Aide = Mess_Aide & CRLF & "   -> Voir la commande 'fenetre/'"
					Mess_Aide = Mess_Aide & CRLF
					Mess_Aide = Mess_Aide & CRLF & "  Voir aussi : picturebox/ , textebox/ , textebloc/"
					Mess_Aide = Mess_Aide & CRLF
				ELSEIF CPCDOS_INSTANCE.Utilisateur_Langage = 1 THEN
					Mess_Aide = Mess_Aide & CRLF & "  '.IMAGE'"
					Mess_Aide = Mess_Aide & CRLF
					Mess_Aide = Mess_Aide & CRLF & "  Fonctionnality :"
					Mess_Aide = Mess_Aide & CRLF & "   This command usable only during registering graphic properties, allow to choice"
					Mess_Aide = Mess_Aide & CRLF & "    the image in your container for your objects or your window"
					Mess_Aide = Mess_Aide & CRLF & "    PNG, JPG and BMP formats are accepted!"
					Mess_Aide = Mess_Aide & CRLF
					Mess_Aide = Mess_Aide & CRLF & "  If this parameter is not specified, container remains neutral."
					Mess_Aide = Mess_Aide & CRLF
					Mess_Aide = Mess_Aide & CRLF & "  Exemple :"
					Mess_Aide = Mess_Aide & CRLF & "   -> Seeing 'window/' command"
					Mess_Aide = Mess_Aide & CRLF
					Mess_Aide = Mess_Aide & CRLF & "  See also : picturebox/ , textbox/ , textbloc/"
					Mess_Aide = Mess_Aide & CRLF
				END IF

				DEBUG(Mess_Aide, Affichage, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_SURBRILLE, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.SansDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_AFF, RetourVAR)
				testCMD = 0
				AfficherAide = 0
				exit _scope_CMD, _scope
			END IF
			' Tester la syntaxe
			testCMD	= CCP_Verifier_Syntaxe(Commande, CommPosition)
			IF testCMD > 10 Then exit _scope_CMD, _scope
			IF testCMD > 0 then  ' Entre 1-5 = Pas d'affichage via le @, @$ ou @#
				IF testCMD < 6 then
					Affichage = 0
					IF testCMD = 3 Then CpcdosCP_SHELL("FIX/ " & CPCDOS_INSTANCE.DEBUG_INSTANCE.LeRetour & " = \#NULL", _CLE_, NIVEAU_CCP, Param_1, Param_2) : RetourVAR = _CLE_ & "N" & NIVEAU_CCP & "->" & CPCDOS_INSTANCE.DEBUG_INSTANCE.LeRetour
					if testCMD = 2 Then RetourVAR = "$>" & CPCDOS_INSTANCE.DEBUG_INSTANCE.LeRetour ' ajouter une securite ?
				Else
					Affichage = 1
				END IF
			Else
				Affichage = 1
			END IF
			' Recuperer les Parametres
			Param = MID(Commande, CommPosition + TailleComm + 2)
			SCOPE
			' ====================================================================

			' Retourner le contenu des quotes des proprietes graphiques
			Dim Retour_quotes as String = get_DonneesQuotesPROP_GUI(Param)
				if NOT Instr(Param, CHR(34)) > 0 Then Retour_quotes = "#@#RETOUR-VAL#" & CPCDOS_INSTANCE.DEBUG_INSTANCE.LeRetour

			' Verifier qu'il n'y a pas eu d'erreurs
			IF NOT Retour_quotes = "-1~#ERR" Then
				CpcdosCP_SHELL = "IUG:IMAGE=" & Retour_quotes
			else
				Message_erreur = ERRAVT("AVT_065", 0)
				IF CPCDOS_INSTANCE.Utilisateur_Langage = 0 Then
					DEBUG("[CpcdosC+] AVT_065 : " & Message_erreur & ". Commande:" & Commande, Affichage, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_AVERTISSEMENT, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.AvecDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_AFF, RetourVAR)
				Else
					DEBUG("[CpcdosC+] AVT_065 : " & Message_erreur & ". Commande:" & Commande, Affichage, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_AVERTISSEMENT, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.AvecDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_AFF, RetourVAR)
				End If
			End if

			' ====================================================================
			END SCOPE

			exit _scope_CMD, _scope
		End if ' **** .IMAGE ****

	_end_scope_CMD

	_scope_CMD

		' =======================================================================
		CommLANG(1) = ".opacite"
		CommLANG(2) = ".opacity"
		CommLANG(3) = "\\#//"
		CommTrouve = 0 : NoCMD = 0
		for boucle as integer = 1 to 2
			IF OnCherche = CommLANG(boucle) Then
				NoCMD = 0
				exit for
			Else
				NoCMD = 1
			End if
		Next boucle
		IF NoCMD = 1 then CommLANG(1) = "[F.#).|" : CommLANG(2) = "[F.#).|" : CommLANG(3) = "\\#//"
		rem Afficher la liste des commandes avec anglais / francais
		IF AfficherAide = 1 then
			IF CPCDOS_INSTANCE.Utilisateur_Langage = 0 then
				CommandesAide = CommandesAide & CRLF & "  IUG -> opacite            Opacite(Alpha) de l'objet/fenetre"
			Else
				CommandesAide = CommandesAide & CRLF & "  GUI -> opacity            Window/object opacity"
			END IF
		END IF
		IF CommLANG(1) = OnCherche Then CommTrouve = 1
		IF CommLANG(2) = OnCherche Then CommTrouve = 2
		IF CommTrouve > 0 Then ' Afficher l'aide de la commande
			IF AfficherAide = 2 then
				Mess_Aide = ""
				IF CPCDOS_INSTANCE.Utilisateur_Langage = 0 THEN
					Mess_Aide = Mess_Aide & CRLF & "  '.OPACITE'"
					Mess_Aide = Mess_Aide & CRLF
					Mess_Aide = Mess_Aide & CRLF & "  Fonctionnalit�e :"
					Mess_Aide = Mess_Aide & CRLF & "   Cette commande utilisable uniquement pendant l'incription d'une propriete"
					Mess_Aide = Mess_Aide & CRLF & "    graphique, permet de choisir la transparence de votre fenetre ou objet"
					Mess_Aide = Mess_Aide & CRLF & "    de votre fenetre."
					Mess_Aide = Mess_Aide & CRLF & "     Valeurs 0:Transparent <--> 255:Opaque"

					Mess_Aide = Mess_Aide & CRLF
					Mess_Aide = Mess_Aide & CRLF & "  Si ce parametre n'est pas specifie, il sera par defaut a 255"
					Mess_Aide = Mess_Aide & CRLF
					Mess_Aide = Mess_Aide & CRLF & "  Exemple :"
					Mess_Aide = Mess_Aide & CRLF & "   -> Voir la commande 'fenetre/'"
					Mess_Aide = Mess_Aide & CRLF
					Mess_Aide = Mess_Aide & CRLF & "  Voir aussi : picturebox/ , textebox/ , textebloc/"
					Mess_Aide = Mess_Aide & CRLF
				ELSEIF CPCDOS_INSTANCE.Utilisateur_Langage = 1 THEN
					Mess_Aide = Mess_Aide & CRLF & "  '.OPACITY'"
					Mess_Aide = Mess_Aide & CRLF
					Mess_Aide = Mess_Aide & CRLF & "  Fonctionnality :"
					Mess_Aide = Mess_Aide & CRLF & "   This command usable only during registering graphic properties, allow to choice"
					Mess_Aide = Mess_Aide & CRLF & "    transparency of your window or gui elements"
					Mess_Aide = Mess_Aide & CRLF & "     Values 0:Transparent <--> 255:Opaque"
					Mess_Aide = Mess_Aide & CRLF
					Mess_Aide = Mess_Aide & CRLF & "  If this parameter is not specified, the default value is 255"
					Mess_Aide = Mess_Aide & CRLF
					Mess_Aide = Mess_Aide & CRLF & "  Exemple :"
					Mess_Aide = Mess_Aide & CRLF & "   -> Seeing 'window/' command"
					Mess_Aide = Mess_Aide & CRLF
					Mess_Aide = Mess_Aide & CRLF & "  See also : picturebox/ , textbox/ , textbloc/"
					Mess_Aide = Mess_Aide & CRLF
				END IF

				DEBUG(Mess_Aide, Affichage, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_SURBRILLE, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.SansDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_AFF, RetourVAR)
				testCMD = 0
				AfficherAide = 0
				exit _scope_CMD, _scope
			END IF
			' Tester la syntaxe
			testCMD	= CCP_Verifier_Syntaxe(Commande, CommPosition)
			IF testCMD > 10 Then exit _scope_CMD, _scope
			IF testCMD > 0 then  ' Entre 1-5 = Pas d'affichage via le @, @$ ou @#
				IF testCMD < 6 then
					Affichage = 0
					IF testCMD = 3 Then CpcdosCP_SHELL("FIX/ " & CPCDOS_INSTANCE.DEBUG_INSTANCE.LeRetour & " = \#NULL", _CLE_, NIVEAU_CCP, Param_1, Param_2) : RetourVAR = _CLE_ & "N" & NIVEAU_CCP & "->" & CPCDOS_INSTANCE.DEBUG_INSTANCE.LeRetour
					if testCMD = 2 Then RetourVAR = "$>" & CPCDOS_INSTANCE.DEBUG_INSTANCE.LeRetour ' ajouter une securite ?
				Else
					Affichage = 1
				END IF
			Else
				Affichage = 1
			END IF
			' Recuperer les Parametres
			Param = MID(Commande, CommPosition + TailleComm + 2)
			SCOPE
			' ====================================================================

			' Retourner le contenu des quotes des proprietes graphiques
			Dim Retour_quotes as String = get_DonneesQuotesPROP_GUI(Param)
				if NOT Instr(Param, CHR(34)) > 0 Then Retour_quotes = "#@#RETOUR-VAL#" & CPCDOS_INSTANCE.DEBUG_INSTANCE.LeRetour

			' Verifier qu'il n'y a pas eu d'erreurs
			IF NOT Retour_quotes = "-1~#ERR" Then
				CpcdosCP_SHELL = "IUG:PROP_ALPHA=" & Retour_quotes
			else
				Message_erreur = ERRAVT("AVT_065", 0)
				IF CPCDOS_INSTANCE.Utilisateur_Langage = 0 Then
					DEBUG("[CpcdosC+] AVT_065 : " & Message_erreur & ". Commande:" & Commande, Affichage, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_AVERTISSEMENT, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.AvecDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_AFF, RetourVAR)
				Else
					DEBUG("[CpcdosC+] AVT_065 : " & Message_erreur & ". Commande:" & Commande, Affichage, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_AVERTISSEMENT, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.AvecDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_AFF, RetourVAR)
				End If
			End if

			' ====================================================================
			END SCOPE
			exit _scope_CMD, _scope
		End if ' **** .OPACITE ****

	_end_scope_CMD

	_scope_CMD

		' =======================================================================
		CommLANG(1) = ".px"
		CommLANG(2) = ".px"
		CommLANG(3) = "\\#//"
		CommTrouve = 0 : NoCMD = 0
		for boucle as integer = 1 to 2
			IF OnCherche = CommLANG(boucle) Then
				NoCMD = 0
				exit for
			Else
				NoCMD = 1
			End if
		Next boucle
		IF NoCMD = 1 then CommLANG(1) = "[F.#).|" : CommLANG(2) = "[F.#).|" : CommLANG(3) = "\\#//"
		rem Afficher la liste des commandes avec anglais / francais
		IF AfficherAide = 1 then
			IF CPCDOS_INSTANCE.Utilisateur_Langage = 0 then
				CommandesAide = CommandesAide & CRLF & "  IUG -> px                 Position horizontale"
			Else
				CommandesAide = CommandesAide & CRLF & "  GUI -> px                 Horizontal position"
			END IF
		END IF
		IF CommLANG(1) = OnCherche Then CommTrouve = 1
		IF CommLANG(2) = OnCherche Then CommTrouve = 2
		IF CommTrouve > 0 Then ' Afficher l'aide de la commande
			IF AfficherAide = 2 then
				Mess_Aide = ""
				IF CPCDOS_INSTANCE.Utilisateur_Langage = 0 THEN
					Mess_Aide = Mess_Aide & CRLF & "  '.PositionX'"
					Mess_Aide = Mess_Aide & CRLF
					Mess_Aide = Mess_Aide & CRLF & "  Fonctionnalit�e :"
					Mess_Aide = Mess_Aide & CRLF & "   Cette commande utilisable uniquement pendant l'incription d'une propriete"
					Mess_Aide = Mess_Aide & CRLF & "    graphique, permet de choisir la position horizontale de la fenetre sur la zone"
					Mess_Aide = Mess_Aide & CRLF & "    horizontale de l'ecran, ou votre object sur la zone horizontale de la fenetre."
					Mess_Aide = Mess_Aide & CRLF
					Mess_Aide = Mess_Aide & CRLF & "  Si ce parametre n'est pas specifie, la fenetre sera place de maniere recursif."
					Mess_Aide = Mess_Aide & CRLF
					Mess_Aide = Mess_Aide & CRLF & "  Exemple :"
					Mess_Aide = Mess_Aide & CRLF & "   -> Voir la commande 'fenetre/'"
					Mess_Aide = Mess_Aide & CRLF
					Mess_Aide = Mess_Aide & CRLF & "  Voir aussi : picturebox/ , textebox/ , textebloc/"
					Mess_Aide = Mess_Aide & CRLF
				ELSEIF CPCDOS_INSTANCE.Utilisateur_Langage = 1 THEN
					Mess_Aide = Mess_Aide & CRLF & "  '.PositionX'"
					Mess_Aide = Mess_Aide & CRLF
					Mess_Aide = Mess_Aide & CRLF & "  Fonctionnality :"
					Mess_Aide = Mess_Aide & CRLF & "   This command usable only during registering graphic properties, allow to choice"
					Mess_Aide = Mess_Aide & CRLF & "    the horizontal position of your window in horizontal screen area"
					Mess_Aide = Mess_Aide & CRLF & "    or an object position in the horizontal area of the window."
					Mess_Aide = Mess_Aide & CRLF
					Mess_Aide = Mess_Aide & CRLF & "  If this parameter is not specified, window will be positioned in a recursive position."
					Mess_Aide = Mess_Aide & CRLF
					Mess_Aide = Mess_Aide & CRLF & "  Exemple :"
					Mess_Aide = Mess_Aide & CRLF & "   -> Seeing 'window/' command"
					Mess_Aide = Mess_Aide & CRLF
					Mess_Aide = Mess_Aide & CRLF & "  See also : picturebox/ , textbox/ , textbloc/"
					Mess_Aide = Mess_Aide & CRLF
				END IF

				DEBUG(Mess_Aide, Affichage, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_SURBRILLE, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.SansDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_AFF, RetourVAR)
				testCMD = 0
				AfficherAide = 0
				exit _scope_CMD, _scope
			END IF
			' Tester la syntaxe
			testCMD	= CCP_Verifier_Syntaxe(Commande, CommPosition)
			IF testCMD > 10 Then exit _scope_CMD, _scope
			IF testCMD > 0 then  ' Entre 1-5 = Pas d'affichage via le @, @$ ou @#
				IF testCMD < 6 then
					Affichage = 0
					IF testCMD = 3 Then CpcdosCP_SHELL("FIX/ " & CPCDOS_INSTANCE.DEBUG_INSTANCE.LeRetour & " = \#NULL", _CLE_, NIVEAU_CCP, Param_1, Param_2) : RetourVAR = _CLE_ & "N" & NIVEAU_CCP & "->" & CPCDOS_INSTANCE.DEBUG_INSTANCE.LeRetour
					if testCMD = 2 Then RetourVAR = "$>" & CPCDOS_INSTANCE.DEBUG_INSTANCE.LeRetour ' ajouter une securite ?
				Else
					Affichage = 1
				END IF
			Else
				Affichage = 1
			END IF
			' Recuperer les Parametres
			Param = MID(Commande, CommPosition + TailleComm + 2)
			SCOPE
			' ====================================================================

			' Retourner le contenu des quotes des proprietes graphiques
			Dim Retour_quotes as String = get_DonneesQuotesPROP_GUI(Param)
				if NOT Instr(Param, CHR(34)) > 0 Then Retour_quotes = "#@#RETOUR-VAL#" & CPCDOS_INSTANCE.DEBUG_INSTANCE.LeRetour
			' Verifier qu'il n'y a pas eu d'erreurs
			IF NOT Retour_quotes = "-1~#ERR" Then
				CpcdosCP_SHELL = "IUG:PROP_PX=" & Retour_quotes
			else
				Message_erreur = ERRAVT("AVT_065", 0)
				IF CPCDOS_INSTANCE.Utilisateur_Langage = 0 Then
					DEBUG("[CpcdosC+] AVT_065 : " & Message_erreur & ". Commande:" & Commande, Affichage, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_AVERTISSEMENT, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.AvecDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_AFF, RetourVAR)
				Else
					DEBUG("[CpcdosC+] AVT_065 : " & Message_erreur & ". Commande:" & Commande, Affichage, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_AVERTISSEMENT, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.AvecDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_AFF, RetourVAR)
				End If
			End if

			' ====================================================================
			END SCOPE
			exit _scope_CMD, _scope
		End if ' **** .PX ****

	_end_scope_CMD

	_scope_CMD

		' =======================================================================
		CommLANG(1) = ".py"
		CommLANG(2) = ".py"
		CommLANG(3) = "\\#//"
		CommTrouve = 0 : NoCMD = 0
		for boucle as integer = 1 to 2
			IF OnCherche = CommLANG(boucle) Then
				NoCMD = 0
				exit for
			Else
				NoCMD = 1
			End if
		Next boucle
		IF NoCMD = 1 then CommLANG(1) = "[F.#).|" : CommLANG(2) = "[F.#).|" : CommLANG(3) = "\\#//"
		rem Afficher la liste des commandes avec anglais / francais
		IF AfficherAide = 1 then
			IF CPCDOS_INSTANCE.Utilisateur_Langage = 0 then
				CommandesAide = CommandesAide & CRLF & "  IUG -> py                 Position verticale"
			Else
				CommandesAide = CommandesAide & CRLF & "  GUI -> py                 Vertical position"
			END IF
		END IF
		IF CommLANG(1) = OnCherche Then CommTrouve = 1
		IF CommLANG(2) = OnCherche Then CommTrouve = 2
		IF CommTrouve > 0 Then ' Afficher l'aide de la commande
			IF AfficherAide = 2 then
				Mess_Aide = ""
				IF CPCDOS_INSTANCE.Utilisateur_Langage = 0 THEN
					Mess_Aide = Mess_Aide & CRLF & "  '.PositionY'"
					Mess_Aide = Mess_Aide & CRLF
					Mess_Aide = Mess_Aide & CRLF & "  Fonctionnalit�e :"
					Mess_Aide = Mess_Aide & CRLF & "   Cette commande utilisable uniquement pendant l'incription d'une propriete"
					Mess_Aide = Mess_Aide & CRLF & "    graphique, permet de choisir la position verticale de la fenetre sur la zone"
					Mess_Aide = Mess_Aide & CRLF & "    verticale de l'ecran, ou votre object sur la zone verticale de la fenetre."
					Mess_Aide = Mess_Aide & CRLF
					Mess_Aide = Mess_Aide & CRLF & "  Si ce parametre n'est pas specifie, la fenetre sera place de maniere recursif."
					Mess_Aide = Mess_Aide & CRLF
					Mess_Aide = Mess_Aide & CRLF & "  Exemple :"
					Mess_Aide = Mess_Aide & CRLF & "   -> Voir la commande 'fenetre/'"
					Mess_Aide = Mess_Aide & CRLF
					Mess_Aide = Mess_Aide & CRLF & "  Voir aussi : picturebox/ , textebox/ , textebloc/"
					Mess_Aide = Mess_Aide & CRLF
				ELSEIF CPCDOS_INSTANCE.Utilisateur_Langage = 1 THEN
					Mess_Aide = Mess_Aide & CRLF & "  '.PositionX'"
					Mess_Aide = Mess_Aide & CRLF
					Mess_Aide = Mess_Aide & CRLF & "  Fonctionnality :"
					Mess_Aide = Mess_Aide & CRLF & "   This command usable only during registering graphic properties, allow to choice"
					Mess_Aide = Mess_Aide & CRLF & "    the vertical position of your window in vertical screen area"
					Mess_Aide = Mess_Aide & CRLF & "    or an object position in the vertical area of the window."
					Mess_Aide = Mess_Aide & CRLF
					Mess_Aide = Mess_Aide & CRLF & "  If this parameter is not specified, window will be positioned in a recursive position."
					Mess_Aide = Mess_Aide & CRLF
					Mess_Aide = Mess_Aide & CRLF & "  Exemple :"
					Mess_Aide = Mess_Aide & CRLF & "   -> Seeing 'window/' command"
					Mess_Aide = Mess_Aide & CRLF
					Mess_Aide = Mess_Aide & CRLF & "  See also : picturebox/ , textbox/ , textbloc/"
					Mess_Aide = Mess_Aide & CRLF
				END IF

				DEBUG(Mess_Aide, Affichage, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_SURBRILLE, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.SansDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_AFF, RetourVAR)
				testCMD = 0
				AfficherAide = 0
				exit _scope_CMD, _scope
			END IF
			' Tester la syntaxe
			testCMD	= CCP_Verifier_Syntaxe(Commande, CommPosition)
			IF testCMD > 10 Then exit _scope_CMD, _scope
			IF testCMD > 0 then  ' Entre 1-5 = Pas d'affichage via le @, @$ ou @#
				IF testCMD < 6 then
					Affichage = 0
					IF testCMD = 3 Then CpcdosCP_SHELL("FIX/ " & CPCDOS_INSTANCE.DEBUG_INSTANCE.LeRetour & " = \#NULL", _CLE_, NIVEAU_CCP, Param_1, Param_2) : RetourVAR = _CLE_ & "N" & NIVEAU_CCP & "->" & CPCDOS_INSTANCE.DEBUG_INSTANCE.LeRetour
					if testCMD = 2 Then RetourVAR = "$>" & CPCDOS_INSTANCE.DEBUG_INSTANCE.LeRetour ' ajouter une securite ?
				Else
					Affichage = 1
				END IF
			Else
				Affichage = 1
			END IF
			' Recuperer les Parametres
			Param = MID(Commande, CommPosition + TailleComm + 2)
			SCOPE
			' ====================================================================

			' Retourner le contenu des quotes des proprietes graphiques
			Dim Retour_quotes as String = get_DonneesQuotesPROP_GUI(Param)
				if NOT Instr(Param, CHR(34)) > 0 Then Retour_quotes = "#@#RETOUR-VAL#" & CPCDOS_INSTANCE.DEBUG_INSTANCE.LeRetour

			' Verifier qu'il n'y a pas eu d'erreurs
			IF NOT Retour_quotes = "-1~#ERR" Then
				CpcdosCP_SHELL = "IUG:PROP_PY=" & Retour_quotes
			else
				Message_erreur = ERRAVT("AVT_065", 0)
				IF CPCDOS_INSTANCE.Utilisateur_Langage = 0 Then
					DEBUG("[CpcdosC+] AVT_065 : " & Message_erreur & ". Commande:" & Commande, Affichage, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_AVERTISSEMENT, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.AvecDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_AFF, RetourVAR)
				Else
					DEBUG("[CpcdosC+] AVT_065 : " & Message_erreur & ". Commande:" & Commande, Affichage, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_AVERTISSEMENT, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.AvecDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_AFF, RetourVAR)
				End If
			End if

			' ====================================================================
			END SCOPE
			exit _scope_CMD, _scope
		End if ' **** .PY ****

	_end_scope_CMD

	_scope_CMD

		' =======================================================================
		CommLANG(1) = ".tx"
		CommLANG(2) = ".sx"
		CommLANG(3) = "\\#//"
		CommTrouve = 0 : NoCMD = 0
		for boucle as integer = 1 to 2
			IF OnCherche = CommLANG(boucle) Then
				NoCMD = 0
				exit for
			Else
				NoCMD = 1
			End if
		Next boucle
		IF NoCMD = 1 then CommLANG(1) = "[F.#).|" : CommLANG(2) = "[F.#).|" : CommLANG(3) = "\\#//"
		rem Afficher la liste des commandes avec anglais / francais
		IF AfficherAide = 1 then
			IF CPCDOS_INSTANCE.Utilisateur_Langage = 0 then
				CommandesAide = CommandesAide & CRLF & "  IUG -> tx                 Taille horizontale"
			Else
				CommandesAide = CommandesAide & CRLF & "  GUI -> sx                 Horizontal size"
			END IF
		END IF
		IF CommLANG(1) = OnCherche Then CommTrouve = 1
		IF CommLANG(2) = OnCherche Then CommTrouve = 2
		IF CommTrouve > 0 Then ' Afficher l'aide de la commande
			IF AfficherAide = 2 then
				Mess_Aide = ""
				IF CPCDOS_INSTANCE.Utilisateur_Langage = 0 THEN
					Mess_Aide = Mess_Aide & CRLF & "  '.TailleX'"
					Mess_Aide = Mess_Aide & CRLF
					Mess_Aide = Mess_Aide & CRLF & "  Fonctionnalit�e :"
					Mess_Aide = Mess_Aide & CRLF & "   Cette commande utilisable uniquement pendant l'incription d'une propriete"
					Mess_Aide = Mess_Aide & CRLF & "    graphique, permet de choisir la taille horizontale de votre fenetre ou objet."
					Mess_Aide = Mess_Aide & CRLF
					Mess_Aide = Mess_Aide & CRLF & "  Si ce parametre n'est pas specifie, la fenetre sera taillee a '100' pixels"
					Mess_Aide = Mess_Aide & CRLF
					Mess_Aide = Mess_Aide & CRLF & "  Exemple :"
					Mess_Aide = Mess_Aide & CRLF & "   -> Voir la commande 'fenetre/'"
					Mess_Aide = Mess_Aide & CRLF
					Mess_Aide = Mess_Aide & CRLF & "  Voir aussi : picturebox/ , textebox/ , textebloc/"
					Mess_Aide = Mess_Aide & CRLF
				ELSEIF CPCDOS_INSTANCE.Utilisateur_Langage = 1 THEN
					Mess_Aide = Mess_Aide & CRLF & "  '.SizeX'"
					Mess_Aide = Mess_Aide & CRLF
					Mess_Aide = Mess_Aide & CRLF & "  Fonctionnality :"
					Mess_Aide = Mess_Aide & CRLF & "   This command usable only during registering graphic properties, allow to choice"
					Mess_Aide = Mess_Aide & CRLF & "    the horizontal size of your window or your object."
					Mess_Aide = Mess_Aide & CRLF
					Mess_Aide = Mess_Aide & CRLF & "  If this parameter is not specified, window will be sized at '100' pixels"
					Mess_Aide = Mess_Aide & CRLF
					Mess_Aide = Mess_Aide & CRLF & "  Exemple :"
					Mess_Aide = Mess_Aide & CRLF & "   -> Seeing 'window/' command"
					Mess_Aide = Mess_Aide & CRLF
					Mess_Aide = Mess_Aide & CRLF & "  See also : picturebox/ , textbox/ , textbloc/"
					Mess_Aide = Mess_Aide & CRLF
				END IF

				DEBUG(Mess_Aide, Affichage, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_SURBRILLE, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.SansDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_AFF, RetourVAR)
				testCMD = 0
				AfficherAide = 0
				exit _scope_CMD, _scope
			END IF
			' Tester la syntaxe
			testCMD	= CCP_Verifier_Syntaxe(Commande, CommPosition)
			IF testCMD > 10 Then exit _scope_CMD, _scope
			IF testCMD > 0 then  ' Entre 1-5 = Pas d'affichage via le @, @$ ou @#
				IF testCMD < 6 then
					Affichage = 0
					IF testCMD = 3 Then CpcdosCP_SHELL("FIX/ " & CPCDOS_INSTANCE.DEBUG_INSTANCE.LeRetour & " = \#NULL", _CLE_, NIVEAU_CCP, Param_1, Param_2) : RetourVAR = _CLE_ & "N" & NIVEAU_CCP & "->" & CPCDOS_INSTANCE.DEBUG_INSTANCE.LeRetour
					if testCMD = 2 Then RetourVAR = "$>" & CPCDOS_INSTANCE.DEBUG_INSTANCE.LeRetour ' ajouter une securite ?
				Else
					Affichage = 1
				END IF
			Else
				Affichage = 1
			END IF
			' Recuperer les Parametres
			Param = MID(Commande, CommPosition + TailleComm + 2)
			SCOPE
			' ====================================================================

			' Retourner le contenu des quotes des proprietes graphiques
			Dim Retour_quotes as String = get_DonneesQuotesPROP_GUI(Param)
				if NOT Instr(Param, CHR(34)) > 0 Then Retour_quotes = "#@#RETOUR-VAL#" & CPCDOS_INSTANCE.DEBUG_INSTANCE.LeRetour

			' Verifier qu'il n'y a pas eu d'erreurs
			IF NOT Retour_quotes = "-1~#ERR" Then
				CpcdosCP_SHELL = "IUG:PROP_TX=" & Retour_quotes
			else
				Message_erreur = ERRAVT("AVT_065", 0)
				IF CPCDOS_INSTANCE.Utilisateur_Langage = 0 Then
					DEBUG("[CpcdosC+] AVT_065 : " & Message_erreur & ". Commande:" & Commande, Affichage, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_AVERTISSEMENT, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.AvecDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_AFF, RetourVAR)
				Else
					DEBUG("[CpcdosC+] AVT_065 : " & Message_erreur & ". Commande:" & Commande, Affichage, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_AVERTISSEMENT, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.AvecDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_AFF, RetourVAR)
				End If
			End if

			' ====================================================================
			END SCOPE
			exit _scope_CMD, _scope
		End if ' **** .TX ****

	_end_scope_CMD

	_scope_CMD

		' =======================================================================
		CommLANG(1) = ".ty"
		CommLANG(2) = ".sy"
		CommLANG(3) = "\\#//"
		CommTrouve = 0 : NoCMD = 0
		for boucle as integer = 1 to 2
			IF OnCherche = CommLANG(boucle) Then
				NoCMD = 0
				exit for
			Else
				NoCMD = 1
			End if
		Next boucle
		IF NoCMD = 1 then CommLANG(1) = "[F.#).|" : CommLANG(2) = "[F.#).|" : CommLANG(3) = "\\#//"
		rem Afficher la liste des commandes avec anglais / francais
		IF AfficherAide = 1 then
			IF CPCDOS_INSTANCE.Utilisateur_Langage = 0 then
				CommandesAide = CommandesAide & CRLF & "  IUG -> ty                 Taille verticale"
			Else
				CommandesAide = CommandesAide & CRLF & "  GUI -> sy                 Vertical size"
			END IF
		END IF
		IF CommLANG(1) = OnCherche Then CommTrouve = 1
		IF CommLANG(2) = OnCherche Then CommTrouve = 2
		IF CommTrouve > 0 Then ' Afficher l'aide de la commande
			IF AfficherAide = 2 then
				Mess_Aide = ""
				IF CPCDOS_INSTANCE.Utilisateur_Langage = 0 THEN
					Mess_Aide = Mess_Aide & CRLF & "  '.TailleY'"
					Mess_Aide = Mess_Aide & CRLF
					Mess_Aide = Mess_Aide & CRLF & "  Fonctionnalit�e :"
					Mess_Aide = Mess_Aide & CRLF & "   Cette commande utilisable uniquement pendant l'incription d'une propriete"
					Mess_Aide = Mess_Aide & CRLF & "    graphique, permet de choisir la taille verticale de votre fenetre ou objet."
					Mess_Aide = Mess_Aide & CRLF
					Mess_Aide = Mess_Aide & CRLF & "  Si ce parametre n'est pas specifie, la fenetre taillee a '150' pixels"
					Mess_Aide = Mess_Aide & CRLF
					Mess_Aide = Mess_Aide & CRLF & "  Exemple :"
					Mess_Aide = Mess_Aide & CRLF & "   -> Voir la commande 'fenetre/'"
					Mess_Aide = Mess_Aide & CRLF
					Mess_Aide = Mess_Aide & CRLF & "  Voir aussi : picturebox/ , textebox/ , textebloc/"
					Mess_Aide = Mess_Aide & CRLF
				ELSEIF CPCDOS_INSTANCE.Utilisateur_Langage = 1 THEN
					Mess_Aide = Mess_Aide & CRLF & "  '.SizeY'"
					Mess_Aide = Mess_Aide & CRLF
					Mess_Aide = Mess_Aide & CRLF & "  Fonctionnality :"
					Mess_Aide = Mess_Aide & CRLF & "   This command usable only during registering graphic properties, allow to choice"
					Mess_Aide = Mess_Aide & CRLF & "    the vertical size of your window, or object"
					Mess_Aide = Mess_Aide & CRLF
					Mess_Aide = Mess_Aide & CRLF & "  If this parameter is not specified, window will be sized at '150' pixels"
					Mess_Aide = Mess_Aide & CRLF
					Mess_Aide = Mess_Aide & CRLF & "  Exemple :"
					Mess_Aide = Mess_Aide & CRLF & "   -> Seeing 'window/' command"
					Mess_Aide = Mess_Aide & CRLF
					Mess_Aide = Mess_Aide & CRLF & "  See also : picturebox/ , textbox/ , textbloc/"
					Mess_Aide = Mess_Aide & CRLF
				END IF

				DEBUG(Mess_Aide, Affichage, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_SURBRILLE, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.SansDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_AFF, RetourVAR)
				testCMD = 0
				AfficherAide = 0
				exit _scope_CMD, _scope
			END IF
			' Tester la syntaxe
			testCMD	= CCP_Verifier_Syntaxe(Commande, CommPosition)
			IF testCMD > 10 Then exit _scope_CMD, _scope
			IF testCMD > 0 then  ' Entre 1-5 = Pas d'affichage via le @, @$ ou @#
				IF testCMD < 6 then
					Affichage = 0
					IF testCMD = 3 Then CpcdosCP_SHELL("FIX/ " & CPCDOS_INSTANCE.DEBUG_INSTANCE.LeRetour & " = \#NULL", _CLE_, NIVEAU_CCP, Param_1, Param_2) : RetourVAR = _CLE_ & "N" & NIVEAU_CCP & "->" & CPCDOS_INSTANCE.DEBUG_INSTANCE.LeRetour
					if testCMD = 2 Then RetourVAR = "$>" & CPCDOS_INSTANCE.DEBUG_INSTANCE.LeRetour ' ajouter une securite ?
				Else
					Affichage = 1
				END IF
			Else
				Affichage = 1
			END IF
			' Recuperer les Parametres
			Param = MID(Commande, CommPosition + TailleComm + 2)
			SCOPE
			' ====================================================================

			' Retourner le contenu des quotes des proprietes graphiques
			Dim Retour_quotes as String = get_DonneesQuotesPROP_GUI(Param)
				if NOT Instr(Param, CHR(34)) > 0 Then Retour_quotes = "#@#RETOUR-VAL#" & CPCDOS_INSTANCE.DEBUG_INSTANCE.LeRetour

			' Verifier qu'il n'y a pas eu d'erreurs
			IF NOT Retour_quotes = "-1~#ERR" Then
				CpcdosCP_SHELL = "IUG:PROP_TY=" & Retour_quotes
			else
				Message_erreur = ERRAVT("AVT_065", 0)
				IF CPCDOS_INSTANCE.Utilisateur_Langage = 0 Then
					DEBUG("[CpcdosC+] AVT_065 : " & Message_erreur & ". Commande:" & Commande, Affichage, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_AVERTISSEMENT, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.AvecDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_AFF, RetourVAR)
				Else
					DEBUG("[CpcdosC+] AVT_065 : " & Message_erreur & ". Commande:" & Commande, Affichage, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_AVERTISSEMENT, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.AvecDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_AFF, RetourVAR)
				End If
			End if

			' ====================================================================
			END SCOPE
			exit _scope_CMD, _scope
		End if ' **** TY ****

	_end_scope_CMD

	_scope_CMD

		' =======================================================================
		CommLANG(1) = ".evenement"
		CommLANG(2) = ".event"
		CommLANG(3) = "\\#//"
		CommTrouve = 0 : NoCMD = 0
		for boucle as integer = 1 to 2
			IF OnCherche = CommLANG(boucle) Then
				NoCMD = 0
				exit for
			Else
				NoCMD = 1
			End if
		Next boucle
		IF NoCMD = 1 then CommLANG(1) = "[F.#).|" : CommLANG(2) = "[F.#).|" : CommLANG(3) = "\\#//"
		rem Afficher la liste des commandes avec anglais / francais
		IF AfficherAide = 1 then
			IF CPCDOS_INSTANCE.Utilisateur_Langage = 0 then
				CommandesAide = CommandesAide & CRLF & "  IUG -> evenement          Fichier contenant les fonctions d'evenements"
			Else
				CommandesAide = CommandesAide & CRLF & "  GUI -> event              File with events functions"
			END IF
		END IF
		IF CommLANG(1) = OnCherche Then CommTrouve = 1
		IF CommLANG(2) = OnCherche Then CommTrouve = 2
		IF CommTrouve > 0 Then ' Afficher l'aide de la commande
			IF AfficherAide = 2 then
				Mess_Aide = ""
				IF CPCDOS_INSTANCE.Utilisateur_Langage = 0 THEN
					Mess_Aide = Mess_Aide & CRLF & "  '.Evenement'"
					Mess_Aide = Mess_Aide & CRLF
					Mess_Aide = Mess_Aide & CRLF & "  Fonctionnalit�e :"
					Mess_Aide = Mess_Aide & CRLF & "   Cette commande utilisable uniquement pendant l'incription d'une propriete"
					Mess_Aide = Mess_Aide & CRLF & "    graphique, permet de definir le fichier source contenant les fonctions evenementielles."
					Mess_Aide = Mess_Aide & CRLF
					Mess_Aide = Mess_Aide & CRLF & "  Un evenement est une interaction graphique ou automatique entre les objets"
					Mess_Aide = Mess_Aide & CRLF & "   et l'utilisateur. Par exemple des que l'utilisateur clique sur un bouton,"
					Mess_Aide = Mess_Aide & CRLF & "   nomme 'MonBouton' avec la propriete .EVENEMENT definit sur 'MonFichier.cpc', il cherchera la ligne"
					Mess_Aide = Mess_Aide & CRLF & "   'FONCTION/ MonBouton.CLIC()' dans le fichier 'MonFichier.cpc'."
					Mess_Aide = Mess_Aide & CRLF & "   si cette fonction n'est pas trouve, le programme continue son execution."
					Mess_Aide = Mess_Aide & CRLF
					Mess_Aide = Mess_Aide & CRLF & "  Si ce propriete n'est pas specifie, aucun evenement sera donc possible !"
					Mess_Aide = Mess_Aide & CRLF
					Mess_Aide = Mess_Aide & CRLF & "  Voir aussi : picturebox/ , textebox/ , textebloc/"
					Mess_Aide = Mess_Aide & CRLF
				ELSEIF CPCDOS_INSTANCE.Utilisateur_Langage = 1 THEN
					Mess_Aide = Mess_Aide & CRLF & "  '.Event'"
					Mess_Aide = Mess_Aide & CRLF
					Mess_Aide = Mess_Aide & CRLF & "  Fonctionnality :"
					Mess_Aide = Mess_Aide & CRLF & "   This command usable only during registering graphic properties, allow to define"
					Mess_Aide = Mess_Aide & CRLF & "    source file, with event content function."
					Mess_Aide = Mess_Aide & CRLF
					Mess_Aide = Mess_Aide & CRLF & "  An event is a graphic ou automatic interaction between objects and user. Example"
					Mess_Aide = Mess_Aide & CRLF & "   when user clic on a button called 'MyButton' with .EVENT propertie defined to 'MyFile.cpc',"
					Mess_Aide = Mess_Aide & CRLF & "   he search this line 'FUNCTION/ MyButton.CLIC()' in 'MyFile.cpc'."
					Mess_Aide = Mess_Aide & CRLF & "   If this file is not found, program continue execution."
					Mess_Aide = Mess_Aide & CRLF
					Mess_Aide = Mess_Aide & CRLF & "  If this propertie is not specified, no event will be possible! "
					Mess_Aide = Mess_Aide & CRLF
					Mess_Aide = Mess_Aide & CRLF & "  See also : picturebox/ , textbox/ , textbloc/"
					Mess_Aide = Mess_Aide & CRLF
				END IF

				DEBUG(Mess_Aide, Affichage, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_SURBRILLE, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.SansDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_AFF, RetourVAR)
				testCMD = 0
				AfficherAide = 0
				exit _scope_CMD, _scope
			END IF
			' Tester la syntaxe
			testCMD	= CCP_Verifier_Syntaxe(Commande, CommPosition)
			IF testCMD > 10 Then exit _scope_CMD, _scope
			IF testCMD > 0 then  ' Entre 1-5 = Pas d'affichage via le @, @$ ou @#
				IF testCMD < 6 then
					Affichage = 0
					IF testCMD = 3 Then CpcdosCP_SHELL("FIX/ " & CPCDOS_INSTANCE.DEBUG_INSTANCE.LeRetour & " = \#NULL", _CLE_, NIVEAU_CCP, Param_1, Param_2) : RetourVAR = _CLE_ & "N" & NIVEAU_CCP & "->" & CPCDOS_INSTANCE.DEBUG_INSTANCE.LeRetour
					if testCMD = 2 Then RetourVAR = "$>" & CPCDOS_INSTANCE.DEBUG_INSTANCE.LeRetour ' ajouter une securite ?
				Else
					Affichage = 1
				END IF
			Else
				Affichage = 1
			END IF
			' Recuperer les Parametres
			Param = MID(Commande, CommPosition + TailleComm + 2)
			SCOPE
			' ====================================================================

			' Retourner le contenu des quotes des proprietes graphiques
			Dim Retour_quotes as String = get_DonneesQuotesPROP_GUI(Param)
				if NOT Instr(Param, CHR(34)) > 0 Then Retour_quotes = "#@#RETOUR-VAL#" & CPCDOS_INSTANCE.DEBUG_INSTANCE.LeRetour

			' Verifier qu'il n'y a pas eu d'erreurs
			IF NOT Retour_quotes = "-1~#ERR" Then
				CpcdosCP_SHELL = "IUG:PROP_EVENEMENT=" & Retour_quotes
			else
				Message_erreur = ERRAVT("AVT_065", 0)
				IF CPCDOS_INSTANCE.Utilisateur_Langage = 0 Then
					DEBUG("[CpcdosC+] AVT_065 : " & Message_erreur & ". Commande:" & Commande, Affichage, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_AVERTISSEMENT, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.AvecDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_AFF, RetourVAR)
				Else
					DEBUG("[CpcdosC+] AVT_065 : " & Message_erreur & ". Commande:" & Commande, Affichage, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_AVERTISSEMENT, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.AvecDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_AFF, RetourVAR)
				End If
			End if

			' ====================================================================
			END SCOPE
			exit _scope_CMD, _scope
		End if ' **** .EVENEMENT ****

	_end_scope_CMD

	_scope_CMD

		' =======================================================================
		CommLANG(1) = "creer/"
		CommLANG(2) = "create/"
		CommLANG(3) = "\\#//"
		CommTrouve = 0 : NoCMD = 0
		for boucle as integer = 1 to 2
			IF OnCherche = CommLANG(boucle) Then
				NoCMD = 0
				exit for
			Else
				NoCMD = 1
			End if
		Next boucle
		IF NoCMD = 1 then CommLANG(1) = "[F.#).|" : CommLANG(2) = "[F.#).|" : CommLANG(3) = "\\#//"
		rem Afficher la liste des commandes avec anglais / francais
		IF AfficherAide = 1 then
			IF CPCDOS_INSTANCE.Utilisateur_Langage = 0 then
				CommandesAide = CommandesAide & CRLF & "  IUG -> creer/             Creer une fenetre ou un objet initialise"
			Else
				CommandesAide = CommandesAide & CRLF & "  GUI -> create/            Create initialised window or object"
			END IF
		END IF
		IF CommLANG(1) = OnCherche Then CommTrouve = 1
		IF CommLANG(2) = OnCherche Then CommTrouve = 2
		IF CommTrouve > 0 Then ' Afficher l'aide de la commande
			IF AfficherAide = 2 then
				Mess_Aide = ""
				IF CPCDOS_INSTANCE.Utilisateur_Langage = 0 THEN
					Mess_Aide = Mess_Aide & CRLF & "  'CREER/'"
					Mess_Aide = Mess_Aide & CRLF
					Mess_Aide = Mess_Aide & CRLF & "  Fonctionnalit�e :"
					Mess_Aide = Mess_Aide & CRLF & "   Cette commande utilisable uniquement avant la fin de l'incription d'une propriete"
					Mess_Aide = Mess_Aide & CRLF & "    graphique, permet de creer votre fenetre ou votre objet."
					Mess_Aide = Mess_Aide & CRLF
					Mess_Aide = Mess_Aide & CRLF & "  Ne peut etre utilise apres un 'FIN/', elle doit imperativement etre utilisee"
					Mess_Aide = Mess_Aide & CRLF & "   pendant l'initialisation des proprietes."
					Mess_Aide = Mess_Aide & CRLF
					Mess_Aide = Mess_Aide & CRLF & "  Exemple :"
					Mess_Aide = Mess_Aide & CRLF & "   -> Voir la commande 'fenetre/'"
					Mess_Aide = Mess_Aide & CRLF
					Mess_Aide = Mess_Aide & CRLF & "  Voir aussi : picturebox/ , textebox/ , textebloc/"
					Mess_Aide = Mess_Aide & CRLF
				ELSEIF CPCDOS_INSTANCE.Utilisateur_Langage = 1 THEN
					Mess_Aide = Mess_Aide & CRLF & "  'CREATE/'"
					Mess_Aide = Mess_Aide & CRLF
					Mess_Aide = Mess_Aide & CRLF & "  Fonctionnality :"
					Mess_Aide = Mess_Aide & CRLF & "   This command usable only during registering graphic properties, allow to create"
					Mess_Aide = Mess_Aide & CRLF & "    your initialised window or object."
					Mess_Aide = Mess_Aide & CRLF
					Mess_Aide = Mess_Aide & CRLF & "  Can't be used after 'END/'. Her must be used during properties initialization."
					Mess_Aide = Mess_Aide & CRLF
					Mess_Aide = Mess_Aide & CRLF & "  Exemple :"
					Mess_Aide = Mess_Aide & CRLF & "   -> Seeing 'window/' command"
					Mess_Aide = Mess_Aide & CRLF
					Mess_Aide = Mess_Aide & CRLF & "  See also : picturebox/ , textbox/ , textbloc/"
					Mess_Aide = Mess_Aide & CRLF
				END IF

				DEBUG(Mess_Aide, Affichage, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_SURBRILLE, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.SansDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_AFF, RetourVAR)
				testCMD = 0
				AfficherAide = 0
				exit _scope_CMD, _scope
			END IF
			' Tester la syntaxe
			testCMD	= CCP_Verifier_Syntaxe(Commande, CommPosition)
			IF testCMD > 10 Then exit _scope_CMD, _scope
			IF testCMD > 0 then  ' Entre 1-5 = Pas d'affichage via le @, @$ ou @#
				IF testCMD < 6 then
					Affichage = 0
					IF testCMD = 3 Then CpcdosCP_SHELL("FIX/ " & CPCDOS_INSTANCE.DEBUG_INSTANCE.LeRetour & " = \#NULL", _CLE_, NIVEAU_CCP, Param_1, Param_2) : RetourVAR = _CLE_ & "N" & NIVEAU_CCP & "->" & CPCDOS_INSTANCE.DEBUG_INSTANCE.LeRetour
					if testCMD = 2 Then RetourVAR = "$>" & CPCDOS_INSTANCE.DEBUG_INSTANCE.LeRetour ' ajouter une securite ?
				Else
					Affichage = 1
				END IF
			Else
				Affichage = 1
			END IF
			' Recuperer les Parametres
			Param = MID(Commande, CommPosition + TailleComm + 2)
			SCOPE
			' ====================================================================

			IF Instr(Param, "/#RENVOIDEBUG:") > 0 Then
				DEBUG(MID(Param, Instr(Param, "/#RENVOIDEBUG:") + 14), Affichage, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_VALIDATION, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.SansDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_AFF, RetourVAR)
			Else
				CpcdosCP_SHELL = "IUG:CREER!"
			End if


			' ====================================================================
			END SCOPE
			exit _scope_CMD, _scope
		End if ' **** CREER/ ****

	_end_scope_CMD

	_scope_CMD

		REM ' ===============================================================
		REM '  Commande conditionnelle
		REM ' ===============================================================
		CommLANG(1) = "si/"
		CommLANG(2) = "if/"
		CommLANG(3) = "\\#//"
		CommTrouve = 0 : NoCMD = 0
		for boucle as integer = 1 to 2
			IF OnCherche = CommLANG(boucle) Then
				NoCMD = 0
				exit for
			Else
				NoCMD = 1
			End if
		Next boucle
		IF NoCMD = 1 then CommLANG(1) = "[F.#).|" : CommLANG(2) = "[F.#).|" : CommLANG(3) = "\\#//"

		REM 'Afficher la liste des commandes avec anglais / francais
		IF AfficherAide = 1 then
			IF CPCDOS_INSTANCE.Utilisateur_Langage = 0 then
				CommandesAide = CommandesAide & CRLF & " si/                        Condition sur deux expresssions"
			Else
				CommandesAide = CommandesAide & CRLF & " if/                        Condition with two expressions"
			END IF
		END IF
		IF CommLANG(1) = OnCherche Then CommTrouve = 1
		IF CommLANG(2) = OnCherche Then CommTrouve = 2
		IF CommTrouve > 0 Then ' Afficher l'aide de la commande
			IF AfficherAide = 2 then
				Mess_Aide = ""
				IF CPCDOS_INSTANCE.Utilisateur_Langage = 0 THEN
					Mess_Aide = Mess_Aide & CRLF & "  'SI'"
					Mess_Aide = Mess_Aide & CRLF
					Mess_Aide = Mess_Aide & CRLF & "  Fonctionnalit�e :"
					Mess_Aide = Mess_Aide & CRLF & "   Cette commande permet d'executer du code sous une condition seulement"
					Mess_Aide = Mess_Aide & CRLF
					Mess_Aide = Mess_Aide & CRLF & " Conditions disponible :"
					Mess_Aide = Mess_Aide & CRLF & "   =  (Egale)                 N=  ou  !=  (Pas egale)"
					Mess_Aide = Mess_Aide & CRLF & "   >  (Superieur)             N>  ou  !>  (Pas superieur)"
					Mess_Aide = Mess_Aide & CRLF & "   <  (Inferieur)             N<  ou  !<  (Pas inferieur)"
					Mess_Aide = Mess_Aide & CRLF & "   >= (Superieur ou egale)    N>= ou  !>= (Pas superieur ou egale)"
					Mess_Aide = Mess_Aide & CRLF & "   <= (Inferieur ou egale)    N<= ou  !<= (Pas Inferieur ou egale)"
					Mess_Aide = Mess_Aide & CRLF & "   ~= (Contient)			  N~= ou  !~= (Ne contient pas)"
					Mess_Aide = Mess_Aide & CRLF
					Mess_Aide = Mess_Aide & CRLF & "  Exemple simple (Mono ligne):"
					Mess_Aide = Mess_Aide & CRLF & "   si/ " & CHR(34) & "%Valeur1%" & CHR(34) & " = " & CHR(34) & "5" & CHR(34) & " alors: txt/ Ok!"
					Mess_Aide = Mess_Aide & CRLF
					Mess_Aide = Mess_Aide & CRLF & "  Exemple simple (Multiligne):"
					Mess_Aide = Mess_Aide & CRLF & "   si/ " & CHR(34) & "5" & CHR(34) & " = " & CHR(34) & "%Valeur2%" & CHR(34) & " alors:"
					Mess_Aide = Mess_Aide & CRLF & "     txt/ Ok!"
					Mess_Aide = Mess_Aide & CRLF & "     txt/ C'est bon!"
					Mess_Aide = Mess_Aide & CRLF & "   fin/ si"
					Mess_Aide = Mess_Aide & CRLF
					Mess_Aide = Mess_Aide & CRLF & "  Exemple (Monoligne avec sinon):"
					Mess_Aide = Mess_Aide & CRLF & "   si/ " & CHR(34) & "%Valeur1%" & CHR(34) & " = " & CHR(34) & "5" & CHR(34) & " alors: txt/ Ok! sinon:txt/ Faux!"
					Mess_Aide = Mess_Aide & CRLF
					Mess_Aide = Mess_Aide & CRLF & "  Exemple (Multiligne):"
					Mess_Aide = Mess_Aide & CRLF & "   si/ " & CHR(34) & "5" & CHR(34) & " = " & CHR(34) & "%Valeur2%" & CHR(34) & " alors:"
					Mess_Aide = Mess_Aide & CRLF & "     txt/ Ok!"
					Mess_Aide = Mess_Aide & CRLF & "     txt/ C'est bon!"
					Mess_Aide = Mess_Aide & CRLF & "   sinon:"
					Mess_Aide = Mess_Aide & CRLF & "     txt/ Faux!"
					Mess_Aide = Mess_Aide & CRLF & "     txt/ pas bien!"
					Mess_Aide = Mess_Aide & CRLF & "   fin/ si"
					Mess_Aide = Mess_Aide & CRLF
					Mess_Aide = Mess_Aide & CRLF & "  Exemple (Multiligne/mono):"
					Mess_Aide = Mess_Aide & CRLF & "   si/ " & CHR(34) & "%Valeur1%" & CHR(34) & " = " & CHR(34) & "5" & CHR(34) & " alors:"
					Mess_Aide = Mess_Aide & CRLF & "     txt/ Ok!"
					Mess_Aide = Mess_Aide & CRLF & "     txt/ C'est bon!"
					Mess_Aide = Mess_Aide & CRLF & "   sinon: txt/ C'est bon!"
					Mess_Aide = Mess_Aide & CRLF
					Mess_Aide = Mess_Aide & CRLF & "  Exemple (Mono ligne/Multiligne):"
					Mess_Aide = Mess_Aide & CRLF & "   si/ " & CHR(34) & "%Valeur1%" & CHR(34) & " = " & CHR(34) & "5" & CHR(34) & " alors:txt/ Ok!"
					Mess_Aide = Mess_Aide & CRLF & "   sinon:"
					Mess_Aide = Mess_Aide & CRLF & "     txt/ C'est bon!"
					Mess_Aide = Mess_Aide & CRLF & "     txt/ Okai"
					Mess_Aide = Mess_Aide & CRLF & "   fin/ si"
					Mess_Aide = Mess_Aide & CRLF
					Mess_Aide = Mess_Aide & CRLF & "  Voir aussi : "
					Mess_Aide = Mess_Aide & CRLF
				ELSEIF CPCDOS_INSTANCE.Utilisateur_Langage = 1 THEN
					Mess_Aide = Mess_Aide & CRLF & "  'IF'"
					Mess_Aide = Mess_Aide & CRLF
					Mess_Aide = Mess_Aide & CRLF & "  Fonctionnality :"
					Mess_Aide = Mess_Aide & CRLF & "   This command allow to execute code under condition only"
					Mess_Aide = Mess_Aide & CRLF
					Mess_Aide = Mess_Aide & CRLF & " Avaiable conditions :"
					Mess_Aide = Mess_Aide & CRLF & "   =  (Equal)                 N=  ou  !=  (Not equal)"
					Mess_Aide = Mess_Aide & CRLF & "   >  (upper)                 N>  ou  !>  (Not upper)"
					Mess_Aide = Mess_Aide & CRLF & "   <  (lower)                 N<  ou  !<  (Not lower)"
					Mess_Aide = Mess_Aide & CRLF & "   >= (upper ou equal)        N>= ou  !>= (Not upper ou equal)"
					Mess_Aide = Mess_Aide & CRLF & "   <= (lower ou equal)        N<= ou  !<= (Not lower ou equal)"
					Mess_Aide = Mess_Aide & CRLF & "   ~= (Content)			  	  N~= ou  !~= (Not content)"
					Mess_Aide = Mess_Aide & CRLF
					Mess_Aide = Mess_Aide & CRLF & "  1.Example (Mono ligne):"
					Mess_Aide = Mess_Aide & CRLF & "   if/ " & CHR(34) & "%Value1%" & CHR(34) & " = " & CHR(34) & "5" & CHR(34) & " then: txt/ Ok!"
					Mess_Aide = Mess_Aide & CRLF
					Mess_Aide = Mess_Aide & CRLF & "  2.Simple example (Multiligne):"
					Mess_Aide = Mess_Aide & CRLF & "   if/ " & CHR(34) & "5" & CHR(34) & " = " & CHR(34) & "%Value2%" & CHR(34) & " then:"
					Mess_Aide = Mess_Aide & CRLF & "     txt/ Ok!"
					Mess_Aide = Mess_Aide & CRLF & "     txt/ C'est bon!"
					Mess_Aide = Mess_Aide & CRLF & "   fin/ if"
					Mess_Aide = Mess_Aide & CRLF
					Mess_Aide = Mess_Aide & CRLF
					Mess_Aide = Mess_Aide & CRLF & "  3.Example (Monoligne with else):"
					Mess_Aide = Mess_Aide & CRLF & "   if/ " & CHR(34) & "%Value1%" & CHR(34) & " = " & CHR(34) & "5" & CHR(34) & " then: txt/ Ok! else:txt/ Faux!"
					Mess_Aide = Mess_Aide & CRLF
					Mess_Aide = Mess_Aide & CRLF & "  4.Example (Multiligne):"
					Mess_Aide = Mess_Aide & CRLF & "   if/ " & CHR(34) & "5" & CHR(34) & " = " & CHR(34) & "%Value2%" & CHR(34) & " then:"
					Mess_Aide = Mess_Aide & CRLF & "     txt/ Ok!"
					Mess_Aide = Mess_Aide & CRLF & "     txt/ C'est bon!"
					Mess_Aide = Mess_Aide & CRLF & "   else:"
					Mess_Aide = Mess_Aide & CRLF & "     txt/ Faux!"
					Mess_Aide = Mess_Aide & CRLF & "     txt/ pas bien!"
					Mess_Aide = Mess_Aide & CRLF & "   fin/ if"
					Mess_Aide = Mess_Aide & CRLF
					Mess_Aide = Mess_Aide & CRLF & "  5.Example (Multiligne/mono):"
					Mess_Aide = Mess_Aide & CRLF & "   if/ " & CHR(34) & "%Value1%" & CHR(34) & " = " & CHR(34) & "5" & CHR(34) & " then:"
					Mess_Aide = Mess_Aide & CRLF & "     txt/ Ok!"
					Mess_Aide = Mess_Aide & CRLF & "     txt/ C'est bon!"
					Mess_Aide = Mess_Aide & CRLF & "   else: txt/ C'est bon!"
					Mess_Aide = Mess_Aide & CRLF
					Mess_Aide = Mess_Aide & CRLF & "  6.Example (Mono ligne/Multiligne):"
					Mess_Aide = Mess_Aide & CRLF & "   if/ " & CHR(34) & "%Value1%" & CHR(34) & " = " & CHR(34) & "5" & CHR(34) & " then:txt/ Ok!"
					Mess_Aide = Mess_Aide & CRLF & "   else:"
					Mess_Aide = Mess_Aide & CRLF & "     txt/ C'est bon!"
					Mess_Aide = Mess_Aide & CRLF & "     txt/ Okai"
					Mess_Aide = Mess_Aide & CRLF & "   fin/ if"
					Mess_Aide = Mess_Aide & CRLF
					Mess_Aide = Mess_Aide & CRLF & "  See also : "
					Mess_Aide = Mess_Aide & CRLF
				END IF

				DEBUG(Mess_Aide, Affichage, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_SURBRILLE, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.SansDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_AFF, RetourVAR)
				testCMD = 0
				AfficherAide = 0
				exit _scope_CMD, _scope
			END IF
			' Tester la syntaxe
			testCMD	= CCP_Verifier_Syntaxe(Commande, CommPosition)
			IF testCMD > 10 Then exit _scope_CMD, _scope
			IF testCMD > 0 then  ' Entre 1-5 = Pas d'affichage via le @, @$ ou @#
				IF testCMD < 6 then
					Affichage = 0
					IF testCMD = 3 Then CpcdosCP_SHELL("FIX/ " & CPCDOS_INSTANCE.DEBUG_INSTANCE.LeRetour & " = \#NULL", _CLE_, NIVEAU_CCP, Param_1, Param_2) : RetourVAR = _CLE_ & "N" & NIVEAU_CCP & "->" & CPCDOS_INSTANCE.DEBUG_INSTANCE.LeRetour
					if testCMD = 2 Then RetourVAR = "$>" & CPCDOS_INSTANCE.DEBUG_INSTANCE.LeRetour ' ajouter une securite ?
				Else
					Affichage = 1
				END IF
			Else
				Affichage = 1
			END IF
			' Recuperer les Parametres
			Param = MID(Commande, CommPosition + TailleComm + 2)
			SCOPE
			' ====================================================================


			' AJOUTER : <> Different de


			Dim SI_ResultatCondition		as integer = 0 ' VRAIS / FAUX
			Dim SI_NonVAL					as integer
			Dim SI_RecupASCII_1 			as integer
			Dim SI_RecupASCII_2 			as integer

			Dim LA_Condition				as integer
			Dim Taille_Condition			as integer

			Dim SI_PosEgale 				as integer ' x = y
			Dim SI_PosPasEgale 				as integer ' x N= y
			Dim SI_PosPasEgaleN				as integer ' x != y

			Dim SI_PosContient 				as integer ' x ~= y
			Dim SI_PosContientPas			as integer ' x N~= y

			Dim SI_PosSuperieur				as integer ' x > y
			Dim SI_PosInferieur				as integer ' x < x

			Dim SI_PosEgaleSuperieur		as integer ' x => x
			Dim SI_PosEgaleInferieur		as integer ' x =< x

			Dim SI_PosPasSuperieur			as integer ' x N> x
			Dim SI_PosPasInferieur			as integer ' x N< x

			Dim SI_PosPasEgaleSuperieur		as integer ' x N=> x  ou
			Dim SI_PosPasEgaleInferieur		as integer ' x N=< x  ou

			Dim SI_PosAlors					as integer ' alors:   ou   then:
			Dim SI_PosAlorsREV				as integer ' alors:   ou   then:
			Dim SI_Alors_T					as integer
			Dim SI_PosSinon					as integer ' sinon:   ou   else:
			Dim SI_Sinon_T					as integer

			Dim SI_POSGuil_EXP_1			as integer
			Dim SI_POSGuil_EXP_2			as integer

			Dim SI_Expression_1				as string ' x
			Dim SI_Expression_2				as string ' y

			SI_PosAlors = Instr(UCASE(Param), "ALORS:") : SI_Alors_T = 5
			if NOT SI_PosAlors > 0 then SI_PosAlors = Instr(UCASE(Param), "THEN:") : SI_Alors_T = 4

			SI_PosAlorsREV = InstrREV(UCASE(Param), "ALORS:")
			if NOT SI_PosAlorsREV > 0 then SI_PosAlorsREV = InstrREV(UCASE(Param), "THEN:")
			IF SI_PosAlors = SI_PosAlorsREV then
				' Si il y a que 1 seul ALORS:, alors on s'approprie le SINON: si present
				'  Sinon il sera reserve pour le prochain SI/
				SI_PosSinon = Instr(UCASE(Param), "SINON:") : SI_Sinon_T = 5
				if NOT SI_PosSinon > 0 then SI_PosSinon = Instr(UCASE(Param), "ELSE:") : SI_Sinon_T = 4
			End if

			SI_PosEgale 	= Instr(Param, " = ")
			if SI_PosEgale = 0 Then SI_PosEgale = Instr(Param, " == ")

			SI_PosPasEgale 	= Instr(Param, " N= ")
			IF NOT SI_PosPasEgale > 0 then SI_PosPasEgale = Instr(Param, " != ") ' Nouveau

			SI_PosSuperieur = Instr(Param, " > ")
			SI_PosInferieur = Instr(Param, " < ")
			SI_PosEgaleSuperieur = Instr(Param, " >= ")
			SI_PosEgaleInferieur = Instr(Param, " <= ")

			SI_PosContient = Instr(Param, " ~= ")
			SI_PosContientPas = Instr(Param, " N~= ")
			IF NOT SI_PosContientPas > 0 Then SI_PosContientPas = Instr(Param, " !~= ") ' Nouveau

			SI_PosPasSuperieur = Instr(Param, " N> ") ' Ancien
			IF NOT SI_PosPasSuperieur > 0 Then SI_PosPasSuperieur = Instr(Param, " !> ") ' Nouveau

			SI_PosPasInferieur = Instr(Param, " N< ") ' Ancien
			IF NOT SI_PosPasInferieur > 0 Then SI_PosPasInferieur = Instr(Param, " !< ") ' Nouveau

			SI_PosPasEgaleSuperieur = Instr(Param, " N>= ") ' Ancien
			IF NOT SI_PosPasEgaleSuperieur > 0 Then SI_PosPasEgaleSuperieur = Instr(Param, " !>= ") ' Nouvea

			SI_PosPasEgaleInferieur = Instr(Param, " N<= ") ' Ancien
			IF NOT SI_PosPasEgaleInferieur > 0 then SI_PosPasEgaleInferieur = Instr(Param, " !<= ") ' Nouveau

			' Si un autre condition est presente apres le alors:
			if SI_PosAlors > 0 then
				if SI_PosAlors < SI_PosEgale 				then SI_PosEgale = 0
				if SI_PosAlors < SI_PosPasEgale 			then SI_PosPasEgale = 0
				if SI_PosAlors < SI_PosContient 			then SI_PosContient = 0
				if SI_PosAlors < SI_PosContientPas 			then SI_PosContientPas = 0
				if SI_PosAlors < SI_PosSuperieur 			then SI_PosSuperieur = 0
				if SI_PosAlors < SI_PosInferieur 			then SI_PosInferieur = 0
				if SI_PosAlors < SI_PosEgaleSuperieur 		then SI_PosEgaleSuperieur = 0
				if SI_PosAlors < SI_PosEgaleInferieur 		then SI_PosEgaleInferieur = 0
				if SI_PosAlors < SI_PosPasSuperieur 		then SI_PosPasSuperieur = 0
				if SI_PosAlors < SI_PosPasInferieur 		then SI_PosPasInferieur = 0
				if SI_PosAlors < SI_PosPasEgaleSuperieur 	then SI_PosPasEgaleSuperieur = 0
				if SI_PosAlors < SI_PosPasEgaleInferieur 	then SI_PosPasEgaleInferieur = 0
			End if

			IF SI_PosContientPas > 0 Then ' !~=
				LA_Condition = SI_PosContientPas
				Taille_Condition = 5
			elseif SI_PosPasEgaleInferieur > 0 Then ' !<=
				LA_Condition = SI_PosPasEgaleInferieur
				Taille_Condition = 5
			elseif SI_PosPasEgaleSuperieur > 0 Then ' !>=
				LA_Condition = SI_PosPasEgaleSuperieur
				Taille_Condition = 5
			elseif SI_PosPasSuperieur > 0 Then ' !>
				LA_Condition = SI_PosPasSuperieur
				Taille_Condition = 4
			elseif SI_PosPasInferieur > 0 Then ' !<
				LA_Condition = SI_PosPasInferieur
				Taille_Condition = 4
			elseif SI_PosContient > 0 Then ' ~=
				LA_Condition = SI_PosContient
				Taille_Condition = 3
			elseif SI_PosSuperieur > 0 Then ' >
				LA_Condition = SI_PosSuperieur
				Taille_Condition = 3
			elseif SI_PosInferieur > 0 Then ' <
				LA_Condition = SI_PosInferieur
				Taille_Condition = 3
			elseif SI_PosEgaleInferieur > 0 Then ' <=
				LA_Condition = SI_PosEgaleInferieur
				Taille_Condition = 3
			elseif SI_PosEgaleSuperieur > 0 Then ' >=
				LA_Condition = SI_PosEgaleSuperieur
				Taille_Condition = 3
			elseif SI_PosEgale > 0 Then ' =
				LA_Condition = SI_PosEgale
				Taille_Condition = 3
			elseif SI_PosPasEgale > 0 Then ' !=
				LA_Condition = SI_PosPasEgale
				Taille_Condition = 4
			Else
				Message_erreur = ERRAVT("AVT_018", 0)
				DEBUG("CpcdosC+ :" & Message_erreur & ". --> " & Commande, Affichage, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_AVERTISSEMENT, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.AvecDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_AFF, RetourVAR)
				exit _scope_CMD, _scope
			end if

			' Recuperer les expressions entre le debut , '=' puis 'alors:'
			SI_Expression_1 = MID(Param, 1, LA_Condition - 1)
			SI_Expression_2 = MID(Param, LA_Condition + Taille_Condition, SI_PosAlors - (LA_Condition + Taille_Condition))

			' On recupere la position du premier " et le deuxi�me " pour la PREMIERE expression
			SI_POSGuil_EXP_1 = Instr(SI_Expression_1, CHR(34)) ' guillemet de gauche
			SI_POSGuil_EXP_2 = InstrRev(SI_Expression_1, CHR(34)) ' guillemet de droit

			if SI_POSGuil_EXP_1 < 0 OR _
				SI_POSGuil_EXP_2 < 0 OR _
				SI_POSGuil_EXP_1 = SI_POSGuil_EXP_2 OR _
				SI_POSGuil_EXP_1 > SI_POSGuil_EXP_2 Then

				' Erreur de guillemets
				Message_erreur = ERRAVT("AVT_017", 0)
				DEBUG("CpcdosC+ :" & Message_erreur & ". --> " & Commande, Affichage, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_AVERTISSEMENT, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.AvecDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_AFF, RetourVAR)
				exit _scope_CMD, _scope

			End if

			' *** Recuperer la premiere expression finale ***
			SI_Expression_1 = MID(SI_Expression_1, SI_POSGuil_EXP_1 + 1, (SI_POSGuil_EXP_2 - SI_POSGuil_EXP_1) - 1)


			' On recupere la position du premier " et le deuxi�me " pour la DEUXIEME expression
			SI_POSGuil_EXP_1 =  Instr(SI_Expression_2, CHR(34)) ' guillemet de gauche
			SI_POSGuil_EXP_2 =  Instrrev(SI_Expression_2, CHR(34)) ' guillemet de droit

			' *** Recuperer la deuxieme expression finale ***
			SI_Expression_2 = MID(SI_Expression_2, SI_POSGuil_EXP_1 + 1, (SI_POSGuil_EXP_2 - SI_POSGuil_EXP_1) - 1)


			SI_NonVAL = 0
			' Chercher la presence d'une chaine de caractere (et/ou avec exp numerique) ou d'un expression numerique seulement
			for SI_BoucleNB as integer = 1 to Len(SI_Expression_1)
				SI_RecupASCII_1 = ASC(MID(SI_Expression_1, SI_BoucleNB, 1)) ' Recuperer 1 caractere par 1
				IF SI_RecupASCII_1 < 48 Then ' Si plus petit que zero en ASCII
					SI_NonVAL = 1
					exit for ' Pas besoin de chercher plus.On optimise
				ElseIF SI_RecupASCII_1 > 57 then ' Si plus grand que 9 en ASCII
					SI_NonVAL = 1
					exit for ' Pas besoin de chercher plus.On optimise
				End if
			next SI_BoucleNB

			for SI_BoucleNB as integer = 1 to Len(SI_Expression_2)
				SI_RecupASCII_2 = ASC(MID(SI_Expression_2, SI_BoucleNB, 1)) ' Recuperer 1 caractere par 1

				IF SI_RecupASCII_2 < 48 Then ' Si plus petit que zero en ASCII
					SI_NonVAL = 1
					exit for ' Pas besoin de chercher plus.On optimise
				ElseIF SI_RecupASCII_2 > 57 then ' Si plus grand que 9 en ASCII
					SI_NonVAL = 1
					exit for ' Pas besoin de chercher plus.On optimise
				End if
			next SI_BoucleNB

			' Tests conditionnels
			IF SI_PosContient > 0 Then
				IF INSTR(SI_Expression_1, SI_Expression_2) > 0 then ' ~=
					SI_ResultatCondition = 1
				Else
					SI_ResultatCondition = 0
				End if
			elseif SI_PosContientPas > 0 Then
				IF INSTR(SI_Expression_1, SI_Expression_2) > 0 then ' ~=
					SI_ResultatCondition = 0
				Else
					SI_ResultatCondition = 1
				End if
			elseif SI_PosPasEgaleInferieur > 0 Then
				IF SI_NonVAL = 1 then
					IF CPCDOS_INSTANCE.Utilisateur_Langage = 0 Then
						DEBUG("CpcdosC+ : Presence de caracteres non numeriques. --> " & Commande, Affichage, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_Normal, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.AvecDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_CPCDOS, RetourVAR)
					Else
						DEBUG("CpcdosC+ : Presence of non-numeric characters. --> " & Commande, Affichage, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_Normal, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.AvecDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_CPCDOS, RetourVAR)
					End If
				End if
				IF NOT Val(SI_Expression_1) <= val(SI_Expression_2) Then ' !<=
					SI_ResultatCondition = 1
				Else
					SI_ResultatCondition = 0
				End if
			elseif SI_PosPasEgaleSuperieur > 0 Then
				IF SI_NonVAL = 1 then
					IF CPCDOS_INSTANCE.Utilisateur_Langage = 0 Then
						DEBUG("CpcdosC+ : Presence de caracteres non numeriques. --> " & Commande, Affichage, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_Normal, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.AvecDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_CPCDOS, RetourVAR)
					Else
						DEBUG("CpcdosC+ : Presence of non-numeric characters. --> " & Commande, Affichage, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_Normal, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.AvecDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_CPCDOS, RetourVAR)
					End If
				End if
				IF NOT Val(SI_Expression_1) >= val(SI_Expression_2) Then ' !>=
					SI_ResultatCondition = 1
				Else
					SI_ResultatCondition = 0
				End if
			elseif SI_PosPasSuperieur > 0 Then
				IF SI_NonVAL = 1 then
					IF CPCDOS_INSTANCE.Utilisateur_Langage = 0 Then
						DEBUG("CpcdosC+ : Presence de caracteres non numeriques. --> " & Commande, Affichage, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_Normal, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.AvecDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_CPCDOS, RetourVAR)
					Else
						DEBUG("CpcdosC+ : Presence of non-numeric characters. --> " & Commande, Affichage, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_Normal, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.AvecDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_CPCDOS, RetourVAR)
					End If
				End if
				IF NOT Val(SI_Expression_1) > val(SI_Expression_2) Then ' !>
					SI_ResultatCondition = 1
				Else
					SI_ResultatCondition = 0
				End if
			elseif SI_PosPasInferieur > 0 Then
				IF SI_NonVAL = 1 then
					IF CPCDOS_INSTANCE.Utilisateur_Langage = 0 Then
						DEBUG("CpcdosC+ : Presence de caracteres non numeriques. --> " & Commande, Affichage, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_Normal, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.AvecDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_CPCDOS, RetourVAR)
					Else
						DEBUG("CpcdosC+ : Presence of non-numeric characters. --> " & Commande, Affichage, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_Normal, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.AvecDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_CPCDOS, RetourVAR)
					End If
				End if
				IF NOT Val(SI_Expression_1) < val(SI_Expression_2) Then ' !<
					SI_ResultatCondition = 1
				Else
					SI_ResultatCondition = 0
				End if
			elseif SI_PosSuperieur > 0 Then
				IF SI_NonVAL = 1 then
					IF CPCDOS_INSTANCE.Utilisateur_Langage = 0 Then
						DEBUG("CpcdosC+ : Presence de caracteres non numeriques. --> " & Commande, Affichage, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_AVERTISSEMENT, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.AvecDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_CPCDOS, RetourVAR)
					Else
						DEBUG("CpcdosC+ : Presence of non-numeric characters. --> " & Commande, Affichage, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_AVERTISSEMENT, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.AvecDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_CPCDOS, RetourVAR)
					End If
				End if
				IF Val(SI_Expression_1) > val(SI_Expression_2) Then ' >
					SI_ResultatCondition = 1
				Else
					SI_ResultatCondition = 0
				End if
			elseif SI_PosInferieur > 0 Then
				IF SI_NonVAL = 1 then
					IF CPCDOS_INSTANCE.Utilisateur_Langage = 0 Then
						DEBUG("CpcdosC+ : Presence de caracteres non numeriques. --> " & Commande, Affichage, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_AVERTISSEMENT, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.AvecDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_CPCDOS, RetourVAR)
					Else
						DEBUG("CpcdosC+ : Presence of non-numeric characters. --> " & Commande, Affichage, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_AVERTISSEMENT, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.AvecDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_CPCDOS, RetourVAR)
					End If
				End if
				IF Val(SI_Expression_1) < val(SI_Expression_2) Then ' <
					SI_ResultatCondition = 1
				Else
					SI_ResultatCondition = 0
				End if
			elseif SI_PosEgaleInferieur > 0 Then '
				IF SI_NonVAL = 1 then
					IF CPCDOS_INSTANCE.Utilisateur_Langage = 0 Then
						DEBUG("CpcdosC+ : Presence de caracteres non numeriques. --> " & Commande, Affichage, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_AVERTISSEMENT, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.AvecDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_CPCDOS, RetourVAR)
					Else
						DEBUG("CpcdosC+ : Presence of non-numeric characters. --> " & Commande, Affichage, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_AVERTISSEMENT, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.AvecDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_CPCDOS, RetourVAR)
					End If
				End if
				IF Val(SI_Expression_1) <= val(SI_Expression_2) Then ' <=
					SI_ResultatCondition = 1
				Else
					SI_ResultatCondition = 0
				End if
			elseif SI_PosEgaleSuperieur > 0 Then ' >=
				IF SI_NonVAL = 1 then
					IF CPCDOS_INSTANCE.Utilisateur_Langage = 0 Then
						DEBUG("CpcdosC+ : Presence de caracteres non numeriques. --> " & Commande, Affichage, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_AVERTISSEMENT, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.AvecDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_CPCDOS, RetourVAR)
					Else
						DEBUG("CpcdosC+ : Presence of non-numeric characters. --> " & Commande, Affichage, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_AVERTISSEMENT, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.AvecDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_CPCDOS, RetourVAR)
					End If
				End if
				IF Val(SI_Expression_1) >= val(SI_Expression_2) Then ' >=
					SI_ResultatCondition = 1
				Else
					SI_ResultatCondition = 0
				End if
			elseif SI_PosEgale > 0 Then ' =

				if SI_NonVAL = 1 then ' Si il a pas que des chiffres
					IF SI_Expression_1 = SI_Expression_2 Then ' Chaine
						SI_ResultatCondition = 1
					Else
						SI_ResultatCondition = 0
					End if
				Else ' Si il y a que des chiffres numeriques
					IF Val(SI_Expression_1) = val(SI_Expression_2) Then ' Valeur
						SI_ResultatCondition = 1
					Else
						SI_ResultatCondition = 0
					End if
				End if
			elseif SI_PosPasEgale > 0 Then ' !=
				if SI_NonVAL = 1 then ' Si il a pas que des chiffres
					IF NOT SI_Expression_1 = SI_Expression_2 Then ' Chaine
						SI_ResultatCondition = 1
					Else
						SI_ResultatCondition = 0
					End if
				Else ' Si il y a que des chiffres numeriques
					IF NOT Val(SI_Expression_1) = val(SI_Expression_2) Then ' Valeur
						SI_ResultatCondition = 1
					Else
						SI_ResultatCondition = 0
					End if
				End if
			Else
				Message_erreur = ERRAVT("AVT_018", 0)
				DEBUG("CpcdosC+ :" & Message_erreur & ". --> " & Commande, Affichage, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_AVERTISSEMENT, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.AvecDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_AFF, RetourVAR)
				exit _scope_CMD, _scope
			end if

			' Si le 'alors:' ou 'then:' est manquant alors on renvoie la valeur de la condition
			if NOT SI_PosAlors > 0 then
				DEBUG(str(SI_ResultatCondition), Affichage, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_Normal, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.SansDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_AFF, RetourVAR)
				exit _scope_CMD, _scope
			End if

			' Test final
			IF SI_ResultatCondition = 1 then
				' La condition est VRAIE
				Dim Commande_A_Executer as string
				if SI_PosSinon > 0 then ' Si le ALORS: ou THEN: et SINON: ou ELSE: sont present sur la meme ligne
					Commande_A_Executer = MID(Param, (SI_PosAlors + SI_Alors_T + 1), SI_PosSinon - (SI_PosAlors + SI_Alors_T + 1))
				Else ' s'il y a seulement ALORS:
					Commande_A_Executer = MID(Param, (SI_PosAlors + SI_Alors_T + 1))
				End if
				IF Len(Commande_A_Executer) > 3 then ' Taille minimale d'une commande
					Dim TestRetouuReuuh as string
					' On execute la commande CCP apres le alors

					TestRetouuReuuh = CpcdosCP_SHELL(Commande_A_Executer, _CLE_, NIVEAU_CCP, Param_1, Param_2)
					IF Instr(UCASE(TestRetouuReuuh), "ALLER/ ") > 0 Then
						CpcdosCP_SHELL = TestRetouuReuuh
						exit _scope_CMD, _scope
					End if
				else
					' Sinon on va chercher en mode multiligne
					CpcdosCP_SHELL = "SI:ALORS"
					exit _scope_CMD, _scope
				end if
			ElseIF SI_ResultatCondition = 0 then
				' La condition est FAUSSE

				Dim Commande_A_Executer as string
				IF SI_PosSinon > 0 then ' Si SINON: sur la meme ligne
					Commande_A_Executer = MID(Param, (SI_PosSinon + SI_Sinon_T + 1))

					IF Len(Commande_A_Executer) > 3 then ' Taille minimale d'une commande
						' On execute la commande CCP apres le alors
						CpcdosCP_SHELL(Commande_A_Executer, _CLE_, NIVEAU_CCP, Param_1, Param_2)

						exit _scope_CMD, _scope
					end if
				else
					' Sinon on va chercher en mode multiligne
					IF len(MID(Param, (SI_PosAlors + SI_Alors_T + 1))) > 3 then
						CpcdosCP_SHELL = "SI:FAUX"
					else
						CpcdosCP_SHELL = "SI:SINON"
					End if
				End if
			End if

			' ====================================================================
			END SCOPE
			exit _scope_CMD, _scope
		End if ' **** SI/ ****

	_end_scope_CMD

	_scope_CMD

		' ===============================================================
		'  Fin d'une fonction
		' ===============================================================
		CommLANG(1) = "fin/"
		CommLANG(2) = "end/"
		CommLANG(3) = "\\#//"
		CommTrouve = 0 : NoCMD = 0
		for boucle as integer = 1 to 2
			IF OnCherche = CommLANG(boucle) Then
				NoCMD = 0
				exit for
			Else
				NoCMD = 1
			End if
		Next boucle
		IF NoCMD = 1 then CommLANG(1) = "[F.#).|" : CommLANG(2) = "[F.#).|" : CommLANG(3) = "\\#//"
		rem Afficher la liste des commandes avec anglais / francais
		IF AfficherAide = 1 then
			IF CPCDOS_INSTANCE.Utilisateur_Langage = 0 then
				CommandesAide = CommandesAide & CRLF & " fin/                       Delimite les conditions / fonctions"
			Else
				CommandesAide = CommandesAide & CRLF & " end/                       Condition / function delimiter"
			END IF
		END IF
		IF CommLANG(1) = OnCherche Then CommTrouve = 1
		IF CommLANG(2) = OnCherche Then CommTrouve = 2

		IF CommTrouve > 0 Then ' Afficher l'aide de la commande
			IF AfficherAide = 2 then
				Mess_Aide = ""
				IF CPCDOS_INSTANCE.Utilisateur_Langage = 0 THEN
					Mess_Aide = Mess_Aide & CRLF & "  'FIN'"
					Mess_Aide = Mess_Aide & CRLF
					Mess_Aide = Mess_Aide & CRLF & "  Fonctionnalit�e :"
					Mess_Aide = Mess_Aide & CRLF & "   Cette commande permet simplement de delimiter la fin d'une fonction"
					Mess_Aide = Mess_Aide & CRLF & "   ou d'une condition"
					Mess_Aide = Mess_Aide & CRLF
					Mess_Aide = Mess_Aide & CRLF & "  Exemples :"
					Mess_Aide = Mess_Aide & CRLF & "   si/ 1 = 1 alors:"
					Mess_Aide = Mess_Aide & CRLF & "      Txt/ Vrais"
					Mess_Aide = Mess_Aide & CRLF & "   fin/ si"
					Mess_Aide = Mess_Aide & CRLF
					Mess_Aide = Mess_Aide & CRLF & "   Fonction/ Ma_Fonction()"
					Mess_Aide = Mess_Aide & CRLF & "     txt/ Coucou!"
					Mess_Aide = Mess_Aide & CRLF & "   Fin/ fonction"
					Mess_Aide = Mess_Aide & CRLF
					Mess_Aide = Mess_Aide & CRLF & "   Fenetre/ Ma_fenetre"
					Mess_Aide = Mess_Aide & CRLF & "     ... {voir la syntaxe fenetre/)"
					Mess_Aide = Mess_Aide & CRLF & "   fin/ fenetre"
					Mess_Aide = Mess_Aide & CRLF
					Mess_Aide = Mess_Aide & CRLF & " Voir aussi : Exe/ , SI/ , Fonction/"
				ELSEIF CPCDOS_INSTANCE.Utilisateur_Langage = 1 THEN
					Mess_Aide = Mess_Aide & CRLF & "  'FIN'"
					Mess_Aide = Mess_Aide & CRLF
					Mess_Aide = Mess_Aide & CRLF & "  Fonctionnality :"
					Mess_Aide = Mess_Aide & CRLF & "   This command allow simply to delimit condition or function"
					Mess_Aide = Mess_Aide & CRLF
					Mess_Aide = Mess_Aide & CRLF & "  Exemples :"
					Mess_Aide = Mess_Aide & CRLF & "   if/ 1 = 1 then:"
					Mess_Aide = Mess_Aide & CRLF & "      Txt/ Vrais"
					Mess_Aide = Mess_Aide & CRLF & "   end/ if"
					Mess_Aide = Mess_Aide & CRLF
					Mess_Aide = Mess_Aide & CRLF & "   Function/ Ma_Fonction()"
					Mess_Aide = Mess_Aide & CRLF & "     txt/ Coucou!"
					Mess_Aide = Mess_Aide & CRLF & "   end/ function"
					Mess_Aide = Mess_Aide & CRLF
					Mess_Aide = Mess_Aide & CRLF & "   window/ my_window"
					Mess_Aide = Mess_Aide & CRLF & "     ... {see window/ syntax)"
					Mess_Aide = Mess_Aide & CRLF & "   fin/ fenetre"
					Mess_Aide = Mess_Aide & CRLF
					Mess_Aide = Mess_Aide & CRLF & " See also : Exe/ , IF/ , Function/"
					Mess_Aide = Mess_Aide & CRLF
				END IF
				DEBUG(Mess_Aide, Affichage, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_SURBRILLE, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.SansDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_AFF, RetourVAR)
				testCMD = 0
				AfficherAide = 0
				exit _scope_CMD, _scope
			END IF
			' Tester la syntaxe
			testCMD	= CCP_Verifier_Syntaxe(Commande, CommPosition)
			IF testCMD > 10 Then exit _scope_CMD, _scope
			IF testCMD > 0 then  ' Entre 1-5 = Pas d'affichage via le @, @$ ou @#
				IF testCMD < 6 then
					Affichage = 0
					' 3 = On nettoie / Cree la variable avant de le definir comme sortie
					IF testCMD = 3 Then CpcdosCP_SHELL("FIX/ " & CPCDOS_INSTANCE.DEBUG_INSTANCE.LeRetour & " = \#NULL", _CLE_, NIVEAU_CCP, 0, "") : RetourVAR = _CLE_ & "N" & NIVEAU_CCP & "->" & CPCDOS_INSTANCE.DEBUG_INSTANCE.LeRetour
					if testCMD = 2 Then RetourVAR = "$>" & CPCDOS_INSTANCE.DEBUG_INSTANCE.LeRetour ' ajouter une securite (autorisation d'acces)?
				Else
					Affichage = 1
				END IF
			Else
				Affichage = 1
			END IF
			' Recuperer les Parametres
			Param = MID(Commande, CommPosition + TailleComm + 2)
			SCOPE
			' ====================================================================

			Param = Ucase(LTrim(Ltrim(RTrim(Param), CHR(09))))

			IF Instr(UCASE(Param), "SI") > 0 AND Len(Param) = 2 Then
				CpcdosCP_SHELL = "SI:FIN"
				exit _scope_CMD, _scope
			Elseif Instr(UCASE(Param), "IF") > 0 AND Len(Param) = 2 Then
				CpcdosCP_SHELL = "SI:FIN"
				exit _scope_CMD, _scope
			End if

			IF Instr(UCASE(Param), "FONCTION") > 0 Then
				CpcdosCP_SHELL = "FONCTION:FIN"
				exit _scope_CMD, _scope
			Elseif Instr(UCASE(Param), "FUNCTION") > 0 Then
				CpcdosCP_SHELL = "FONCTION:FIN"
				exit _scope_CMD, _scope
			End if


			IF Instr(UCASE(Param), "FENETRE") > 0 Then
				CpcdosCP_SHELL = "IUG:FENETRE_FIN"
				exit _scope_CMD, _scope
			ElseIF Instr(UCASE(Param), "WINDOW") > 0 Then
				CpcdosCP_SHELL = "IUG:FENETRE_FIN"
				exit _scope_CMD, _scope
			End if


			IF Instr(UCASE(Param), "BOUTON") > 0 Then
				CpcdosCP_SHELL = "IUG:BOUTON_FIN"
				exit _scope_CMD, _scope
			End if
			IF Instr(UCASE(Param), "BUTTON") > 0 Then
				CpcdosCP_SHELL = "IUG:BOUTON_FIN"
				exit _scope_CMD, _scope
			End if


			IF Instr(UCASE(Param), "IMAGEBOX") > 0 Then
				CpcdosCP_SHELL = "IUG:PICTUREBOX_FIN"
				exit _scope_CMD, _scope
			End if
			IF Instr(UCASE(Param), "PICTUREBOX") > 0 Then
				CpcdosCP_SHELL = "IUG:PICTUREBOX_FIN"
				exit _scope_CMD, _scope
			End if

			IF Instr(UCASE(Param), "TEXTEBLOC") > 0 Then
				CpcdosCP_SHELL = "IUG:TEXTEBLOC_FIN"
				exit _scope_CMD, _scope
			ElseIF Instr(UCASE(Param), "TEXTBLOCK") > 0 Then
				CpcdosCP_SHELL = "IUG:TEXTEBLOC_FIN"
				exit _scope_CMD, _scope
			End if

			IF Instr(UCASE(Param), "TEXTEBOX") > 0 Then
				CpcdosCP_SHELL = "IUG:TEXTEBOX_FIN"
				exit _scope_CMD, _scope
			ElseIF Instr(UCASE(Param), "TEXTBOX") > 0 Then
				CpcdosCP_SHELL = "IUG:TEXTEBOX_FIN"
				exit _scope_CMD, _scope
			End if

			IF Instr(UCASE(Param), "BARREPROGRESSION") > 0 Then
				CpcdosCP_SHELL = "IUG:PROGRESSBAR_FIN"
				exit _scope_CMD, _scope
			ElseIF Instr(UCASE(Param), "PROGRESSBAR") > 0 Then
				CpcdosCP_SHELL = "IUG:PROGRESSBAR_FIN"
				exit _scope_CMD, _scope
			End if


			' ====================================================================
			END SCOPE
			exit _scope_CMD, _scope
		End if ' **** FIN/ ****

	_end_scope_CMD

	_scope_CMD

		' ===============================================================
		'  Arreter la lecture d'un fichier CpcdosC+
		' ===============================================================
		CommLANG(1) = "stop/"
		CommLANG(2) = "stop/"
		CommLANG(3) = "\\#//"
		CommTrouve = 0 : NoCMD = 0
		for boucle as integer = 1 to 2
			IF OnCherche = CommLANG(boucle) Then
				NoCMD = 0
				exit for
			Else
				NoCMD = 1
			End if
		Next boucle
		IF NoCMD = 1 then CommLANG(1) = "[F.#).|" : CommLANG(2) = "[F.#).|" : CommLANG(3) = "\\#//"
		rem Afficher la liste des commandes avec anglais / francais
		IF AfficherAide = 1 then
			IF CPCDOS_INSTANCE.Utilisateur_Langage = 0 then
				CommandesAide = CommandesAide & CRLF & " stop/                      Met fin a la lecture d'un fichier .CPC"
			Else
				CommandesAide = CommandesAide & CRLF & " stop/                      Ending .CPC file"
			END IF
		END IF
		IF CommLANG(1) = OnCherche Then CommTrouve = 1
		IF CommLANG(2) = OnCherche Then CommTrouve = 2

		IF CommTrouve > 0 Then ' Afficher l'aide de la commande
			IF AfficherAide = 2 then
				Mess_Aide = ""
				IF CPCDOS_INSTANCE.Utilisateur_Langage = 0 THEN
					Mess_Aide = Mess_Aide & CRLF & "  'STOP'"
					Mess_Aide = Mess_Aide & CRLF
					Mess_Aide = Mess_Aide & CRLF & "  Fonctionnalit�e :"
					Mess_Aide = Mess_Aide & CRLF & "   Cette commande permet simplement de mettre fin a la lecture d'un"
					Mess_Aide = Mess_Aide & CRLF & "   fichier CpcdosC+."
					Mess_Aide = Mess_Aide & CRLF
					Mess_Aide = Mess_Aide & CRLF & "  Exemple :"
					Mess_Aide = Mess_Aide & CRLF & "   Txt/ Cette ligne sera affichee"
					Mess_Aide = Mess_Aide & CRLF & "   Stop/"
					Mess_Aide = Mess_Aide & CRLF & "   Txt/ Cette ligne ne sera jamais affichee"
					Mess_Aide = Mess_Aide & CRLF
					Mess_Aide = Mess_Aide & CRLF & " Voir aussi : exe/ , stopk/"
				ELSEIF CPCDOS_INSTANCE.Utilisateur_Langage = 1 THEN
					Mess_Aide = Mess_Aide & CRLF & "  'STOP'"
					Mess_Aide = Mess_Aide & CRLF
					Mess_Aide = Mess_Aide & CRLF & "  Fonctionnality :"
					Mess_Aide = Mess_Aide & CRLF & "   This command allow simply to stop CpcdosC+ file execution."
					Mess_Aide = Mess_Aide & CRLF
					Mess_Aide = Mess_Aide & CRLF & "  Exemple :"
					Mess_Aide = Mess_Aide & CRLF & "   txt/ This line will be displayed"
					Mess_Aide = Mess_Aide & CRLF & "   stop/"
					Mess_Aide = Mess_Aide & CRLF & "   txt/ This line will never be deplayed"
					Mess_Aide = Mess_Aide & CRLF
					Mess_Aide = Mess_Aide & CRLF & " See also : exe/ , stopk/"
				END IF
				DEBUG(Mess_Aide, Affichage, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_SURBRILLE, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.SansDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_AFF, RetourVAR)
				testCMD = 0
				AfficherAide = 0
				exit _scope_CMD, _scope
			END IF
			' Tester la syntaxe
			testCMD	= CCP_Verifier_Syntaxe(Commande, CommPosition)
			IF testCMD > 10 Then exit _scope_CMD, _scope
			IF testCMD > 0 then  ' Entre 1-5 = Pas d'affichage via le @, @$ ou @#
				IF testCMD < 6 then
					Affichage = 0
					' 3 = On nettoie / Cree la variable avant de le definir comme sortie
					IF testCMD = 3 Then CpcdosCP_SHELL("FIX/ " & CPCDOS_INSTANCE.DEBUG_INSTANCE.LeRetour & " = \#NULL", _CLE_, NIVEAU_CCP, 0, "") : RetourVAR = _CLE_ & "N" & NIVEAU_CCP & "->" & CPCDOS_INSTANCE.DEBUG_INSTANCE.LeRetour
					if testCMD = 2 Then RetourVAR = "$>" & CPCDOS_INSTANCE.DEBUG_INSTANCE.LeRetour ' ajouter une securite (autorisation d'acces)?
				Else
					Affichage = 1
				END IF
			Else
				Affichage = 1
			END IF
			' Recuperer les Parametres
			' Param = MID(Commande, CommPosition + TailleComm + 2)
			' ====================================================================
			CpcdosCP_SHELL = "STOP:FIN"
			exit _scope_CMD, _scope
		End if ' **** STOP/ ****

	_end_scope_CMD

	_scope_CMD

		' ===============================================================
		'  Commande de positionnement
		' ===============================================================
		CommLANG(1) = "pos/"
		CommLANG(2) = "loc/"
		CommLANG(3) = "\\#//"
		CommTrouve = 0 : NoCMD = 0
		for boucle as integer = 1 to 2
			IF OnCherche = CommLANG(boucle) Then
				NoCMD = 0
				exit for
			Else
				NoCMD = 1
			End if
		Next boucle
		IF NoCMD = 1 then CommLANG(1) = "[F.#).|" : CommLANG(2) = "[F.#).|" : CommLANG(3) = "\\#//"
		rem Afficher la liste des commandes avec anglais / francais
		IF AfficherAide = 1 then
			IF CPCDOS_INSTANCE.Utilisateur_Langage = 0 then
				CommandesAide = CommandesAide & CRLF & " pos/                       Positionne ou recupere le curseur console ou GUI"
			Else
				CommandesAide = CommandesAide & CRLF & " loc/                       Locate or get GUI or console cursor"
			END IF
		END IF
		IF CommLANG(1) = OnCherche Then CommTrouve = 1
		IF CommLANG(2) = OnCherche Then CommTrouve = 2
		IF CommTrouve > 0 Then ' Afficher l'aide de la commande
			IF AfficherAide = 2 then
				Mess_Aide = ""
				IF CPCDOS_INSTANCE.Utilisateur_Langage = 0 THEN
					Mess_Aide = Mess_Aide & CRLF & "  'POSitionner'"
					Mess_Aide = Mess_Aide & CRLF
					Mess_Aide = Mess_Aide & CRLF & "  Fonctionnalit�e :"
					Mess_Aide = Mess_Aide & CRLF & "   Cette commande permet d'afficher ou changer de place le curseur console en X / Y"
					Mess_Aide = Mess_Aide & CRLF & "    ou votre curseur graphique quand elle est executee."
					Mess_Aide = Mess_Aide & CRLF
					Mess_Aide = Mess_Aide & CRLF & "  Exemple :"
					Mess_Aide = Mess_Aide & CRLF & "   pos/ x:10"
					Mess_Aide = Mess_Aide & CRLF & "   txt/ Coucou"
					Mess_Aide = Mess_Aide & CRLF & "   pos/ y:5"
					Mess_Aide = Mess_Aide & CRLF & "   txt/ Coucou"
					Mess_Aide = Mess_Aide & CRLF & "   pos/ x:20 y:10"
					Mess_Aide = Mess_Aide & CRLF & "   txt/ Hello!"
					Mess_Aide = Mess_Aide & CRLF
					Mess_Aide = Mess_Aide & CRLF & "  Afficher les valeurs :"
					Mess_Aide = Mess_Aide & CRLF & "   pos/"
					Mess_Aide = Mess_Aide & CRLF & "   pos/ x"
					Mess_Aide = Mess_Aide & CRLF & "   pos/ y"
					Mess_Aide = Mess_Aide & CRLF & "   pos/ x y"
					Mess_Aide = Mess_Aide & CRLF
					Mess_Aide = Mess_Aide & CRLF & "  Voir aussi : txt/ , couleurf/ , couleurp/"
					Mess_Aide = Mess_Aide & CRLF
				ELSEIF CPCDOS_INSTANCE.Utilisateur_Langage = 1 THEN
					Mess_Aide = Mess_Aide & CRLF & "  'LOCate'"
					Mess_Aide = Mess_Aide & CRLF
					Mess_Aide = Mess_Aide & CRLF & "  Fonctionnality :"
					Mess_Aide = Mess_Aide & CRLF & "   This command allow locate your console cursor (x / y)"
					Mess_Aide = Mess_Aide & CRLF & "    or your GUI console when it in execution."
					Mess_Aide = Mess_Aide & CRLF
					Mess_Aide = Mess_Aide & CRLF & "  Exemple :"
					Mess_Aide = Mess_Aide & CRLF & "   pos/ x:10"
					Mess_Aide = Mess_Aide & CRLF & "   txt/ Hello"
					Mess_Aide = Mess_Aide & CRLF & "   pos/ y:5"
					Mess_Aide = Mess_Aide & CRLF & "   txt/ hello"
					Mess_Aide = Mess_Aide & CRLF & "   pos/ x:20 y:10"
					Mess_Aide = Mess_Aide & CRLF & "   txt/ Hello!"
					Mess_Aide = Mess_Aide & CRLF
					Mess_Aide = Mess_Aide & CRLF & "  See also : txt/ , couleurf/ , couleurp/"
					Mess_Aide = Mess_Aide & CRLF
				END IF

				DEBUG(Mess_Aide, Affichage, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_SURBRILLE, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.SansDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_AFF, RetourVAR)
				testCMD = 0
				AfficherAide = 0
				exit _scope_CMD, _scope
			END IF
			' Tester la syntaxe
			testCMD	= CCP_Verifier_Syntaxe(Commande, CommPosition)
			IF testCMD > 10 Then exit _scope_CMD, _scope
			IF testCMD > 0 then  ' Entre 1-5 = Pas d'affichage via le @, @$ ou @#
				IF testCMD < 6 then
					Affichage = 0
					IF testCMD = 3 Then CpcdosCP_SHELL("FIX/ " & CPCDOS_INSTANCE.DEBUG_INSTANCE.LeRetour & " = \#NULL", _CLE_, NIVEAU_CCP, Param_1, Param_2) : RetourVAR = _CLE_ & "N" & NIVEAU_CCP & "->" & CPCDOS_INSTANCE.DEBUG_INSTANCE.LeRetour
					if testCMD = 2 Then RetourVAR = "$>" & CPCDOS_INSTANCE.DEBUG_INSTANCE.LeRetour ' ajouter une securite ?
				Else
					Affichage = 1
				END IF
			Else
				Affichage = 1
			END IF
			' Recuperer les Parametres
			Param = MID(Commande, CommPosition + TailleComm + 2)
			SCOPE
			' ====================================================================

			Dim PosDEFINIR_X as integer
			Dim PosDEFINIR_Y as integer

			Dim PosOBTENIR_X as integer
			Dim PosOBTENIR_Y as integer

			Dim PosFINAL_X as integer
			Dim PosFINAL_Y as integer

			Dim as integer Pos_X, Pos_Y, Scroll_Weel, TypeClic, clip

			if Param = "" Then
				IF CPCDOS_INSTANCE.SCI_INSTANCE.GUI_Exec = TRUE AND CPCDOS_INSTANCE.SCI_INSTANCE.GUI_Mode = TRUE then
					GetMouse(Pos_X, Pos_Y, Scroll_Weel, TypeClic, Clip)

					DEBUG("X:" & Pos_X & " Y:" & Pos_Y, Affichage, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_Normal, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.SansDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_AFF, RetourVAR)
				else
					DEBUG("X:" & POS(0) & " Y:" & CSRLIN - 1, Affichage, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_Normal, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.SansDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_AFF, RetourVAR)
				End if
				exit _scope_CMD, _scope
			End if


			PosDEFINIR_X = instr(UCASE(Param), "X:")
			PosDEFINIR_Y = instr(UCASE(Param), "Y:")

			if PosDEFINIR_X > 0 then ' Si X Present
				if PosDEFINIR_Y > 0 then ' Si Y present
					IF PosDEFINIR_Y > PosDEFINIR_X then ' Si Y > X
						PosFINAL_X = Val(MID(Param, PosDEFINIR_X + 2, Instr(MID(Param, PosDEFINIR_X + 2), " ")-1))
						PosFINAL_Y = Val(MID(Param, PosDEFINIR_Y + 2))
					else ' Si X > Y
						PosFINAL_X = Val(MID(Param, PosDEFINIR_X + 2))
						PosFINAL_Y = Val(MID(Param, PosDEFINIR_Y + 2, Instr(MID(Param, PosDEFINIR_Y + 2), " ")-1))
					end if
				else ' Si Y non present
					PosFINAL_X = Val(MID(Param, PosDEFINIR_X + 2))
				end if
			Elseif PosDEFINIR_Y > 0 then ' Si Y present seulement
				PosFINAL_Y = Val(MID(Param, PosDEFINIR_Y + 2))

			Else' Afficher les positions
				PosDEFINIR_X = instr(UCASE(Param), "X")
				PosDEFINIR_Y = instr(UCASE(Param), "Y")
				if PosDEFINIR_X > 0 Then

					IF CPCDOS_INSTANCE.SCI_INSTANCE.GUI_Exec = TRUE AND CPCDOS_INSTANCE.SCI_INSTANCE.GUI_Mode = TRUE then
						GetMouse(Pos_X, Pos_Y, Scroll_Weel, TypeClic, Clip)

						DEBUG(str(Pos_X), Affichage, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_Normal, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.SansDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_AFF, RetourVAR)
					else
						DEBUG(str(POS(0)), Affichage, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_Normal, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.SansDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_AFF, RetourVAR)
					End if
				end if
				if PosDEFINIR_Y > 0 Then
					IF CPCDOS_INSTANCE.SCI_INSTANCE.GUI_Exec = TRUE AND CPCDOS_INSTANCE.SCI_INSTANCE.GUI_Mode = TRUE then
						GetMouse(Pos_X, Pos_Y, Scroll_Weel, TypeClic, Clip)

						DEBUG(str(Pos_Y), Affichage, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_Normal, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.SansDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_AFF, RetourVAR)
					else
						DEBUG(str(CSRLIN), Affichage, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_Normal, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.SansDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_AFF, RetourVAR)
					End if

				end if
				exit _scope_CMD, _scope
			end if

			if PosFINAL_X > 0 then
				if PosFINAL_Y > 0 Then
					IF CPCDOS_INSTANCE.SCI_INSTANCE.GUI_Exec = TRUE AND CPCDOS_INSTANCE.SCI_INSTANCE.GUI_Mode = TRUE then
						SetMouse(PosFINAL_X, PosFINAL_Y)
					else
						locate int(PosFINAL_Y), int(PosFINAL_X)
					End if
				else
					IF CPCDOS_INSTANCE.SCI_INSTANCE.GUI_Exec = TRUE AND CPCDOS_INSTANCE.SCI_INSTANCE.GUI_Mode = TRUE then
						SetMouse(PosFINAL_X, Pos_Y)
					else
						locate CSRLIN, int(PosFINAL_X)
					End if
				end if
			else
				if PosFINAL_Y > 0 Then
					IF CPCDOS_INSTANCE.SCI_INSTANCE.GUI_Exec = TRUE AND CPCDOS_INSTANCE.SCI_INSTANCE.GUI_Mode = TRUE then
						SetMouse(Pos_X, PosFINAL_Y)
					else
						locate int(PosFINAL_Y), POS(0)
					End if
				else
					IF CPCDOS_INSTANCE.SCI_INSTANCE.GUI_Exec = TRUE AND CPCDOS_INSTANCE.SCI_INSTANCE.GUI_Mode = TRUE then
						GetMouse(Pos_X, Pos_Y, Scroll_Weel, TypeClic, Clip)

						DEBUG("X:" & Pos_X & " Y:" & Pos_Y, Affichage, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_Normal, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.SansDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_AFF, RetourVAR)
					else
						DEBUG("X:" & POS(0) & " Y:" & CSRLIN - 1, Affichage, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_Normal, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.SansDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_AFF, RetourVAR)
					End if

					' Si aucun parametre definir alors on affiche les deux positions sur la meme ligne

				end if

			end if

			' ====================================================================
			END SCOPE
			exit _scope_CMD, _scope
		End if ' **** POS/ ****

	_end_scope_CMD

	_scope_CMD

		REM ' ===============================================================
		REM '  Commande pour stopper brusquement l'OS et fermer le kernel (Non conseille)
		REM ' ===============================================================
		CommLANG(1) = "stopk/"
		CommLANG(2) = "stopk/"
		CommLANG(3) = "\\#//"
		CommTrouve = 0 : NoCMD = 0
		for boucle as integer = 1 to 2
			IF OnCherche = CommLANG(boucle) Then
				NoCMD = 0
				exit for
			Else
				NoCMD = 1
			End if
		Next boucle
		IF NoCMD = 1 then CommLANG(1) = "[F.#).|" : CommLANG(2) = "[F.#).|" : CommLANG(3) = "\\#//"

		REM 'Afficher la liste des commandes avec anglais / francais
		IF AfficherAide = 1 then
			IF CPCDOS_INSTANCE.Utilisateur_Langage = 0 then
				CommandesAide = CommandesAide & CRLF & " stopk/                     Stoppe directement le kernel"
			Else
				CommandesAide = CommandesAide & CRLF & " stopk/                     Stop kernel."
			END IF
		END IF
		IF CommLANG(1) = OnCherche Then CommTrouve = 1
		IF CommLANG(2) = OnCherche Then CommTrouve = 2
		IF CommTrouve > 0 Then ' Afficher l'aide de la commande
			IF AfficherAide = 2 then
				Mess_Aide = ""
				IF CPCDOS_INSTANCE.Utilisateur_Langage = 0 THEN
					Mess_Aide = Mess_Aide & CRLF & "  'stopKernel'"
					Mess_Aide = Mess_Aide & CRLF
					Mess_Aide = Mess_Aide & CRLF & "  Fonctionnalit�e :"
					Mess_Aide = Mess_Aide & CRLF & "   Cette commande permet d'arreter NET, le kernel ( en urgence )"
					Mess_Aide = Mess_Aide & CRLF
					Mess_Aide = Mess_Aide & CRLF & "  Voir aussi : "
					Mess_Aide = Mess_Aide & CRLF
				ELSEIF CPCDOS_INSTANCE.Utilisateur_Langage = 1 THEN
					Mess_Aide = Mess_Aide & CRLF & "  'CLear Screen'"
					Mess_Aide = Mess_Aide & CRLF
					Mess_Aide = Mess_Aide & CRLF & "  Fonctionnality :"
					Mess_Aide = Mess_Aide & CRLF & "   This command allow to stop Kernel (With urgency)"
					Mess_Aide = Mess_Aide & CRLF
					Mess_Aide = Mess_Aide & CRLF & "  See also : "
					Mess_Aide = Mess_Aide & CRLF
				END IF

				DEBUG(Mess_Aide, Affichage, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_SURBRILLE, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.SansDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_AFF, RetourVAR)
				testCMD = 0
				AfficherAide = 0
				exit _scope_CMD, _scope
			END IF
			' Tester la syntaxe
			testCMD	= CCP_Verifier_Syntaxe(Commande, CommPosition)
			IF testCMD > 10 Then exit _scope_CMD, _scope
			IF testCMD > 0 then  ' Entre 1-5 = Pas d'affichage via le @, @$ ou @#
				IF testCMD < 6 then
					Affichage = 0
					IF testCMD = 3 Then CpcdosCP_SHELL("FIX/ " & CPCDOS_INSTANCE.DEBUG_INSTANCE.LeRetour & " = \#NULL", _CLE_, NIVEAU_CCP, Param_1, Param_2) : RetourVAR = _CLE_ & "N" & NIVEAU_CCP & "->" & CPCDOS_INSTANCE.DEBUG_INSTANCE.LeRetour
					if testCMD = 2 Then RetourVAR = "$>" & CPCDOS_INSTANCE.DEBUG_INSTANCE.LeRetour ' ajouter une securite ?
				Else
					Affichage = 1
				END IF
			Else
				Affichage = 1
			END IF
			' Recuperer les Parametres
			Param = MID(Commande, CommPosition + TailleComm + 2)
			SCOPE
			' ====================================================================

			' On affiche en mode console
			' CPCDOS_INSTANCE.SYSTEME_INSTANCE.set_Resolution(0)
			CpcdosCP_SHELL("SYS/ /DEBUG = 1", _CLE_, NIVEAU_CCP, Param_1, Param_2)
			CpcdosCP_SHELL("SYS/ /DEBUG /CPINTICORE = 1", _CLE_, NIVEAU_CCP, Param_1, Param_2)
			CpcdosCP_SHELL("SYS/ /ECRAN 0", _CLE_, NIVEAU_CCP, Param_1, Param_2)
			doevents(1000)

			IF CPCDOS_INSTANCE.Utilisateur_Langage = 0 Then
				DEBUG("[CpcdosC+] Arret d'urgence du Kernel Cpcdos...!", Affichage, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_Normal, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.AvecDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_AFF, RetourVAR)
			Else
				DEBUG("[CpcdosC+] Stopping cpcdos kernel...", Affichage, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_Normal, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.AvecDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_AFF, RetourVAR)
			End if
			doevents(500000)
			IF CPCDOS_INSTANCE.Utilisateur_Langage = 0 Then
				DEBUG("[Cpcdos] Fermeture des descripteurs de fichiers...!", Affichage, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_ACTION, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.AvecDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_AFF, RetourVAR)
			Else
				DEBUG("[Cpcdos] Closing file descriptor...", Affichage, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_ACTION, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.AvecDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_AFF, RetourVAR)
			End if
			Reset()
			doevents(2000000)
			IF CPCDOS_INSTANCE.Utilisateur_Langage = 0 Then
				DEBUG("[Cpcdos] OK, BYE!", Affichage, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_VALIDATION, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.AvecDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_AFF, RetourVAR)
			Else
				DEBUG("[Cpcdos] OK, BYE!", Affichage, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_VALIDATION, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.AvecDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_AFF, RetourVAR)
			End if
			doevents(1000000)
			end
'-------------------------------------------------' CPCDOS_INSTANCE.CPintiCore_INSTANCE.Quitter_CPintiCore() -------------------------------------------------

			' ====================================================================
			END SCOPE
			exit _scope_CMD, _scope
		End if ' **** STOPK/ ****

	_end_scope_CMD

	_scope_CMD


		' ===============================================================
		'  Commande pour atteindre un label code
		' ===============================================================
		CommLANG(1) = "aller/"
		CommLANG(2) = "goto/"
		CommLANG(3) = "\\#//"
		CommTrouve = 0 : NoCMD = 0
		for boucle as integer = 1 to 2
			IF OnCherche = CommLANG(boucle) Then
				NoCMD = 0
				exit for
			Else
				NoCMD = 1
			End if
		Next boucle
		IF NoCMD = 1 then CommLANG(1) = "[F.#).|" : CommLANG(2) = "[F.#).|" : CommLANG(3) = "\\#//"

		rem Afficher la liste des commandes avec anglais / francais
		IF AfficherAide = 1 then
			IF CPCDOS_INSTANCE.Utilisateur_Langage = 0 then
				CommandesAide = CommandesAide & CRLF & " aller/                     Atteindre un label dans un code en execution"
			Else
				CommandesAide = CommandesAide & CRLF & " goto/                      Go to at specified label in code in execution"
			END IF
		END IF
		IF CommLANG(1) = OnCherche Then CommTrouve = 1
		IF CommLANG(2) = OnCherche Then CommTrouve = 2
		IF CommTrouve > 0 Then
		IF AfficherAide = 2 then
				Mess_Aide = ""
				IF CPCDOS_INSTANCE.Utilisateur_Langage = 0 THEN
					Mess_Aide = Mess_Aide & CRLF & "  Fonctionnalit�e :"
					Mess_Aide = Mess_Aide & CRLF & "   Cette commande permet d'atteindre un label sp�cifi� dans le code"
					Mess_Aide = Mess_Aide & CRLF
					Mess_Aide = Mess_Aide & CRLF & "  Exemple simple :"
					Mess_Aide = Mess_Aide & CRLF & "   txt/ Coucou"
					Mess_Aide = Mess_Aide & CRLF & "   aller/ MonLabel"
					Mess_Aide = Mess_Aide & CRLF & "   txt/ Ca va ?"
					Mess_Aide = Mess_Aide & CRLF & "  :MonLabel:"
					Mess_Aide = Mess_Aide & CRLF & "   txt/ Aurevoir"
					Mess_Aide = Mess_Aide & CRLF
					Mess_Aide = Mess_Aide & CRLF & "  Sortie :"
					Mess_Aide = Mess_Aide & CRLF & "   Coucou"
					Mess_Aide = Mess_Aide & CRLF & "   Aurevoir"
					Mess_Aide = Mess_Aide & CRLF
					Mess_Aide = Mess_Aide & CRLF & "  Voir aussi : exe/ "
					Mess_Aide = Mess_Aide & CRLF
				ELSEIF CPCDOS_INSTANCE.Utilisateur_Langage = 1 THEN
					Mess_Aide = Mess_Aide & CRLF & "  Fonctionnality :"
					Mess_Aide = Mess_Aide & CRLF & "   This command allow to go to in a specified label in your code"
					Mess_Aide = Mess_Aide & CRLF
					Mess_Aide = Mess_Aide & CRLF & "  Exemple simple :"
					Mess_Aide = Mess_Aide & CRLF & "   txt/ Hello"
					Mess_Aide = Mess_Aide & CRLF & "   aller/ MyLabel"
					Mess_Aide = Mess_Aide & CRLF & "   txt/ How are you?"
					Mess_Aide = Mess_Aide & CRLF & "  :MonLabel:"
					Mess_Aide = Mess_Aide & CRLF & "   txt/ Bye!"
					Mess_Aide = Mess_Aide & CRLF
					Mess_Aide = Mess_Aide & CRLF & "  Results :"
					Mess_Aide = Mess_Aide & CRLF & "   Hello"
					Mess_Aide = Mess_Aide & CRLF & "   Bye!"
					Mess_Aide = Mess_Aide & CRLF
					Mess_Aide = Mess_Aide & CRLF & "  See also : exe/ "
					Mess_Aide = Mess_Aide & CRLF
				END IF
				DEBUG(Mess_Aide, Affichage, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_SURBRILLE, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.SansDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_AFF, RetourVAR)
				testCMD = 0
				AfficherAide = 0
				exit _scope_CMD, _scope
			END IF
			' Tester la syntaxe
			testCMD	= CCP_Verifier_Syntaxe(Commande, CommPosition)
			IF testCMD > 10 Then exit _scope_CMD, _scope
			IF testCMD > 0 then  ' Entre 1-5 = Pas d'Affichage via le @, @$ ou @#
				IF testCMD < 6 then
					Affichage = 0
					IF testCMD = 3 Then CpcdosCP_SHELL("FIX/ " & CPCDOS_INSTANCE.DEBUG_INSTANCE.LeRetour & " = \#NULL", _CLE_, NIVEAU_CCP, Param_1, Param_2) : RetourVAR = _CLE_ & "N" & NIVEAU_CCP & "->" & CPCDOS_INSTANCE.DEBUG_INSTANCE.LeRetour
					if testCMD = 2 Then RetourVAR = "$>" & CPCDOS_INSTANCE.DEBUG_INSTANCE.LeRetour ' ajouter une securite ?
				Else
					Affichage = 1
				END IF
			Else
				Affichage = 1
			END IF
			' Recuperer les Parametres
			Param = MID(Commande, CommPosition + TailleComm + 2)
			SCOPE
			' ===================================================================

			IF CPCDOS_INSTANCE.SYSTEME_INSTANCE.get_DBG_DEBUG() > 0 Then
				IF CPCDOS_INSTANCE.Utilisateur_Langage = 0 Then
					DEBUG("[CpcdosC+] Saut vers :" & Param & ":", Affichage, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_Normal, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.AvecDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_CPCDOS, RetourVAR)
				Else
					DEBUG("[CpcdosC+] Jump to :" & Param & ":", Affichage, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_Normal, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.AvecDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_CPCDOS, RetourVAR)
				End If
			End if

			CpcdosCP_SHELL = "ALLER/ " & Param ' on renvoie ca a la boucle while de la lecture

			' ====================================================================
			END SCOPE
			exit _scope_CMD, _scope
		End if ' **** ALLER/ ****

	_end_scope_CMD

	_scope_CMD

		' ===============================================================
		'  Commande pour declarer une fonction CpcdosC+
		' ===============================================================
		CommLANG(1) = "retour/"
		CommLANG(2) = "return/"
		CommLANG(3) = "\\#//"
		CommTrouve = 0 : NoCMD = 0
		for boucle as integer = 1 to 2
			IF OnCherche = CommLANG(boucle) Then
				NoCMD = 0
				exit for
			Else
				NoCMD = 1
			End if
		Next boucle
		IF NoCMD = 1 then CommLANG(1) = "[F.#).|" : CommLANG(2) = "[F.#).|" : CommLANG(3) = "\\#//"
		rem Afficher la liste des commandes avec anglais / francais
		IF AfficherAide = 1 then
			IF CPCDOS_INSTANCE.Utilisateur_Langage = 0 then
				CommandesAide = CommandesAide & CRLF & " retour/                    Retourner une valeur depuis une fonction CpcdosC+"
			Else
				CommandesAide = CommandesAide & CRLF & " return/                    Return value from CpcdosC+ function"
			END IF
		END IF

		IF CommLANG(1) = OnCherche Then CommTrouve = 1
		IF CommLANG(2) = OnCherche Then CommTrouve = 2

		IF CommTrouve > 0 Then
			IF AfficherAide = 2 then
				Mess_Aide = ""
				IF CPCDOS_INSTANCE.Utilisateur_Langage = 0 THEN
					Mess_Aide = Mess_Aide & CRLF & "  'RETOUR'"
					Mess_Aide = Mess_Aide & CRLF
					Mess_Aide = Mess_Aide & CRLF & "  Fonctionnalit�e :"
					Mess_Aide = Mess_Aide & CRLF & "   Cette commande permet de retourner une valeur non type"
					Mess_Aide = Mess_Aide & CRLF & "    depuis une fonction CpcdosC+"
					Mess_Aide = Mess_Aide & CRLF
					Mess_Aide = Mess_Aide & CRLF & "  Exemple 1 :"
					Mess_Aide = Mess_Aide & CRLF & "   Fonction/ Un_exemple()"
					Mess_Aide = Mess_Aide & CRLF & "      retour/ Toto!"
					Mess_Aide = Mess_Aide & CRLF & "   Fin/ fonction"
					Mess_Aide = Mess_Aide & CRLF & "   Txt/ /F:Un_Exemple()"
					Mess_Aide = Mess_Aide & CRLF
					Mess_Aide = Mess_Aide & CRLF & "  Affiche : Toto!"
					Mess_Aide = Mess_Aide & CRLF
					Mess_Aide = Mess_Aide & CRLF & "  Exemple 2 :"
					Mess_Aide = Mess_Aide & CRLF & "   Fonction/ Un_exemple()"
					Mess_Aide = Mess_Aide & CRLF & "      txt/ Je suis dans ma fonction!"
					Mess_Aide = Mess_Aide & CRLF & "      retour/ Voila c'est finis!"
					Mess_Aide = Mess_Aide & CRLF & "   Fin/ fonction"
					Mess_Aide = Mess_Aide & CRLF & "   Txt/ /F:Un_Exemple()"
					Mess_Aide = Mess_Aide & CRLF
					Mess_Aide = Mess_Aide & CRLF & "  Voir aussi : txt/ , ccp/, declarer/"
					Mess_Aide = Mess_Aide & CRLF
				ELSEIF CPCDOS_INSTANCE.Utilisateur_Langage = 1 THEN
					Mess_Aide = Mess_Aide & CRLF & "  Fonctionnality :"
					Mess_Aide = Mess_Aide & CRLF & "   This command allow to declare CpcdosC+ function"
					Mess_Aide = Mess_Aide & CRLF
					Mess_Aide = Mess_Aide & CRLF & "  Exemple 1 :"
					Mess_Aide = Mess_Aide & CRLF & "   Function/ My_Exemple()"
					Mess_Aide = Mess_Aide & CRLF & "      Return/ Foo!"
					Mess_Aide = Mess_Aide & CRLF & "   End/ Function"
					Mess_Aide = Mess_Aide & CRLF & "   Txt/ /F:My_Exemple()"
					Mess_Aide = Mess_Aide & CRLF
					Mess_Aide = Mess_Aide & CRLF & "  Display : Foo!"
					Mess_Aide = Mess_Aide & CRLF
					Mess_Aide = Mess_Aide & CRLF & "  Exemple 2 :"
					Mess_Aide = Mess_Aide & CRLF & "   Fonction/ My_Exemple()"
					Mess_Aide = Mess_Aide & CRLF & "      txt/ I'm in my function!"
					Mess_Aide = Mess_Aide & CRLF & "      return/ tada!!"
					Mess_Aide = Mess_Aide & CRLF & "   Fin/ fonction"
					Mess_Aide = Mess_Aide & CRLF & "   Txt/ /F:My_Exemple()"
					Mess_Aide = Mess_Aide & CRLF
					Mess_Aide = Mess_Aide & CRLF & "  Affiche : I'm in my function!"
					Mess_Aide = Mess_Aide & CRLF & "            tada!!"
					Mess_Aide = Mess_Aide & CRLF
					Mess_Aide = Mess_Aide & CRLF & "  See also : txt/ , ccp/"
					Mess_Aide = Mess_Aide & CRLF
				END IF
				DEBUG(Mess_Aide, Affichage, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_SURBRILLE, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.SansDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_AFF, RetourVAR)
				testCMD = 0
				AfficherAide = 0
				exit _scope_CMD, _scope
			END IF
			' Tester la syntaxe
			testCMD	= CCP_Verifier_Syntaxe(Commande, CommPosition)
			IF testCMD > 10 Then exit _scope_CMD, _scope
			IF testCMD > 0 then  ' Entre 1-5 = Pas d'affichage via le @, @$ ou @#
				IF testCMD < 6 then
					Affichage = 0
					IF testCMD = 3 Then CpcdosCP_SHELL("FIX/ " & CPCDOS_INSTANCE.DEBUG_INSTANCE.LeRetour & " = \#NULL", _CLE_, NIVEAU_CCP, Param_1, Param_2) : RetourVAR = _CLE_ & "N" & NIVEAU_CCP & "->" & CPCDOS_INSTANCE.DEBUG_INSTANCE.LeRetour
					if testCMD = 2 Then RetourVAR = "$>" & CPCDOS_INSTANCE.DEBUG_INSTANCE.LeRetour ' ajouter une securite ?
				Else
					Affichage = 1
				END IF
			Else
				Affichage = 1
			END IF
			' Recuperer les Parametres
			Param = MID(Commande, CommPosition + TailleComm + 2)
			SCOPE
			' ====================================================================

			CpcdosCP_SHELL = "FONCTION-RETOUR:" & Param

			' ====================================================================
			END SCOPE
			exit _scope_CMD, _scope
		End if ' **** RETOUR ****

	_end_scope_CMD

	_scope_CMD

		' ===============================================================
		'  Commande pour declarer une fonction CpcdosC+
		' ===============================================================
		CommLANG(1) = "fonction/"
		CommLANG(2) = "function/"
		CommLANG(3) = "\\#//"
		CommTrouve = 0 : NoCMD = 0
		for boucle as integer = 1 to 2
			IF OnCherche = CommLANG(boucle) Then
				NoCMD = 0
				exit for
			Else
				NoCMD = 1
			End if
		Next boucle
		IF NoCMD = 1 then CommLANG(1) = "[F.#).|" : CommLANG(2) = "[F.#).|" : CommLANG(3) = "\\#//"
		rem Afficher la liste des commandes avec anglais / francais
		IF AfficherAide = 1 then
			IF CPCDOS_INSTANCE.Utilisateur_Langage = 0 then
				CommandesAide = CommandesAide & CRLF & " fonction/                  Declare une fonction CpcdosC+ a un niveau choisis"
			Else
				CommandesAide = CommandesAide & CRLF & " function/                  Declare CpcdosC+ function with a level"
			END IF
		END IF

		IF CommLANG(1) = OnCherche Then CommTrouve = 1
		IF CommLANG(2) = OnCherche Then CommTrouve = 2

		IF CommTrouve > 0 Then
			IF AfficherAide = 2 then
				Mess_Aide = ""
				IF CPCDOS_INSTANCE.Utilisateur_Langage = 0 THEN
					Mess_Aide = Mess_Aide & CRLF & "  'FONCTION'"
					Mess_Aide = Mess_Aide & CRLF
					Mess_Aide = Mess_Aide & CRLF & "  Fonctionnalit�e :"
					Mess_Aide = Mess_Aide & CRLF & "   Cette commande permet de creer une fonction"
					Mess_Aide = Mess_Aide & CRLF
					Mess_Aide = Mess_Aide & CRLF & "  Exemple:"
					Mess_Aide = Mess_Aide & CRLF & "   Fonction/ Ma_Fonction()"
					Mess_Aide = Mess_Aide & CRLF & "      Retourne/ Bonjour!"
					Mess_Aide = Mess_Aide & CRLF & "   Fin/ Ma_Fonction"
					Mess_Aide = Mess_Aide & CRLF
					Mess_Aide = Mess_Aide & CRLF & "   txt/ /F:Ma_Fonction()"
					Mess_Aide = Mess_Aide & CRLF
					Mess_Aide = Mess_Aide & CRLF & "  Voir aussi : Declarer/ , exe/"
					Mess_Aide = Mess_Aide & CRLF
				ELSEIF CPCDOS_INSTANCE.Utilisateur_Langage = 1 THEN
					Mess_Aide = Mess_Aide & CRLF & "  Fonctionnality :"
					Mess_Aide = Mess_Aide & CRLF & "   This command allow to create a function"
					Mess_Aide = Mess_Aide & CRLF
					Mess_Aide = Mess_Aide & CRLF & "  Exemple:"
					Mess_Aide = Mess_Aide & CRLF & "   Function/ My_Function()"
					Mess_Aide = Mess_Aide & CRLF & "      return/ Hello!"
					Mess_Aide = Mess_Aide & CRLF & "   end/ function"
					Mess_Aide = Mess_Aide & CRLF
					Mess_Aide = Mess_Aide & CRLF & "   txt/ /F:My_Function()"
					Mess_Aide = Mess_Aide & CRLF
					Mess_Aide = Mess_Aide & CRLF & "  See also : Declare/ , exe/"
					Mess_Aide = Mess_Aide & CRLF
				END IF
				DEBUG(Mess_Aide, Affichage, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_SURBRILLE, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.SansDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_AFF, RetourVAR)
				testCMD = 0
				AfficherAide = 0
				exit _scope_CMD, _scope
			END IF
			' Tester la syntaxe
			testCMD	= CCP_Verifier_Syntaxe(Commande, CommPosition)
			IF testCMD > 10 Then exit _scope_CMD, _scope
			IF testCMD > 0 then  ' Entre 1-5 = Pas d'affichage via le @, @$ ou @#
				IF testCMD < 6 then
					Affichage = 0
					IF testCMD = 3 Then CpcdosCP_SHELL("FIX/ " & CPCDOS_INSTANCE.DEBUG_INSTANCE.LeRetour & " = \#NULL", _CLE_, NIVEAU_CCP, Param_1, Param_2) : RetourVAR = _CLE_ & "N" & NIVEAU_CCP & "->" & CPCDOS_INSTANCE.DEBUG_INSTANCE.LeRetour
					if testCMD = 2 Then RetourVAR = "$>" & CPCDOS_INSTANCE.DEBUG_INSTANCE.LeRetour ' ajouter une securite ?
				Else
					Affichage = 1
				END IF
			Else
				Affichage = 1
			END IF
			' Recuperer les Parametres
			Param = MID(Commande, CommPosition + TailleComm + 2)
			SCOPE
			' ====================================================================

			CpcdosCP_SHELL = "FONCTION:" & PARAM

			' ====================================================================
			END SCOPE
			exit _scope_CMD, _scope
		End if ' **** RETOUR ****

	_end_scope_CMD

	_scope_CMD

		' ===============================================================
		'  Commande pour executer une commande avec ou sans Parametres
		' ===============================================================
		CommLANG(1) = "cmd/"
		CommLANG(2) = "cmd/"
		CommLANG(3) = "\\#//"
		CommTrouve = 0 : NoCMD = 0
		for boucle as integer = 1 to 2
			IF OnCherche = CommLANG(boucle) Then
				NoCMD = 0
				exit for
			Else
				NoCMD = 1
			End if
		Next boucle
		IF NoCMD = 1 then CommLANG(1) = "[F.#).|" : CommLANG(2) = "[F.#).|" : CommLANG(3) = "\\#//"

		rem Afficher la liste des commandes avec anglais / francais
		IF AfficherAide = 1 then
			IF CPCDOS_INSTANCE.Utilisateur_Langage = 0 then
				CommandesAide = CommandesAide & CRLF & " cmd/                       Executer une commande CpcdosC+ avec ou sans Parametres"
			Else
				CommandesAide = CommandesAide & CRLF & " cmd/                       Launch CpcdosC+ command with or without Parameters"
			END IF
		END IF
		IF CommLANG(1) = OnCherche Then CommTrouve = 1
		IF CommLANG(2) = OnCherche Then CommTrouve = 2
		IF CommTrouve > 0 Then
		IF AfficherAide = 2 then
				Mess_Aide = ""
				IF CPCDOS_INSTANCE.Utilisateur_Langage = 0 THEN
					Mess_Aide = Mess_Aide & CRLF & "  Fonctionnalit�e :"
					Mess_Aide = Mess_Aide & CRLF & "   Cette commande permet d'executer une commande CpcdosC+"
					Mess_Aide = Mess_Aide & CRLF
					Mess_Aide = Mess_Aide & CRLF & "  Elle est capable d'executer une commande dans un autre thread independant"
					Mess_Aide = Mess_Aide & CRLF & "   ou un processus"
					Mess_Aide = Mess_Aide & CRLF
					Mess_Aide = Mess_Aide & CRLF & "  Parametres disponibles :"
					Mess_Aide = Mess_Aide & CRLF & "   /thread       : Execute la commande dans un nouveau thread independant"
					Mess_Aide = Mess_Aide & CRLF & "   /thread[MAX]  : Idem, mais avec une priorit�e MAXimale"
					Mess_Aide = Mess_Aide & CRLF & "   /thread[ST+]  : Idem, mais avec une priorit�e superieur au STanDard"
					Mess_Aide = Mess_Aide & CRLF & "   /thread[STD]  : Idem, mais avec une priorit�e STanDard (Meme effet que /thread)"
					Mess_Aide = Mess_Aide & CRLF & "   /thread[MI+]  : Idem, mais avec une priorit�e superieur au MINimale"
					Mess_Aide = Mess_Aide & CRLF & "   /thread[MIN]  : Idem, mais avec une priorit�e MINimale"
					Mess_Aide = Mess_Aide & CRLF & "   /pid:123		 : Execute l'instruction dans le PID numero '123'"
					Mess_Aide = Mess_Aide & CRLF
					Mess_Aide = Mess_Aide & CRLF & "  Exemple simple :"
					Mess_Aide = Mess_Aide & CRLF & "   cmd/ txt/ coucou!"
					Mess_Aide = Mess_Aide & CRLF & "   cmd/ exe/ MonProgramme"
					Mess_Aide = Mess_Aide & CRLF & "   cmd/ ping/ www.google.fr"
					Mess_Aide = Mess_Aide & CRLF
					Mess_Aide = Mess_Aide & CRLF & "  Meme exemple un autre thread :"
					Mess_Aide = Mess_Aide & CRLF & "   cmd/ /thread txt/ coucou!"
					Mess_Aide = Mess_Aide & CRLF & "   cmd/ /thread exe/ MonProgramme"
					Mess_Aide = Mess_Aide & CRLF & "   cmd/ /thread Ping/ www.google.fr"
					Mess_Aide = Mess_Aide & CRLF
					Mess_Aide = Mess_Aide & CRLF & "  Meme exemple mais avec une priorit�e :"
					Mess_Aide = Mess_Aide & CRLF & "   cmd/ /thread[MIN] txt/ coucou!"
					Mess_Aide = Mess_Aide & CRLF & "   cmd/ /thread[STD] exe/ MonProgramme"
					Mess_Aide = Mess_Aide & CRLF & "   cmd/ /thread[MAX] Ping/ www.google.fr"
					Mess_Aide = Mess_Aide & CRLF
					Mess_Aide = Mess_Aide & CRLF & "  Executer le thread du serveur dans un autre processus"
					Mess_Aide = Mess_Aide & CRLF & "   existant (Exemple avec 123)"
					Mess_Aide = Mess_Aide & CRLF & "   cmd/ /pid:123 serveur/ /tcp:2316"
					Mess_Aide = Mess_Aide & CRLF
					Mess_Aide = Mess_Aide & CRLF & "  Executer l'armorceur de l'OS dans un autre processus"
					Mess_Aide = Mess_Aide & CRLF & "   cmd/ /pid:123 DEMARRER/"
					Mess_Aide = Mess_Aide & CRLF
					Mess_Aide = Mess_Aide & CRLF & "  Executer un fichier executable dans un autre processus"
					Mess_Aide = Mess_Aide & CRLF & "   cmd/ /pid:123 exe/ MonFichier.cpc"
					Mess_Aide = Mess_Aide & CRLF
					Mess_Aide = Mess_Aide & CRLF & "  Voir aussi : exe/ "
					Mess_Aide = Mess_Aide & CRLF
				ELSEIF CPCDOS_INSTANCE.Utilisateur_Langage = 1 THEN
					Mess_Aide = Mess_Aide & CRLF & "  Fonctionnality :"
					Mess_Aide = Mess_Aide & CRLF & "   This command allow to launch a CpcdosC+ command"
					Mess_Aide = Mess_Aide & CRLF & "   This is able to launch in another threads or process"
					Mess_Aide = Mess_Aide & CRLF
					Mess_Aide = Mess_Aide & CRLF & "  Parametres disponibles :"
					Mess_Aide = Mess_Aide & CRLF & "   /thread       : Launch command in another thread"
					Mess_Aide = Mess_Aide & CRLF & "   /thread[MAX]  : Idem, but with MAXimal priority"
					Mess_Aide = Mess_Aide & CRLF & "   /thread[ST+]  : Idem, but with more that STanDard priority"
					Mess_Aide = Mess_Aide & CRLF & "   /thread[STD]  : Idem, but with STanDard priority (Same effect that /thread)"
					Mess_Aide = Mess_Aide & CRLF & "   /thread[MI+]  : Idem, but with more that MINimal priority"
					Mess_Aide = Mess_Aide & CRLF & "   /thread[MIN]  : Idem, but with MINimal priority"
					Mess_Aide = Mess_Aide & CRLF & "   /pid:123		 : Execute instructions from the '123' process"
					Mess_Aide = Mess_Aide & CRLF
					Mess_Aide = Mess_Aide & CRLF & "  Example :"
					Mess_Aide = Mess_Aide & CRLF & "   cmd/ txt/ Hello!"
					Mess_Aide = Mess_Aide & CRLF & "   cmd/ exe/ MyProgramme"
					Mess_Aide = Mess_Aide & CRLF & "   cmd/ ping/ www.google.com"
					Mess_Aide = Mess_Aide & CRLF
					Mess_Aide = Mess_Aide & CRLF & "  Same example in another thread :"
					Mess_Aide = Mess_Aide & CRLF & "   cmd/ /thread txt/ Hello!"
					Mess_Aide = Mess_Aide & CRLF & "   cmd/ /thread exe/ MyProgramme"
					Mess_Aide = Mess_Aide & CRLF & "   cmd/ /thread Ping/ www.google.com"
					Mess_Aide = Mess_Aide & CRLF
					Mess_Aide = Mess_Aide & CRLF & "  Same example but with priority :"
					Mess_Aide = Mess_Aide & CRLF & "   cmd/ /thread[MIN] txt/ Hello!"
					Mess_Aide = Mess_Aide & CRLF & "   cmd/ /thread[STD] exe/ MyProgramme"
					Mess_Aide = Mess_Aide & CRLF & "   cmd/ /thread[MAX] Ping/ www.google.com"
					Mess_Aide = Mess_Aide & CRLF
					Mess_Aide = Mess_Aide & CRLF & "  Execute server thread in another existing process (Example with 123)"
					Mess_Aide = Mess_Aide & CRLF & "   cmd/ /pid:123 server/ /tcp:2316"
					Mess_Aide = Mess_Aide & CRLF
					Mess_Aide = Mess_Aide & CRLF & "  Execute OS loader from another process"
					Mess_Aide = Mess_Aide & CRLF & "   cmd/ /pid:123 Start/"
					Mess_Aide = Mess_Aide & CRLF
					Mess_Aide = Mess_Aide & CRLF & "  Execute executable file from another process"
					Mess_Aide = Mess_Aide & CRLF & "   cmd/ /pid:123 exe/ MyFile.cpc"
					Mess_Aide = Mess_Aide & CRLF
					Mess_Aide = Mess_Aide & CRLF & "  See also : exe/ "
					Mess_Aide = Mess_Aide & CRLF
				END IF
				DEBUG(Mess_Aide, Affichage, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_SURBRILLE, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.SansDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_AFF, RetourVAR)
				testCMD = 0
				AfficherAide = 0
				exit _scope_CMD, _scope
			END IF
			' Tester la syntaxe
			testCMD	= CCP_Verifier_Syntaxe(Commande, CommPosition)
			IF testCMD > 10 Then exit _scope_CMD, _scope
			IF testCMD > 0 then  ' Entre 1-5 = Pas d'affichage via le @, @$ ou @#
				IF testCMD < 6 then
					Affichage = 0
					IF testCMD = 3 Then CpcdosCP_SHELL("FIX/ " & CPCDOS_INSTANCE.DEBUG_INSTANCE.LeRetour & " = \#NULL", _CLE_, NIVEAU_CCP, Param_1, Param_2) : RetourVAR = _CLE_ & "N" & NIVEAU_CCP & "->" & CPCDOS_INSTANCE.DEBUG_INSTANCE.LeRetour
					if testCMD = 2 Then RetourVAR = "$>" & CPCDOS_INSTANCE.DEBUG_INSTANCE.LeRetour ' ajouter une securite ?
				Else
					Affichage = 1
				END IF
			Else
				Affichage = 1
			END IF
			' Recuperer les Parametres
			Param = MID(Commande, CommPosition + TailleComm + 2)
			SCOPE
			' ===================================================================
			Dim PosParam1				as Integer
			Dim PosParam2				as Integer
			Dim PosParam3				as Integer
			Dim PosParam4				as Integer
			Dim PosParam5				as Integer
			Dim PosParam6				as Integer
			Dim Thread_MaxStdMin		as Integer

			Dim NumeroPID_cmd 		as integer = 0
			Dim NomProcessus_cmd 	as String = ""
			IF Instr(UCASE(Param), "/PID") > 0 Then
				NumeroPID_cmd = VAL(Mid(Param, instr(Ucase(Param), "/PID") + 5))
				Param = Mid(Param, 1, instr(Ucase(Param), "/PID") - 1) & Mid(Param, instr(Instr(ucase(Param), "/PID"), Param, " ") + 1)

				' Redonner et regenerer les nouvelle infos du nouveau processus
				Auth_PID = NumeroPID_cmd
				_CLE_ = CPCDOS_INSTANCE.Generer_cle(Auth_Kernel, Auth_OS, Auth_Utilisateur, Auth_PID, Auth_TID)

			End if

			IF NumeroPID_cmd > 0 Then
				NomProcessus_cmd = CPCDOS_INSTANCE.get_Nom_Processus(NumeroPID_cmd)
				IF CPCDOS_INSTANCE.SYSTEME_INSTANCE.get_DBG_DEBUG() > 0 Then
					IF CPCDOS_INSTANCE.Utilisateur_Langage = 0 Then
						DEBUG("[CpcdosC+] Definition du processus cible sur '" & NomPRocessus_cmd & "' PID:" & NumeroPID_cmd, Affichage, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_Normal, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.AvecDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_CPCDOS, RetourVAR)
					Else
						DEBUG("[CpcdosC+] Definition host process on '" & NomPRocessus_cmd & "' PID:" & NumeroPID_cmd, Affichage, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_Normal, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.AvecDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_CPCDOS, RetourVAR)
					End If
				End if
			End if

			PosParam1 = Instr(UCASE(Param), "/THREAD ")	  ' 0
			PosParam2 = Instr(UCASE(Param), "/THREAD[MIN] ") ' 1
			PosParam3 = Instr(UCASE(Param), "/THREAD[MI+] ") ' 1
			PosParam4 = Instr(UCASE(Param), "/THREAD[STD] ") ' 2
			PosParam5 = Instr(UCASE(Param), "/THREAD[ST+] ") ' 2
			PosParam6 = Instr(UCASE(Param), "/THREAD[MAX] ") ' 3

			IF PosParam1 > 0 Then
				Param = MID(Param, PosParam1 + 8)
				Thread_MaxStdMin = 2 ' Standard
			ElseIf PosParam2 > 0 Then
				Param = MID(Param, PosParam2 + 13)
				Thread_MaxStdMin = 1 ' Minimum
			ElseIf PosParam3 > 0 Then
				Param = MID(Param, PosParam3 + 13)
				Thread_MaxStdMin = 2 ' Minimum +
			ElseIf PosParam4 > 0 Then
				Param = MID(Param, PosParam4 + 13)
				Thread_MaxStdMin = 3 ' Standard
			ElseIf PosParam5 > 0 Then
				Param = MID(Param, PosParam4 + 13)
				Thread_MaxStdMin = 4 ' Standard+
			ElseIf PosParam6 > 0 Then
				Param = MID(Param, PosParam4 + 13)
				Thread_MaxStdMin = 5 ' Maximum
			Else
				Thread_MaxStdMin = 0 ' pas de thread

			End if


			' Verifier s'il y a une execution interactive d'une fonction
			'  Car si elle est executee dans un autre thread il ne trouvera jamais la fonction
			'  Du coup il faut re-preciser le fichier source
			IF Instr(UCASE(Param), "/F:") > 0 AND Instr(UCASE(Param), "(") > Instr(UCASE(Param), "/F:") AND Instr(UCASE(Param), ")") > Instr(UCASE(Param), "(") Then
				Dim NomFichier_correction as string = UCASE(CPCDOS_INSTANCE.SHELLCCP_INSTANCE.CCP_Lire_Variable("_EXE_PATH_F_", 2, _CLE_))
				Param = "EXE/ " & NomFichier_correction & " /FN:" & mid(Param, instr(Param, "/F:") + 3) & ") ->"
				Param = MID(Param, 1, Instr(Param, ") ->") - 1) & "->" & _CLE_

				IF CPCDOS_INSTANCE.SYSTEME_INSTANCE.get_DBG_DEBUG() > 0 Then
					IF CPCDOS_INSTANCE.Utilisateur_Langage = 0 Then
						DEBUG("[CpcdosC+] Fonction detectee! Correction des arguments d'entres : " & Param, Affichage, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_Normal, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.AvecDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_CPCDOS, RetourVAR)
					Else
						DEBUG("[CpcdosC+] Function detected! Entry arguments correction : " & Param, Affichage, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_Normal, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.AvecDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_CPCDOS, RetourVAR)
					End If
				End if

			End if

			IF Thread_MaxStdMin = 0 Then ' Execution normal, sur le meme thread
				IF CPCDOS_INSTANCE.SYSTEME_INSTANCE.get_DBG_DEBUG() > 0 Then
					IF CPCDOS_INSTANCE.Utilisateur_Langage = 0 Then
						DEBUG("[CpcdosC+] DEBUT Execution interactive de la commande " & Param, Affichage, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_Normal, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.AvecDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_CPCDOS, RetourVAR)
					Else
						DEBUG("[CpcdosC+] BEGIN Interactive command execution ", Affichage, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_Normal, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.AvecDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_CPCDOS, RetourVAR)
					End If
				End if
				' Execution de la commande
				CpcdosCP_SHELL(Param, _CLE_, NIVEAU_CCP, Param_1, Param_2)
				IF CPCDOS_INSTANCE.SYSTEME_INSTANCE.get_DBG_DEBUG() > 0 Then
					IF CPCDOS_INSTANCE.Utilisateur_Langage = 0 Then
						DEBUG("[CpcdosC+] FIN de l'execution interactive de la commande " & Param, Affichage, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_Normal, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.AvecDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_CPCDOS, RetourVAR)
					Else
						DEBUG("[CpcdosC+] END interactive command execution ", Affichage, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_Normal, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.AvecDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_CPCDOS, RetourVAR)
					End If
				End if
				exit _scope_CMD, _scope
			End if
			IF Thread_MaxStdMin > 0 Then
				IF CPCDOS_INSTANCE.SYSTEME_INSTANCE.get_DBG_DEBUG() > 0 Then
					IF CPCDOS_INSTANCE.Utilisateur_Langage = 0 Then
						DEBUG("Kernel > Creation d'un processus d'execution asynchrome CCP...", Affichage, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_Normal, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.AvecDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_CPCDOS, RetourVAR)
					Else
						DEBUG("Kernel > Creating asynchrome execution CCP process...", Affichage, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_Normal, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.AvecDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_CPCDOS, RetourVAR)
					End If
				End if

				' Si > 0 Alors c'est qu'on doit creer un nouveau thread
				SCOPE

					Dim TidRetour as uinteger
					' Creer une instance de _STRUCT_THREAD_Cpcdos_OSx__, remplir le donnees
					Dim INSTANCE_STRUCT_THREAD as _STRUCT_THREAD_Cpcdos_OSx__
					INSTANCE_STRUCT_THREAD.Nom 		= "_CPCDOSCP_ASYNC_"  & _CLE_ & "~" & CPCDOS_INSTANCE.get_id_PID(_CLE_)
					INSTANCE_STRUCT_THREAD.Fonction = cast(any ptr, @Shell_THREAD) 		' PTR
					INSTANCE_STRUCT_THREAD.PROC_ID 	= Auth_PID							' PID uint
					INSTANCE_STRUCT_THREAD.OS_ID	= Auth_OS							' ID de l'OS
					INSTANCE_STRUCT_THREAD.USER_ID	= Auth_Utilisateur					' ID de l'user
					INSTANCE_STRUCT_THREAD.KERNEL_ID= Auth_Kernel						' ID du kernel

					INSTANCE_STRUCT_THREAD.ARG_1 = malloc(sizeof(Param))
					memcpy(INSTANCE_STRUCT_THREAD.ARG_1, cast(any ptr, @Param), sizeof(Param))
					INSTANCE_STRUCT_THREAD.ARG_2 = NULL ' CLE
					INSTANCE_STRUCT_THREAD.ARG_3 = cast(any ptr, NIVEAU_CCP)
					INSTANCE_STRUCT_THREAD.ARG_4 = cast(any ptr, Param_1)
					INSTANCE_STRUCT_THREAD.ARG_5 = malloc(sizeof(Param_2))
					memcpy(INSTANCE_STRUCT_THREAD.ARG_5, cast(any ptr, @Param_2), sizeof(Param_2))


					'' 25-01-2017 A FAIRE : Gerer les priorites
					If Thread_MaxStdMin = 1 Then ' Execution dans un thread de priorite minimale
						IF CPCDOS_INSTANCE.SYSTEME_INSTANCE.get_DBG_DEBUG() > 0 Then
							IF CPCDOS_INSTANCE.Utilisateur_Langage = 0 Then
								DEBUG("[CpcdosC+] DEBUT Execution multi-thread de priorit�e minimale de la commande " & Param, Affichage, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_Normal, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.AvecDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_CPCDOS, RetourVAR)
							Else
								DEBUG("[CpcdosC+] BEGIN Minimal priority multi-thread command execution ", Affichage, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_Normal, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.AvecDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_CPCDOS, RetourVAR)
							End If
						End if

						INSTANCE_STRUCT_THREAD.Priorite = _PRIORITE_THRD_TRES_FAIBLE

						' on cree le nouveau thread
						TidRetour = CPCDOS_INSTANCE.Creer_thread(INSTANCE_STRUCT_THREAD)

					ElseIf Thread_MaxStdMin = 2 Then ' Execution dans un thread de priorite minimale+
						IF CPCDOS_INSTANCE.SYSTEME_INSTANCE.get_DBG_DEBUG() > 0 Then
							IF CPCDOS_INSTANCE.Utilisateur_Langage = 0 Then
								DEBUG("[CpcdosC+] DEBUT Execution multi-thread de priorit�e normale de la commande " & Param, Affichage, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_Normal, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.AvecDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_CPCDOS, RetourVAR)
							Else
								DEBUG("[CpcdosC+] BEGIN Normal priority multi-thread command execution ", Affichage, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_Normal, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.AvecDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_CPCDOS, RetourVAR)
							End If
						End if

						INSTANCE_STRUCT_THREAD.Priorite = _PRIORITE_THRD_FAIBLE

						' on cree le nouveau thread
						TidRetour = CPCDOS_INSTANCE.Creer_thread(INSTANCE_STRUCT_THREAD)

					ElseIf Thread_MaxStdMin = 3 Then ' Execution dans un thread de priorite normale
						IF CPCDOS_INSTANCE.SYSTEME_INSTANCE.get_DBG_DEBUG() > 0 Then
							IF CPCDOS_INSTANCE.Utilisateur_Langage = 0 Then
								DEBUG("[CpcdosC+] DEBUT Execution multi-thread de priorit�e normale de la commande " & Param, Affichage, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_Normal, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.AvecDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_CPCDOS, RetourVAR)
							Else
								DEBUG("[CpcdosC+] BEGIN Normal priority multi-thread command execution ", Affichage, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_Normal, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.AvecDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_CPCDOS, RetourVAR)
							End If
						End if

						INSTANCE_STRUCT_THREAD.Priorite = _PRIORITE_THRD_MOYENNE

						' on cree le nouveau thread
						TidRetour = CPCDOS_INSTANCE.Creer_thread(INSTANCE_STRUCT_THREAD)

					ElseIf Thread_MaxStdMin = 4 Then ' Execution dans un thread de priorite normale
						IF CPCDOS_INSTANCE.SYSTEME_INSTANCE.get_DBG_DEBUG() > 0 Then
							IF CPCDOS_INSTANCE.Utilisateur_Langage = 0 Then
								DEBUG("[CpcdosC+] DEBUT Execution multi-thread de priorit�e normale de la commande " & Param, Affichage, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_Normal, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.AvecDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_CPCDOS, RetourVAR)
							Else
								DEBUG("[CpcdosC+] BEGIN Normal priority multi-thread command execution ", Affichage, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_Normal, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.AvecDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_CPCDOS, RetourVAR)
							End If
						End if

						INSTANCE_STRUCT_THREAD.Priorite = _PRIORITE_THRD_MOYENNE

						' on cree le nouveau thread
						TidRetour = CPCDOS_INSTANCE.Creer_thread(INSTANCE_STRUCT_THREAD)

					ElseIf Thread_MaxStdMin = 5 Then ' Execution dans un thread de priorite normale+
						IF CPCDOS_INSTANCE.SYSTEME_INSTANCE.get_DBG_DEBUG() > 0 Then
							IF CPCDOS_INSTANCE.Utilisateur_Langage = 0 Then
								DEBUG("[CpcdosC+] DEBUT Execution multi-thread de haute priorit�e de la commande " & Param, Affichage, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_Normal, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.AvecDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_CPCDOS, RetourVAR)
							Else
								DEBUG("[CpcdosC+] BEGIN Hight priority multi-thread command execution ", Affichage, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_Normal, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.AvecDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_CPCDOS, RetourVAR)
							End If
						End if

						INSTANCE_STRUCT_THREAD.Priorite = _PRIORITE_THRD_ASSEZ_HAUTE

						TidRetour = CPCDOS_INSTANCE.Creer_thread(INSTANCE_STRUCT_THREAD)
					End if

					if TidRetour > 0 Then
						' on cree le nouveau thread


						DEBUG("" & TidRetour, Affichage, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_Validation, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.SansDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_AFF, RetourVAR)
						exit _scope_CMD, _scope
					Else
						IF CPCDOS_INSTANCE.SYSTEME_INSTANCE.get_DBG_DEBUG() > 0 Then
							IF CPCDOS_INSTANCE.Utilisateur_Langage = 0 Then
								DEBUG("[CpcdosC+] ERREUR TID nulle, le thread '" & INSTANCE_STRUCT_THREAD.Nom & "' n'a pas pu etre cree", Affichage, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_Erreur, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.AvecDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_CPCDOS, RetourVAR)
							Else
								DEBUG("[CpcdosC+] ERROR TID is null, thread '" & INSTANCE_STRUCT_THREAD.Nom & "' can't be created ", Affichage, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_Erreur, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.AvecDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_CPCDOS, RetourVAR)
							End If
						End if
					End if
				END SCOPE
			End if

			' ====================================================================
			END SCOPE
			exit _scope_CMD, _scope
		End if ' **** CMD/ ****

	_end_scope_CMD

	_scope_CMD

		' ===============================================================
		'  Commande pour ouvrir directement/simplement un fichier
		' ===============================================================
		CommLANG(1) = "ouvrir/"
		CommLANG(2) = "open/"
		CommLANG(3) = "\\#//"
		CommTrouve = 0 : NoCMD = 0
		for boucle as integer = 1 to 2
			IF OnCherche = CommLANG(boucle) Then
				NoCMD = 0
				exit for
			Else
				NoCMD = 1
			End if
		Next boucle
		IF NoCMD = 1 then CommLANG(1) = "[F.#).|" : CommLANG(2) = "[F.#).|" : CommLANG(3) = "\\#//"

		rem Afficher la liste des commandes avec anglais / francais
		IF AfficherAide = 1 then
			IF CPCDOS_INSTANCE.Utilisateur_Langage = 0 then
				CommandesAide = CommandesAide & CRLF & " ouvrir/                    Lire simplement le contenu d'un fichier"
			Else
				CommandesAide = CommandesAide & CRLF & " open/                      Read only file content"
			END IF
		END IF
		IF CommLANG(1) = OnCherche Then CommTrouve = 1
		IF CommLANG(2) = OnCherche Then CommTrouve = 2
		IF CommTrouve > 0 Then
		IF AfficherAide = 2 then
				Mess_Aide = ""
				IF CPCDOS_INSTANCE.Utilisateur_Langage = 0 THEN
					Mess_Aide = Mess_Aide & CRLF & "  Fonctionnalit�e :"
					Mess_Aide = Mess_Aide & CRLF & "   Cette commande permet simplement de lire le contenu d'un fichier et transferer le flux"
					Mess_Aide = Mess_Aide & CRLF & "    de donnees a l'ecran ou dans une autre direction '@#, @$..'"
					Mess_Aide = Mess_Aide & CRLF & "   Cette commande est aussi pratique puisse que cpcdos ouvre, lit et ferme le fichier"
					Mess_Aide = Mess_Aide & CRLF & "    automatiquement."
					Mess_Aide = Mess_Aide & CRLF
					Mess_Aide = Mess_Aide & CRLF & "  1er exemple simple (Affichage sur la console) :"
					Mess_Aide = Mess_Aide & CRLF & "   Ouvrir/ index.htm"
					Mess_Aide = Mess_Aide & CRLF & "   Ouvrir/ Dossier\Texte.txt"
					Mess_Aide = Mess_Aide & CRLF & "   Ouvrir/ C:\Temp\resultats.log"
					Mess_Aide = Mess_Aide & CRLF
					Mess_Aide = Mess_Aide & CRLF & "  2eme exemple (R�cuperation du texte -> Variable)"
					Mess_Aide = Mess_Aide & CRLF & "   @#MonTexte Ouvrir/ C:\Redaction.txt"
					Mess_Aide = Mess_Aide & CRLF & "   txt/ Voici le contenu du fichier : %MonTexte%"
					Mess_Aide = Mess_Aide & CRLF
					Mess_Aide = Mess_Aide & CRLF & "  3eme exemple (R�cuperation du texte -> Autre fichier)"
					Mess_Aide = Mess_Aide & CRLF & "   @$C:\Copie.txt Ouvrir/ C:\Redaction.txt"
					Mess_Aide = Mess_Aide & CRLF & "   txt/ Redaction.txt a ete copi�!"
					Mess_Aide = Mess_Aide & CRLF
					Mess_Aide = Mess_Aide & CRLF & "  4eme exemple (Lire la 4eme ligne) :"
					Mess_Aide = Mess_Aide & CRLF & "   Ouvrir/ texte.txt/ligne:4"
					Mess_Aide = Mess_Aide & CRLF
					Mess_Aide = Mess_Aide & CRLF & "  5eme exemple (Lire la ligne qui contient 'toto') :"
					Mess_Aide = Mess_Aide & CRLF & "   Ouvrir/ texte.txt /texte:toto"
					Mess_Aide = Mess_Aide & CRLF
					Mess_Aide = Mess_Aide & CRLF & "  Voir aussi : ecrire/ "
					Mess_Aide = Mess_Aide & CRLF
				ELSEIF CPCDOS_INSTANCE.Utilisateur_Langage = 1 THEN
					Mess_Aide = Mess_Aide & CRLF & "  Fonctionnality :"
					Mess_Aide = Mess_Aide & CRLF & "   This command allows simply to read a file content and get data and display"
					Mess_Aide = Mess_Aide & CRLF & "    this to screen or in another direction '@#, @$ .. '"
					Mess_Aide = Mess_Aide & CRLF & "   This command is also pratical, because, he open, reads, and closes files automatically."
					Mess_Aide = Mess_Aide & CRLF
					Mess_Aide = Mess_Aide & CRLF & "  1st example simple (Displaying on console) :"
					Mess_Aide = Mess_Aide & CRLF & "   Ouvrir/ index.htm"
					Mess_Aide = Mess_Aide & CRLF & "   Ouvrir/ Directory\Text.txt"
					Mess_Aide = Mess_Aide & CRLF & "   Ouvrir/ C:\Temp\Results.log"
					Mess_Aide = Mess_Aide & CRLF
					Mess_Aide = Mess_Aide & CRLF & "  2th exemple (Getting data -> Variable)"
					Mess_Aide = Mess_Aide & CRLF & "   @#MyText Open/ C:\Redaction.txt"
					Mess_Aide = Mess_Aide & CRLF & "   txt/ This is the file content : %MyText%"
					Mess_Aide = Mess_Aide & CRLF
					Mess_Aide = Mess_Aide & CRLF & "  3th example (Getting data -> Other file)"
					Mess_Aide = Mess_Aide & CRLF & "   @$C:\Copy.txt Open/ C:\Redaction.txt"
					Mess_Aide = Mess_Aide & CRLF & "   txt/ Redaction.txt has been copied!"
					Mess_Aide = Mess_Aide & CRLF
					Mess_Aide = Mess_Aide & CRLF & "  4th example (Getting 4th line) :"
					Mess_Aide = Mess_Aide & CRLF & "   Open/ text.txt /line:4 "
					Mess_Aide = Mess_Aide & CRLF
					Mess_Aide = Mess_Aide & CRLF & "  5th example (Lire la ligne qui contient 'foo') :"
					Mess_Aide = Mess_Aide & CRLF & "   Open/ text.txt /text:foo"
					Mess_Aide = Mess_Aide & CRLF
					Mess_Aide = Mess_Aide & CRLF & "  See also : write/"
					Mess_Aide = Mess_Aide & CRLF
				END IF
				DEBUG(Mess_Aide, Affichage, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_SURBRILLE, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.SansDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_AFF, RetourVAR)
				testCMD = 0
				AfficherAide = 0
				exit _scope_CMD, _scope
			END IF
			' Tester la syntaxe
			testCMD	= CCP_Verifier_Syntaxe(Commande, CommPosition)
			IF testCMD > 10 Then exit _scope_CMD, _scope
			IF testCMD > 0 then  ' Entre 1-5 = Pas d'affichage via le @, @$ ou @#
				IF testCMD < 6 then
					Affichage = 0
					IF testCMD = 3 Then CpcdosCP_SHELL("FIX/ " & CPCDOS_INSTANCE.DEBUG_INSTANCE.LeRetour & " = \#NULL", _CLE_, NIVEAU_CCP, Param_1, Param_2) : RetourVAR = _CLE_ & "N" & NIVEAU_CCP & "->" & CPCDOS_INSTANCE.DEBUG_INSTANCE.LeRetour
					if testCMD = 2 Then RetourVAR = "$>" & CPCDOS_INSTANCE.DEBUG_INSTANCE.LeRetour ' ajouter une securite ?
				Else
					Affichage = 1
				END IF
			Else
				Affichage = 1
			END IF
			' Recuperer les Parametres
			Param = LTRIM(LTRIM(RTRIM(RTRIM(MID(Commande, CommPosition + TailleComm + 2), CHR(09))), CHR(09)))
			SCOPE
			' ===================================================================

			Dim Numero_Ligne as integer = -2
			Dim Text_Recherche as String = ""
			Dim PosParam as integer = 0
			Dim TailleParam as integer = 0
			if instr(UCASE(Param), "/LIGNE:") > 0 Then
				PosParam = instr(UCASE(Param), "/LIGNE:")
				Numero_Ligne = -1
				TailleParam = 7
			elseif instr(UCASE(Param), "/LINE:") > 0 Then
				PosParam = instr(UCASE(Param), "/LINE:")
				Numero_Ligne = -1
				TailleParam = 6
			elseif instr(UCASE(Param), "/TEXTE:") > 0 Then
				PosParam = instr(UCASE(Param), "/TEXTE:")
				TailleParam = 7
			elseif instr(UCASE(Param), "/TEXT:") > 0 Then
				PosParam = instr(UCASE(Param), "/TEXT:")
				TailleParam = 6
			end if

			if PosParam > 0 Then
				if Numero_Ligne = -1 then ' Numero de ligne
					Numero_Ligne = val(Mid(Param, PosParam + TailleParam, 8)) ' Limite a 8 digits
				elseif Numero_Ligne = -2 Then ' Texte
					Text_Recherche = Mid(Param, PosParam + TailleParam, 24) ' Limite 24 caracteres
				end if

				Param = Mid(Param, 1, PosParam - 1)
			End if


			' Tester l'existence du fichier
			If CPCDOS_INSTANCE.Fichier_Existe(Param) = TRUE then
				Dim TailleRetourCHR as integer


				IF CPCDOS_INSTANCE.SYSTEME_INSTANCE.get_DBG_DEBUG() > 0 Then
					IF CPCDOS_INSTANCE.Utilisateur_Langage = 0 Then
						DEBUG("[CpcdosC+] OK, Ouverture de '" & Param & "' ...", Affichage, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_Normal, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.AvecDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_CPCDOS, RetourVAR)
					Else
						DEBUG("[CpcdosC+] OK, opening of '" & Param & "' ...", Affichage, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_Normal, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.AvecDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_CPCDOS, RetourVAR)
					End If
				End if
				'doevents(_PAUSE_CRT) ' Pause CRT CPinticore

				' Lire le contenu depuis CPinti core
				Dim Buffer_CCP as String = CPCDOS_INSTANCE.Lire_fichier_complet(Param)

				' Cuter le contenu si le numero de ligne a ete demande
				if Numero_Ligne > -1 Then
					dim Decoupage as integer = 1
					for boucle as integer = 0 to Len(Buffer_CCP)

						if Decoupage > 1 Then
							' S'il y a un CRLF, alors on cut !
							if Instr(Buffer_CCP, CRLF) > 0 Then
								Buffer_CCP = Mid(Buffer_CCP, Instr(Buffer_CCP, CRLF) + 2)

							' Ou... s'il y a un CR
							Elseif Instr(Buffer_CCP, CR) > 0 Then
								Buffer_CCP = Mid(Buffer_CCP, Instr(Buffer_CCP, CR) + 2)

							' Ou... s'il y a un LF
							Elseif Instr(Buffer_CCP, LF) > 0 Then
								Buffer_CCP = Mid(Buffer_CCP, Instr(Buffer_CCP, LF) + 2)
							end if
						End if

						' Jusqu'a qu'on atteingne le nombre de ligne
						if Decoupage > Numero_Ligne-1 Then exit for

						' Nombre de lignes cutes
						Decoupage += 1
					next boucle

					' Puis on cute les autres lignes!
					if Instr(Buffer_CCP, CRLF) > 0 Then
						Buffer_CCP = Mid(Buffer_CCP, 1, Instr(Buffer_CCP, CRLF) - 1)
					Elseif Instr(Buffer_CCP, CR) > 0 Then
						Buffer_CCP = Mid(Buffer_CCP, 1, Instr(Buffer_CCP, CR) - 1)
					Elseif Instr(Buffer_CCP, LF) > 0 Then
						Buffer_CCP = Mid(Buffer_CCP, 1, Instr(Buffer_CCP, LF) - 1)
					end if

				' Cuter le contenu a partir de la ligne souhaite ou le texte apparait
				ElseIf Numero_Ligne = -2 Then
					dim Decoupage as integer = 1
					if len(Text_Recherche) > 0 Then
						for boucle as integer = 0 to Len(Buffer_CCP)

							if Decoupage > 1 Then
								' S'il y a un CRLF, alors on cut !
								if Instr(Buffer_CCP, CRLF) > 0 Then
									Buffer_CCP = Mid(Buffer_CCP, Instr(Buffer_CCP, CRLF) + 2)

								' Ou... s'il y a un CR
								Elseif Instr(Buffer_CCP, CR) > 0 Then
									Buffer_CCP = Mid(Buffer_CCP, Instr(Buffer_CCP, CR) + 1)

								' Ou... s'il y a un LF
								Elseif Instr(Buffer_CCP, LF) > 0 Then
									Buffer_CCP = Mid(Buffer_CCP, Instr(Buffer_CCP, LF) +1 )
								end if
							End if

							' Des qu'il y a le texte recherche!
							if Instr(Mid(Buffer_CCP, 1, Instr(Buffer_CCP, CRLF) - 1), Text_Recherche) > 0 Then Exit for
							if Instr(Mid(Buffer_CCP, 1, Instr(Buffer_CCP, CR) - 1), Text_Recherche) > 0 Then Exit for
							if Instr(Mid(Buffer_CCP, 1, Instr(Buffer_CCP, LF) - 1), Text_Recherche) > 0 Then Exit for

							' Jusqu'a qu'on atteingne le nombre de ligne
							if Decoupage > Len(Buffer_CCP) Then exit for

							' Nombre de lignes cutes
							Decoupage += 1

						next boucle

						' Puis on cute les autres lignes!
						if Instr(Buffer_CCP, CRLF) > 0 Then
							Buffer_CCP = Mid(Buffer_CCP, 1, Instr(Buffer_CCP, CRLF) - 1)
						Elseif Instr(Buffer_CCP, CR) > 0 Then
							Buffer_CCP = Mid(Buffer_CCP, 1, Instr(Buffer_CCP, CR) - 1)
						Elseif Instr(Buffer_CCP, LF) > 0 Then
							Buffer_CCP = Mid(Buffer_CCP, 1, Instr(Buffer_CCP, LF) - 1)
						end if
					End if
				End if

				' Recuperer la taille d fichier
				Dim Taille_Du_Fichier as uinteger = Len(Buffer_CCP)




				IF CPCDOS_INSTANCE.SYSTEME_INSTANCE.get_DBG_DEBUG() > 0 Then
					IF CPCDOS_INSTANCE.Utilisateur_Langage = 0 Then
						DEBUG("[CpcdosC+] Taille " & Taille_Du_Fichier & " octets ...", Affichage, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_Normal, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.AvecDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_CPCDOS, RetourVAR)
					Else
						DEBUG("[CpcdosC+] Size " & Taille_Du_Fichier & " bytes ...", Affichage, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_Normal, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.AvecDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_CPCDOS, RetourVAR)
					End If
				End if

				' Verifier si CPintiCore nous a communique une erreur
				IF Taille_Du_Fichier = 0 then
					' ca sert a rien de continuer si le fichier est vide
					exit _scope_CMD, _scope
				Else
					' Fichier OK !
					DEBUG(Buffer_CCP, Affichage, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_Normal, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.SansDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_AFF, RetourVAR)

					IF CPCDOS_INSTANCE.SYSTEME_INSTANCE.get_DBG_DEBUG() > 0 Then
						IF CPCDOS_INSTANCE.Utilisateur_Langage = 0 Then
							DEBUG("[CpcdosC+] Fin de lecture de " & Param, Affichage, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_Normal, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.AvecDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_CPCDOS, RetourVAR)
						Else
							DEBUG("[CpcdosC+] End reading " & Param, Affichage, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_Normal, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.AvecDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_CPCDOS, RetourVAR)
						End If
					End if


				End if ' l'erreur interne
			else
				' Ah bah fichier indisponible
				Message_erreur = ERRAVT("ERR_015", 0)
				DEBUG("[CpcdosC+] " & Message_erreur & " " & CHR(34) & Param & CHR(34), Affichage, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_ERREUR, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.SansDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_AFF, RetourVAR)
			End if
			' Fin

			' ====================================================================
			END SCOPE
			exit _scope_CMD, _scope
		End if ' **** OUVRIR/ ****

	_end_scope_CMD

	_scope_CMD

		' ===============================================================
		'  Commande pour ecrire directement/simplement un fichier
		' ===============================================================
		CommLANG(1) = "ecrire/"
		CommLANG(2) = "write/"
		CommLANG(3) = "\\#//"
		CommTrouve = 0 : NoCMD = 0
		for boucle as integer = 1 to 2
			IF OnCherche = CommLANG(boucle) Then
				NoCMD = 0
				exit for
			Else
				NoCMD = 1
			End if
		Next boucle
		IF NoCMD = 1 then CommLANG(1) = "[F.#).|" : CommLANG(2) = "[F.#).|" : CommLANG(3) = "\\#//"

		rem Afficher la liste des commandes avec anglais / francais
		IF AfficherAide = 1 then
			IF CPCDOS_INSTANCE.Utilisateur_Langage = 0 then
				CommandesAide = CommandesAide & CRLF & " ecrire/                    Ecrire simplement dans un fichier"
			Else
				CommandesAide = CommandesAide & CRLF & " write/                     Write in file"
			END IF
		END IF
		IF CommLANG(1) = OnCherche Then CommTrouve = 1
		IF CommLANG(2) = OnCherche Then CommTrouve = 2
		IF CommTrouve > 0 Then
		IF AfficherAide = 2 then
				Mess_Aide = ""
				IF CPCDOS_INSTANCE.Utilisateur_Langage = 0 THEN
					Mess_Aide = Mess_Aide & CRLF & "  Fonctionnalit�e :"
					Mess_Aide = Mess_Aide & CRLF & "   Cette commande permet simplement d'ecrire dans un fichier"
					Mess_Aide = Mess_Aide & CRLF
					Mess_Aide = Mess_Aide & CRLF & "  Parametres diponibles:"
					Mess_Aide = Mess_Aide & CRLF & "   /BIN : Ecrire en mode BINaire"
					Mess_Aide = Mess_Aide & CRLF & "   /APP : Ecrire en mode APPending"
					Mess_Aide = Mess_Aide & CRLF & "   /APPBIN ou /BINAPP :"
					Mess_Aide = Mess_Aide & CRLF & "          Ecrire binaire en mode APPending"
					Mess_Aide = Mess_Aide & CRLF & "   Sans parametres : Ecriture normale"
					Mess_Aide = Mess_Aide & CRLF
					Mess_Aide = Mess_Aide & CRLF
					Mess_Aide = Mess_Aide & CRLF & "  Exemple 1 :"
					Mess_Aide = Mess_Aide & CRLF & "   Ecrire/ toto.txt = Hello le monde!"
					Mess_Aide = Mess_Aide & CRLF & "   Ecrire/ /APP index.htm = Vous allez bien ?"
					Mess_Aide = Mess_Aide & CRLF
					Mess_Aide = Mess_Aide & CRLF & "  Exemple 2 (Ajoute 1 saut de ligne) :"
					Mess_Aide = Mess_Aide & CRLF & "   Ecrire/ toto.txt = Bonjour %CPC.CRLF%Ca va ?"
					Mess_Aide = Mess_Aide & CRLF
					Mess_Aide = Mess_Aide & CRLF & "  Exemple 3 (A partir d'une variable) :"
					Mess_Aide = Mess_Aide & CRLF & "   FIX/ Mon_Contenu = Voici le contenu du fichier."
					Mess_Aide = Mess_Aide & CRLF & "   Ecrire/ toto.txt = %Mon_Contenu% Et c'est tout!"
					Mess_Aide = Mess_Aide & CRLF
					Mess_Aide = Mess_Aide & CRLF & "  Exemple 4 (Copier le contenu d'un fichier dans un autre) :"
					Mess_Aide = Mess_Aide & CRLF & "   @#Donnees Ouvrir/ Source.txt"
					Mess_Aide = Mess_Aide & CRLF & "   Ecrire/ Destination.txt = %Donnees%"
					Mess_Aide = Mess_Aide & CRLF
					Mess_Aide = Mess_Aide & CRLF & " Autres informations :"
					Mess_Aide = Mess_Aide & CRLF & "  En mode binaire, le retour chariot CRLF n'est pas ecrit en fin de ligne"
					Mess_Aide = Mess_Aide & CRLF
					Mess_Aide = Mess_Aide & CRLF & "  Voir aussi : Ouvrir/ "
					Mess_Aide = Mess_Aide & CRLF
				ELSEIF CPCDOS_INSTANCE.Utilisateur_Langage = 1 THEN
					Mess_Aide = Mess_Aide & CRLF & "  Fonctionnality :"
					Mess_Aide = Mess_Aide & CRLF & "   This command allows write in a file."
					Mess_Aide = Mess_Aide & CRLF
					Mess_Aide = Mess_Aide & CRLF & "  Avaiable parameters:"
					Mess_Aide = Mess_Aide & CRLF & "   /BIN : Writing in BINary mode"
					Mess_Aide = Mess_Aide & CRLF & "   /APP : Writing in APPending mode"
					Mess_Aide = Mess_Aide & CRLF & "   /APPBIN  or  /BINAPP :"
					Mess_Aide = Mess_Aide & CRLF & "          Writing in BINary and APPending mode"
					Mess_Aide = Mess_Aide & CRLF & "   Without parameters : Normal writing"
					Mess_Aide = Mess_Aide & CRLF
					Mess_Aide = Mess_Aide & CRLF
					Mess_Aide = Mess_Aide & CRLF & "  Example 1 :"
					Mess_Aide = Mess_Aide & CRLF & "   Write/ foo.txt = Hello everyone!"
					Mess_Aide = Mess_Aide & CRLF & "   Write/ /APP foo.txt = how are you?"
					Mess_Aide = Mess_Aide & CRLF
					Mess_Aide = Mess_Aide & CRLF & "  Example 2 (Add 1 jump line) :"
					Mess_Aide = Mess_Aide & CRLF & "   Write/ foo.txt = Hello %CPC.CRLF%how are you?"
					Mess_Aide = Mess_Aide & CRLF
					Mess_Aide = Mess_Aide & CRLF & "  Example 3 (From variable) :"
					Mess_Aide = Mess_Aide & CRLF & "   SET/ My_Content = This is the file content"
					Mess_Aide = Mess_Aide & CRLF & "   Write/ foo.txt = %My_Content% the end!"
					Mess_Aide = Mess_Aide & CRLF
					Mess_Aide = Mess_Aide & CRLF & "  Example 4 (Copy the file content for another)"
					Mess_Aide = Mess_Aide & CRLF & "   @#Data Open/ Source.txt"
					Mess_Aide = Mess_Aide & CRLF & "   Write/ Destination.txt = %Data%"
					Mess_Aide = Mess_Aide & CRLF
					Mess_Aide = Mess_Aide & CRLF & " Others informations :"
					Mess_Aide = Mess_Aide & CRLF & "  In binary mode, the CRLF is not included on each lines"
					Mess_Aide = Mess_Aide & CRLF
					Mess_Aide = Mess_Aide & CRLF & "  See also : open/"
					Mess_Aide = Mess_Aide & CRLF
				END IF
				DEBUG(Mess_Aide, Affichage, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_SURBRILLE, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.SansDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_AFF, RetourVAR)
				testCMD = 0
				AfficherAide = 0
				exit _scope_CMD, _scope
			END IF
			' Tester la syntaxe
			testCMD	= CCP_Verifier_Syntaxe(Commande, CommPosition)
			IF testCMD > 10 Then exit _scope_CMD, _scope
			IF testCMD > 0 then  ' Entre 1-5 = Pas d'affichage via le @, @$ ou @#
				IF testCMD < 6 then
					Affichage = 0
					IF testCMD = 3 Then CpcdosCP_SHELL("FIX/ " & CPCDOS_INSTANCE.DEBUG_INSTANCE.LeRetour & " = \#NULL", _CLE_, NIVEAU_CCP, Param_1, Param_2) : RetourVAR = _CLE_ & "N" & NIVEAU_CCP & "->" & CPCDOS_INSTANCE.DEBUG_INSTANCE.LeRetour
					if testCMD = 2 Then RetourVAR = "$>" & CPCDOS_INSTANCE.DEBUG_INSTANCE.LeRetour ' ajouter une securite ?
				Else
					Affichage = 1
				END IF
			Else
				Affichage = 1
			END IF
			' Recuperer les Parametres
			Param = MID(Commande, CommPosition + TailleComm + 2)
			SCOPE
			' ===================================================================

			IF CPCDOS_INSTANCE.SYSTEME_INSTANCE.get_DBG_DEBUG() > 0 Then
				IF CPCDOS_INSTANCE.Utilisateur_Langage = 0 Then
					DEBUG("[CpcdosC+][CPinti] Creation d'une nouvelle instance de CPinti pour l'ecriture de " & Param & " ...", Affichage, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_Normal, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.AvecDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_CPCDOS, RetourVAR)
				Else
					DEBUG("[CpcdosC+][CPinti] Creating new CPinti instance for writing " & Param & " ...", Affichage, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_Normal, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.AvecDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_CPCDOS, RetourVAR)
				End If
			End if


			Dim FLAG as integer = 0 ' Par defaut (ca ecrase tout)

			Dim PosEgECR as integer = 0 ' 0 par defaut = ecrase tout
			Dim PosParamFLAG(0 to 3) as integer

			Dim Donnees as string
			Dim Nom_Fichier as String
			PosEgECR = Instr(Ucase(Param), "=")
			if PosEgECR > 0 then ' Tant que les parametres serons derriere le '='

				PosParamFLAG(0) = instr(ucase(Param), "/BIN ") ' Mode binaire
				PosParamFLAG(1) = instr(ucase(Param), "/APP ") ' Mode appending
				PosParamFLAG(2) = instr(ucase(Param), "/BINAPP ") ' Mode binaire appending
				PosParamFLAG(3) = instr(ucase(Param), "/APPBIN ") ' Mode binaire appending

				if PosParamFLAG(3) > 0 and PosParamFLAG(3) < PosEgECR then
					Param = Mid(Param, PosParamFLAG(3) + 8)
					FLAG = 3 ' Mode binaire + appending
				elseif PosParamFLAG(2) > 0  and PosParamFLAG(2) < PosEgECR then
					Param = Mid(Param, PosParamFLAG(2) + 8)
					FLAG = 3 ' Mode binaire + appending
				elseif PosParamFLAG(1) > 0  and PosParamFLAG(1) < PosEgECR then
					Param = Mid(Param, PosParamFLAG(1) + 5)
					FLAG = 2 ' Mode appending
				elseif PosParamFLAG(0) > 0  and PosParamFLAG(0) < PosEgECR then
					Param = Mid(Param, PosParamFLAG(0) +5)
					FLAG = 1 ' Mode binaire
				end if
			end if


			PosEgECR = Instr(Ucase(Param), "=")

			' Si le signe '=' est present
			if PosEgECR > 0 then
				Nom_Fichier = LTRIM(RTRIM(LTRIM(Mid(Param, 1, PosEgECR - 1))), CHR(09)) ' Recuperer le nom enlevant TAB, et espaces avant et apres

				Donnees = Mid(Param, PosEgECR + 1)

				' Si ca commence par un espace alors on le compte pas, le 2eme oui
				if MID(Donnees, 1, 1) = " " Then Donnees = MID(Donnees, 2)

				' Si c'est PAS en binaire, alors on ajoute le CRLF
				IF FLAG = 0 OR FLAG = 2 Then
					if NOT Donnees = "" Then
						Donnees = Donnees & CRLF
					End if
				END IF
			else
				' Pas de "=" on cree simplement le fichier
				Nom_Fichier = LTRIM(RTRIM(LTRIM(Mid(Param, 1, PosEgECR - 1))), CHR(09)) ' Recuperer le nom enlevant TAB, et espaces avant et apres
				Donnees = ""
				FLAG = 0
			end if

			if Nom_Fichier = "" then
				' Avertissment
				IF CPCDOS_INSTANCE.Utilisateur_Langage = 0 Then
					DEBUG("[CpcdosC+] Entrez un nom de fichier correct.", Affichage, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_OK, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.AvecDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_AFF, RetourVAR)
				Else
					DEBUG("[CpcdosC+] Please enter correct name file", Affichage, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_OK, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.AvecDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_AFF, RetourVAR)
				End If
				exit _scope_CMD, _scope
			end if


			' Ecrire les donnees depuis CPinti Core
			if CPCDOS_INSTANCE.Ecrire_fichier_complet(Nom_Fichier, Donnees, FLAG) >= 0 then
				IF CPCDOS_INSTANCE.SYSTEME_INSTANCE.get_DBG_DEBUG() > 0 Then
					IF CPCDOS_INSTANCE.Utilisateur_Langage = 0 Then
						DEBUG("[CpcdosC+] Ecriture terminee", Affichage, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_OK, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.AvecDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_CPCDOS, RetourVAR)
					Else
						DEBUG("[CpcdosC+] Writting is finish", Affichage, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_OK, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.AvecDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_CPCDOS, RetourVAR)
					End If
				End if
			else
				' erreur
				Message_erreur = ERRAVT("ERR_053", 0) ' Erreur lors de l'ecriture du fichier
				IF CPCDOS_INSTANCE.Utilisateur_Langage = 0 Then
					DEBUG("[CpcdosC+] ERR_053:" & Message_erreur & " Verifiez son chemin d'acces et sa disponibilitee.", Affichage, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_OK, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.AvecDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_AFF, RetourVAR)
				Else
					DEBUG("[CpcdosC+] ERR_053:" & Message_erreur & " Please verify access path and his disponibilities.", Affichage, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_OK, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.AvecDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_AFF, RetourVAR)
				End If
			end if

			' ===================================================================
			END SCOPE
			exit _scope_CMD, _scope
		End if ' **** ECRIRE/ ****

	_end_scope_CMD

	_scope_CMD


		' ===============================================================
		'  Commande pour pinger une machine
		' ===============================================================
		CommLANG(1) = "ping/"
		CommLANG(2) = "ping/"
		CommLANG(3) = "\\#//"
		CommTrouve = 0 : NoCMD = 0
		for boucle as integer = 1 to 2
			IF OnCherche = CommLANG(boucle) Then
				NoCMD = 0
				exit for
			Else
				NoCMD = 1
			End if
		Next boucle
		IF NoCMD = 1 then CommLANG(1) = "[F.#).|" : CommLANG(2) = "[F.#).|" : CommLANG(3) = "\\#//"

		rem Afficher la liste des commandes avec anglais / francais
		IF AfficherAide = 1 then
			IF CPCDOS_INSTANCE.Utilisateur_Langage = 0 then
				CommandesAide = CommandesAide & CRLF & " ping/                      Tester une machine sur le reseau"
			Else
				CommandesAide = CommandesAide & CRLF & " ping/                      Test a network machine"
			END IF
		END IF
		IF CommLANG(1) = OnCherche Then CommTrouve = 1
		IF CommLANG(2) = OnCherche Then CommTrouve = 2
		IF CommTrouve > 0 Then
		IF AfficherAide = 2 then
				Mess_Aide = ""
				IF CPCDOS_INSTANCE.Utilisateur_Langage = 0 THEN
					Mess_Aide = Mess_Aide & CRLF & "  Fonctionnalit�e :"
					Mess_Aide = Mess_Aide & CRLF & "   Cette commande permet d'envoyer une requete ICMP sur une machine connect�e"
					Mess_Aide = Mess_Aide & CRLF
					Mess_Aide = Mess_Aide & CRLF & "  Exemple simple :"
					Mess_Aide = Mess_Aide & CRLF & "   Ping/ 192.168.1.1"
					Mess_Aide = Mess_Aide & CRLF & "   Ping/ www.google.fr"
					Mess_Aide = Mess_Aide & CRLF & "   Ping/ cpcdos.fr.nf"
					Mess_Aide = Mess_Aide & CRLF
					Mess_Aide = Mess_Aide & CRLF & "  Voir aussi : serveur/ , "
					Mess_Aide = Mess_Aide & CRLF
				ELSEIF CPCDOS_INSTANCE.Utilisateur_Langage = 1 THEN
					Mess_Aide = Mess_Aide & CRLF & "  Fonctionnality :"
					Mess_Aide = Mess_Aide & CRLF & "   This command allow to test a network machine with ICMP request"
					Mess_Aide = Mess_Aide & CRLF
					Mess_Aide = Mess_Aide & CRLF & "  Simple exemple :"
					Mess_Aide = Mess_Aide & CRLF & "   Ping/ 192.168.1.1"
					Mess_Aide = Mess_Aide & CRLF & "   Ping/ www.google.fr"
					Mess_Aide = Mess_Aide & CRLF & "   Ping/ cpcdos.fr.nf"
					Mess_Aide = Mess_Aide & CRLF
					Mess_Aide = Mess_Aide & CRLF & "  See also : server/ "
					Mess_Aide = Mess_Aide & CRLF
				END IF
				DEBUG(Mess_Aide, Affichage, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_SURBRILLE, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.SansDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_AFF, RetourVAR)
				testCMD = 0
				AfficherAide = 0
				exit _scope_CMD, _scope
			END IF
			' Tester la syntaxe
			testCMD	= CCP_Verifier_Syntaxe(Commande, CommPosition)
			IF testCMD > 10 Then exit _scope_CMD, _scope
			IF testCMD > 0 then  ' Entre 1-5 = Pas d'affichage via le @, @$ ou @#
				IF testCMD < 6 then
					Affichage = 0
					IF testCMD = 3 Then CpcdosCP_SHELL("FIX/ " & CPCDOS_INSTANCE.DEBUG_INSTANCE.LeRetour & " = \#NULL", _CLE_, NIVEAU_CCP, Param_1, Param_2) : RetourVAR = _CLE_ & "N" & NIVEAU_CCP & "->" & CPCDOS_INSTANCE.DEBUG_INSTANCE.LeRetour
					if testCMD = 2 Then RetourVAR = "$>" & CPCDOS_INSTANCE.DEBUG_INSTANCE.LeRetour ' ajouter une securite ?
				Else
					Affichage = 1
				END IF
			Else
				Affichage = 1
			END IF
			' Recuperer les Parametres
			Param = MID(Commande, CommPosition + TailleComm + 2)
			SCOPE
			' ===================================================================

			Dim AdresseIP 	as String
			Dim TestPing	as Integer
			Dim TempsPris	as Integer
' --------------------- if 1 = 1 then ''if Demarrage_OK = 1 then ----------------------------------------
			if 1 = 1 then
				IF Param <> "" Then
					If Param <> " " Then
						AdresseIP = Param
					End if
				End if

				IF CPCDOS_INSTANCE.SYSTEME_INSTANCE.get_DBG_DEBUG() > 0 Then
					IF CPCDOS_INSTANCE.Utilisateur_Langage = 0 Then
						DEBUG("[CpcdosC+] Envoi d'une requete ICMP a " & AdresseIP & " ...", Affichage, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_Normal, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.AvecDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_CPCDOS, RetourVAR)
					Else
						DEBUG("[CpcdosC+] Sending ICMP request to " & AdresseIP & " ...", Affichage, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_Normal, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.AvecDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_CPCDOS, RetourVAR)
					End If
				End if

				' Appeler la fonction pour envoyer la requete ping
				TestPing = CPCDOS_INSTANCE.RESEAU_INSTANCE.Ping(AdresseIP, _CLE_)

				if TestPing >= 0 then ' La machine a repondu a la requete ICMP
					IF CPCDOS_INSTANCE.Utilisateur_Langage = 0 Then
						DEBUG("[CPinti] Reseau Ping " & AdresseIP & " a repondu! (" & TestPing & " ms)", Affichage, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_VALIDATION, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.AvecDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_AFF, RetourVAR)
					Else
						DEBUG("[CPinti] Network Ping: Reponse from " & AdresseIP & "! (" & TestPing & " ms)" , Affichage, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_VALIDATION, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.AvecDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_AFF, RetourVAR)
					End If
				elseif TestPing < -1 then
					' Probleme reseau
					IF CPCDOS_INSTANCE.Utilisateur_Langage = 0 Then
						DEBUG("[CPinti] Reseau Ping: (" & AdresseIP & ") Erreur reseau...", Affichage, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_ERREUR, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.AvecDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_AFF, RetourVAR)
					Else
						DEBUG("[CPinti] Network Ping: (" & AdresseIP & ") Network error...", Affichage, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_ERREUR, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.AvecDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_AFF, RetourVAR)
					End If
				else
					' La machine n'a pas repondu..
					IF CPCDOS_INSTANCE.Utilisateur_Langage = 0 Then
						DEBUG("[CPinti] Reseau Ping: " & AdresseIP & " n'a pas repondu...", Affichage, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_AVERTISSEMENT, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.AvecDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_AFF, RetourVAR)
					Else
						DEBUG("[CPinti] Network Ping: No reponse from " & AdresseIP & " ..." , Affichage, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_AVERTISSEMENT, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.AvecDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_AFF, RetourVAR)
					End If
				end if
			Else ' Aucun pilote reseau ou mode DOSBOX
				IF CPCDOS_INSTANCE.DosBox = True Then
					Message_erreur = ERRAVT("AVT_055", 0)
					IF CPCDOS_INSTANCE.Utilisateur_Langage = 0 Then
						DEBUG("[CPinti] Reseau ping: (" & AdresseIP & ") " & Message_erreur & ". Impossible de pinger la machine", Affichage, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_AVERTISSEMENT, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.SansDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_AFF, RetourVAR)
					Else
						DEBUG("[CPinti] Network Ping: (" & AdresseIP & ") " & Message_erreur & ". Unable to ping machine", Affichage, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_AVERTISSEMENT, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.SansDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_AFF, RetourVAR)
					End if
				ELSE
					Message_erreur = ERRAVT("AVT_023", 0)
					IF CPCDOS_INSTANCE.Utilisateur_Langage = 0 Then
						DEBUG("[CPinti] Reseau ping: (" & AdresseIP & ") " & Message_erreur & ". Impossible de pinger la machine", Affichage, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_AVERTISSEMENT, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.SansDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_AFF, RetourVAR)
					Else
						DEBUG("[CPinti] Network Ping: (" & AdresseIP & ") " & Message_erreur & ". Unable to ping machine", Affichage, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_AVERTISSEMENT, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.SansDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_AFF, RetourVAR)
					End if
				END IF
			end if

			' ===================================================================
			END SCOPE
			exit _scope_CMD, _scope
		End if ' **** PING/ ****

	_end_scope_CMD

	_scope_CMD

		' ===============================================================
		'  Commande pour telecharger un fichier en http
		' ===============================================================
		CommLANG(1) = "telecharger/"
		CommLANG(2) = "download/"
		CommLANG(3) = "\\#//"
		CommTrouve = 0 : NoCMD = 0
		for boucle as integer = 1 to 2
			IF OnCherche = CommLANG(boucle) Then
				NoCMD = 0
				exit for
			Else
				NoCMD = 1
			End if
		Next boucle
		IF NoCMD = 1 then CommLANG(1) = "[F.#).|" : CommLANG(2) = "[F.#).|" : CommLANG(3) = "\\#//"

		rem Afficher la liste des commandes avec anglais / francais
		IF AfficherAide = 1 then
			IF CPCDOS_INSTANCE.Utilisateur_Langage = 0 then
				CommandesAide = CommandesAide & CRLF & " telecharger/               Telecharge un fichier HTTP"
			Else
				CommandesAide = CommandesAide & CRLF & " download/                  Download HTTP file"
			END IF
		END IF
		IF CommLANG(1) = OnCherche Then CommTrouve = 1
		IF CommLANG(2) = OnCherche Then CommTrouve = 2
		IF CommTrouve > 0 Then
		IF AfficherAide = 2 then
				Mess_Aide = ""
				IF CPCDOS_INSTANCE.Utilisateur_Langage = 0 THEN
					Mess_Aide = Mess_Aide & CRLF & "  Fonctionnalit�e :"
					Mess_Aide = Mess_Aide & CRLF & "   Cette commande permet de t�l�charger un fichier sur un serveur HTTP"
					Mess_Aide = Mess_Aide & CRLF & "   Par defaut, les fichiers telecharges se trouve dans le dossier TEMP\NET"
					Mess_Aide = Mess_Aide & CRLF & "    Variable utilisee pour cette operation %CPC_TEMP.NET%"
					Mess_Aide = Mess_Aide & CRLF
					Mess_Aide = Mess_Aide & CRLF & "  Exemple simple :"
					Mess_Aide = Mess_Aide & CRLF & "   Telecharger/ http://www.google.fr/"
					Mess_Aide = Mess_Aide & CRLF & "   Telecharger/ http://192.168.1.1/index.html"
					Mess_Aide = Mess_Aide & CRLF & "   Telecharger/ http://monsiteWeb/dossier/fichier.cpc"
					Mess_Aide = Mess_Aide & CRLF & "   Telecharger/ http://monsiteweb/images/photo.png"
					Mess_Aide = Mess_Aide & CRLF
					Mess_Aide = Mess_Aide & CRLF & "  Recevoir uniquement les information du serveur (HEAD command)"
					Mess_Aide = Mess_Aide & CRLF & "   Telecharger/ /SRVINFO http://MonSiteWeb.com/toto.html"
					Mess_Aide = Mess_Aide & CRLF
					Mess_Aide = Mess_Aide & CRLF & "  Recevoir les information du serveur + les donnees"
					Mess_Aide = Mess_Aide & CRLF & "   Telecharger/ /+SRVINFO http://MonSiteWeb.com/toto.html"
					Mess_Aide = Mess_Aide & CRLF
					Mess_Aide = Mess_Aide & CRLF & "  Vous pouvez recuperer le pourcentage de la progression depuis un autre thread"
					Mess_Aide = Mess_Aide & CRLF & "   via une variable de niveau 5 :"
					Mess_Aide = Mess_Aide & CRLF & "    telecharger/ http://blabla.com /Progression:MaVariable"
					Mess_Aide = Mess_Aide & CRLF & "      --> Et durant le telechargement, la variable %MaVariable% contient la progression en % de la copie"
					Mess_Aide = Mess_Aide & CRLF
					Mess_Aide = Mess_Aide & CRLF & "  Meme chose pour le nombre d'octets copie :"
					Mess_Aide = Mess_Aide & CRLF & "    telecharger/ http://blabla.com /Octets:MaVariable"
					Mess_Aide = Mess_Aide & CRLF
					Mess_Aide = Mess_Aide & CRLF & "  Le nombre d'octets par secondes :"
					Mess_Aide = Mess_Aide & CRLF & "    telecharger/ http://blabla.com /OctetsParSec:MaVariable"
					Mess_Aide = Mess_Aide & CRLF
					Mess_Aide = Mess_Aide & CRLF & "  Ou les 2 ou 3 parametres en meme temps aussi !"
					Mess_Aide = Mess_Aide & CRLF & "    telecharger/ http://blabla.com /Pogresson:Var1 /octets:Var2 /OctetsParSec:Var3"
					Mess_Aide = Mess_Aide & CRLF
					Mess_Aide = Mess_Aide & CRLF & "  Recuperer le numero de socket :"
					Mess_Aide = Mess_Aide & CRLF & "    telecharger/ http://blabla.com /socket:MaVariable"
					Mess_Aide = Mess_Aide & CRLF
					Mess_Aide = Mess_Aide & CRLF & "  Choisir le dossier de destination manuellement :"
					Mess_Aide = Mess_Aide & CRLF & "   Telecharger/ http://monsite.com/toto.html /Temp:c:\Dossier"
					Mess_Aide = Mess_Aide & CRLF & "  Choisir le fichier de destination en plus du dossier :"
					Mess_Aide = Mess_Aide & CRLF & "   Telecharger/ http://monsite.com/toto.html /Temp:c:\Dossier\Fichier.html"
					Mess_Aide = Mess_Aide & CRLF
					Mess_Aide = Mess_Aide & CRLF & "  Voir aussi : serveur/ , ping/ "
					Mess_Aide = Mess_Aide & CRLF
				ELSEIF CPCDOS_INSTANCE.Utilisateur_Langage = 1 THEN
					Mess_Aide = Mess_Aide & CRLF & "  Fonctionnality :"
					Mess_Aide = Mess_Aide & CRLF & "   This command allow to download a HTTP file"
					Mess_Aide = Mess_Aide & CRLF
					Mess_Aide = Mess_Aide & CRLF & "   Download/ http://www.google.com/"
					Mess_Aide = Mess_Aide & CRLF & "   download/ http://192.168.1.1/index.html"
					Mess_Aide = Mess_Aide & CRLF & "   download/ http://myWebSite/directory/file.cpc"
					Mess_Aide = Mess_Aide & CRLF & "   Download/ http://myWebSite/images/picture.png"
					Mess_Aide = Mess_Aide & CRLF
					Mess_Aide = Mess_Aide & CRLF & "  Recieve only server informations (HEAD command)"
					Mess_Aide = Mess_Aide & CRLF & "   Download/ /SRVINFO http://MyWebSite.com/foo.html"
					Mess_Aide = Mess_Aide & CRLF
					Mess_Aide = Mess_Aide & CRLF & "  Recieve server informations + file data"
					Mess_Aide = Mess_Aide & CRLF & "   Telecharger/ /+SRVINFO http://MyWebSite.com/foo.html"
					Mess_Aide = Mess_Aide & CRLF
					Mess_Aide = Mess_Aide & CRLF & "  Choice manually directory destination :"
					Mess_Aide = Mess_Aide & CRLF & "   Download/ http://monsite.com/toto.html /Temp:c:\MyDirectory"
					Mess_Aide = Mess_Aide & CRLF & "  Choice the name file :"
					Mess_Aide = Mess_Aide & CRLF & "   Download/ http://monsite.com/toto.html /Temp:c:\MyDirectory\MyFile.html"
					Mess_Aide = Mess_Aide & CRLF
					Mess_Aide = Mess_Aide & CRLF & "  You can get pourcentage during downloading from another thread with level 5 variable :"
					Mess_Aide = Mess_Aide & CRLF & "    download/ http://blabla.com /Progression:MyVariable"
					Mess_Aide = Mess_Aide & CRLF & "      --> And during downloading, variable %MyVariable% content the % of donwload"
					Mess_Aide = Mess_Aide & CRLF
					Mess_Aide = Mess_Aide & CRLF & "  Same thing with bytes :"
					Mess_Aide = Mess_Aide & CRLF & "    download/ http://blabla.com /Bytes:MyVariable"
					Mess_Aide = Mess_Aide & CRLF
					Mess_Aide = Mess_Aide & CRLF & "  Count of bytes by seconds :"
					Mess_Aide = Mess_Aide & CRLF & "    download/ http://blabla.com /BytesBySec:MyVariable"
					Mess_Aide = Mess_Aide & CRLF
					Mess_Aide = Mess_Aide & CRLF & "  Get socket number : "
					Mess_Aide = Mess_Aide & CRLF & "    download/ http://blabla.com /Socket:MyVariable"
					Mess_Aide = Mess_Aide & CRLF
					Mess_Aide = Mess_Aide & CRLF & "  Or more parametrers in same time"
					Mess_Aide = Mess_Aide & CRLF & "    download/ http://blabla.com /Progression:Var1 /Bytes:Var2 /BytesBySec:Var3"
					Mess_Aide = Mess_Aide & CRLF
					Mess_Aide = Mess_Aide & CRLF & "  See also : server/ , ping/"
					Mess_Aide = Mess_Aide & CRLF
				END IF
				DEBUG(Mess_Aide, Affichage, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_SURBRILLE, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.SansDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_AFF, RetourVAR)
				testCMD = 0
				AfficherAide = 0
				exit _scope_CMD, _scope
			END IF
			' Tester la syntaxe
			testCMD	= CCP_Verifier_Syntaxe(Commande, CommPosition)
			IF testCMD > 10 Then exit _scope_CMD, _scope
			IF testCMD > 0 then  ' Entre 1-5 = Pas d'affichage via le @, @$ ou @#
				IF testCMD < 6 then
					Affichage = 0
					IF testCMD = 3 Then CpcdosCP_SHELL("FIX/ " & CPCDOS_INSTANCE.DEBUG_INSTANCE.LeRetour & " = \#NULL", _CLE_, NIVEAU_CCP, Param_1, Param_2) : RetourVAR = _CLE_ & "N" & NIVEAU_CCP & "->" & CPCDOS_INSTANCE.DEBUG_INSTANCE.LeRetour
					if testCMD = 2 Then RetourVAR = "$>" & CPCDOS_INSTANCE.DEBUG_INSTANCE.LeRetour ' ajouter une securite ?
				Else
					Affichage = 1
				END IF
			Else
				Affichage = 1
			END IF
			' Recuperer les Parametres
			Param = MID(Commande, CommPosition + TailleComm + 2)
			SCOPE
			' ===================================================================

			' === A FAIRE ===
			' Telecharger du HTTP avec nom du fichier dans l'URI. Si nom de fichier URI non present, alors index.htm
			' Telecharger uniquement le HEAD
			' Telecharer AVEC le HEAD
			' Telecharger avec comme destination l'ecran ou dossier TEMP
			' Telecharger avec un port perso
			' === A FAIRE ===


			if 1 = 1 then ''if Demarrage_OK = 1 then
				Dim DossierTemp_NET 		as string = UCASE(CCP_Lire_Variable("CPC_TEMP.NET", 5, _CLE_))
				Dim Adresse_Serveur 		as string = "255.255.255.255"
				Dim Adresse_URI				as String
				Dim Commande_HTTP 			as string = "    "
				Dim Redirection				as string = ""
				Dim Redirection_REPERTOIRE	as string = ""
				Dim Redirection_MANUEL		as String

				Dim POS_http				as Integer
				Dim POS_https				as Integer
				Dim POS_ftp					as integer

				Dim POS_SRVINFO				as integer
				Dim POS_PlusSRVINFO			as integer

				Dim POS_Temp				as integer
				Dim POS_Temp_Relatif		as integer

				Dim PosOctets 			as integer


				Dim PosBytes 			as integer

				Dim PosOctetsParSec		as integer
				Dim PosBytesBySec		as integer


				Dim Var_Progression 	as String
				Dim Var_Octets 			as String
				Dim Var_OctetsParSec 	as String
				Dim VAR_Socket			as String

				Dim PosProgress as integer = Instr(Ucase(Param), " /PROGRESSION:")


				' Supprimer les espaces et tabulations
				Param = RTRIM(LTRIM(LTRIM(Param), chr(09)))

				if PosProgress > 0 Then
					IF PosProgress > Instr(Param, ",") Then
						Var_Progression = Rtrim(Rtrim(Ltrim(Ltrim(Mid(Param, PosProgress + 14, Instr(PosProgress + 14, Param & " ", " ") - (PosProgress + 14)), CHR(09))), CHR(09)))

						Param = Param & " "

						' Supprimer le progress
						Param = Mid(Param, 1, PosProgress - 1) & " " & Mid(Param, Instr(PosProgress + 14, Param & " ", " ") + 1)

					Else
						IF CPCDOS_INSTANCE.Utilisateur_Langage = 0 Then
							DEBUG("[CpcdosC+] Veuillez placer l'argument '/PROGRESSION' apres le path de destination ", Affichage, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_AVERTISSEMENT, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.AvecDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_AFF, RetourVAR)
						Else
							DEBUG("[CpcdosC+] Please put '/PROGRESSION' argument after path destination", Affichage, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_AVERTISSEMENT, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.AvecDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_AFF, RetourVAR)
						End if

						exit _scope_CMD, _scope
					End if
				End if

				Dim PosSocket as integer = Instr(Ucase(Param), " /SOCKET:")


				' Supprimer les espaces et tabulations
				Param = RTRIM(LTRIM(LTRIM(Param), chr(09)))

				if PosSocket > 0 Then
					IF PosSocket > Instr(Param, ",") Then
						VAR_Socket = Rtrim(Rtrim(Ltrim(Ltrim(Mid(Param, PosSocket + 9, Instr(PosSocket + 9, Param & " ", " ") - (PosProgress + 14)), CHR(09))), CHR(09)))

						Param = Param & " "

						' Supprimer le progress
						Param = Mid(Param, 1, PosSocket - 1) & " " & Mid(Param, Instr(PosSocket + 9, Param & " ", " ") + 1)

					Else
						IF CPCDOS_INSTANCE.Utilisateur_Langage = 0 Then
							DEBUG("[CpcdosC+] Veuillez placer l'argument '/SOCKET' apres le path de destination ", Affichage, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_AVERTISSEMENT, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.AvecDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_AFF, RetourVAR)
						Else
							DEBUG("[CpcdosC+] Please put '/SOCKET' argument after path destination", Affichage, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_AVERTISSEMENT, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.AvecDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_AFF, RetourVAR)
						End if

						exit _scope_CMD, _scope
					End if
				End if

				PosOctets = Instr(Ucase(Param), " /OCTETS:")
				PosBytes  = Instr(Ucase(Param), " /BYTES:")

				if PosOctets > 0 OR PosBytes > 0 Then
					IF PosOctets > Instr(Param, ",") Then
						Var_Octets = Rtrim(Rtrim(Ltrim(Ltrim(Mid(Param, PosOctets + 9, Instr(PosOctets + 9, Param & " ", " ") - (PosOctets + 9)), CHR(09))), CHR(09)))

						Param = Param & " "

						' Supprimer le octets
						Param = Mid(Param, 1, PosOctets - 1) & " " & Mid(Param, Instr(PosOctets + 9, Param & " ", " ") + 1)

					ElseIf PosBytes > Instr(Param, ",") Then
						Var_Octets = Rtrim(Rtrim(Ltrim(Ltrim(Mid(Param, PosBytes + 8, Instr(PosBytes + 8, Param & " ", " ") - (PosBytes + 8)), CHR(09))), CHR(09)))

						Param = Param & " "

						' Supprimer le bytes
						Param = Mid(Param, 1, PosBytes - 1) & " " & Mid(Param, Instr(PosBytes + 8, Param & " ", " ") + 1)

					Else
						IF CPCDOS_INSTANCE.Utilisateur_Langage = 0 Then
							DEBUG("[CpcdosC+] Veuillez placer l'argument '/OCTETS' ou '/BYTES' apres le path de destination ", Affichage, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_AVERTISSEMENT, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.AvecDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_AFF, RetourVAR)
						Else
							DEBUG("[CpcdosC+] Please put '/OCTETS' or '/BYTES' argument after path destination", Affichage, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_AVERTISSEMENT, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.AvecDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_AFF, RetourVAR)
						End if

						exit _scope_CMD, _scope
					End if
				End if

				PosOctetsParSec	= Instr(Ucase(Param), " /OCTETSPARSEC:")
				PosBytesBySec 	= Instr(Ucase(Param), " /BYTESBYSEC:")

				if PosOctetsParSec > 0 OR PosBytesBySec > 0 Then
					IF PosOctetsParSec > Instr(Param, ",") Then
						Var_OctetsParSec = Rtrim(Rtrim(Ltrim(Ltrim(Mid(Param, PosOctetsParSec + 15, Instr(PosOctetsParSec + 15, Param & " ", " ") - (PosOctetsParSec + 15)), CHR(09))), CHR(09)))

						Param = Param & " "

						' Supprimer le OctetsParSec
						Param = Mid(Param, 1, PosOctetsParSec - 1) & " " & Mid(Param, Instr(PosOctetsParSec + 15, Param & " ", " "))

					ElseIf PosBytesBySec > Instr(Param, ",") Then
						Var_OctetsParSec = Rtrim(Rtrim(Ltrim(Ltrim(Mid(Param, PosBytesBySec + 13, Instr(PosBytesBySec + 13, Param & " ", " ") - (PosBytesBySec + 13)), CHR(09))), CHR(09)))

						Param = Param & " "

						' Supprimer le bytesBySec
						Param = Mid(Param, 1, PosBytesBySec - 1) & " " & Mid(Param, Instr(PosBytesBySec + 13, Param & " ", " ") + 1)

					Else
						IF CPCDOS_INSTANCE.Utilisateur_Langage = 0 Then
							DEBUG("[CpcdosC+] Veuillez placer l'argument '/OctetsParSec' ou '/BytesBySec' apres le path de destination ", Affichage, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_AVERTISSEMENT, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.AvecDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_AFF, RetourVAR)
						Else
							DEBUG("[CpcdosC+] Please put '/OctetsParSec' or '/BytesBySec' argument after path destination", Affichage, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_AVERTISSEMENT, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.AvecDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_AFF, RetourVAR)
						End if

						exit _scope_CMD, _scope
					End if
				End if

				if len(Var_Progression) > 0 or len(Var_OctetsParSec) > 0 or len(Var_Octets) > 0 Then
					IF CPCDOS_INSTANCE.SYSTEME_INSTANCE.get_DBG_DEBUG() > 0 Then
						IF CPCDOS_INSTANCE.Utilisateur_Langage = 0 Then
							DEBUG("[CpcdosC+] Telechargement avec : Progression '" & Var_Progression & "' Vitesse '" & Var_OctetsParSec & "' Recu '" & Var_Octets & "' comme indicateur ...", Affichage, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_Normal, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.AvecDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_CPCDOS, RetourVAR)
						Else
							DEBUG("[CpcdosC+] Downloading with : Progression '" & Var_Progression & "' Speed '" & Var_OctetsParSec & "' Reveive '" & Var_Octets & "' like indicator ...", Affichage, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_Normal, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.AvecDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_CPCDOS, RetourVAR)
						End if
					END IF
				END IF


				' Uniquement l'entete
				POS_SRVINFO = INSTR(Ucase(Param), "/SRVINFO")

				' Avec l'entete
				POS_PlusSRVINFO = INSTR(Ucase(Param), "/+SRVINFO")

				' On veut la HEAD
				IF POS_SRVINFO > 0 Then
					' Enlever l'argument
					Param = MID(Param, 1, POS_SRVINFO - 1) & MID(Param, POS_SRVINFO + LEN("/SRVINFO") + 1)
					Commande_HTTP = "HEAD"

				' On veut la HEAD + la requete
				ElseIf POS_PlusSRVINFO > 0 Then
					' Enlever l'argument
					Param = MID(Param, 1, POS_PlusSRVINFO - 1) & MID(Param, POS_PlusSRVINFO + LEN("/+SRVINFO") + 1)
					Commande_HTTP = "GET"
				Else
					' Get normal ;)
					Commande_HTTP = "GET"
				End if

				' Dossier tempoaire absolue
				POS_Temp = INSTR(Ucase(Param), "/TEMP:")

				' Dossier temporaire relatif a l'emplacement du fichier sur le serveur WEB
				POS_Temp_Relatif = INSTR(Ucase(Param), "/TEMPR:")

				' on change de dossier temporaire
				IF POS_Temp > 0 Then

					' Recuperer le chemin
					Redirection_MANUEL = MID(Param, (POS_Temp + LEN("/TEMP:")), INSTR(POS_Temp, Param, " ") - (POS_Temp + LEN("/TEMP:")))

					' Enlever l'argument jusqu'au prochain espace
					Param = MID(Param, 1, POS_Temp - 1) & MID(Param, INSTR(POS_Temp, Param, " ") + 1)

				' On veut la HEAD + la requete
				ElseIf POS_Temp_Relatif > 0 Then

					' Recuperer le chemin et modifier le dossier temporaire directement
					DossierTemp_NET = MID(Param, (POS_Temp_Relatif + LEN("/TEMPR:")), INSTR(POS_Temp_Relatif, Param, " ") - (POS_Temp_Relatif + LEN("/TEMPR:")))

					' Enlever l'argument jusqu'au prochain espace
					Param = MID(Param, 1, POS_Temp_Relatif - 1) & MID(Param, INSTR(POS_Temp_Relatif, Param, " ") + 1)
				Else
					' Get normal ;)
					' Commande_HTTP = "GET"
				End if

				' Recuperer la position de 'HTTP://'
				POS_http = INSTR(Ucase(Param), "HTTP://")

				' Recuperer la position de 'HTTPS://'
				POS_https = INSTR(Ucase(Param), "HTTPS://")

				' Recuperer la position de 'FTP://'
				POS_ftp = INSTR(Ucase(Param), "FTP://")



				' C'est le protocole HTTP
				IF POS_http > 0 Then

					Dim URL				as String
					DIM Fichier_http	as String
					Dim PosPremierSLASH as Integer

					URL = MID(Param, LEN("HTTP://") + 1)

					' Rechercher le premier '/'
					PosPremierSLASH = INSTR(URL, "/")

					IF PosPremierSLASH >  0 Then
						' Pour recuperer le nom du serveur avant l'URI (http://Serveur/blabla)
						Adresse_Serveur = MID(URL, 1, PosPremierSLASH - 1)

						' Recuperer le reste apres le premier '/'. Il est problable qu'il y a rien (http://serveur/)
						Adresse_URI = MID(URL, PosPremierSLASH + 1)

						' Si le dernier caractere se finit par '/'
						If MID(Adresse_URI, LEN(Adresse_URI)) = "/" Then
							Adresse_URI = MID(Adresse_URI, 1, LEN(Adresse_URI) - 1) ' On supprime le caractere
						End if

						' Recuperer le dernier element du URI
						Fichier_http = MID(Adresse_URI, INSTRREV(Adresse_URI, "/") + 1)

						' Verifier s'il finit par "?"
						IF INSTR(Fichier_http, "?") > 0 Then ' le nom de fichier avant "?"

							' Si oui, on recupere ce qu'il y a AVANT
							Fichier_http = MID(Fichier_http, 1, INSTR(Fichier_http, "?") - 1)  ' Recuperer avant "?"
						End if
					Else
						' S'il y a pas de '/' c'est qu'il y a uniquement le nom du serveur
						Adresse_Serveur = URL
					End if

					' Si y'a aucun fichier
					IF Adresse_URI = "" Then
						Adresse_URI = "/"
						Redirection = DossierTemp_NET & "\" & Adresse_Serveur & "\index.htm"
					Else
						' Remplacer les '/' par '\' pour l'inscrire dans un fichier
						Redirection = DossierTemp_NET & "\" & Adresse_Serveur & "\" & CPCDOS_INSTANCE.remplacer_Caractere(Adresse_URI, "/", "\")



						' Recuperer ce qu'il y a avant "?"
						' Verifier s'il finit par "?"
						IF INSTR(Redirection, "?") > 0 Then ' le nom de fichier avant "?"
							' Si oui, on recupere ce qu'il y a AVANT


							Redirection = MID(Redirection, 1, INSTR(Redirection, "?") - 1)  ' Recuperer avant "?"



						End if
					End if

					' Recuperer seulement le repertoire
					Redirection_REPERTOIRE = Mid(Redirection, 1, InstrREV(Redirection, "\") - 1)

					' On check les caracteres interdits (< > ? ....)
					Redirection_REPERTOIRE = CPCDOS_INSTANCE.SYSTEME_INSTANCE.check_NomAutorise(Redirection_REPERTOIRE, TRUE, TRUE, FALSE)




					IF NOT Redirection_MANUEL = "" Then
						' Creer la structure du repertoire
						CPCDOS_INSTANCE.SYSTEME_INSTANCE.creer_Repertoire(Redirection_MANUEL, "")
					Else
						' Creer la structure du repertoire
						CPCDOS_INSTANCE.SYSTEME_INSTANCE.creer_Repertoire(Redirection_REPERTOIRE, "")
					End if


				' C'est le protocole HTTPS
				ElseIF POS_https > 0 Then
					Dim URL				as String
					DIM Fichier_http	as String
					Dim PosPremierSLASH as Integer

					URL = MID(Param, LEN("HTTPS://") + 1)

					' Rechercher le premier '/'
					PosPremierSLASH = INSTR(URL, "/")

					IF PosPremierSLASH >  0 Then
						' Pour recuperer le nom du serveur avant l'URI (http://Serveur/blabla)
						Adresse_Serveur = MID(URL, 1, PosPremierSLASH - 1)

						' Recuperer le reste apres le premier '/'. Il est problable qu'il y a rien (http://serveur/)
						Adresse_URI = MID(URL, PosPremierSLASH + 1)

						' Si le dernier caractere se finit par '/'
						If MID(Adresse_URI, LEN(Adresse_URI)) = "/" Then
							Adresse_URI = MID(Adresse_URI, 1, LEN(Adresse_URI) - 1) ' On supprime le caractere
						End if

						' Recuperer le dernier element du URI
						Fichier_http = MID(Adresse_URI, INSTRREV(Adresse_URI, "/") + 1)

						' Verifier s'il finit par "?"
						IF INSTR(Fichier_http, "?") > 0 Then ' le nom de fichier avant "?"

							' Si oui, on recupere ce qu'il y a AVANT
							Fichier_http = MID(Fichier_http, 1, INSTR(Fichier_http, "?") - 1)  ' Recuperer avant "?"
						End if
					Else
						' S'il y a pas de '/' c'est qu'il y a uniquement le nom du serveur
						Adresse_Serveur = URL
					End if


					' Si y'a aucun fichier
					IF Adresse_URI = "" Then
						Adresse_URI = "/"
						Redirection = DossierTemp_NET & "\" & Adresse_Serveur & "\index.htm"
					Else
						' Remplacer les '/' par '\' pour l'inscrire dans un fichier
						Redirection = DossierTemp_NET & "\" & Adresse_Serveur & "\" & CPCDOS_INSTANCE.remplacer_Caractere(Adresse_URI, "/", "\")

						' Recuperer ce qu'il y a avant "?"
						' Verifier s'il finit par "?"
						IF INSTR(Redirection, "?") > 0 Then ' le nom de fichier avant "?"
							' Si oui, on recupere ce qu'il y a AVANT
							Redirection = MID(Redirection, 1, INSTR(Redirection, "?") - 1)  ' Recuperer avant "?"

						End if
					End if

					' Recuperer seulement le repertoire
					Redirection_REPERTOIRE = Mid(Redirection, 1, InstrREV(Redirection, "\") - 1)


					' On check les caracteres interdits (< > ? ....)
					Redirection_REPERTOIRE = CPCDOS_INSTANCE.SYSTEME_INSTANCE.check_NomAutorise(Redirection_REPERTOIRE, TRUE, TRUE, FALSE)


					IF NOT Redirection_MANUEL = "" Then
						' Creer la structure du repertoire
						CPCDOS_INSTANCE.SYSTEME_INSTANCE.creer_Repertoire(Redirection_MANUEL, "")
					Else
						' Creer la structure du repertoire
						CPCDOS_INSTANCE.SYSTEME_INSTANCE.creer_Repertoire(Redirection_REPERTOIRE, "")
					End if

				' C'est le protocole FTP
				ElseIF POS_ftp > 0 Then
					Dim URL				as String
					DIM Fichier_http	as String
					Dim PosPremierSLASH as Integer

					URL = MID(Param, LEN("FTP://") + 1)

					' Rechercher le premier '/'
					PosPremierSLASH = INSTR(URL, "/")

					IF PosPremierSLASH >  0 Then
						' Pour recuperer le nom du serveur avant l'URI (http://Serveur/blabla)
						Adresse_Serveur = MID(URL, 1, PosPremierSLASH - 1)

						' Recuperer le reste apres le premier '/'. Il est problable qu'il y a rien (http://serveur/)
						Adresse_URI = MID(URL, PosPremierSLASH + 1)

						' Si le dernier caractere se finit par '/'
						If MID(Adresse_URI, LEN(Adresse_URI)) = "/" Then
							Adresse_URI = MID(Adresse_URI, 1, LEN(Adresse_URI) - 1) ' On supprime le caractere
						End if

						' Recuperer le dernier element du URI
						Fichier_http = MID(Adresse_URI, INSTRREV(Adresse_URI, "/") + 1)

						' Verifier s'il finit par "?"
						IF INSTR(Fichier_http, "?") > 0 Then ' le nom de fichier avant "?"

							' Si oui, on recupere ce qu'il y a AVANT
							Fichier_http = MID(Fichier_http, 1, INSTR(Fichier_http, "?") - 1)  ' Recuperer avant "?"
						End if
					Else
						' S'il y a pas de '/' c'est qu'il y a uniquement le nom du serveur
						Adresse_Serveur = URL
					End if

					' Si y'a aucun fichier
					IF Adresse_URI = "" Then
						Adresse_URI = "/"
						Redirection = DossierTemp_NET & "\" & Adresse_Serveur & "\index.htm"
					Else
						' Remplacer les '/' par '\' pour l'inscrire dans un fichier
						Redirection = DossierTemp_NET & "\" & Adresse_Serveur & "\" & CPCDOS_INSTANCE.remplacer_Caractere(Adresse_URI, "/", "\")

						' Recuperer ce qu'il y a avant "?"
						' Verifier s'il finit par "?"
						IF INSTR(Redirection, "?") > 0 Then ' le nom de fichier avant "?"
							' Si oui, on recupere ce qu'il y a AVANT
							Redirection = MID(Redirection, 1, INSTR(Redirection, "?") - 1)  ' Recuperer avant "?"
						End if
					End if

					' Recuperer seulement le repertoire
					Redirection_REPERTOIRE = Mid(Redirection, 1, InstrREV(Redirection, "\") - 1)


					' On check les caracteres interdits (< > ? ....)
					Redirection_REPERTOIRE = CPCDOS_INSTANCE.SYSTEME_INSTANCE.check_NomAutorise(Redirection_REPERTOIRE, TRUE, TRUE, FALSE)


					IF NOT Redirection_MANUEL = "" Then
						' Creer la structure du repertoire
						CPCDOS_INSTANCE.SYSTEME_INSTANCE.creer_Repertoire(Redirection_MANUEL, "")
					Else
						' Creer la structure du repertoire
						CPCDOS_INSTANCE.SYSTEME_INSTANCE.creer_Repertoire(Redirection_REPERTOIRE, "")
					End if

				Else
					' Vous devez specifier un nom de protocole
					Message_erreur = ERRAVT("AVT_061", 0)
					IF CPCDOS_INSTANCE.Utilisateur_Langage = 0 Then
						DEBUG("[CpcdosC+] : " & Message_erreur & ". (http, ftp) Impossible de telecharger.", Affichage, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_AVERTISSEMENT, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.AvecDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_AFF, RetourVAR)
					Else
						DEBUG("[CpcdosC+] : " & Message_erreur & ". (http, ftp) Unable download.", Affichage, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_AVERTISSEMENT, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.AvecDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_AFF, RetourVAR)
					End if
					exit _scope_CMD, _scope
				End If

				' Si c'est une redirection du dossier temporaire manuel, alors on suppime le chemin d'acces
				'  du debut pour le remplacer par le nouvea, tout en gardant uniquement le nom du fichier
				IF NOT Redirection_MANUEL = "" Then
					Redirection = Redirection_MANUEL & "\" & MID(Redirection, INSTRREV(Redirection, "\") + 1)
				End if

				Redirection = Rtrim(Rtrim(Ltrim(Rtrim(Rtrim(Ltrim(Redirection, CHR(09)), CR), LF)), CHR(09)))

				IF NOT Commande_HTTP = "" Then

					if Commande_HTTP = "GET" then
						IF POS_PlusSRVINFO > 0 Then
							' Telecharger le FICHIER + INFO

							IF CPCDOS_INSTANCE.SYSTEME_INSTANCE.get_DBG_DEBUG() > 0 Then
								IF CPCDOS_INSTANCE.Utilisateur_Langage = 0 Then
									DEBUG("[CpcdosC+] : Telechargement du fichier + entete des informations serveur.", Affichage, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_ACTION, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.AvecDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_CPCDOS, RetourVAR)
								Else
									DEBUG("[CpcdosC+] : Downloading file + server informations header .", Affichage, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_ACTION, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.AvecDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_CPCDOS, RetourVAR)
								End if
							End if


							CPCDOS_INSTANCE.RESEAU_INSTANCE.get_http(Adresse_Serveur, 80, Adresse_URI, Redirection, TRUE, _CLE_, RetourVAR, Var_Progression, Var_OctetsParSec, Var_Octets, VAR_Socket)
						Else
							' Telecharger le FICHIER uniquement

							IF CPCDOS_INSTANCE.SYSTEME_INSTANCE.get_DBG_DEBUG() > 0 Then
								IF CPCDOS_INSTANCE.Utilisateur_Langage = 0 Then
									DEBUG("[CpcdosC+] : Telechargement du fichier uniquement .", Affichage, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_ACTION, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.AvecDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_CPCDOS, RetourVAR)
								Else
									DEBUG("[CpcdosC+] : Downloading file only.", Affichage, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_ACTION, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.AvecDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_CPCDOS, RetourVAR)
								End if
							End if
							CPCDOS_INSTANCE.RESEAU_INSTANCE.get_http(Adresse_Serveur, 80, Adresse_URI, Redirection, FALSE, _CLE_, RetourVAR, Var_Progression, Var_OctetsParSec, Var_Octets, VAR_Socket)
						End if
					ElseIF Commande_HTTP = "HEAD" Then
						' Telecharger l'entete seulement

						IF CPCDOS_INSTANCE.SYSTEME_INSTANCE.get_DBG_DEBUG() > 0 Then
							IF CPCDOS_INSTANCE.Utilisateur_Langage = 0 Then
								DEBUG("[CpcdosC+] : Telechargement des informations serveur uniquement.", Affichage, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_ACTION, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.AvecDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_CPCDOS, RetourVAR)
							Else
								DEBUG("[CpcdosC+] : Downloading server informatons only.", Affichage, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_ACTION, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.AvecDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_CPCDOS, RetourVAR)
							End if
						End if

						CPCDOS_INSTANCE.RESEAU_INSTANCE.head_http(Adresse_Serveur, 80, Adresse_URI, Redirection, _CLE_, RetourVAR)
					End if
				End if


				IF 1 = 2 Then

				End if
			END IF

			' ===================================================================
			END SCOPE
			exit _scope_CMD, _scope
		End if ' **** TELECHARGER ****

	_end_scope_CMD

	_scope_CMD


		' ===============================================================
		'  Commande pour configurer le CpcdosC+
		' ===============================================================
		CommLANG(1) = "ccp/"
		CommLANG(2) = "ccp/"
		CommLANG(3) = "\\#//"
		CommTrouve = 0 : NoCMD = 0
		for boucle as integer = 1 to 2
			IF OnCherche = CommLANG(boucle) Then
				NoCMD = 0
				exit for
			Else
				NoCMD = 1
			End if
		Next boucle
		IF NoCMD = 1 then CommLANG(1) = "[F.#).|" : CommLANG(2) = "[F.#).|" : CommLANG(3) = "\\#//"

		rem Afficher la liste des commandes avec anglais / francais
		IF AfficherAide = 1 then
			IF CPCDOS_INSTANCE.Utilisateur_Langage = 0 then
				CommandesAide = CommandesAide & CRLF & " ccp/                       Configuration du CpcdosC+"
			Else
				CommandesAide = CommandesAide & CRLF & " ccp/                       CpcdosC+ configuration"
			END IF
		END IF
		IF CommLANG(1) = OnCherche Then CommTrouve = 1
		IF CommLANG(2) = OnCherche Then CommTrouve = 2
		IF CommTrouve > 0 Then
		IF AfficherAide = 2 then
				Mess_Aide = ""
				IF CPCDOS_INSTANCE.Utilisateur_Langage = 0 THEN
					Mess_Aide = Mess_Aide & CRLF & "  Fonctionnalit�e :"
					Mess_Aide = Mess_Aide & CRLF & "   Cette commande permet de modifier des Parametres du CpcdosC+"
					Mess_Aide = Mess_Aide & CRLF
					Mess_Aide = Mess_Aide & CRLF & "    ccp/ /fix.niveau"
					Mess_Aide = Mess_Aide & CRLF & "      Permet de configurer le niveau de la variable (niveau de privacit�)"
					Mess_Aide = Mess_Aide & CRLF & "       Priv� procedure&fonction --> ccp/ /fix.niveau = 1"
					Mess_Aide = Mess_Aide & CRLF & "       Priv� Application        --> ccp/ /fix.niveau = 2"
					Mess_Aide = Mess_Aide & CRLF & "       Publique Utilisateur     --> ccp/ /fix.niveau = 3"
					Mess_Aide = Mess_Aide & CRLF & "       Publique OS              --> ccp/ /fix.niveau = 4"
					Mess_Aide = Mess_Aide & CRLF & "       Publique Kernel          --> ccp/ /fix.niveau = 5"
					Mess_Aide = Mess_Aide & CRLF & "      Et toutes les variables cr�es seront affect�s par le niveau indiqu�"
					Mess_Aide = Mess_Aide & CRLF & "      Penser donc a r�tablir le niveau souhait� pour ne pas affecter le reste"
					Mess_Aide = Mess_Aide & CRLF
					Mess_Aide = Mess_Aide & CRLF & "    ccp/ /lang"
					Mess_Aide = Mess_Aide & CRLF & "      Permet de d�finir la langue du systeme"
					Mess_Aide = Mess_Aide & CRLF
					Mess_Aide = Mess_Aide & CRLF & "      Exemples :"
					Mess_Aide = Mess_Aide & CRLF & "       Retourne la langue en cours [FR] ou [EN]"
					Mess_Aide = Mess_Aide & CRLF & "        ccp/ /lang"
					Mess_Aide = Mess_Aide & CRLF & "       Definit la langue en Francais (French language)"
					Mess_Aide = Mess_Aide & CRLF & "        ccp/ /lang = FR"
					Mess_Aide = Mess_Aide & CRLF & "       Definit la langue en Anglais (English language)"
					Mess_Aide = Mess_Aide & CRLF & "        ccp/ /lang = EN"
					Mess_Aide = Mess_Aide & CRLF
					Mess_Aide = Mess_Aide & CRLF & "    ccp/ /change:Ma_Variable"
					Mess_Aide = Mess_Aide & CRLF & "     Ceci permet de bloquer le thread en cours jusqu'a que 'Ma_Variable'"
					Mess_Aide = Mess_Aide & CRLF & "      change de contenu"
					Mess_Aide = Mess_Aide & CRLF
					Mess_Aide = Mess_Aide & CRLF & "    ccp/ /pause"
					Mess_Aide = Mess_Aide & CRLF & "      Permet de mettre en pause le thread en cours (le programme)"
					Mess_Aide = Mess_Aide & CRLF & "      pendant un temps definit en millisecondes"
					Mess_Aide = Mess_Aide & CRLF
					Mess_Aide = Mess_Aide & CRLF & "     Exemples:"
					Mess_Aide = Mess_Aide & CRLF & "      Faire une pause de 500ms"
					Mess_Aide = Mess_Aide & CRLF & "       ccp/ /pause 500"
					Mess_Aide = Mess_Aide & CRLF & "      Faire une pause de 1 secondes et 200 millisecondes"
					Mess_Aide = Mess_Aide & CRLF & "       ccp/ /pause 1200"
					Mess_Aide = Mess_Aide & CRLF & "      Faire une pause de 25 micro secondes"
					Mess_Aide = Mess_Aide & CRLF & "       ccp/ /pause 0.025"
					Mess_Aide = Mess_Aide & CRLF
					Mess_Aide = Mess_Aide & CRLF & "    ccp/ /optimisation"
					Mess_Aide = Mess_Aide & CRLF & "       Permet d'activer ou non l'analyse des programmes avant execution"
					Mess_Aide = Mess_Aide & CRLF & "        afin de permettre de trouver une eventuelle optimisation du code"
					Mess_Aide = Mess_Aide & CRLF
					Mess_Aide = Mess_Aide & CRLF & "     Exemples:"
					Mess_Aide = Mess_Aide & CRLF & "      Activer l'optimisation"
					Mess_Aide = Mess_Aide & CRLF & "       ccp/ /optimisation = 1"
					Mess_Aide = Mess_Aide & CRLF & "      Activer l'optimisation avec temporisation du scheduleur"
					Mess_Aide = Mess_Aide & CRLF & "       ccp/ /optimisation = 2"
					Mess_Aide = Mess_Aide & CRLF & "      Desactiver l'optimisation"
					Mess_Aide = Mess_Aide & CRLF & "       ccp/ /optimisation = 0"
					Mess_Aide = Mess_Aide & CRLF
					Mess_Aide = Mess_Aide & CRLF & "    ccp/ /test"
					Mess_Aide = Mess_Aide & CRLF & "      Permet de tester le noyau et CPinti avec 3 niveaux differents"
					Mess_Aide = Mess_Aide & CRLF & "      Simple test     : ccp/ /test   ou  ccp/ /test1"
					Mess_Aide = Mess_Aide & CRLF & "      Test difficile  : ccp/ /test2"
					Mess_Aide = Mess_Aide & CRLF & "      Test tres hard  : ccp/ /test3"
					Mess_Aide = Mess_Aide & CRLF
					Mess_Aide = Mess_Aide & CRLF & "    ccp/ /DEBUT_SECTION_CRITIQUE"
					Mess_Aide = Mess_Aide & CRLF & "      Permet de bloquer toutes interruptions et tous les autres threads"
					Mess_Aide = Mess_Aide & CRLF & "       afin de rendre PRIORITAIRE l'execution du code CpcdosC+."
					Mess_Aide = Mess_Aide & CRLF & "       Ce qui a pour effet d'augmenter les performances d'execution, mais"
					Mess_Aide = Mess_Aide & CRLF & "       en revanche, peut eventuellement 'figer' l'ecran et autres."
					Mess_Aide = Mess_Aide & CRLF & "       jusqu'a la fin de la section critique. (Voir ci-dessous)"
					Mess_Aide = Mess_Aide & CRLF
					Mess_Aide = Mess_Aide & CRLF & "    ccp/ /FIN_SECTION_CRITIQUE"
					Mess_Aide = Mess_Aide & CRLF & "      Permet de d�bloquer toutes les interruptions et les autres threads"
					Mess_Aide = Mess_Aide & CRLF & "       afin de reprendre l'execution NORMALE du code CpcdosC+."
					Mess_Aide = Mess_Aide & CRLF
					Mess_Aide = Mess_Aide & CRLF & "    ccp/ /DISCRETION = 1"
					Mess_Aide = Mess_Aide & CRLF & "      Permet d'executer les instruction sans influencer le sablier de la GUI"
					Mess_Aide = Mess_Aide & CRLF
					Mess_Aide = Mess_Aide & CRLF & "    ccp/ /DISCRETION = 0"
					Mess_Aide = Mess_Aide & CRLF & "      Permet d'influencer les instruction en enfluencant le sablier de la GUI"
					Mess_Aide = Mess_Aide & CRLF
					Mess_Aide = Mess_Aide & CRLF & "  Voir aussi : sys/ "
					Mess_Aide = Mess_Aide & CRLF
				ELSEIF CPCDOS_INSTANCE.Utilisateur_Langage = 1 THEN
					Mess_Aide = Mess_Aide & CRLF & "  Fonctionnality :"
					Mess_Aide = Mess_Aide & CRLF & "   This command allow to configure CpcdosC+"
					Mess_Aide = Mess_Aide & CRLF
					Mess_Aide = Mess_Aide & CRLF & "    ccp/ /set.level"
					Mess_Aide = Mess_Aide & CRLF & "      Allow to configure variable level (privacity level)"
					Mess_Aide = Mess_Aide & CRLF & "       Private sub&fonction     --> ccp/ /fix.niveau = 1"
					Mess_Aide = Mess_Aide & CRLF & "       Private Application      --> ccp/ /fix.niveau = 2"
					Mess_Aide = Mess_Aide & CRLF & "       Public  User             --> ccp/ /fix.niveau = 3"
					Mess_Aide = Mess_Aide & CRLF & "       Public  OS               --> ccp/ /fix.niveau = 4"
					Mess_Aide = Mess_Aide & CRLF & "       Public  Kernel           --> ccp/ /fix.niveau = 5"
					Mess_Aide = Mess_Aide & CRLF & "      And all variable created will be affected by the level configured"
					Mess_Aide = Mess_Aide & CRLF & "      So, you can re-define origin level, for not affect others"
					Mess_Aide = Mess_Aide & CRLF
					Mess_Aide = Mess_Aide & CRLF & "    ccp/ /lang"
					Mess_Aide = Mess_Aide & CRLF & "      Allow to define system language"
					Mess_Aide = Mess_Aide & CRLF
					Mess_Aide = Mess_Aide & CRLF & "      Exemples :"
					Mess_Aide = Mess_Aide & CRLF & "       Retourn actual language [FR] or [EN]"
					Mess_Aide = Mess_Aide & CRLF & "        ccp/ /lang"
					Mess_Aide = Mess_Aide & CRLF & "       Define in French language (Langue Francaise)"
					Mess_Aide = Mess_Aide & CRLF & "        ccp/ /lang = FR"
					Mess_Aide = Mess_Aide & CRLF & "       Define in English language (Langue Anglaise)"
					Mess_Aide = Mess_Aide & CRLF & "        ccp/ /lang = EN"
					Mess_Aide = Mess_Aide & CRLF
					Mess_Aide = Mess_Aide & CRLF & "    ccp/ /change:My_Variable"
					Mess_Aide = Mess_Aide & CRLF & "     This allow to block current thread and deblock if 'My_Variable'"
					Mess_Aide = Mess_Aide & CRLF & "      change the content"
					Mess_Aide = Mess_Aide & CRLF
					Mess_Aide = Mess_Aide & CRLF & "    ccp/ /pause"
					Mess_Aide = Mess_Aide & CRLF & "      Allow to pause current thread (Program) for a specified time"
					Mess_Aide = Mess_Aide & CRLF & "      in milliseconds"
					Mess_Aide = Mess_Aide & CRLF
					Mess_Aide = Mess_Aide & CRLF & "     Exemples:"
					Mess_Aide = Mess_Aide & CRLF & "      Pause for 500ms"
					Mess_Aide = Mess_Aide & CRLF & "       ccp/ /pause 500"
					Mess_Aide = Mess_Aide & CRLF & "      Pause for 1 seconds and 200 microseconds"
					Mess_Aide = Mess_Aide & CRLF & "       ccp/ /pause 1200"
					Mess_Aide = Mess_Aide & CRLF & "      For 25 micro seconds"
					Mess_Aide = Mess_Aide & CRLF & "       ccp/ /pause 0.025"
					Mess_Aide = Mess_Aide & CRLF
					Mess_Aide = Mess_Aide & CRLF & "    ccp/ /optimization"
					Mess_Aide = Mess_Aide & CRLF & "       Enable optimizing programs, before execution"
					Mess_Aide = Mess_Aide & CRLF & "        for check an eventual optimizing"
					Mess_Aide = Mess_Aide & CRLF
					Mess_Aide = Mess_Aide & CRLF & "     Examples:"
					Mess_Aide = Mess_Aide & CRLF & "      Enable optimization"
					Mess_Aide = Mess_Aide & CRLF & "       ccp/ /optimization = 1"
					Mess_Aide = Mess_Aide & CRLF & "      Disable optimization"
					Mess_Aide = Mess_Aide & CRLF & "       ccp/ /optimization = 0"
					Mess_Aide = Mess_Aide & CRLF
					Mess_Aide = Mess_Aide & CRLF & "    ccp/ /test"
					Mess_Aide = Mess_Aide & CRLF & "      Allow to test kernel and CPinti core with differents levels"
					Mess_Aide = Mess_Aide & CRLF & "      Simple test     : ccp/ /test   ou  ccp/ /test1"
					Mess_Aide = Mess_Aide & CRLF & "      Difficult test  : ccp/ /test2"
					Mess_Aide = Mess_Aide & CRLF & "      Very hard test  : ccp/ /test3"
					Mess_Aide = Mess_Aide & CRLF
					Mess_Aide = Mess_Aide & CRLF & "    ccp/ /begin_critical_section"
					Mess_Aide = Mess_Aide & CRLF & "      Allow to blocking all interrupts and threads, to make it"
					Mess_Aide = Mess_Aide & CRLF & "       PRIORITY the execution of CpcdosC+ code."
					Mess_Aide = Mess_Aide & CRLF & "       This cause betters perforances, but, this can freeze your screen"
					Mess_Aide = Mess_Aide & CRLF & "       and others, until the end of critical section (see below)"
					Mess_Aide = Mess_Aide & CRLF
					Mess_Aide = Mess_Aide & CRLF & "    ccp/ /end_critical_section"
					Mess_Aide = Mess_Aide & CRLF & "      Allow to unblocking all interrupts and threads, in order to"
					Mess_Aide = Mess_Aide & CRLF & "       run your CpcdosC+ code normally."
					Mess_Aide = Mess_Aide & CRLF
					Mess_Aide = Mess_Aide & CRLF & "    ccp/ /DISCRETION = 1"
					Mess_Aide = Mess_Aide & CRLF & "      Allow to execute instruction without influence hourglass."
					Mess_Aide = Mess_Aide & CRLF
					Mess_Aide = Mess_Aide & CRLF & "    ccp/ /DISCRETION = 0"
					Mess_Aide = Mess_Aide & CRLF & "      Allow to influence hourglass when during execution code."
					Mess_Aide = Mess_Aide & CRLF
					Mess_Aide = Mess_Aide & CRLF & "  See also : sys/ "
					Mess_Aide = Mess_Aide & CRLF
				END IF
				DEBUG(Mess_Aide, Affichage, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_SURBRILLE, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.SansDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_AFF, RetourVAR)
				testCMD = 0
				AfficherAide = 0
				exit _scope_CMD, _scope
			END IF
			' Tester la syntaxe
			testCMD	= CCP_Verifier_Syntaxe(Commande, CommPosition)
			IF testCMD > 10 Then exit _scope_CMD, _scope
			IF testCMD > 0 then  ' Entre 1-5 = Pas d'affichage via le @, @$ ou @#
				IF testCMD < 6 then
					Affichage = 0
					IF testCMD = 3 Then CpcdosCP_SHELL("FIX/ " & CPCDOS_INSTANCE.DEBUG_INSTANCE.LeRetour & " = \#NULL", _CLE_, NIVEAU_CCP, Param_1, Param_2) : RetourVAR = _CLE_ & "N" & NIVEAU_CCP & "->" & CPCDOS_INSTANCE.DEBUG_INSTANCE.LeRetour
					if testCMD = 2 Then RetourVAR = "$>" & CPCDOS_INSTANCE.DEBUG_INSTANCE.LeRetour ' ajouter une securite ?
				Else
					Affichage = 1
				END IF
			Else
				Affichage = 1
			END IF
			' Recuperer les Parametres
			Param = MID(Commande, CommPosition + TailleComm + 2)
			SCOPE
			' ===================================================================
			Dim privaciteDefinition as String = ""

			' Configurer le niveau de privacite des variables
			IF Instr(UCASE(Param), "/SET.") > 0 OR Instr(UCASE(Param), "/FIX.") > 0 Then
				IF Instr(UCASE(Param), ".LEVEL") > 0 OR Instr(UCASE(Param), ".NIVEAU") > 0 Then
					IF Instr(UCASE(Param), " = 1") > 0 Then
						privaciteDefinition = "FIX_NIVEAU1"
					ElseIF Instr(UCASE(Param), " = 2") > 0 Then
						privaciteDefinition = "FIX_NIVEAU2"
					ElseIF Instr(UCASE(Param), " = 3") > 0 Then
						privaciteDefinition = "FIX_NIVEAU3"
					ElseIF Instr(UCASE(Param), " = 4") > 0 Then
						privaciteDefinition = "FIX_NIVEAU4"
					ElseIF Instr(UCASE(Param), " = 5") > 0 Then
						privaciteDefinition = "FIX_NIVEAU5"
					ElseIF Instr(UCASE(Param), " = ") > 0 Then
						Message_erreur = ERRAVT("AVT_051", 0)
						DEBUG("[CpcdosC+] " & Message_erreur & " " & CHR(34) & Commande & CHR(34) & ".", Affichage, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_ERREUR, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.SansDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_AFF, RetourVAR)
						CpcdosCP_SHELL = "#STOP_ERREUR#"
						exit _scope_CMD, _scope
					End if

					' Afficher le niveau en cours
					IF privaciteDefinition = "" Then
						DEBUG(str(NIVEAU_CCP), Affichage, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_Normal, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.SansDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_AFF, RetourVAR)
						exit _scope_CMD, _scope
					End if

					CpcdosCP_SHELL = privaciteDefinition
					IF CPCDOS_INSTANCE.SYSTEME_INSTANCE.get_DBG_DEBUG() > 0 Then
						IF CPCDOS_INSTANCE.Utilisateur_Langage = 0 Then
							DEBUG("[CpcdosC+] Definition du niveau de privacite a " & privaciteDefinition, Affichage, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_Normal, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.AvecDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_CPCDOS, RetourVAR)
						Else
							DEBUG("[CpcdosC+] Private level defined at " & privaciteDefinition, Affichage, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_Normal, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.AvecDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_CPCDOS, RetourVAR)
						End If
					End if
					exit _scope_CMD, _scope
				END IF
			End if

			IF Instr(UCASE(Param), "/LANG") > 0 OR Instr(UCASE(Param), "/LANGAGE") > 0 OR Instr(UCASE(Param), "/LANGUAGE") > 0  Then
				Dim Langgg_tmp 	as String

				IF Instr(UCASE(Param), " = FR") > 0 Then CPCDOS_INSTANCE.Utilisateur_Langage = 0 : DEBUG(" [FR] Bienvenue dans la langue Francaise! :-)", Affichage, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_SURBRILLE, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.SansDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_AFF, RetourVAR) : exit _scope_CMD, _scope
				IF Instr(UCASE(Param), " = EN") > 0 Then CPCDOS_INSTANCE.Utilisateur_Langage = 1 : DEBUG(" [EN] Welcome to English language! :-)", Affichage, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_SURBRILLE, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.SansDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_AFF, RetourVAR) : exit _scope_CMD, _scope
				IF Instr(UCASE(Param), " = ") > 0 Then
					Message_erreur = ERRAVT("AVT_051", 0)
					DEBUG("[CpcdosC+] " & Message_erreur & " " & CHR(34) & Commande & CHR(34) & ".", Affichage, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_ERREUR, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.SansDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_AFF, RetourVAR)
					CpcdosCP_SHELL = "#STOP_ERREUR#"
					exit _scope_CMD, _scope
				End if

				IF CPCDOS_INSTANCE.Utilisateur_Langage = 0 Then Langgg_tmp = "FR"
				IF CPCDOS_INSTANCE.Utilisateur_Langage = 1 Then Langgg_tmp = "EN"
				DEBUG(Langgg_tmp, Affichage, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_Normal, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.SansDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_AFF, RetourVAR)
				exit _scope_CMD, _scope
			END IF

			' Mettre en pause le thread (Peut sauver la vie du kernel)
			IF Instr(UCASE(Param), "/PAUSE") > 0 Then
				Dim positionPause as integer
				Dim ValeurPause as integer = 0
				positionPause = Instr(UCASE(Param), "/PAUSE") + 7
				ValeurPause = val(MID(Param, positionPause)) * 10^3
				if ValeurPause < 1 then
					IF CPCDOS_INSTANCE.Utilisateur_Langage = 0 Then
						DEBUG("[CpcdosC+] Nombre egale ou inferieur a 0 interdit!", Affichage, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_AVERTISSEMENT, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.AvecDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_AFF, RetourVAR)
					Else
						DEBUG("[CpcdosC+] Number equal or greater forbidden!", Affichage, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_AVERTISSEMENT, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.AvecDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_AFF, RetourVAR)
					End If
					exit _scope_CMD, _scope
				End if
				doevents(ValeurPause)
				exit _scope_CMD, _scope
			End if

			' Attendre le changement d'une variable en bloquant le thread
			IF Instr(UCASE(Param), "/CHANGE:") > 0 Then
				Dim PositionCHANGE as integer
				Dim VariableAttendre as string
				Dim VariableContenuAV as string, VariableContenuAP as string

				PositionCHANGE = Instr(UCASE(Param), "/CHANGE:")
				VariableAttendre = MID(Param, PositionCHANGE + 8)
				VariableContenuAV = Gest_variables_LIRE(VariableAttendre, NIVEAU_CCP, Auth_Kernel, Auth_OS, Auth_Utilisateur, Auth_PID, Auth_TID)
				VariableContenuAP = VariableContenuAV

				' On bloque le thread tant que FIXQuestion n'est pas null
				while(VariableContenuAP = VariableContenuAV)
					doevents( 52803)
					VariableContenuAP = Gest_variables_LIRE(VariableAttendre, NIVEAU_CCP, Auth_Kernel, Auth_OS, Auth_Utilisateur, Auth_PID, Auth_TID)
					if UCASE(VariableContenuAP) = "#NULL" then VariableContenuAP = VariableContenuAV
				Wend
				exit _scope_CMD, _scope
			end if

			' Optimiser le Cc+
			IF Instr(UCASE(Param), "/OPTIMISATION") > 0 OR Instr(UCASE(Param), "/OPTIMIZATION") > 0 Then
				IF Instr(UCASE(Param), " = 0") > 0 Then this.Cpcdos_Optimisation = 0 : exit _scope_CMD, _scope
				IF Instr(UCASE(Param), " = 1") > 0 Then this.Cpcdos_Optimisation = 1 : exit _scope_CMD, _scope
				IF Instr(UCASE(Param), " = 2") > 0 Then this.Cpcdos_Optimisation = 2 : exit _scope_CMD, _scope
				IF Instr(UCASE(Param), " = ") > 0 Then
					Message_erreur = ERRAVT("AVT_051", 0)
					DEBUG("[CpcdosC+] " & Message_erreur & " " & CHR(34) & Commande & CHR(34) & ".", Affichage, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_ERREUR, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.SansDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_AFF, RetourVAR)
					CpcdosCP_SHELL = "#STOP_ERREUR#"
					exit _scope_CMD, _scope
				End if
				DEBUG(Str(this.Cpcdos_Optimisation), Affichage, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_Normal, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.SansDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_AFF, RetourVAR)
				exit _scope_CMD, _scope
			END IF

			IF Instr(UCASE(Param), "/TEST") > 0 Then
				' Tests de Cpcdos CPinti Core
				IF Instr(UCASE(Param), "/TEST2") > 0 Then
					' Test difficile

					DEBUG("Test tres difficile en developpement" & privaciteDefinition, Affichage, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_AVERTISSEMENT, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.SansDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_AFF, RetourVAR)
					exit _scope_CMD, _scope
				End if

				IF Instr(UCASE(Param), "/TEST3") > 0 Then
					' Test tres hard

					DEBUG("Test tres difficile en developpement" & privaciteDefinition, Affichage, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_AVERTISSEMENT, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.SansDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_AFF, RetourVAR)
					exit _scope_CMD, _scope
				End if

				' Simple test
				'  Tester en liberant simplement le thread en cours pour executer tous les autres
				doevents(1)
				DEBUG("OK!" & privaciteDefinition, Affichage, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_Normal, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.SansDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_AFF, RetourVAR)
				exit _scope_CMD, _scope
			End if

			IF Instr(UCASE(Param), "/DEBUT_SECTION_CRITIQUE") > 0 OR Instr(UCASE(Param), "/BEGIN_CRITICAL_SECTION") > 0 Then
				' Permet de rendre l'ex�cution d'un morceau de code PRIORITAIRE sans autres interruptions
				this.SECTION_CRITIQUE = TRUE

				IF CPCDOS_INSTANCE.Utilisateur_Langage = 0 Then
					DEBUG("[CpcdosC+] Debut de la section critique. Toutes interruptions et threads sont desormais bloques durant l'execution du PID:" & Auth_PID & " TID:" & Auth_TID & " -> [0x" & Hex(Val(Auth_PID & Auth_TID)) & "]", Affichage, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_AVERTISSEMENT, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.AvecDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_CPCDOS, RetourVAR)
				Else
					DEBUG("[CpcdosC+] Begining critical section. All interrupts and thread are blocked during execution of PID:" & Auth_PID & " TID:" & Auth_TID & " -> [0x" & Hex(Val(Auth_PID & Auth_TID)) & "]", Affichage, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_AVERTISSEMENT, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.AvecDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_CPCDOS, RetourVAR)
				End If

				exit _scope_CMD, _scope
			End if

			IF Instr(UCASE(Param), "/FIN_SECTION_CRITIQUE") > 0 OR Instr(UCASE(Param), "/END_CRITICAL_SECTION") > 0 Then
				' Permet de reprendre l'execution normale du code CpcdosC+
				this.SECTION_CRITIQUE = FALSE

				IF CPCDOS_INSTANCE.Utilisateur_Langage = 0 Then
					DEBUG("[CpcdosC+] Fin de la section critique pour PID:" & Auth_PID & " TID:" & Auth_TID & " -> [0x" & Hex(Val(Auth_PID & Auth_TID)) & "]. Toutes interruptions et threads fonctionnent normalement.", Affichage, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_AVERTISSEMENT, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.AvecDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_CPCDOS, RetourVAR)
				Else
					DEBUG("[CpcdosC+] Ending critical section for PID:" & Auth_PID & " TID:" & Auth_TID & " -> [0x" & Hex(Val(Auth_PID & Auth_TID)) & "]. All interrupts and thread are in normal execution.", Affichage, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_AVERTISSEMENT, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.AvecDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_CPCDOS, RetourVAR)
				End If

				exit _scope_CMD, _scope
			End if

			' Configurer la langue du noyau
			IF Instr(UCASE(Param), "/DISCRETION") > 0 Then

				IF Instr(UCASE(Param), " = 0") > 0 Then CpcdosCP_SHELL = "#DISCRETION:0" : exit _scope_CMD, _scope
				IF Instr(UCASE(Param), " = 1") > 0 Then CpcdosCP_SHELL = "#DISCRETION:1" : exit _scope_CMD, _scope
				IF Instr(UCASE(Param), " = ") > 0 Then
					Message_erreur = ERRAVT("AVT_051", 0)
					DEBUG("[CpcdosC+] " & Message_erreur & " " & CHR(34) & Commande & CHR(34) & ".", Affichage, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_ERREUR, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.SansDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_AFF, RetourVAR)
					CpcdosCP_SHELL = "#STOP_ERREUR#"
					exit _scope_CMD, _scope
				End if
				exit _scope_CMD, _scope
			END IF

			IF CPCDOS_INSTANCE.Utilisateur_Langage = 0 Then
				DEBUG("[CpcdosC+] Veuillez entrer un parametre disponible. (Tapez AIDE/ CCP/). '" & Param & "'", Affichage, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_AVERTISSEMENT, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.AvecDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_AFF, RetourVAR)
			Else
				DEBUG("[CpcdosC+] Please enter an avaiable parameter. (Type HELP/ CCP/). '" & Param & "'", Affichage, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_AVERTISSEMENT, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.AvecDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_AFF, RetourVAR)
			End If


			' ===================================================================
			END SCOPE
			exit _scope_CMD, _scope
		End if ' **** CCP/ ****

	_end_scope_CMD

	_scope_CMD

		' ===============================================================
		'  Commande pour executer un fichier CpcdosC+
		' ===============================================================
		CommLANG(1) = "exe/"
		CommLANG(2) = "exe/"
		CommLANG(3) = "\\#//"
		CommTrouve = 0 : NoCMD = 0
		for boucle as integer = 1 to 2
			IF OnCherche = CommLANG(boucle) Then
				NoCMD = 0
				exit for
			Else
				NoCMD = 1
			End if
		Next boucle

		IF NoCMD = 1 then CommLANG(1) = "[F.#).|" : CommLANG(2) = "[F.#).|" : CommLANG(3) = "\\#//"

		rem Afficher la liste des commandes avec anglais / francais
		IF AfficherAide = 1 then
			IF CPCDOS_INSTANCE.Utilisateur_Langage = 0 then
				CommandesAide = CommandesAide & CRLF & " exe/                       Executer un fichier CpcdosC+"
			Else
				CommandesAide = CommandesAide & CRLF & " exe/                       Launch a CpcdosC+ file"
			END IF
		END IF
		IF CommLANG(1) = OnCherche Then CommTrouve = 1
		IF CommLANG(2) = OnCherche Then CommTrouve = 2

		IF CommTrouve > 0 Then
			IF AfficherAide = 2 then
				Mess_Aide = ""
				IF CPCDOS_INSTANCE.Utilisateur_Langage = 0 THEN
					Mess_Aide = Mess_Aide & CRLF & "  Fonctionnalit�e :"
					Mess_Aide = Mess_Aide & CRLF & "   Cette commande permet d'executer un fichier de type CpcdosC+"
					Mess_Aide = Mess_Aide & CRLF & "    ou un executable PE (Experimentale!!)"
					Mess_Aide = Mess_Aide & CRLF
					Mess_Aide = Mess_Aide & CRLF & "  3 Exemples :"
					Mess_Aide = Mess_Aide & CRLF & "   exe/ Program.cpc"
					Mess_Aide = Mess_Aide & CRLF & "   exe/ os\prog\Program.cpc"
					Mess_Aide = Mess_Aide & CRLF & "   exe/ C:\dossier\Program.cpc"
					Mess_Aide = Mess_Aide & CRLF
					Mess_Aide = Mess_Aide & CRLF & "  Executer un executable windows PE :"
					Mess_Aide = Mess_Aide & CRLF & "   exe/ /pe Program.exe"
					Mess_Aide = Mess_Aide & CRLF & "    ou"
					Mess_Aide = Mess_Aide & CRLF & "   exe/ /win32 Program.exe"
					Mess_Aide = Mess_Aide & CRLF
					Mess_Aide = Mess_Aide & CRLF & "  Executer un programme IR/LLVM (Format BC ou LL)"
					Mess_Aide = Mess_Aide & CRLF & "   via du code g�n�r� par compilateur CLANG 3.8."
					Mess_Aide = Mess_Aide & CRLF & "   (LLVM:Low-Level-Virtual-Machine / Machine virtuel de bas niveau)"
					Mess_Aide = Mess_Aide & CRLF
					Mess_Aide = Mess_Aide & CRLF & "   exe/ /llvm Programme.ll"
					Mess_Aide = Mess_Aide & CRLF & "   exe/ /llvm Programme.bc"
					Mess_Aide = Mess_Aide & CRLF
					Mess_Aide = Mess_Aide & CRLF & " Voir aussi: "
				ELSEIF CPCDOS_INSTANCE.Utilisateur_Langage = 1 THEN
					Mess_Aide = Mess_Aide & CRLF & "  Fonctionnality :"
					Mess_Aide = Mess_Aide & CRLF & "   This command allow to execute a CpcdosC+ file"
					Mess_Aide = Mess_Aide & CRLF & "    or PE executable (Experimental!!)"
					Mess_Aide = Mess_Aide & CRLF
					Mess_Aide = Mess_Aide & CRLF & "  3 exemples :"
					Mess_Aide = Mess_Aide & CRLF & "   exe/ Program.cpc"
					Mess_Aide = Mess_Aide & CRLF & "   exe/ os\prog\Program.cpc"
					Mess_Aide = Mess_Aide & CRLF & "   exe/ C:\directry\Program.cpc"
					Mess_Aide = Mess_Aide & CRLF
					Mess_Aide = Mess_Aide & CRLF & "  Launch an PE windows executable :"
					Mess_Aide = Mess_Aide & CRLF & "   exe/ /pe Program.exe"
					Mess_Aide = Mess_Aide & CRLF & "    or"
					Mess_Aide = Mess_Aide & CRLF & "   exe/ /win32 Program.exe"
					Mess_Aide = Mess_Aide & CRLF
					Mess_Aide = Mess_Aide & CRLF & "  Execute IR/LLVM program (BC or LL format)"
					Mess_Aide = Mess_Aide & CRLF & "   from code generated by CLANG 3.8 compiler."
					Mess_Aide = Mess_Aide & CRLF & "   (LLVM:Low-Level-Virtual-Machine)"
					Mess_Aide = Mess_Aide & CRLF
					Mess_Aide = Mess_Aide & CRLF & "   exe/ /llvm Programme.ll"
					Mess_Aide = Mess_Aide & CRLF & "   exe/ /llvm Programme.bc"
					Mess_Aide = Mess_Aide & CRLF
					Mess_Aide = Mess_Aide & CRLF & " Voir aussi: "
				END IF
				DEBUG(Mess_Aide, Affichage, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_SURBRILLE, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.SansDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_AFF, RetourVAR)
				testCMD = 0
				AfficherAide = 0
				exit _scope_CMD, _scope
			END IF
			' Tester la syntaxe
			testCMD	= CCP_Verifier_Syntaxe(Commande, CommPosition )
			IF testCMD > 10 Then exit _scope_CMD, _scope
			IF testCMD > 0 then  ' Entre 1-5 = Pas d'affichage via le @, @$ ou @#
				IF testCMD < 6 then
					Affichage = 0
					IF testCMD = 3 Then CpcdosCP_SHELL("FIX/ " & CPCDOS_INSTANCE.DEBUG_INSTANCE.LeRetour & " = \#NULL", _CLE_, NIVEAU_CCP, Param_1, Param_2) : RetourVAR = _CLE_ & "N" & NIVEAU_CCP & "->" & CPCDOS_INSTANCE.DEBUG_INSTANCE.LeRetour
					if testCMD = 2 Then RetourVAR = "$>" & CPCDOS_INSTANCE.DEBUG_INSTANCE.LeRetour ' ajouter une securite ?
				Else
					Affichage = 1
				END IF
			Else
				Affichage = 1
			END IF
			' Recuperer les Parametres
			Param = MID(Commande, CommPosition + TailleComm + 2)
			SCOPE
			' ====================================================================

			Dim CCP_discretion		as boolean = false

			Dim CCP_Fonction_ARGS_N 	as Integer
			Dim CCP_Fonction_ARGS		(0 to this.MEMOIRE_CCP._MAX_FONCTION_ARGS) as String
			Dim CCP_Fonction_ARGS_2		(0 to this.MEMOIRE_CCP._MAX_FONCTION_ARGS) as String
			Dim CCP_Fonction_DATA		(0 to this.MEMOIRE_CCP._MAX_FONCTION_ARGS) as String
			Dim CCP_Fonction_CLE		(0 to this.MEMOIRE_CCP._MAX_FONCTION_ARGS) as double

			Dim Nom_Fichier 		as String
			Dim NomLblAAtteindre	as String
			Dim LabelAChercher 		as String
			Dim CCP_Fonction_EXEC	as String
			Dim NumeroDeLigneAChercher	as Integer = 0
			Dim PosLabelLigneExec		as Integer = 0

			Dim PosFonctExec			as Integer = 0
			Dim PosLabelExec			as Integer = 0

			Dim Position_DEBUT 			as Integer = 0
			Dim Position_FIN 			as Integer = 0

			Dim ExecMultiTHREAD 		as Integer = 0

			Dim PosETCommerciale 		as Integer = 0

			'doevents(_PAUSE_CRT) ' Pause CRT CPinticore

			IF INSTR(Ucase(Param), "/LLVM ") > 0 Then
				IF INSTR(Ucase(Param), "/LLVM ") < 5 Then
					Dim POS_LLVM as integer = INSTR(Ucase(Param), "/LLVM ")
					DIM Fichier_LLVM as string = MID(Param, POS_LLVM + 6)

					dim FunctionID_RET 		as integer = 0
					dim FUNCTION_ID__ 		as integer = CPCDOS_INSTANCE._FUNCTIONID__LLVM

					IF CPCDOS_INSTANCE.SYSTEME_INSTANCE.get_DBG_DEBUG() > 0 Then
						IF CPCDOS_INSTANCE.Utilisateur_Langage = 0 Then
							DEBUG("Kernel > Creation d'un thread asynchrome d'une machine virtuel LLVM, et tentative d'execution de " & LTRIM(Fichier_LLVM) & "...", Affichage, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_Normal, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.AvecDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_CPCDOS, RetourVAR)
						Else
							DEBUG("Kernel > Creating LLVM virtual machine asynchrome thread, attempted execution of " & LTRIM(Fichier_LLVM) & "...", Affichage, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_Normal, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.AvecDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_CPCDOS, RetourVAR)
						End If
					End if

					' A MODIFIER !! Sinon instance de la console bloque!

					IF CPCDOS_INSTANCE.get_Nom_Thread(Auth_TID) = "THREAD_CONSOLE" Then
						IF CPCDOS_INSTANCE.SYSTEME_INSTANCE.get_DBG_DEBUG() > 0 Then
							IF CPCDOS_INSTANCE.Utilisateur_Langage = 0 Then
								DEBUG("Execution depuis 'THREAD_CONSOLE' --> Creation d'un nouveau thread...", Affichage, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_AVERTISSEMENT, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.AvecDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_CPCDOS, RetourVAR)
							Else
								DEBUG("Execution from 'THREAD_CONSOLE'  --> Creating new thread...", Affichage, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_AVERTISSEMENT, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.AvecDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_CPCDOS, RetourVAR)
							End If
						End if
						IF CPCDOS_INSTANCE.SYSTEME_INSTANCE.get_DBG_DEBUG() > 0 Then
							IF CPCDOS_INSTANCE.Utilisateur_Langage = 0 Then
								DEBUG("Le PID du processus parent est egale a '0' --> Creation d'un nouveau thread...", Affichage, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_AVERTISSEMENT, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.AvecDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_CPCDOS, RetourVAR)
							Else
								DEBUG("The parent PID process is equal at '0' --> Creating new thread...", Affichage, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_AVERTISSEMENT, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.AvecDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_CPCDOS, RetourVAR)
							End If
						End if

						scope
							Fichier_LLVM = LTRIM(Fichier_LLVM)
							' Creer une instance de _STRUCT_THREAD_Cpcdos_OSx__, remplir le donnees
							Dim INSTANCE_STRUCT_THREAD as _STRUCT_THREAD_Cpcdos_OSx__
							INSTANCE_STRUCT_THREAD.Nom = "_LLVM_ASYNC_"  & _CLE_ & "~" & CPCDOS_INSTANCE.get_id_PID(_CLE_) & "~" & LTRIM(Fichier_LLVM)
							INSTANCE_STRUCT_THREAD.Fonction = cast(any ptr, @Wrapper_THREAD)
							INSTANCE_STRUCT_THREAD.PROC_ID = Auth_PID
							INSTANCE_STRUCT_THREAD.OS_ID	= Auth_OS		' ID de l'OS
							INSTANCE_STRUCT_THREAD.USER_ID	= Auth_Utilisateur	' ID de l'user
							INSTANCE_STRUCT_THREAD.KERNEL_ID= Auth_Kernel						' ID du kernel

							INSTANCE_STRUCT_THREAD.Priorite = _PRIORITE_THRD_MOYENNE

							INSTANCE_STRUCT_THREAD.ARG_CP 	= cast(any ptr, FUNCTION_ID__)

							INSTANCE_STRUCT_THREAD.ARG_1 	= malloc(sizeof(Fichier_LLVM))
							memcpy(INSTANCE_STRUCT_THREAD.ARG_1, cast(any ptr, @Fichier_LLVM), sizeof(Fichier_LLVM))

							INSTANCE_STRUCT_THREAD.ARG_2 = NULL
							INSTANCE_STRUCT_THREAD.ARG_3 = NULL
							INSTANCE_STRUCT_THREAD.ARG_4 = NULL
							INSTANCE_STRUCT_THREAD.ARG_5 = NULL

							CPCDOS_INSTANCE.Creer_thread(INSTANCE_STRUCT_THREAD)

							IF CPCDOS_INSTANCE.SYSTEME_INSTANCE.get_DBG_DEBUG() > 0 Then
								IF CPCDOS_INSTANCE.Utilisateur_Langage = 0 Then
									DEBUG("Kernel > Le thread " & INSTANCE_STRUCT_THREAD.Nom & " a ete cree!", Affichage, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_Normal, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.AvecDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_CPCDOS, RetourVAR)
								Else
									DEBUG("Kernel > Thread " & INSTANCE_STRUCT_THREAD.Nom & " was created!", Affichage, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_Normal, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.AvecDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_CPCDOS, RetourVAR)
								End If
							End if
						End scope
					else
						' Execution du LLVM via le wrapper Cpcdos/CpintiCore
						FunctionID_RET = Exec_WRAPPER(FUNCTION_ID__, _CLE_, LTRIM(Fichier_LLVM), 0, NULL, NULL, NULL)

						IF CPCDOS_INSTANCE.SYSTEME_INSTANCE.get_DBG_DEBUG() > 0 Then
							IF CPCDOS_INSTANCE.Utilisateur_Langage = 0 Then
								DEBUG("Kernel > Creation d'un thread asynchrome d'une machine virtuel LLVM, et tentative d'execution de " & LTRIM(Fichier_LLVM) & "...", Affichage, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_Normal, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.AvecDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_CPCDOS, RetourVAR)
							Else
								DEBUG("Kernel > Creating LLVM virtual machine asynchrome thread, attempted execution of " & LTRIM(Fichier_LLVM) & "...", Affichage, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_Normal, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.AvecDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_CPCDOS, RetourVAR)
							End If
						End if
					End if
					exit _scope_CMD, _scope
				end if
			End if


			IF INSTR(Ucase(Param), "/PE ") > 0 OR INSTR(Ucase(Param), "/WIN32 ") > 0 Then
				if INSTR(Ucase(Param), "/PE ") < 5 OR INSTR(Ucase(Param), "/WIN32 ") < 8 then
					Dim POS_PE as integer = INSTR(Ucase(Param), "/PE ")
					DIM Fichier_PE as string = MID(Param, POS_PE + 4)
					Dim POS_Win32 as integer = INSTR(Ucase(Param), "/WIN32 ")
					DIM Fichier_Win32 as string = MID(Param, POS_Win32 + 7)

					if POS_PE = 0 Then
						if len(POS_Win32) > 0 Then Fichier_PE = Fichier_Win32
					End if

					dim FunctionID_RET 		as integer = 0
					dim FUNCTION_ID__		as integer = CPCDOS_INSTANCE._FUNCTIONID__EXELOADER

					IF CPCDOS_INSTANCE.SYSTEME_INSTANCE.get_DBG_DEBUG() > 0 Then
						IF CPCDOS_INSTANCE.Utilisateur_Langage = 0 Then
							DEBUG("Kernel > Execution d'un fichier PE (PortableExecutable WIN32) '" & LTRIM(Fichier_PE) & "' PID:" & Auth_PID & " TID:" & Auth_TID & " ...", Affichage, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_Normal, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.AvecDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_CPCDOS, RetourVAR)
						Else
							DEBUG("Kernel > Executing PortableExecutable file '" & LTRIM(Fichier_PE) & "' PID:" & Auth_PID & " TID:" & Auth_TID & " ...", Affichage, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_Normal, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.AvecDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_CPCDOS, RetourVAR)
						End If
					End if
					' A MODIFIER !! Sinon instance de la console bloque!
					' Execution du ExeLoader via le wrapper Cpcdos/CpintiCore

					IF CPCDOS_INSTANCE.get_Nom_Thread(Auth_TID) = "THREAD_CONSOLE" Then
						IF CPCDOS_INSTANCE.SYSTEME_INSTANCE.get_DBG_DEBUG() > 0 Then
							IF CPCDOS_INSTANCE.Utilisateur_Langage = 0 Then
								DEBUG("Execution depuis 'THREAD_CONSOLE' --> Creation d'un nouveau thread...", Affichage, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_AVERTISSEMENT, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.AvecDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_CPCDOS, RetourVAR)
							Else
								DEBUG("Execution from 'THREAD_CONSOLE'  --> Creating new thread...", Affichage, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_AVERTISSEMENT, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.AvecDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_CPCDOS, RetourVAR)
							End If
						End if

						Scope
							Fichier_PE = LTRIM(Fichier_PE)
							' Creer une instance de _STRUCT_THREAD_Cpcdos_OSx__, remplir le donnees
							Dim INSTANCE_STRUCT_THREAD as _STRUCT_THREAD_Cpcdos_OSx__
							INSTANCE_STRUCT_THREAD.Nom 		= "_WIN32PE_ASYNC_"  & _CLE_ & "~" & CPCDOS_INSTANCE.get_id_PID(_CLE_) & "~" & LTRIM(Fichier_PE)
							INSTANCE_STRUCT_THREAD.Fonction = cast(any ptr, @Wrapper_THREAD)
							INSTANCE_STRUCT_THREAD.PROC_ID 	= Auth_PID
							INSTANCE_STRUCT_THREAD.OS_ID	= Auth_OS		' ID de l'OS
							INSTANCE_STRUCT_THREAD.USER_ID	= Auth_Utilisateur	' ID de l'user
							INSTANCE_STRUCT_THREAD.KERNEL_ID= Auth_Kernel						' ID du kernel

							INSTANCE_STRUCT_THREAD.Priorite = _PRIORITE_THRD_MOYENNE
							INSTANCE_STRUCT_THREAD.ARG_CP 	= cast(any ptr, FUNCTION_ID__)

							INSTANCE_STRUCT_THREAD.ARG_1 	= malloc(sizeof(Fichier_PE))
							memcpy(INSTANCE_STRUCT_THREAD.ARG_1, cast(any ptr, @Fichier_PE), sizeof(Fichier_PE))

							INSTANCE_STRUCT_THREAD.ARG_2 = NULL
							INSTANCE_STRUCT_THREAD.ARG_3 = NULL
							INSTANCE_STRUCT_THREAD.ARG_4 = NULL
							INSTANCE_STRUCT_THREAD.ARG_5 = NULL

							CPCDOS_INSTANCE.Creer_thread(INSTANCE_STRUCT_THREAD)

							IF CPCDOS_INSTANCE.SYSTEME_INSTANCE.get_DBG_DEBUG() > 0 Then
								IF CPCDOS_INSTANCE.Utilisateur_Langage = 0 Then
									DEBUG("Kernel > Le thread " & INSTANCE_STRUCT_THREAD.Nom & " a ete cree!", Affichage, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_Normal, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.AvecDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_CPCDOS, RetourVAR)
								Else
									DEBUG("Kernel > Thread " & INSTANCE_STRUCT_THREAD.Nom & " was created!", Affichage, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_Normal, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.AvecDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_CPCDOS, RetourVAR)
								End If
							End if
						End scope
					Else
						' Execution du LLVM via le wrapper Cpcdos/CpintiCore
						FunctionID_RET = Exec_WRAPPER(FUNCTION_ID__, _CLE_, LTRIM(Fichier_PE), 0, NULL, NULL, NULL)
						IF CPCDOS_INSTANCE.SYSTEME_INSTANCE.get_DBG_DEBUG() > 0 Then
							IF CPCDOS_INSTANCE.Utilisateur_Langage = 0 Then
								DEBUG("Kernel > Creation d'un thread asynchrome d'un executable Win32, et tentative d'execution de " & LTRIM(Fichier_PE) & "...", Affichage, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_Normal, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.AvecDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_CPCDOS, RetourVAR)
							Else
								DEBUG("Kernel > Creating Win32 executable asynchrome thread, attempted execution of " & LTRIM(Fichier_PE) & "...", Affichage, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_Normal, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.AvecDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_CPCDOS, RetourVAR)
							End If
						End if
					end if
					exit _scope_CMD, _scope
				End if
			End if

			Dim ErreurAVT_053 as Boolean = false
			PosETCommerciale = INSTR(Param, "&")
			ExecMultiTHREAD = 0
			IF INSTR(Param, "&") > 0 Then
				IF INSTR(Param, " &") > 0 Then
					IF INSTR(Param, " &") < PosETCommerciale Then
						ErreurAVT_053 = TRUE
					ELSE
						IF INSTR(Param, " & ") > 0 Then
							IF INSTR(Param, " & ") < PosETCommerciale Then
								Param = MID(Param, PosETCommerciale + 2)
								CpcdosCP_SHELL = "&RETOUR"
							Else
								ErreurAVT_053 = TRUE
							END IF
						ELSE
							IF INSTR(Param, " &+ ") > 0 Then
								IF INSTR(Param, " &+ ") < PosETCommerciale Then
									Param = MID(Param, PosETCommerciale + 3)
									ExecMultiTHREAD = 1
								Else
									ErreurAVT_053 = TRUE
								END IF
							ELSE
								ErreurAVT_053 = TRUE
							End if
						End if

					END IF
				ELSE
					IF INSTR(Param, "& ") = PosETCommerciale Then
						Param = MID(Param, PosETCommerciale + 2)
						CpcdosCP_SHELL = "&RETOUR"
					ELSE
						IF INSTR(Param, "&+ ") = PosETCommerciale Then
							Param = MID(Param, PosETCommerciale + 3)
							ExecMultiTHREAD = 1
						ELSE
							ErreurAVT_053 = TRUE
						End if
					END IF
				End if
			ELSE
				CpcdosCP_SHELL = "&NONRETOUR"
			End if

			IF ErreurAVT_053 = TRUE Then
				Message_erreur = ERRAVT("AVT_053", 0)
				DEBUG("[CpcdosC+] " & Message_erreur & " " & CHR(34) & Commande & CHR(34) & ".", Affichage, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_AVERTISSEMENT, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.SansDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_AFF, RetourVAR)
				CpcdosCP_SHELL = "&NONRETOUR"
				exit _scope_CMD, _scope
			End if

			IF ExecMultiTHREAD = 1 Then
				' Executer un fichier CpcdosC+ dans un autre thread avec celui cifi�
				' de maniere "ascynchrome"
				IF CPCDOS_INSTANCE.SYSTEME_INSTANCE.get_DBG_DEBUG() > 0 Then
					IF CPCDOS_INSTANCE.Utilisateur_Langage = 0 Then
						DEBUG("Kernel > Creation d'un processus d'execution asynchrome CCP...", Affichage, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_Normal, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.AvecDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_CPCDOS, RetourVAR)
					Else
						DEBUG("Kernel > Creating asynchrome execution CCP process...", Affichage, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_Normal, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.AvecDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_CPCDOS, RetourVAR)
					End If
				End if

				scope
					Dim ExeParamsc as String = "Exe/ " & Param
					' Creer une instance de _STRUCT_THREAD_Cpcdos_OSx__, remplir le donnees
					Dim INSTANCE_STRUCT_THREAD as _STRUCT_THREAD_Cpcdos_OSx__
					INSTANCE_STRUCT_THREAD.Nom 		= "_CPCDOSCP_ASYNC_"  & _CLE_ & "~" & CPCDOS_INSTANCE.get_id_PID(_CLE_)
					INSTANCE_STRUCT_THREAD.Fonction = cast(any ptr, @Shell_THREAD)
					INSTANCE_STRUCT_THREAD.PROC_ID 	= Auth_PID
					INSTANCE_STRUCT_THREAD.OS_ID	= Auth_OS		' ID de l'OS
					INSTANCE_STRUCT_THREAD.USER_ID	= Auth_Utilisateur	' ID de l'user
					INSTANCE_STRUCT_THREAD.KERNEL_ID= Auth_Kernel						' ID du kernel

					INSTANCE_STRUCT_THREAD.Priorite = _PRIORITE_THRD_MOYENNE
					INSTANCE_STRUCT_THREAD.ARG_1 	= malloc(sizeof(ExeParamsc))
					memcpy(INSTANCE_STRUCT_THREAD.ARG_1, cast(any ptr, @ExeParamsc), sizeof(ExeParamsc))
					INSTANCE_STRUCT_THREAD.ARG_2 	= NULL ' CLE
					INSTANCE_STRUCT_THREAD.ARG_3 	= cast(any ptr, NIVEAU_CCP)
					INSTANCE_STRUCT_THREAD.ARG_4 	= cast(any ptr, Param_1)

					INSTANCE_STRUCT_THREAD.ARG_5 = malloc(sizeof(Param_2))
					memcpy(INSTANCE_STRUCT_THREAD.ARG_5, cast(any ptr, @Param_2), sizeof(Param_2))


					CPCDOS_INSTANCE.Creer_thread(INSTANCE_STRUCT_THREAD)

					doevents(100000)

				End scope
				exit _scope_CMD, _scope
			End if

			IF CPCDOS_INSTANCE.SYSTEME_INSTANCE.get_DBG_DEBUG() > 0 Then
				IF CPCDOS_INSTANCE.Utilisateur_Langage = 0 Then
					DEBUG("[CpcdosC+] Creation d'un processus d'execution CCP...", Affichage, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_Normal, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.AvecDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_CPCDOS, RetourVAR)
				Else
					DEBUG("[CpcdosC+] Creating execution CCP process...", Affichage, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_Normal, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.AvecDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_CPCDOS, RetourVAR)
				End If
			End if
			Dim Si_Non_EXE_FONCT as integer = 0
			' Ici on cherche un nouvel emplacement memoire pour creer une nouveau processus

			NomLblAAtteindre = ""

			' Si le parametre "/FN:" {Fonction} est present
			PosFonctExec = Instr(UCASE(Param), "/FN:")

			' Etre sur que ces attributs publiques sont vides
			CCP_Fonction_EXEC = ""
			CCP_Fonction_ARGS_N = 0
			For b as integer = 1 to this.MEMOIRE_CCP._MAX_FONCTION_ARGS : CCP_Fonction_ARGS(b) = "" : CCP_Fonction_DATA(b) = "" : CCP_Fonction_CLE(b) = 0 : next b

			Dim Arguments_CCP_FONCT_exec as string

			IF PosFonctExec > 0 Then

				' Declarer les attributs qui vont permettre la recherche
				Dim Pos_Virgule_DEBUT 		as integer = 0
				Dim Pos_Virgule_FIN 		as integer = 0

				Dim NomFonctExec 			as String = MID(Param, PosFonctExec + 4)
				Dim Position_1erParenthese 	as integer = Instr(NomFonctExec, "(")
				Dim Position_2emParenthese	as integer = InstrREV(NomFonctExec, ")")
				Dim NomFonction 			as string = Mid(NomFonctExec, 1, (Position_1erParenthese) - 1)
				Dim Arguments 				as string = Mid(NomFonctExec, Position_1erParenthese + 1, Position_2emParenthese - (Position_1erParenthese + 1))
				Dim Cle_CALLER_stack		as double = VAL(Mid(NomFonctExec, Instr(NomFonctExec, "->") + 2))

				' CORRECTION de cette PUTAIN FUCKING majuscule DANS les arguments !

				NomFonction = Ucase(NomFonction)
				NomFonctExec = Ucase(NomFonctExec)

				Arguments_CCP_FONCT_exec = Arguments

				' Transferer dans un attribut publique
				CCP_Fonction_EXEC = NomFonction




				' Recuperer les arguments pour les placer dans un tableau
				IF Position_1erParenthese = Position_2emParenthese - 1 then
					' S'il s'agit d'une fonction sans arguments
					IF CPCDOS_INSTANCE.SYSTEME_INSTANCE.get_DBG_DEBUG() > 0 Then
						IF CPCDOS_INSTANCE.Utilisateur_Langage = 0 Then
							DEBUG("[CpcdosC+] Fonction sans arguments.",  Affichage, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_SURBRILLE, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.SansDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_CPCDOS, RetourVAR)
						Else
							DEBUG("[CpcdosC+] Function without arguments.",  Affichage, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_SURBRILLE, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.SansDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_CPCDOS, RetourVAR)
						End if
					End if
				else

					IF CPCDOS_INSTANCE.SYSTEME_INSTANCE.get_DBG_DEBUG() > 0 Then
						IF CPCDOS_INSTANCE.Utilisateur_Langage = 0 Then
							DEBUG("[CpcdosC+] Fonction avec argument(s).",  Affichage, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_SURBRILLE, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.SansDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_CPCDOS, RetourVAR)
						Else
							DEBUG("[CpcdosC+] Function with argument(s).",  Affichage, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_SURBRILLE, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.SansDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_CPCDOS, RetourVAR)
						End if
					End if
					' Une fonction avec 1 ou plusieurs arguments
					For Boucle_ARGS 		as integer = 1 to this.MEMOIRE_CCP._MAX_FONCTION_ARGS
						' Recuperer les positions
						Pos_Virgule_DEBUT = Pos_Virgule_FIN + 1
						Pos_Virgule_FIN = Instr(Pos_Virgule_DEBUT, Arguments, ",")

						' Verifier la presence d'une vigule
						IF Pos_Virgule_FIN > 0 Then
							'  Virgule presente!
							CCP_Fonction_ARGS(Boucle_ARGS) = LTrim(MID(Arguments, Pos_Virgule_DEBUT, (Pos_Virgule_FIN) - Pos_Virgule_DEBUT))
						else
							' Hop on recupere le dernier argument avant la parenthese
							CCP_Fonction_ARGS(Boucle_ARGS) = LTrim(MID(Arguments, Pos_Virgule_DEBUT, (Position_2emParenthese) - Pos_Virgule_DEBUT))

							' Ah .. C'est finis mon gros ;)
							CCP_Fonction_ARGS_N = Boucle_ARGS
							exit for
						End if

					Next Boucle_ARGS
				End if

				IF CCP_Fonction_ARGS_N > 0 Then
					' On recupere si possible les donnees des variables
					For boucle_rempl as integer = 0 to CCP_Fonction_ARGS_N

						Dim Test_Remplace as string

						' Si c'est une variable
						If InstrREV(Commande, "%") > Instr(Commande, "%") THEN

							' Recuperer les ID des variables en argument depuis le Stack de celui qui a appele la fonction.
							Dim tmp_Auth_Kernel				as uinteger = CPCDOS_INSTANCE.get_id_kernel		(Cle_CALLER_stack)
							Dim tmp_Auth_OS					as uinteger = CPCDOS_INSTANCE.get_id_OS			(Cle_CALLER_stack)
							Dim tmp_Auth_Utilisateur		as uinteger = CPCDOS_INSTANCE.get_id_Utilisateur(Cle_CALLER_stack)
							Dim tmp_Auth_PID				as uinteger = CPCDOS_INSTANCE.get_id_PID		(Cle_CALLER_stack)
							Dim tmp_Auth_TID				as uinteger = CPCDOS_INSTANCE.get_id_TID		(Cle_CALLER_stack)


							' Retrouver toutes les variables en memoire depuis la precedente stack
							Test_Remplace = CCP_Rempl_VAR(CCP_Fonction_ARGS(boucle_rempl), NIVEAU_CCP, tmp_Auth_Kernel, tmp_Auth_OS, tmp_Auth_Utilisateur, tmp_Auth_PID, tmp_Auth_TID, RetourVAR)

							' Si ce n'est pas une variable, alors se sont des donnees brutes ?
							IF NOT Test_Remplace = CPCDOS_INSTANCE._CONTENU_IMPROPABLE then
								' On recupere les donnees
								CCP_Fonction_DATA(boucle_rempl) = Test_Remplace
							Else
								Message_erreur = ERRAVT("AVT_008", 0)
								IF CPCDOS_INSTANCE.Utilisateur_Langage = 0 Then
									DEBUG("[CpcdosC+] AVT_008:" & Message_erreur & " --> '" & CCP_Fonction_ARGS(boucle_rempl) & "' depuis l'appel de fonction " & CCP_Fonction_EXEC & ". (KRNL_ID:" & tmp_Auth_Kernel & " OS:" & tmp_Auth_OS & " USER:" & tmp_Auth_Utilisateur & " PID:" & tmp_Auth_PID & " TID:" & tmp_Auth_TID & ") CleID: &" & Cle_CALLER_stack & " [&B" & Bin(Cle_CALLER_stack, 36) & "] -> 0x" & hex(Cle_CALLER_stack, 10), Affichage, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_AVERTISSEMENT, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.AvecDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_AFF, RetourVAR)
								Else
									DEBUG("[CpcdosC+] AVT_008:" & Message_erreur & " --> '" & CCP_Fonction_ARGS(boucle_rempl) & "' from calling function " & CCP_Fonction_EXEC & ". (KRNL_ID:" & tmp_Auth_Kernel & " OS:" & tmp_Auth_OS & " USER:" & tmp_Auth_Utilisateur & " PID:" & tmp_Auth_PID & " TID:" & tmp_Auth_TID & ") CleID: &" & Cle_CALLER_stack & " [&B" & Bin(Cle_CALLER_stack, 36) & "] -> 0x" & hex(Cle_CALLER_stack, 10), Affichage, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_AVERTISSEMENT, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.AvecDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_AFF, RetourVAR)
								End If
							End if
						Else
							CCP_Fonction_DATA(boucle_rempl) = CCP_Fonction_ARGS(boucle_rempl)

						End if
					Next boucle_rempl
				End if


				' Enlever le '/FN:'
				Param = MID(Param, 1, PosFonctExec - 2)


				' IF CPCDOS_INSTANCE.SYSTEME_INSTANCE.get_DBG_DEBUG() > 0 Then
					' IF CPCDOS_INSTANCE.Utilisateur_Langage = 0 Then
						' DEBUG("[CpcdosC+] Redefinition de la cle d'identification", Affichage, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_Normal, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.NoCRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.AvecDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_CPCDOS, RetourVAR)
					' Else
						' DEBUG("[CpcdosC+] Redefinition key ID", Affichage, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_Normal, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.NoCRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.AvecDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_CPCDOS, RetourVAR)
					' End If
				' End if

				' ' Redefinition des cle d'identifications
				' Auth_TID = int(Auth_TID + CPCDOS_INSTANCE.Generer_RND(1, 99))
				' _CLE_ = CPCDOS_INSTANCE.Generer_cle(Auth_Kernel, Auth_OS, Auth_Utilisateur, Auth_PID, Auth_TID)

				' IF CPCDOS_INSTANCE.SYSTEME_INSTANCE.get_DBG_DEBUG() > 0 Then
					' DEBUG("[OK] --> CleID:" & _CLE_ & " [&B" & Bin(_CLE_, 36) & "] -> 0x" & hex(_CLE_, 10) & " (TID:" & Auth_TID & ")", Affichage, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_Normal, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.SansDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_CPCDOS, RetourVAR)
				' End if

				Si_Non_EXE_FONCT = 1
				IF CPCDOS_INSTANCE.SYSTEME_INSTANCE.get_DBG_DEBUG() > 0 Then
					IF CPCDOS_INSTANCE.Utilisateur_Langage = 0 Then
						DEBUG("[CpcdosC+] Appelle de la fonction '" & CCP_Fonction_EXEC & "()'...", Affichage, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_Normal, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.AvecDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_CPCDOS, RetourVAR)
					Else
						DEBUG("[CpcdosC+] Calling function '" & CCP_Fonction_EXEC & "()'...", Affichage, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_Normal, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.AvecDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_CPCDOS, RetourVAR)
					End If
				End if


			End if

			' Si le parametre "/L:{Nom du label}" ou "/L:#{Numero de ligne}" est present
			PosLabelExec = Instr(UCASE(Param), "/L:")
			IF PosLabelExec > 0 Then

				' On se positionne a partir du premier "/"
				NomLblAAtteindre = MID(Param, PosLabelExec)

				' On verifie si il y a pas le "#" a cote
				PosLabelLigneExec = Instr(UCASE(Param), "/L:#")
				IF PosLabelLigneExec > 0 Then
					' Si oui, on Recupere le NUMERO DE LIGNE
					NumeroDeLigneAChercher = Val(MID(Param, PosLabelLigneExec + 4))
					NomLblAAtteindre = ""
					' Puis releve le /L:# pour recuperer le nom de fihcier uniquement
					Param = MID(Param, 1, PosLabelLigneExec - 2)
				Else
					' Si non, on Recupere le NOM DE LABEL
					NomLblAAtteindre = UCASE(MID(Param, PosLabelExec + 3))

					' Puis releve le /L: pour recuperer le nom de fihcier uniquement
					Param = MID(Param, 1, PosLabelExec - 2)
				End if
			End if

			Nom_Fichier = UCASE(Param)
			IF Instr(MID(Nom_Fichier, 1, 1), " ") > 0 Then Nom_Fichier = MID(Nom_Fichier, 2)

			' Tester si la nouvelle instance d'objet a reussi
			IF 1 = 1 Then
				IF CPCDOS_INSTANCE.SYSTEME_INSTANCE.get_DBG_DEBUG() > 0 Then
					IF CPCDOS_INSTANCE.Utilisateur_Langage = 0 Then
						DEBUG("[CpcdosC+][CPinti] OK, Test de l'existence de '" & Nom_Fichier & "' ...", Affichage, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_Normal, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.AvecDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_CPCDOS, RetourVAR)
					Else
						DEBUG("[CpcdosC+][CPinti] OK, Testing existence '" & Nom_Fichier & "' ...", Affichage, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_Normal, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.AvecDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_CPCDOS, RetourVAR)
					End If
				End if

				Nom_Fichier_DBG = Nom_Fichier
				' Tester l'existence du fichier
				If CPCDOS_INSTANCE.Fichier_Existe(Nom_Fichier) = TRUE then

					Dim Taille_Du_Fichier 	as uinteger = 0
					Dim Buffer_CCP 			as String = ""
					' exe/
					Dim RetourCCP 			as String = ""

					IF CPCDOS_INSTANCE.SYSTEME_INSTANCE.get_DBG_DEBUG() > 0 Then
						IF CPCDOS_INSTANCE.Utilisateur_Langage = 0 Then
							DEBUG("[CpcdosC+] OK, Ouverture de '" & Param & "' ...", Affichage, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_Normal, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.AvecDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_CPCDOS, RetourVAR)
						Else
							DEBUG("[CpcdosC+] OK, opening of '" & Param & "' ...", Affichage, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_Normal, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.AvecDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_CPCDOS, RetourVAR)
						End If
					End if
					'doevents(_PAUSE_CRT) ' Pause CRT CPinticore

					if CPCDOS_INSTANCE.Fichier_Existe(Nom_Fichier) = true Then
						' Lire le contenu depuis CPinti core
						Buffer_CCP = CPCDOS_INSTANCE.Lire_fichier_complet(Nom_Fichier)
					End if

					' Recuperer la taille d fichier
					Taille_Du_Fichier = Len(Buffer_CCP)

					' ENTRER_SectionCritique()
					' Print "Contenu fichier : " & Buffer_CCP & "."
					' print "Taille final : " & Taille_Du_Fichier & "."
					' dim touche as string
					' SORTIR_SectionCritique()

					' while(true)
						' touche = inkey
						' if touche = "1" then exit while
					' wend

					IF CPCDOS_INSTANCE.SYSTEME_INSTANCE.get_DBG_DEBUG() > 0 Then
						IF CPCDOS_INSTANCE.Utilisateur_Langage = 0 Then
							DEBUG("[CpcdosC+] Taille " & Taille_Du_Fichier & " octets ...", Affichage, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_Normal, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.AvecDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_CPCDOS, RetourVAR)
						Else
							DEBUG("[CpcdosC+] Size " & Taille_Du_Fichier & " bytes ...", Affichage, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_Normal, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.AvecDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_CPCDOS, RetourVAR)
						End If
					End if

					' Verifier si CPintiCore nous a communique une erreur
					IF Taille_Du_Fichier = 0 then
						' ca sert a rien de continuer si le fichier est vide
						exit _scope_CMD, _scope
					Else

						Dim FinDuFichier		as Integer = 0
						Dim Passage				as Integer = 0
						Dim TestALLER 			as Integer = 0

						DIM PILE_SI(0 to 64) 	as integer
						DIM Execute_SI		 	as integer = 0

						DIM PILE_SI_NB			as integer = 0
						DIM NB_Si_Non_Exe		as integer = 0
						DIM SI_CEST_FONCTION	as integer = 0
						Dim Empl_1 				as integer = 0
						Dim ModeAnalyse			as integer = 0
						if this.Cpcdos_Optimisation > 0 Then ModeAnalyse = 1

						Dim Index_Label			as integer = 0

						Dim Temp_exe 				as Integer

						Dim EmplacementLabel	(0 to CPCDOS_INSTANCE.SHELLCCP_INSTANCE.MEMOIRE_CCP._MAX_LABEL + 1) 	as integer
						Dim NoLigneLabel		(0 to CPCDOS_INSTANCE.SHELLCCP_INSTANCE.MEMOIRE_CCP._MAX_LABEL + 1)		as integer
						Dim NomLabel_Emplace	(0 to CPCDOS_INSTANCE.SHELLCCP_INSTANCE.MEMOIRE_CCP._MAX_LABEL + 1) 	as String

						' Forcer la memoire vide 6 octets
						for nom_boucle as integer = 0 to CPCDOS_INSTANCE.SHELLCCP_INSTANCE.MEMOIRE_CCP._MAX_LABEL + 1
							NomLabel_Emplace(nom_boucle) = chr(0) & chr(0) & chr(0) & chr(0) & chr(0) & chr(0)
							NomLabel_Emplace(nom_boucle) = ""
						next nom_boucle

						Dim Nouvelle_TID 			as uinteger
						Dim Nouvelle_Cle 			as double
						Dim Nouvelle_Cle_GUI 		as double
						Dim Nouvelle_OS_ID	 		as integer = Auth_OS ' OS EN COURS

						' IUG
						DIM Modification_IUG		as boolean
						DIM Modification_IUG_TID	as double

						Dim _INDEX_FENETRE_ 		as integer = 0
						Dim _INDEX_BOUTON_ 			as integer = 0
						Dim _INDEX_PICTUREBOX_ 		as integer = 0
						Dim _INDEX_TEXTBLOCK_		as integer = 0
						Dim _INDEX_TEXTBOX_			as integer = 0
						Dim _INDEX_PROGRESSBAR_		as integer = 0
						Dim _INDEX_CHECKBOX_		as integer = 0

						Dim IUG_CREATION_FENETRE 	as string
						Dim IUG_CREATION_BOUTON 	as string
						Dim IUG_CREATION_PICTUREBOX as string
						Dim IUG_CREATION_TEXTEBOX 	as string
						Dim IUG_CREATION_TEXTEBLOCK as string
						Dim IUG_CREATION_PROGRESSBAR as string
						Dim IUG_CREATION_CHECKBOX 	as string


						Dim Buffer_lecture 			as String

						Position_DEBUT	 	= 1
						Position_FIN 	 	= 0
						Buffer_lecture  	= ""
						Numero_de_Ligne 	= 0
						RetourCCP 			= ""
						LabelAChercher		= RTRIM(RTRIM(RTRIM(RTRIM(LTRIM(LTRIM(LTRIM(LTRIM(UCASE(NomLblAAtteindre)), chr(09)), chr(10)), chr(13)), chr(09)), chr(13)), chr(10)))
						TestALLER 			= 0
						Niveau_2			= 2

						IF CPCDOS_INSTANCE.SYSTEME_INSTANCE.get_DBG_DEBUG() > 0 Then
							IF CPCDOS_INSTANCE.Utilisateur_Langage = 0 Then
								DEBUG(" - Cle id:" & _CLE_, Affichage, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_VALIDATION, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.AvecDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_CPCDOS, RetourVAR)
							Else
								DEBUG(" - Key id:" & _CLE_, Affichage, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_VALIDATION, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.AvecDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_CPCDOS, RetourVAR)
							End If
						End if


						IF NOT EXEC_FONCTION_FICHIER = "" THEN
							IF CPCDOS_INSTANCE.SYSTEME_INSTANCE.get_DBG_DEBUG() > 0 Then
								IF CPCDOS_INSTANCE.Utilisateur_Langage = 0 Then
									DEBUG("[CpcdosC+] Pas de redefinition de la cle d'identification d'executable", Affichage, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_ACTION, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.NoCRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.AvecDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_CPCDOS, RetourVAR)
								Else
									DEBUG("[CpcdosC+] No redefinition key ID for executable", Affichage, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_ACTION, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.NoCRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.AvecDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_CPCDOS, RetourVAR)
								End If
							End if
							' Pas de changements si c'est une fonction car elle c'est deja fait
							Nouvelle_TID = Auth_TID
							Nouvelle_Cle = _CLE_
						' Elseif Slash_FN_Presend = TRUE Then
							' ' Idem car on le FERA
							' Nouvelle_TID = Auth_TID
							' Nouvelle_Cle = _CLE_

						Else
							' Si c'est pas une fonction, on regenere une nouvelle cle
							IF CPCDOS_INSTANCE.SYSTEME_INSTANCE.get_DBG_DEBUG() > 0 Then
								IF CPCDOS_INSTANCE.Utilisateur_Langage = 0 Then
									DEBUG("[CpcdosC+] Redefinition de la cle d'identification d'executable", Affichage, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_ACTION, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.NoCRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.AvecDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_CPCDOS, RetourVAR)
								Else
									DEBUG("[CpcdosC+] Redefinition key ID for executable", Affichage, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_ACTION, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.NoCRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.AvecDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_CPCDOS, RetourVAR)
								End If
							End if

							Nouvelle_TID = int(Auth_TID + CPCDOS_INSTANCE.Generer_RND(50, 99))
							Nouvelle_Cle = CPCDOS_INSTANCE.Generer_cle(Auth_Kernel, Auth_OS, Auth_Utilisateur, Auth_PID, Nouvelle_TID)
						End if

						IF CPCDOS_INSTANCE.SYSTEME_INSTANCE.get_DBG_DEBUG() > 0 Then
							DEBUG("[OK] --> CleID:" & Nouvelle_Cle & " [&B" & Bin(Nouvelle_Cle, 36) & "] -> 0x" & hex(Nouvelle_Cle, 10) & " (TID:" & Auth_TID & ")", Affichage, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_OK, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.SansDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_CPCDOS, RetourVAR)
						End if
						Nouvelle_Cle_GUI = Nouvelle_Cle


						CpcdosCP_SHELL("FIX/ _EXE_PATH_ = " & Param, Nouvelle_Cle, 2, Param_1, Param_2)

						CpcdosCP_SHELL("FIX/ _EXE_PATH_F_ = " & Mid(Param, 1, INSTRREV(Param, "\") - 1), Nouvelle_Cle, 2, Param_1, Param_2)

						CpcdosCP_SHELL("FIX/ _EXE_PID_ = " & Auth_PID , Nouvelle_Cle, 2, Param_1, Param_2)

						CpcdosCP_SHELL("FIX/ _EXE_TID_ = " & CPCDOS_INSTANCE.get_ThreadEnCours(), Nouvelle_Cle, 2, Param_1, Param_2)

						CpcdosCP_SHELL("FIX/ _EXE_DATE_ = " & CPCDOS_INSTANCE.get_Date("AAAA-MM-JJ") & " " & CPCDOS_INSTANCE.get_Heure("HH:MM:SS"), Nouvelle_Cle, 2, Param_1, Param_2)

						IF ModeAnalyse = 1 then
							IF CPCDOS_INSTANCE.SYSTEME_INSTANCE.get_DBG_DEBUG() > 0 Then
								IF CPCDOS_INSTANCE.Utilisateur_Langage = 0 Then
									DEBUG("[CpcdosC+] Debut de l'analyse du programme pour d'eventuels optimisations...", Affichage, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_Normal, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.AvecDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_CPCDOS, RetourVAR)
								Else
									DEBUG("[CpcdosC+] Starting analysis program for possible optimizations...", Affichage, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_Normal, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.AvecDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_CPCDOS, RetourVAR)
								End If
							End if
						End if


					scope
						Dim NumeroOS					as Integer = Auth_OS
						' Proprietes d'identification du Processus hebergeur
						DIM GUI__PROC_PARENT			as String	= CPCDOS_INSTANCE.get_Nom_Processus(Auth_PID)
						DIM GUI__PID_PARENT				as integer	= Auth_PID

						' Proprietes d'identification du Thread executif
						DIM GUI__THREAD_PARENT			as String	= CPCDOS_INSTANCE.get_Nom_Thread(Auth_TID)
						DIM GUI__TID_PARENT				as Integer 	= Auth_TID

						' Proprietes d'identification d'Objet graphique hebergeur
						'	Dans le cas si on cree une fenetre --> Son hebergeur sera null
						DIM GUI__Fenetre_PARENT			as String 	= ""	' Nom de la fenetre hebergeur
						DIM GUI__Index_FNT_PARENT		as Integer 	= 0 	' Index de la fenetre hebergeur
						DIM GUI__Handle_PARENT			as Integer 	= 0 	' Handle de la fenetre hebergeur

						' Proprietes d'identification de l'Objet concerne
						DIM GUI__Nom					as String	= ""	' Nom de l'objet
						DIM GUI__Index_ENFANT			as integer 	= 0		' Index de l'objet
						DIM GUI__Handle					as integer	= 0		' Numero d'Handle de l'objet

						' Proprietes uniques de l'objet concerne
						DIM GUI__PROP_TYPE 				as String 	= ""
						DIM GUI__DEJA_INITIALISE		as boolean = false

						DIM GUI__PROP_TITRE 			as String 	= CCP_Lire_Variable("CPC_GUI.WINDOW.TITLE", 3, _CLE_)
						DIM GUI__PROP_TITRE_PX			as Integer 	= Val(CCP_Lire_Variable("CPC_GUI.WINDOW.TITLE_PX", 3, _CLE_))
						DIM GUI__PROP_TITRE_PY			as Integer 	= Val(CCP_Lire_Variable("CPC_GUI.WINDOW.TITLE_PY", 3, _CLE_))

						Dim GUI__PROP_TITRE_IMG_ID				as integer = 0
						Dim GUI__PROP_BUFFER_TITRE_IMG_ID		as integer = 0
						Dim GUI__PROP_BUFFER_TITRE_2_IMG_ID		as integer = 0
						Dim GUI__PROP_BUFFER_WIN_IMG_ID			as integer = 0
						Dim GUI__PROP_BUFFER_OMBRE_WIN_IMG_ID	as integer = 0



						DIM GUI__IUG_UPDATER			as integer 	= 100
						DIM GUI__THREAD_OK				as integer 	= 0
						DIM GUI__PROP_TEXTE				as String 	= ""
						DIM GUI__PROP_VALEUR			as Integer 	= 0

						DIM GUI__PROP_TYPE_OBJ			as integer 	= 0 ' Fenetre/Objet normal

						DIM GUI__PROP_DEPLACABLE		as boolean 	= true
						DIM GUI__PROP_SIZEABLE_ANGL 	as boolean 	= true
						DIM GUI__PROP_SIZEABLE 			as boolean 	= true
						DIM GUI__PROP_REDUCTABLE 		as boolean 	= true
						DIM GUI__PROP_FERMABLE 			as boolean 	= true




						DIM GUI__PROP_TYPE_BORDURE		as integer	= Val(CCP_Lire_Variable("CPC_GUI.WINDOW.BORD", 3, _CLE_))
						Dim GUI__PROP_TYPE_Ombre		as integer	= Val(CCP_Lire_Variable("CPC_GUI.WINDOW.SHADOW", 3, _CLE_))
						Dim GUI__PROP_TYPE_Editable		as boolean	= TRUE
						Dim GUI__PROP_TYPE_MultiLignes	as boolean	= FALSE
						Dim GUI__PROP_TYPE_Console		as boolean 	= FALSE
						Dim GUI__PROP_TYPE_Ombre_RVB	as String	= CCP_Lire_Variable("CPC_GUI.WINDOW.SHADOW_RGB", 3, _CLE_)

						Dim GUI__PROP_OMBRE_PX			as integer = Val(CCP_Lire_Variable("CPC_GUI.WINDOW.SHADOW_PX", 3, _CLE_))
						Dim GUI__PROP_OMBRE_PY			as integer = Val(CCP_Lire_Variable("CPC_GUI.WINDOW.SHADOW_PY", 3, _CLE_))


						DIM GUI__PROP_COULEURALPHA		as string	= CCP_Lire_Variable("CPC_GUI.WINDOW.ALPHA", 3, _CLE_)
						DIM GUI__PROP_COULEURTITRE 		as String 	= CCP_Lire_Variable("CPC_GUI.WINDOW.TITLE_RGB", 3, _CLE_)
						DIM GUI__PROP_COULEURTEXTE		as String   = CCP_Lire_Variable("CPC_GUI.TEXT_RGB", 3, _CLE_)
						DIM GUI__PROP_COULEURFENETRE 	as String 	= CCP_Lire_Variable("CPC_GUI.WINDOW.RGB", 3, _CLE_)
						DIM GUI__PROP_COULEURFOND		as String 	= CCP_Lire_Variable("CPC_GUI.WINDOW.BACKGROUND_RGB", 3, _CLE_)
						DIM GUI__PROP_COULEUR			as String 	= CCP_Lire_Variable("CPC_GUI.RGB", 3, _CLE_)

						DIM GUI__PROP_EditBar			as String 	= CCP_Lire_Variable("CPC_GUI.TEXTBOX.EDITBAR", 3, _CLE_)
						DIM GUI__PROP_EditBar_L			as String 	= CCP_Lire_Variable("CPC_GUI.TEXTBOX.EDITBAR_L", 3, _CLE_)

						' APPLICATION ICONE
						DIM GUI__PROP_ICONE				as String 	= CCP_Lire_Variable("CPC_GUI.WINDOW.ICO", 3, _CLE_)
						Dim GUI__PROP_ICONE_IMG_ID			as integer 	= 0
						Dim GUI__PROP_ICONE_ORG_IMG_ID		as integer 	= 0
						DIM GUI__PROP_ICONE_PX			as Integer 	= Val(CCP_Lire_Variable("CPC_GUI.WINDOW.ICO_PX", 3, _CLE_))
						DIM GUI__PROP_ICONE_PY			as Integer 	= Val(CCP_Lire_Variable("CPC_GUI.WINDOW.ICO_PY", 3, _CLE_))
						DIM GUI__PROP_ICONE_POS			as Integer 	= Val(CCP_Lire_Variable("CPC_GUI.WINDOW.ICO_POSITION", 3, _CLE_))
						DIM GUI__PROP_ICONE_TX			as Integer 	= Val(CCP_Lire_Variable("CPC_GUI.WINDOW.ICO_SX", 3, _CLE_))
						DIM GUI__PROP_ICONE_TY			as Integer 	= Val(CCP_Lire_Variable("CPC_GUI.WINDOW.ICO_SY", 3, _CLE_))
						DIM GUI__PROP_ICONE_T			as Boolean
						IF  Val(CCP_Lire_Variable("CPC_GUI.WINDOW.ICO_S", 3, _CLE_)) = 1 Then
							GUI__PROP_ICONE_T = TRUE
						Else
							GUI__PROP_ICONE_T = FALSE
						End if

						' APPLICATION FERMETURE
						DIM GUI__PROP_BT_CLOSE			as String 	= CCP_Lire_Variable("CPC_GUI.WINDOW.BT_CLOSE", 3, _CLE_)

						Dim GUI__PROP_BT_CLOSE_IMG_ID 	as integer = 0
						Dim GUI__PROP_BT_CLOSE_ORG_IMG_ID as integer = 0

						DIM GUI__PROP_BT_CLOSE_PX		as Integer 	= Val(CCP_Lire_Variable("CPC_GUI.WINDOW.BT_CLOSE_PX", 3, _CLE_))
						DIM GUI__PROP_BT_CLOSE_PY		as Integer 	= Val(CCP_Lire_Variable("CPC_GUI.WINDOW.BT_CLOSE_PY", 3, _CLE_))
						DIM GUI__PROP_BT_CLOSE_POS		as Integer 	= Val(CCP_Lire_Variable("CPC_GUI.WINDOW.BT_CLOSE_POSITION", 3, _CLE_))
						DIM GUI__PROP_BT_CLOSE_TX		as Integer 	= Val(CCP_Lire_Variable("CPC_GUI.WINDOW.BT_CLOSE_SX", 3, _CLE_))
						DIM GUI__PROP_BT_CLOSE_TY		as Integer 	= Val(CCP_Lire_Variable("CPC_GUI.WINDOW.BT_CLOSE_SY", 3, _CLE_))
						DIM GUI__PROP_BT_CLOSE_T		as Boolean
						IF  Val(CCP_Lire_Variable("CPC_GUI.WINDOW.BT_CLOSE_S", 3, _CLE_)) = 1 Then
							GUI__PROP_BT_CLOSE_T = TRUE
						Else
							GUI__PROP_BT_CLOSE_T = FALSE
						End if

						' APPLICATION AGRANDISSEMENT
						DIM GUI__PROP_BT_SIZEUP		as String 	= CCP_Lire_Variable("CPC_GUI.WINDOW.BT_SIZEUP", 3, _CLE_)
						DIM GUI__PROP_BT_SIZEUP_PX	as Integer 	= Val(CCP_Lire_Variable("CPC_GUI.WINDOW.BT_SIZEUP_PX", 3, _CLE_))
						DIM GUI__PROP_BT_SIZEUP_PY	as Integer 	= Val(CCP_Lire_Variable("CPC_GUI.WINDOW.BT_SIZEUP_PY", 3, _CLE_))
						DIM GUI__PROP_BT_SIZEUP_POS	as Integer 	= Val(CCP_Lire_Variable("CPC_GUI.WINDOW.BT_SIZEUP_POSITION", 3, _CLE_))
						DIM GUI__PROP_BT_SIZEUP_TX	as Integer 	= Val(CCP_Lire_Variable("CPC_GUI.WINDOW.BT_SIZEUP_SX", 3, _CLE_))
						DIM GUI__PROP_BT_SIZEUP_TY	as Integer 	= Val(CCP_Lire_Variable("CPC_GUI.WINDOW.BT_SIZEUP_SY", 3, _CLE_))
						DIM GUI__PROP_BT_SIZEUP_T		as Boolean
						IF  Val(CCP_Lire_Variable("CPC_GUI.WINDOW.BT_SIZEUP_S", 3, _CLE_)) = 1 Then
							GUI__PROP_BT_SIZEUP_T = TRUE
						Else
							GUI__PROP_BT_SIZEUP_T = FALSE
						End if

						' APPLICATION RETRECISSEMENT
						DIM GUI__PROP_BT_SIZEDOWN			as String 	= CCP_Lire_Variable("CPC_GUI.WINDOW.BT_SIZEDOWN", 3, _CLE_)
						DIM GUI__PROP_BT_SIZEDOWN_PX		as Integer 	= Val(CCP_Lire_Variable("CPC_GUI.WINDOW.BT_SIZEDOWN_PX", 3, _CLE_))
						DIM GUI__PROP_BT_SIZEDOWN_PY		as Integer 	= Val(CCP_Lire_Variable("CPC_GUI.WINDOW.BT_SIZEDOWN_PY", 3, _CLE_))
						DIM GUI__PROP_BT_SIZEDOWN_POS		as Integer 	= Val(CCP_Lire_Variable("CPC_GUI.WINDOW.BT_SIZEDOWN_POSITION", 3, _CLE_))
						DIM GUI__PROP_BT_SIZEDOWN_TX		as Integer 	= Val(CCP_Lire_Variable("CPC_GUI.WINDOW.BT_SIZEDOWN_SX", 3, _CLE_))
						DIM GUI__PROP_BT_SIZEDOWN_TY		as Integer 	= Val(CCP_Lire_Variable("CPC_GUI.WINDOW.BT_SIZEDOWN_SY", 3, _CLE_))
						DIM GUI__PROP_BT_SIZEDOWN_T		as Boolean
						IF  Val(CCP_Lire_Variable("CPC_GUI.WINDOW.BT_SIZEDOWN_S", 3, _CLE_)) = 1 Then
							GUI__PROP_BT_SIZEDOWN_T = TRUE
						Else
							GUI__PROP_BT_SIZEDOWN_T = FALSE
						End if

						' APPLICATION REDUCTION
						DIM GUI__PROP_BT_REDUCT			as String 	= CCP_Lire_Variable("CPC_GUI.WINDOW.BT_REDUCT", 3, _CLE_)
						DIM GUI__PROP_BT_REDUCT_PX		as Integer 	= Val(CCP_Lire_Variable("CPC_GUI.WINDOW.BT_REDUCT_PX", 3, _CLE_))
						DIM GUI__PROP_BT_REDUCT_PY		as Integer 	= Val(CCP_Lire_Variable("CPC_GUI.WINDOW.BT_REDUCT_PY", 3, _CLE_))
						DIM GUI__PROP_BT_REDUCT_POS		as Integer 	= Val(CCP_Lire_Variable("CPC_GUI.WINDOW.BT_REDUCT_POSITION", 3, _CLE_))
						DIM GUI__PROP_BT_REDUCT_TX		as Integer 	= Val(CCP_Lire_Variable("CPC_GUI.WINDOW.BT_REDUCT_SX", 3, _CLE_))
						DIM GUI__PROP_BT_REDUCT_TY		as Integer 	= Val(CCP_Lire_Variable("CPC_GUI.WINDOW.BT_REDUCT_SY", 3, _CLE_))
						DIM GUI__PROP_BT_REDUCT_T		as Boolean
						IF  Val(CCP_Lire_Variable("CPC_GUI.WINDOW.BT_REDUCT_S", 3, _CLE_)) = 1 Then
							GUI__PROP_BT_REDUCT_T = TRUE
						Else
							GUI__PROP_BT_REDUCT_T = FALSE
						End if


						DIM GUI__PROP_IMGTITRE			as String 	= CCP_Lire_Variable("CPC_GUI.WINDOW.TITLE_IMG", 3, _CLE_)


						DIM GUI__PROP_IMAGE				as String 	= ""
						DIM GUI__PROP_IMAGE_ANCIEN		as String 	= ""

						Dim GUI__PROP_IMAGE_ID			as Integer 	= 0
						Dim GUI__PROP_IMAGE_prog_ID		as Integer 	= 0
						Dim GUI__PROP_IMAGE_fond_ID		as Integer 	= 0
						Dim GUI__PROP_IMAGE_ORG_ID		as Integer 	= 0

						Dim GUI__PROP_IMAGE_SURVOLE_ID	as Integer 	= 0
						Dim GUI__PROP_IMAGE_SURVOLE_ORG_ID as Integer = 0


						DIM GUI__PROP_IMAGEPTR			as ANY PTR	= 0
						DIM GUI__PROP_IMAGEPTR_ORG		as ANY PTR	= 0
						DIM GUI__PROP_IMAGEPTR_ANCIEN	as ANY PTR	= 0
						DIM GUI__PROP_BIT_ORG			as integer = 0


						DIM GUI__PROP_UPDATER			as integer	= 0

						DIM GUI__PROP_CONTENEUR_COMPLET as boolean 	= false
						DIM GUI__PROP_ALPHA_MODE 		as integer	= 0

						DIM GUI__PROP_FOND_COULEUR		as boolean = TRUE

						DIM GUI__PROP_AUTOSIZE			as integer	= 0

						DIM GUI__PROP_PX 				as Integer 	= 100
						DIM GUI__PROP_PY 				as Integer 	= 100
						DIM GUI__PROP_TX 				as Integer 	= 150
						DIM GUI__PROP_TY 				as Integer 	= 100
						DIM GUI__PROP_TTITRE			as Integer 	= Val(CCP_Lire_Variable("CPC_GUI.WINDOW.TITLE_SY", 3, _CLE_))

						DIM GUI__PROP_EVENEMENT			as String 	= ""
						DIM GUI__PROP_EVENEMENT_DISPO	as String 	= ""

						Dim si_EXE_FIXE_VARIABLES as integer = 0
						Dim si_EXE_FONCTION_NIV_1 as integer = 0

						'doevents(_PAUSE_CRT) ' Pause CRT CPinticore

						DIM Pourcent_CPU 		as integer
						Dim TailleRetourCHR 	as integer
						Dim Deja_Affiche		as boolean = false
						Dim Buffer_LABEL 		as String


						CPCDOS_INSTANCE.En_Charge(true)
						while ((LEN(Buffer_CCP)-Position_FIN) > 0) ' Si on est encore a l'interieur

							TailleRetourCHR = 0

							' Recuperer l'emplacement de 13 10
							Position_FIN = Instr(Position_DEBUT, Buffer_CCP, CHR(13) & CHR(10))
							TailleRetourCHR = 2

							' Si ca existe, on capture les 13 10
							IF Position_FIN > 0 Then
								Position_FIN = Position_FIN + 2
							Else
								' Autrmement on cherche 13
								if Position_FIN = 0 Then Position_FIN = Instr(Position_DEBUT, Buffer_CCP, CHR(13)) : TailleRetourCHR = 1

								' Autrmement on cherche 10
								if Position_FIN = 0 Then Position_FIN = Instr(Position_DEBUT, Buffer_CCP, CHR(10)) : TailleRetourCHR = 1

								' Si rien n'a ete trouve, alors on est a la fin du fichier
								if Position_FIN = 0 Then Position_FIN = LEN(Buffer_CCP)

							End if

							' On capture du debut de la ligne jusqu'a la fin
							Buffer_lecture = LTRIM(LTRIM(MID(Buffer_CCP, Position_DEBUT, Position_FIN-Position_DEBUT)), chr(09))

							' On se place apres les retour chariot
							Position_DEBUT = Position_FIN ' + TailleRetourCHR - 1

							IF ModeAnalyse = 1 then

								If LEN(Buffer_CCP)-Position_FIN > 0 then
									Buffer_LABEL = ""
									IF TailleRetourCHR > 0 Then
										Empl_1 = 0
										Numero_de_Ligne = Numero_de_Ligne + 1
									End if

									If NOT Empl_1 > 0 Then
										Empl_1 = Instr(Buffer_lecture, ":")
									End if

									Dim Empl_2 as integer = InstrREV(Buffer_lecture, ":")

									IF Empl_1 < Empl_2 Then
										Buffer_LABEL = Ucase(Mid(Buffer_lecture, Empl_1+1, (Empl_2) - (Empl_1+1)))

										IF NOT Instr(UCASE(Buffer_LABEL), " ") > 0 Then
											IF NOT Instr(UCASE(Buffer_LABEL), "/") > 0 Then
												IF NOT Instr(UCASE(Buffer_LABEL), "\") > 0 Then
													IF Len(Buffer_LABEL) <= 64 Then ' Taille max des noms de labels
														IF Len(Buffer_LABEL) > 1 Then
															Index_Label = Index_Label + 1


															if Index_Label < CPCDOS_INSTANCE.SHELLCCP_INSTANCE.MEMOIRE_CCP._MAX_LABEL Then
																NoLigneLabel(Index_Label) = Numero_de_Ligne
																EmplacementLabel(Index_Label) = Position_FIN
																NomLabel_Emplace(Index_Label) = Buffer_LABEL
																IF CPCDOS_INSTANCE.SYSTEME_INSTANCE.get_DBG_DEBUG() > 0 Then
																	IF CPCDOS_INSTANCE.Utilisateur_Langage = 0 Then
																		DEBUG(" #Optimisation " & Index_Label & "/" & Taille_Du_Fichier & " pointage [0x" & Hex(EmplacementLabel(Index_Label), 8) & "]:" & EmplacementLabel(Index_Label), Affichage, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_VALIDATION, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.SansDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_CPCDOS, RetourVAR)
																	Else
																		DEBUG(" #Optimising " & Index_Label & "/" & Taille_Du_Fichier & " pointing [0x" & Hex(EmplacementLabel(Index_Label), 8) & "]:" & EmplacementLabel(Index_Label), Affichage, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_VALIDATION, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.AvecDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_CPCDOS, RetourVAR)
																	End If
																End if
															Else
																IF CPCDOS_INSTANCE.SYSTEME_INSTANCE.get_DBG_DEBUG() > 0 Then
																	IF CPCDOS_INSTANCE.Utilisateur_Langage = 0 Then
																		DEBUG("Taille memoire par indexage maximale atteinte (" & index_label & "). Impossible d'optimiser plus", Affichage, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_AVERTISSEMENT, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.SansDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_CPCDOS, RetourVAR)
																	Else
																		DEBUG("Maximum indexing size limit (" & index_label & "). Can't optimize more", Affichage, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_AVERTISSEMENT, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.SansDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_CPCDOS, RetourVAR)
																	End If
																End if
															End if
															Buffer_LABEL = ""
															Empl_1 = 0
															Empl_2 = 0
														End if
													else
														Empl_1 = 0
													End if
												else
													Empl_1 = 0
												End if
											else
												Empl_1 = 0
											End if
										else
											Empl_1 = 0
										End if
									Else
										' S'il ya rien a optimiser, on quitte l'opti! <--- Correction 12/04/2020 (boucle infinie) - Jordan
										' ModeAnalyse = 2
										' Position_FIN = 0
										' Position_DEBUT = 1
										' Buffer_lecture = ""
										' TestALLER = 0
										' Numero_de_Ligne = 0
										' Empl_1 = 0
										' FinDuFichier = 0
										' Numero_de_Ligne = 0
										' IF CPCDOS_INSTANCE.SYSTEME_INSTANCE.get_DBG_DEBUG() > 0 Then
											' if Index_Label > 0 Then
												' IF CPCDOS_INSTANCE.Utilisateur_Langage = 0 Then
													' DEBUG("[CpcdosC+] Fin de l'analyse. Optimisation gagne " & int(((Index_Label/Taille_Du_Fichier)*100)*(Taille_Du_Fichier/6)) & "%", Affichage, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_Normal, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.AvecDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_CPCDOS, RetourVAR)
												' Else
													' DEBUG("[CpcdosC+] End of analysis. Optimising gained " & int(((Index_Label/Taille_Du_Fichier)*100)*(Taille_Du_Fichier/6)) & "%", Affichage, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_Normal, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.AvecDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_CPCDOS, RetourVAR)
												' End If
											' Else
												' IF CPCDOS_INSTANCE.Utilisateur_Langage = 0 Then
													' DEBUG("[CpcdosC+] Fin de l'analyse. Aucune optimisations.", Affichage, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_Normal, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.AvecDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_CPCDOS, RetourVAR)
												' Else
													' DEBUG("[CpcdosC+] End of analysis. No optimizations.", Affichage, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_Normal, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.AvecDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_CPCDOS, RetourVAR)
												' End If
											' End if
										' End if
									End if
								Else
									ModeAnalyse = 2
									Position_FIN = 0
									Position_DEBUT = 1
									Buffer_lecture = ""
									TestALLER = 0
									Numero_de_Ligne = 0
									Empl_1 = 0
									FinDuFichier = 0
									Numero_de_Ligne = 0
									IF CPCDOS_INSTANCE.SYSTEME_INSTANCE.get_DBG_DEBUG() > 0 Then
										if Index_Label > 0 Then
											IF CPCDOS_INSTANCE.Utilisateur_Langage = 0 Then
												DEBUG("[CpcdosC+] Fin de l'analyse. Optimisation gagne " & int(((Index_Label/Taille_Du_Fichier)*100)*(Taille_Du_Fichier/6)) & "%", Affichage, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_Normal, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.AvecDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_CPCDOS, RetourVAR)
											Else
												DEBUG("[CpcdosC+] End of analysis. Optimising gained " & int(((Index_Label/Taille_Du_Fichier)*100)*(Taille_Du_Fichier/6)) & "%", Affichage, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_Normal, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.AvecDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_CPCDOS, RetourVAR)
											End If
										Else
											IF CPCDOS_INSTANCE.Utilisateur_Langage = 0 Then
												DEBUG("[CpcdosC+] Fin de l'analyse. Aucune optimisations.", Affichage, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_Normal, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.AvecDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_CPCDOS, RetourVAR)
											Else
												DEBUG("[CpcdosC+] End of analysis. No optimizations.", Affichage, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_Normal, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.AvecDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_CPCDOS, RetourVAR)
											End If
										End if
									End if
								End if

								' Goto NoLGNSaut
								Continue while
							End if


							IF NumeroDeLigneAChercher > 0 Then
								IF Numero_de_Ligne > NumeroDeLigneAChercher Then
									' On a atteint le nombre de lignes demande
									NumeroDeLigneAChercher = 0
								Else
									' On saute on execute pas
									Numero_de_Ligne = Numero_de_Ligne + 1

									' Goto NoLGNSaut
									Continue while
								End if
							End if

							IF LEN(LabelAChercher) > 0 then ' On recherche un label
								IF ModeAnalyse = 2 then ' Avec le mode optimisation
									IF Deja_Affiche = false then
										Deja_Affiche = true
										IF CPCDOS_INSTANCE.SYSTEME_INSTANCE.get_DBG_DEBUG() > 0 Then
											IF CPCDOS_INSTANCE.Utilisateur_Langage = 0 Then
												DEBUG(" #Recherche en mode optimise", Affichage, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_AVERTISSEMENT, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.AvecDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_CPCDOS, RetourVAR)
											Else
												DEBUG(" #Search in optimised mode", Affichage, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_AVERTISSEMENT, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.AvecDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_CPCDOS, RetourVAR)
											End If
										End if
									End if
									For BoucleChercherLabelNom as integer = 1 to CPCDOS_INSTANCE.SHELLCCP_INSTANCE.MEMOIRE_CCP._MAX_LABEL ' MEMOIRE_CCP.CpcdosCP_Variable_MAXI

										IF (":" & NomLabel_Emplace(BoucleChercherLabelNom) & ":") = (":" & LabelAChercher & ":") Then
											Numero_de_Ligne = NoLigneLabel(BoucleChercherLabelNom)
											Position_FIN = EmplacementLabel(BoucleChercherLabelNom)
											Position_DEBUT = Position_FIN
											LabelAChercher = ""
											exit for
										End if
									Next BoucleChercherLabelNom
								else ' Sans le mode optimisation
									IF Deja_Affiche = false then
										Deja_Affiche = true
										IF CPCDOS_INSTANCE.SYSTEME_INSTANCE.get_DBG_DEBUG() > 0 Then
											IF CPCDOS_INSTANCE.Utilisateur_Langage = 0 Then
												DEBUG(" #Recherche en mode standard --> :" & LabelAChercher & ":", Affichage, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_AVERTISSEMENT, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.AvecDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_CPCDOS, RetourVAR)
											Else
												DEBUG(" #Search in standard mode --> :" & LabelAChercher & ":", Affichage, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_AVERTISSEMENT, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.AvecDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_CPCDOS, RetourVAR)
											End If
										End if
									End if
									Numero_de_Ligne = Numero_de_Ligne + 1
									IF Instr(UCASE(Buffer_lecture), ":" & LabelAChercher & ":") > 0 Then ' si ils correspondent
										LabelAChercher = ""
									End if ' Hop on reboucle!
								end if
							Else ' Si aucun label a chercher

								Numero_de_Ligne = Numero_de_Ligne + 1
								IF FinDuFichier = 0 Then
									' Suppression du CRLF si on n'est pas a la fin du fichier
									IF TailleRetourCHR = 2 Then
										Buffer_lecture = MID(Buffer_lecture, 1, LEN(Buffer_lecture) - 2)
									ElseIf TailleRetourCHR = 1 Then
										Buffer_lecture = MID(Buffer_lecture, 1, LEN(Buffer_lecture) - 1)
									End if
								End if

								' OPTIMISATION : Si la commande est "REM/" ou // ou ' on quitte la fonction
								Scope
									Dim Test_REM as Integer = Instr(Ucase(Buffer_lecture), "REM/")
									Dim Test_CMD as Integer = 0

									' Si elle est presente, on verifie sa syntaxe
									If Test_REM > 0 Then
										IF NOT CCP_Verifier_Syntaxe(Buffer_lecture, Test_REM) > 10 Then Buffer_lecture = ""
									End if

									' Si la ligne commence par // ou par ' alors c'est un commentaire
									IF INSTR(Buffer_lecture, "// ") = 1 OR INSTR(Buffer_lecture, "//" & CHR(09)) = 1 OR INSTR(Buffer_lecture, "///") = 1 OR INSTR(Buffer_lecture, "' ") = 1 OR INSTR(Buffer_lecture, "''") = 1 Then Buffer_lecture = ""
								End Scope

								IF LEN(Buffer_lecture) > 0 then

									Passage = Passage + 1

									' Si la section critique est active, on n'execute PAS le yielding
									IF this.SECTION_CRITIQUE = FALSE THEN
										' Si le CPU est en galere
										' if Passage > 8 Then
											' Pourcent_CPU = CPCDOS_INSTANCE.SYSTEME_INSTANCE.get_cpu_pourcent()
											' if Pourcent_CPU > 80 Then
												' doevents(1000) ' On libere 1ms

											' elseif Pourcent_CPU >= 100 Then ' On libere 100ms
												' doevents(100000)
											' End if
										' End if

										if this.Cpcdos_Optimisation = 2 then
											IF Passage > 42 then doevents(0) : Passage = 0
										else
											IF Passage > 24 then doevents(0) : Passage = 0
										End if

									End if

	_scope_SAUT_COMMANDE

									' On verifie si on doit executer une fonction dans le fichier
									IF Si_Non_EXE_FONCT = 1 Then
										IF NOT CCP_Fonction_EXEC = "" Then
											' On recherche dans la table des fonctions publiques
											'  ( les fameuses fonction externes! )
											Dim Boucle_table as integer
											' On verifie deja si on est pas deja dans le fichier qui contient
											'  sinon ca boucle et ca crash .. lol
											' IF NOT Ucase(this.MEMOIRE_CCP.TAB_FONCTION_CCP_SRC(Boucle_table)) = Ucase(Nom_Fichier) Then

												For Boucle_table = 1 to this.MEMOIRE_CCP._MAX_FONCTION_PUBLIC
													' Si le nom de la fonction existe
													IF this.MEMOIRE_CCP.TAB_FONCTION_CCP_NOM(Boucle_table) = CCP_Fonction_EXEC THEN
														IF this.MEMOIRE_CCP.TAB_FONCTION_CCP_NIV(Boucle_table) >= NIVEAU_CCP Then ' Le niveau est correct
															Dim Retour_Fonction_ as string
															' Verifier s'il sagit d'une fonction du noyau

															IF Instr(Ucase(this.MEMOIRE_CCP.TAB_FONCTION_CCP_NOM(Boucle_table)), "CPC.") > 0 Then
																' C'est une fonction declare qui appartient au noyau
																IF Arguments_CCP_FONCT_exec = "" Then


																	' Si il n'y a pas d'arguments, on cherche si c'est pas une fonction VAR
																	Retour_Fonction_ = Recherche_Fonction_Var(this.MEMOIRE_CCP.TAB_FONCTION_CCP_NOM(Boucle_table), Nouvelle_Cle)
																	' Verifier ce qu'il retourne
																	IF CPCDOS_INSTANCE.Utilisateur_Langage = 0 Then
																		IF Retour_Fonction_ = " #Fonction Cpcdos non disponible#" Then
																			' Ce n'est pas une fonction interne
																			' Chercher dans les fonctions du noyau Cpcdos
																			Retour_Fonction_ = Recherche_Fonction_CPCDOS(this.MEMOIRE_CCP.TAB_FONCTION_CCP_NOM(Boucle_table), Arguments_CCP_FONCT_exec, 0, NIVEAU_CCP, Auth_Kernel, Auth_OS, Auth_Utilisateur, Auth_PID, Nouvelle_TID, RetourVAR)
																			CpcdosCP_SHELL = "FONCTION-RETOUR:" & Retour_Fonction_
																			Si_Non_EXE_FONCT = 0
																			' Goto _FIN_EXE_CCP_EXE
																			exit while
																		End if
																	Else
																		IF Retour_Fonction_ = " #Cpcdos function not avaiable#" Then
																			' Ce n'est pas une fonction interne
																			' Chercher dans les fonctions du noyau Cpcdos
																			Retour_Fonction_ = Recherche_Fonction_CPCDOS(this.MEMOIRE_CCP.TAB_FONCTION_CCP_NOM(Boucle_table), Arguments_CCP_FONCT_exec, 0, NIVEAU_CCP, Auth_Kernel, Auth_OS, Auth_Utilisateur, Auth_PID, Nouvelle_TID, RetourVAR)
																			CpcdosCP_SHELL = "FONCTION-RETOUR:" & Retour_Fonction_
																			Si_Non_EXE_FONCT = 0
																			' Goto _FIN_EXE_CCP_EXE
																			exit while
																		End if
																	End if
																Else
																	' Chercher dans les fonctions du noyau Cpcdos
																	Retour_Fonction_ = Recherche_Fonction_CPCDOS(this.MEMOIRE_CCP.TAB_FONCTION_CCP_NOM(Boucle_table), Arguments_CCP_FONCT_exec, 0, NIVEAU_CCP, Auth_Kernel, Auth_OS, Auth_Utilisateur, Auth_PID, Auth_TID, RetourVAR)
																	' Retour_Fonction_ = Recherche_Fonction_CPCDOS(this.MEMOIRE_CCP.TAB_FONCTION_CCP_NOM(Boucle_table), Arguments_CCP_FONCT_exec, 0, NIVEAU_CCP, Auth_Kernel, Auth_OS, Auth_Utilisateur, Auth_PID, Nouvelle_TID, RetourVAR)
																	CpcdosCP_SHELL = "FONCTION-RETOUR:" & Retour_Fonction_
																	Si_Non_EXE_FONCT = 0
																	' Goto _FIN_EXE_CCP_EXE
																	exit while

																End if
															Else
																' Dim Nouvelle_Cle as double = CPCDOS_INSTANCE.Generer_cle(Auth_Kernel, Auth_OS, Auth_Utilisateur, Auth_PID, Auth_PID + CPCDOS_INSTANCE.Generer_RND(100, 999))

																' IF NOT this.MEMOIRE_CCP.TAB_FONCTION_CCP_SRC(Boucle_table) = Nom_Fichier then
																IF NOT PosFonctExec > 0 AND NOT Nom_Fichier = "KRNL\NULL.CPC" Then
																	' Si le /FN: a ete utilise pas la pene de recommencer!
																	' Autrement ca boucle a l'infinit jusqu'a crash s'en suive..
																	' C'est une fonction ecrit dans un fichier externe

																	CpcdosCP_SHELL = CpcdosCP_SHELL("EXE/ " & this.MEMOIRE_CCP.TAB_FONCTION_CCP_SRC(Boucle_table) & " /FN:" & this.MEMOIRE_CCP.TAB_FONCTION_CCP_NOM(Boucle_table) & "(" & Arguments_CCP_FONCT_exec & ")->" & _CLE_, _CLE_, NIVEAU_CCP, Param_1, Param_2)
																else
																	IF Nom_Fichier = "KRNL\NULL.CPC" then
																		CpcdosCP_SHELL = CpcdosCP_SHELL("EXE/ " & this.MEMOIRE_CCP.TAB_FONCTION_CCP_SRC(Boucle_table) & " /FN:" & this.MEMOIRE_CCP.TAB_FONCTION_CCP_NOM(Boucle_table) & "(" & Arguments_CCP_FONCT_exec & ")->" & _CLE_, _CLE_, NIVEAU_CCP, Param_1, Param_2)
																		Si_Non_EXE_FONCT = 0

																		' Goto _FIN_EXE_CCP_EXE
																		exit while
																	End if
																	' Goto Saut_Fincp
																	exit for
																End if
															End if
															Si_Non_EXE_FONCT = 0
															' Goto _FIN_EXE_CCP_EXE
															exit while
														End if
													End if
												Next Boucle_table
											' End if
' Saut_Fincp:

											' On verifie si on tombe bien sur la ligne de la syntaxe ou se situe la fonction
											Dim POSCommFONCTION_FR as integer = Instr(Ucase(Buffer_lecture), this.Liste_CMD_FR(23) & " ") ' FONCTION/
											Dim POSCommFONCTION_EN as integer = Instr(Ucase(Buffer_lecture), this.Liste_CMD_EN(23) & " ") ' FUNCTION/

											IF POSCommFONCTION_FR > 0 OR POSCommFONCTION_EN > 0 Then
												IF Instr(Ucase(Buffer_lecture), CCP_Fonction_EXEC) > 0 Then
													Dim NomFonctExec as String
													Dim testCMD	as integer
													IF POSCommFONCTION_FR > 0 Then
														testCMD = CCP_Verifier_Syntaxe(Buffer_lecture, POSCommFONCTION_FR - 1)
														NomFonctExec = UCASE(MID(Buffer_lecture, POSCommFONCTION_FR + LEN(this.Liste_CMD_FR(23)) + 1)) ' MODIF 22-02-2017 : Suppr POSCommFONCTION_FR + 4))
													ElseIF POSCommFONCTION_EN > 0 Then
														testCMD = CCP_Verifier_Syntaxe(Buffer_lecture, POSCommFONCTION_EN - 1)
														NomFonctExec = UCASE(MID(Buffer_lecture, POSCommFONCTION_EN + LEN(this.Liste_CMD_EN(23)) - 1)) ' MODIF 22-02-2017 : Suppr POSCommFONCTION_EN + 4))
													End if


													' Si la commande est bonne
													IF testCMD < 10 Then
														' On verifie si le nombre d'arguments concordent

														Dim Position_1erParenthese 	as integer = Instr(NomFonctExec, "(")
														Dim Position_2emParenthese	as integer = InstrREV(NomFonctExec, ")")
														Dim Arguments 				as string = Mid(NomFonctExec, Position_1erParenthese + 1, Position_2emParenthese - (Position_1erParenthese + 1))

														' Declarer les attributs qui vont permettre la recherche
														Dim Pos_Virgule_DEBUT 	as integer = 0
														Dim Pos_Virgule_FIN 	as integer = 0
														Dim Nombre_Arguments	as integer = 0

														' Recuperer les arguments pour les placer dans un tableau
														' IF Position_1erParenthese = Position_2emParenthese then

														IF Position_1erParenthese = Position_2emParenthese - 1 then
															' S'il s'agit d'une fonction sans arguments
															IF CPCDOS_INSTANCE.SYSTEME_INSTANCE.get_DBG_DEBUG() > 0 Then
																IF CPCDOS_INSTANCE.Utilisateur_Langage = 0 Then
																	DEBUG("[CpcdosC+] : Fonction sans arguments.",  Affichage, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_SURBRILLE, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.SansDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_CPCDOS, RetourVAR)
																Else
																	DEBUG("[CpcdosC+] : Function without arguments.",  Affichage, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_SURBRILLE, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.SansDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_CPCDOS, RetourVAR)
																End if
															End if
														else

															IF CPCDOS_INSTANCE.SYSTEME_INSTANCE.get_DBG_DEBUG() > 0 Then
																IF CPCDOS_INSTANCE.Utilisateur_Langage = 0 Then
																	DEBUG("[CpcdosC+] : Fonction avec argument(s).",  Affichage, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_SURBRILLE, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.SansDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_CPCDOS, RetourVAR)
																Else
																	DEBUG("[CpcdosC+] : Function with argument(s).",  Affichage, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_SURBRILLE, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.SansDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_CPCDOS, RetourVAR)
																End if
															End if

															' Une fonction avec 1 ou plusieurs arguments
															For Boucle_ARGS as integer = 1 to this.MEMOIRE_CCP._MAX_FONCTION_ARGS
																' Recuperer les positions
																Pos_Virgule_DEBUT = Pos_Virgule_FIN + 1
																Pos_Virgule_FIN = Instr(Pos_Virgule_DEBUT, Arguments, ",")

																' Verifier la presence d'une vigule
																IF Pos_Virgule_FIN > 0 Then
																	'  Virgule presente!
																	CCP_Fonction_ARGS_2(Boucle_ARGS) = LTrim(MID(Arguments, Pos_Virgule_DEBUT, (Pos_Virgule_FIN) - Pos_Virgule_DEBUT))
																else
																	' Hop on recupere le dernier argument avant la parenthese
																	CCP_Fonction_ARGS_2(Boucle_ARGS) = LTrim(MID(Arguments, Pos_Virgule_DEBUT, (Position_2emParenthese) - Pos_Virgule_DEBUT))

																	' Ah .. C'est finis mon gros ;)
																	Nombre_Arguments = Boucle_ARGS
																	exit for
																End if
															Next Boucle_ARGS
														End if

														IF CCP_Fonction_ARGS_N = Nombre_Arguments then
															' Le nom de fonction + le nombre d'arguments concordent, DONC
															'  on active la lecture et on relit la prochaine ligne

															Si_Non_EXE_FONCT = 0
															si_EXE_FIXE_VARIABLES = 1
															si_EXE_FONCTION_NIV_1 = 1
															' Le moteur ccp devrai croiser FIN/ FONCTION et arreter la lecture
															exit _scope_SAUT_COMMANDE ' Goto Saut_Commande
														End if
													End if ' testCMD < 10
												End if ' Instr(Ucase(Buffer_lecture), CCP_Fonction_EXEC) > 0
											End if ' POSCommFONCTION_FR > 0 OR POSCommFONCTION_EN > 0
										End IF
									End IF

									' ========== FONCTION ==========
									IF SI_CEST_FONCTION = 1 then
										Dim FonctionPresentFR as integer
										Dim FonctionPresentEN as integer
										Dim FinPresentFR as integer
										Dim FinPresentEN as integer
										Dim RetourPresentFR as integer
										Dim RetourPresentEN as integer
										' Attendre qu'on croise un FIN/ FONCTION

										FonctionPresentFR = Instr(UCASE(Buffer_lecture), " FONCTION")

										' Verifier si c'est pas plutot un " FONCTION/" au lieu d'un " FONCTION" en EN
										if FonctionPresentFR > 0 Then
											IF INSTR(UCASE(Buffer_lecture), " FONCTION/") = FonctionPresentFR Then
												FonctionPresentFR = 0 ' Ne pas continuer
											End if
										End if

										FonctionPresentEN = Instr(UCASE(Buffer_lecture), " FUNCTION")

										' Verifier si c'est pas plutot un " FUNCTION/" au lieu d'un " FUNCTION" en EN
										if FonctionPresentEN > 0 Then
											IF INSTR(UCASE(Buffer_lecture), " FUNCTION/") = FonctionPresentEN Then
												FonctionPresentEN = 0 ' Ne pas continuer
											End if
										End if

										IF FonctionPresentFR + FonctionPresentEN > 0 Then
											FinPresentFR = Instr(UCASE(Buffer_lecture), "FIN/ ")
											FinPresentEN = Instr(UCASE(Buffer_lecture), "END/ ")
											IF FinPresentFR + FinPresentEN > 0 Then

												' si on le croise, verifier sa syntaxe
												IF FinPresentFR > 0 Then
													FinPresentFR = CCP_Verifier_Syntaxe(Buffer_lecture, FinPresentFR - 1)
													IF FinPresentEN < 6 then
														' Si sa syntaxe est bonne on execute a nouveau
														SI_CEST_FONCTION = 0
														exit _scope_SAUT_COMMANDE ' Goto Saut_Commande
													end if
												ELSEIF FinPresentEN > 0 Then
													FinPresentEN = CCP_Verifier_Syntaxe(Buffer_lecture, FinPresentEN - 1)
													IF FinPresentEN < 6 then
														' Si sa syntaxe est bonne on execute a nouveau
														SI_CEST_FONCTION = 0
														exit _scope_SAUT_COMMANDE ' Goto Saut_Commande
													end if
												End if
											end if
										End if
									End if
									' ========== CONDITION ==========

									' Verifier si on est dans un SI
									If PILE_SI_NB > 0 Then
										Dim SinonPresent as integer
										Dim SiPresent as integer

										IF PILE_SI(PILE_SI_NB) = 3 Then ' niveau attente fin
											IF Execute_SI = 0 Then
												SiPresent = Instr(UCASE(Buffer_lecture), "SI/ ")
												if NOT SiPresent > 0 then SiPresent = Instr(UCASE(Buffer_lecture), "IF/ ")
												IF SiPresent > 0 Then
													SiPresent = CCP_Verifier_Syntaxe(Buffer_lecture, SiPresent - 1)
													IF SiPresent < 6 Then
														SiPresent = Instr(UCASE(Buffer_lecture), "ALORS:")
														if NOT SiPresent > 0 then SiPresent = Instr(UCASE(Buffer_lecture), "THEN:")
														IF SiPresent > 0 Then ' il y a bien un SI/ avec ALORS:
															IF Len(MID(Buffer_lecture, SiPresent + 5)) < 3 Then
																NB_Si_Non_Exe = NB_Si_Non_Exe + 1
																exit _scope_SAUT_COMMANDE ' Goto Saut_Commande
															End if
														End if
													End if
												End if
											End if
										ElseIF PILE_SI(PILE_SI_NB) = 1 Then ' niveau positif
											' Verifier si on croise un SINON:
											SinonPresent = Instr(UCASE(Buffer_lecture), "SINON:")
											if NOT SinonPresent > 0 then SinonPresent = Instr(UCASE(Buffer_lecture), "ELSE:")
											IF SinonPresent > 0 Then
												' Et que la syntaxe est correcte
												SinonPresent = CCP_Verifier_Syntaxe(Buffer_lecture, SinonPresent - 1)
												IF SinonPresent < 6 THEN
													' Si oui, on execute plus rien jusqu'a FIN/ SI
													Execute_SI = 0
													PILE_SI(PILE_SI_NB) = 3 ' En attente de fin
													exit _scope_SAUT_COMMANDE ' Goto Saut_Commande
												End if
											End if
										ElseIF PILE_SI(PILE_SI_NB) = 2 Then ' niveau negatif
											IF Execute_SI = 0 Then
												SiPresent = Instr(UCASE(Buffer_lecture), "SI/ ")
												if NOT SiPresent > 0 then SiPresent = Instr(UCASE(Buffer_lecture), "IF/ ")
												IF SiPresent > 0 Then
													SiPresent = CCP_Verifier_Syntaxe(Buffer_lecture, SiPresent - 1)
													IF SiPresent < 6 Then
														SiPresent = Instr(UCASE(Buffer_lecture), "ALORS:")
														if NOT SiPresent > 0 then SiPresent = Instr(UCASE(Buffer_lecture), "THEN:")
														IF SiPresent > 0 Then ' il y a bien un SI/ avec ALORS:
															IF Len(MID(Buffer_lecture, SiPresent + 5)) < 3 Then
																NB_Si_Non_Exe = NB_Si_Non_Exe + 1
																exit _scope_SAUT_COMMANDE ' Goto Saut_Commande
															End if
														End if
													End if
												End if
											End if
											IF NB_Si_Non_Exe < 1 Then
												SinonPresent = Instr(UCASE(Buffer_lecture), "SINON:")
												if NOT SinonPresent > 0 then SinonPresent = Instr(UCASE(Buffer_lecture), "ELSE:")
												IF SinonPresent > 0 Then
												' Et que la syntaxe est correcte
													SinonPresent = CCP_Verifier_Syntaxe(Buffer_lecture, SinonPresent - 1)
													IF SinonPresent < 6 THEN
														IF PILE_SI(PILE_SI_NB) = 1 Then
															Execute_SI = 0
															exit _scope_SAUT_COMMANDE ' Goto Saut_Commande
														else
															Execute_SI = 1
															exit _scope_SAUT_COMMANDE ' Goto Saut_Commande
														End if
													End if
												End if
											End if
										End if
									End if
									IF PILE_SI(PILE_SI_NB) > 0 Then
										IF Execute_SI = 0 Then
											Dim ExecCMDEXE as Boolean = FALSE
											Dim SinonPresent as integer
											' Attendre qu'on croise un FIN/ SI
											SinonPresent = Instr(UCASE(Buffer_lecture), " SI")
											if NOT SinonPresent > 0 then SinonPresent = Instr(UCASE(Buffer_lecture), " IF")
											IF SinonPresent > 0 Then

												SinonPresent = Instr(UCASE(Buffer_lecture), "FIN/ ")
												if NOT SinonPresent > 0 then SinonPresent = Instr(UCASE(Buffer_lecture), "END/ ")
												IF SinonPresent > 0 Then
													' si on le croise, verifier sa syntaxe
													SinonPresent = CCP_Verifier_Syntaxe(Buffer_lecture, SinonPresent - 1)
													IF SinonPresent < 6 then
														IF NB_Si_Non_Exe > 0 then
															NB_Si_Non_Exe = NB_Si_Non_Exe - 1
															exit _scope_SAUT_COMMANDE ' Goto Saut_Commande
														End if
														' Si sa syntaxe est bonne on decend d'un niveau
														ExecCMDEXE = TRUE ' Goto ExecCMDEXE
													end if
												end if
											End if
											IF ExecCMDEXE = False Then exit _scope_SAUT_COMMANDE ' Goto Saut_Commande
										End if
									End if
' ExecCMDEXE:
									IF NB_Si_Non_Exe > 0 OR Si_Non_EXE_FONCT = 1 Then exit _scope_SAUT_COMMANDE ' Goto Saut_Commande
									' ===============================


									Temp_exe = Niveau_2

									IF si_EXE_FONCTION_NIV_1 = 1 then
										si_EXE_FONCTION_NIV_1 = 0
										Niveau_2 = 1
									End if



									' Si on lit une fonction de maniere externe
									IF SI_CEST_FONCTION = 1 then exit _scope_SAUT_COMMANDE ' Goto Saut_Commande
									IF CPCDOS_INSTANCE.SYSTEME_INSTANCE.get_DBG_DEBUG() > 0 Then
										IF CPCDOS_INSTANCE.Utilisateur_Langage = 0 Then
											DEBUG(" Lecture : " & Buffer_lecture, Affichage, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_Normal, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.AvecDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_CPCDOS, RetourVAR)
										Else
											DEBUG(" Reading : " & Buffer_lecture, Affichage, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_Normal, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.AvecDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_CPCDOS, RetourVAR)
										End If
									End if



									IF si_EXE_FIXE_VARIABLES = 1 then
										si_EXE_FIXE_VARIABLES = 0
										For Boucle_FIXER as integer = 1 to this.MEMOIRE_CCP._MAX_FONCTION_ARGS
											IF NOT CCP_Fonction_ARGS_2(Boucle_FIXER) = "" THEN
												CpcdosCP_SHELL("FIX/ " & CCP_Fonction_ARGS_2(Boucle_FIXER) & " = " & CCP_Fonction_DATA(Boucle_FIXER), Nouvelle_Cle, Niveau_2, Param_1, Param_2)
											End if
										Next Boucle_FIXER
									End if

									' Si la commande contient un appel de fonction, on va executer
									'  cette fonction dans une nouvelle instance de CpcdosCP_SHELL() bloquante
									IF Instr(Ucase(Buffer_lecture), "/F:") > 0 Then
										' Pour executer une fonction en local qui se situe dans le meme 'Nom_Fichier'
										Dim Deja_Trouve as integer = 0
										Dim Fonction_a_test as string = Mid(Buffer_lecture, instr(Ucase(Buffer_lecture), "/F:") + 3)
										Fonction_a_test = Mid(Fonction_a_test, 1, Instr(Fonction_a_test, "(") -1)

										For Boucle_Cherche as integer = 1 to this.MEMOIRE_CCP._MAX_FONCTION_PUBLIC
											IF Instr(this.MEMOIRE_CCP.TAB_FONCTION_CCP_NOM(Boucle_Cherche), Ucase(Fonction_a_test)) > 0 AND INSTR(Buffer_lecture, ")") > INSTR(Buffer_lecture, "(") Then
												Buffer_lecture = "##FONCTION=:" & this.MEMOIRE_CCP.TAB_FONCTION_CCP_SRC(Boucle_Cherche) & ":=##" & Ltrim(Ltrim(Buffer_lecture, CHR(09)))
												Deja_Trouve = 1
												Exit for
											End if
										next Boucle_Cherche
										IF Deja_Trouve = 0 then
											Buffer_lecture = "##FONCTION=:" & Nom_Fichier & ":=##" & Ltrim(Ltrim(Buffer_lecture, CHR(09)))
										End if
									End if

									if NOT len(Buffer_lecture) < 2 then
										Dim CleAUtiliser as Double

										if Modification_IUG = true Then
											Dim TestTemp as String = Ucase(Buffer_lecture)
											IF CCP_Verifier_Syntaxe(TestTemp, Instr(TestTemp, "CREER/")) > 10 Then
												CleAUtiliser = Nouvelle_Cle_GUI
											ElseIF CCP_Verifier_Syntaxe(TestTemp, Instr(TestTemp, "CREATE/")) > 10 Then
												CleAUtiliser = Nouvelle_Cle_GUI
											Else
												CleAUtiliser = Nouvelle_Cle
											End if
										Else
											CleAUtiliser = Nouvelle_Cle
										End if

										RetourCCP = CpcdosCP_SHELL(Buffer_lecture, CleAUtiliser, Niveau_2, Param_1, Param_2)
									End if

									IF CPCDOS_INSTANCE.SYSTEME_INSTANCE.get_DBG_DEBUG() > 0 Then
										IF CPCDOS_INSTANCE.Utilisateur_Langage = 0 Then
											DEBUG(" Retour : " & RetourCCP, Affichage, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_Normal, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.AvecDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_CPCDOS, RetourVAR)
										Else
											DEBUG(" Return : " & RetourCCP, Affichage, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_Normal, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.AvecDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_CPCDOS, RetourVAR)
										End If
									End if

									Niveau_2 = Temp_exe

									If Instr(RetourCCP, "FIX_NIVEAU") > 0 Then
										IF RetourCCP = "FIX_NIVEAU1" Then
											Niveau_2 = 1
										ELSEIF RetourCCP = "FIX_NIVEAU2" Then
											Niveau_2 = 2
										ELSEIF RetourCCP = "FIX_NIVEAU3" Then
											Niveau_2 = 3
										ELSEIF RetourCCP = "FIX_NIVEAU4" Then
											Niveau_2 = 4
										ELSEIF RetourCCP = "FIX_NIVEAU5" Then
											Niveau_2 = 5
										END IF
									END IF


									if RetourCCP = "ERR_050" Then CpcdosCP_SHELL = RetourCCP


									if RetourCCP = "#DISCRETION:0" Then
										if CCP_discretion = true then
											CPCDOS_INSTANCE.En_Charge(true)
											CCP_discretion = false
										end if
									elseif RetourCCP = "#DISCRETION:1" Then
										if CCP_discretion = false then
											CPCDOS_INSTANCE.En_Charge(false)
											CCP_discretion = true
										End if
									End if

									IF Instr(RetourCCP, "SWITCH:OS_ID=") > 0 Then
										Dim tmpNomOS 		as String = Ltrim(Rtrim(Mid(RetourCCP, Instr(RetourCCP, "SWITCH:OS_ID=") + 13)))
										Dim NumeroOS_tmp 	as integer = CPCDOS_INSTANCE.test_OSPresent(tmpNomOS)
										Dim Ancien_OS 		as String = CPCDOS_INSTANCE.get_OSPresent(NumeroOS)

										if Ancien_OS = "" then Ancien_OS = "<null>"

										IF NumeroOS_tmp > -1 Then

											IF CPCDOS_INSTANCE.Utilisateur_Langage = 0 Then
												DEBUG("[SHELL] Switch de '" & Ancien_OS & "' (OSID:" & NumeroOS & ") a '" & tmpNomOS & "' (OSID:" & NumeroOS_tmp & ")", CPCDOS_INSTANCE.DEBUG_INSTANCE.Ecran, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_Action, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.SansDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_AFF, RetourCCP)
											Else
												DEBUG("[SHELL] Switching from " & Ancien_OS & " (OSID:" & NumeroOS & ") OSID:" & NumeroOS & " to '" & tmpNomOS & "' (OSID:" & NumeroOS_tmp & ")", CPCDOS_INSTANCE.DEBUG_INSTANCE.Ecran, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_Action, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.SansDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_AFF, RetourCCP)
											End if

											NumeroOS = NumeroOS_tmp
											Nouvelle_Cle = CPCDOS_INSTANCE.Generer_cle(CPCDOS_INSTANCE.get_id_kernel(), NumeroOS, CPCDOS_INSTANCE.get_id_Utilisateur(), Auth_PID, 0)

											' Et definit le OS id sans le SCI
											CPCDOS_INSTANCE.SCI_INSTANCE.set_OSid(NumeroOS)

											IF CPCDOS_INSTANCE.Utilisateur_Langage = 0 Then
												DEBUG("[SHELL] Nouvelle CleID:" & _CLE_ & " [0x" & hex(_CLE_, 8) & "]", CPCDOS_INSTANCE.DEBUG_INSTANCE.Ecran, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_Validation, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.SansDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_AFF, RetourCCP)
											Else
												DEBUG("[SHELL] New KeyID:" & _CLE_ & " [0x" & hex(_CLE_, 8) & "]", CPCDOS_INSTANCE.DEBUG_INSTANCE.Ecran, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_Validation, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.SansDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_AFF, RetourCCP)
											End if
										Else
											IF CPCDOS_INSTANCE.Utilisateur_Langage = 0 Then
												DEBUG("[CpcdosC+] Systeme d'exploitation '" & tmpNomOS & "' non present.", CPCDOS_INSTANCE.DEBUG_INSTANCE.Ecran, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_ERREUR, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.SansDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_AFF, RetourCCP)
											Else
												DEBUG("[CpcdosC+] Operating system '" & tmpNomOS & "' not found.", CPCDOS_INSTANCE.DEBUG_INSTANCE.Ecran, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_ERREUR, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.SansDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_AFF, RetourCCP)
											End if
										ENd if
									End if


									' Ceci stoppe la lecture du code
									IF RetourCCP = "ERR_010" Then ' Erreur syntaxe
										_COMMANDE_ = Buffer_lecture
										testCMD = 42 ' 32
										EXIT while
									End if

									IF RetourCCP = "ERR_009" Then ' Label introuvable
										EXIT while
									End if


									' On arrive a la fin de la section de la fonction
									IF RetourCCP = "FONCTION:FIN" Then
										IF CPCDOS_INSTANCE.SYSTEME_INSTANCE.get_DBG_DEBUG() > 0 Then
											IF CPCDOS_INSTANCE.Utilisateur_Langage = 0 Then
												DEBUG("[CpcdosC+] Fin de fonction", Affichage, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_Normal, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.AvecDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_CPCDOS, RetourVAR)
											Else
												DEBUG("[CpcdosC+] End function", Affichage, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_Normal, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.AvecDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_CPCDOS, RetourVAR)
											End if
										END IF
										EXIT while
									End if

									' Renvoyer le contenu de la fonction qui envoit un retour
									IF Instr(RetourCCP, "FONCTION-RETOUR:") > 0 Then
										IF CPCDOS_INSTANCE.SYSTEME_INSTANCE.get_DBG_DEBUG() > 0 Then
											IF CPCDOS_INSTANCE.Utilisateur_Langage = 0 Then
												DEBUG("[CpcdosC+] Retour de fonction", Affichage, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_Normal, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.AvecDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_CPCDOS, RetourVAR)
											Else
												DEBUG("[CpcdosC+] Return in function", Affichage, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_Normal, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.AvecDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_CPCDOS, RetourVAR)
											End if
										END IF
										CpcdosCP_SHELL = RetourCCP
										EXIT while
									End if

									' Arreter l'execution du code CC+
									IF RetourCCP = "STOP:FIN" Then
										IF CPCDOS_INSTANCE.SYSTEME_INSTANCE.get_DBG_DEBUG() > 0 Then
											IF CPCDOS_INSTANCE.Utilisateur_Langage = 0 Then
												DEBUG("[CpcdosC+] Fin de l'execution du fichier CpcdosC+.", Affichage, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_Normal, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.AvecDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_CPCDOS, RetourVAR)
											Else
												DEBUG("[CpcdosC+] Ending CpcdosC+ file execution.", Affichage, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_Normal, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.AvecDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_CPCDOS, RetourVAR)
											End if
										END IF
										EXIT while
									End if

									IF RetourCCP = "&NONRETOUR" THEN EXIT while
									IF INSTR(RetourCCP, "FONCTION:") > 0 Then SI_CEST_FONCTION = 1
									TestALLER = Instr(UCASE(RetourCCP), "ALLER/ ")

	_end_scope_SAUT_COMMANDE

' Saut_Commande:
									If TestALLER > 0 Then
										LabelAChercher = RTRIM(RTRIM(RTRIM(RTRIM(LTRIM(LTRIM(UCASE(MID(RetourCCP, TestALLER + 7))), chr(09)), chr(09)), chr(13)), chr(10)))
										TestALLER = 0
										Position_FIN = 1
										FinDuFichier = 0
										Numero_de_Ligne = 0
									ELSE
										IF FinDuFichier = 1 Then FinDuFichier = 0 : Exit while
									END IF
									If Instr(RetourCCP, "SI:") > 0 Then
										IF RetourCCP = "SI:ALORS" Then
											' On monte d'un niveau positif
											PILE_SI_NB = PILE_SI_NB + 1
											PILE_SI(PILE_SI_NB) = 1
											Execute_SI = 1
										ElseIF RetourCCP = "SI:SINON" Then
											' On monte d'un niveau negatif
											PILE_SI_NB = PILE_SI_NB + 1
											PILE_SI(PILE_SI_NB) = 2
											Execute_SI = 0
										ElseIF RetourCCP = "SI:FIN" Then
											' On decend d'un niveau
											PILE_SI(PILE_SI_NB) = 0
											PILE_SI_NB = PILE_SI_NB - 1
											if NB_Si_Non_Exe > 0 then
												Execute_SI = 0
											else
												IF PILE_SI(PILE_SI_NB) = 2 then Execute_SI = 1
												IF PILE_SI(PILE_SI_NB) = 1 then Execute_SI = 1
											End if
										End if
										RetourCCP = ""
									End if

									IF Instr(RetourCCP, "IUG:") > 0 Then
										' **** Declarations d'objets graphiques ****

										' ICI placer le mode d'edition des objets ! :)

										' Si on est en mode edition ou non
										IF Instr(RetourCCP, "~MODIF#") > 0 Then
											Modification_IUG = true

											IF Instr(ucase(RetourCCP), "/TID") > 0 Then
												Modification_IUG_TID = val(MID(RetourCCP, 1 + 4, Instr(RetourCCP, "~MODIF#") - 1))
											End if

											RetourCCP = MID(RetourCCP, 1, Instr(RetourCCP, "~MODIF#") - 1)

										End if

										' Dans la meme fenetre, il n'est pas possible d'avoir les memes noms d'objets
										'  mais possible dans plusieurs fenetres

										IF Instr(RetourCCP, ":FENETRE_NOM=") > 0 Then
											IUG_CREATION_FENETRE = MID(RetourCCP, Instr(RetourCCP, ":FENETRE_NOM=") + 13)

											IF Modification_IUG = True Then
												For _INDEX_FENETRE_ = 0 to CPCDOS_INSTANCE._MAX_GUI_FENETRE

													IF IUG_CREATION_FENETRE = CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__FENETRE(_INDEX_FENETRE_).Identification_Objet.NOM Then


														' Verifier si la cle d'identification KERNEL, OS, USER, et PID est identique
														IF CPCDOS_INSTANCE.get_id_kernel(_CLE_) 		= CPCDOS_INSTANCE.get_id_kernel(CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__FENETRE(_INDEX_FENETRE_).Identification_Objet._CLE_) AND _
															CPCDOS_INSTANCE.get_id_OS(_CLE_) 			= CPCDOS_INSTANCE.get_id_OS(CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__FENETRE(_INDEX_FENETRE_).Identification_Objet._CLE_) AND _
															CPCDOS_INSTANCE.get_id_Utilisateur(_CLE_) 	= CPCDOS_INSTANCE.get_id_Utilisateur(CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__FENETRE(_INDEX_FENETRE_).Identification_Objet._CLE_) AND _
															CPCDOS_INSTANCE.get_id_PID(_CLE_) 			= CPCDOS_INSTANCE.get_id_PID(CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__FENETRE(_INDEX_FENETRE_).Identification_Objet._CLE_) Then


															Dim ADD_NUM_R as String
															Dim ADD_NUM_V as String
															Dim ADD_NUM_B as String

															IF CPCDOS_INSTANCE.SYSTEME_INSTANCE.get_DBG_DEBUG() > 0 Then
																IF CPCDOS_INSTANCE.Utilisateur_Langage = 0 Then
																	DEBUG("[CpcdosC+] GUI --> Mode edition de la fenetre '" & IUG_CREATION_FENETRE & "' UID:" & CPCDOS_INSTANCE.get_id_Utilisateur(_CLE_) & " PID:" & CPCDOS_INSTANCE.get_id_PID(_CLE_) & " TID:" & CPCDOS_INSTANCE.get_id_TID(_CLE_), Affichage, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_ACTION, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.AvecDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_CPCDOS, RetourVAR)
																Else
																	DEBUG("[CpcdosC+] GUI --> Window edition mode for '" & IUG_CREATION_FENETRE & "' UID:" & CPCDOS_INSTANCE.get_id_Utilisateur(_CLE_) & " PID:" & CPCDOS_INSTANCE.get_id_PID(_CLE_) & " TID:" & CPCDOS_INSTANCE.get_id_TID(_CLE_), Affichage, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_ACTION, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.AvecDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_CPCDOS, RetourVAR)
																End If
															End if

															IF CPCDOS_INSTANCE.SYSTEME_INSTANCE.get_DBG_DEBUG() > 0 Then
																IF CPCDOS_INSTANCE.Utilisateur_Langage = 0 Then
																	DEBUG("[CpcdosC+] Recuperation des proprietes grahpiques en memoire...", Affichage, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_ACTION, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.AvecDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_CPCDOS, RetourVAR)
																Else
																	DEBUG("[CpcdosC+] Recovery graphical properties in memory...", Affichage, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_ACTION, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.AvecDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_CPCDOS, RetourVAR)
																End If
															End if


															GUI__DEJA_INITIALISE	= TRUE

															' Proprietes d'identification du Processus hebergeur
															GUI__PROC_PARENT	 	= CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__FENETRE(_INDEX_FENETRE_).Identification_Objet.Proc_PARENT
															GUI__PID_PARENT			= CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__FENETRE(_INDEX_FENETRE_).Identification_Objet.PID_PARENT

															' Proprietes d'identification du Thread executif
															GUI__THREAD_PARENT	 	= CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__FENETRE(_INDEX_FENETRE_).Identification_Objet.THREAD_PARENT
															GUI__TID_PARENT			= CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__FENETRE(_INDEX_FENETRE_).Identification_Objet.TID_PARENT

															' Proprietes d'identification d'Objet graphique hebergeur
															GUI__Fenetre_PARENT 	= CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__FENETRE(_INDEX_FENETRE_).Identification_Objet.Fenetre_PARENT
															GUI__Index_FNT_PARENT 	= CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__FENETRE(_INDEX_FENETRE_).Identification_Objet.Index_FNT_PARENT
															GUI__Handle_PARENT 		= CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__FENETRE(_INDEX_FENETRE_).Identification_Objet.Handle_PARENT

															' Proprietes d'identification de l'Objet concerne
															GUI__Nom				= CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__FENETRE(_INDEX_FENETRE_).Identification_Objet.Nom
															CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__FENETRE(_INDEX_FENETRE_).Identification_Objet.Index_ENFANT = _INDEX_FENETRE_
															GUI__Index_ENFANT		= _INDEX_FENETRE_
															GUI__Handle				= CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__FENETRE(_INDEX_FENETRE_).Identification_Objet.handle




															' Proprietes uniques de l'objet concerne
															Nouvelle_Cle_GUI 		= CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__FENETRE(_INDEX_FENETRE_).Identification_Objet._CLE_

															Nouvelle_OS_ID 			= CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__FENETRE(_INDEX_FENETRE_).Identification_Objet.OS_id

															GUI__DEJA_INITIALISE	= TRUE


															IUG_CREATION_FENETRE 	= CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__FENETRE(_INDEX_FENETRE_).Identification_Objet.Nom

															GUI__PROP_TITRE 		= CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__FENETRE(_INDEX_FENETRE_).TITRE
															GUI__PROP_TITRE_PX 		= CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__FENETRE(_INDEX_FENETRE_).POS_TITRE_X
															GUI__PROP_TITRE_PY 		= CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__FENETRE(_INDEX_FENETRE_).POS_TITRE_Y

															GUI__PROP_TITRE_IMG_ID				= CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__FENETRE(_INDEX_FENETRE_).TITRE_IMG_ID
															GUI__PROP_BUFFER_TITRE_IMG_ID		= CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__FENETRE(_INDEX_FENETRE_).BUFFER_TITRE_IMG_ID
															GUI__PROP_BUFFER_TITRE_2_IMG_ID		= CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__FENETRE(_INDEX_FENETRE_).BUFFER_TITRE_2_IMG_ID
															GUI__PROP_BUFFER_WIN_IMG_ID			= CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__FENETRE(_INDEX_FENETRE_).BUFFER_WIN_IMG_ID
															GUI__PROP_BUFFER_OMBRE_WIN_IMG_ID	= CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__FENETRE(_INDEX_FENETRE_).BUFFER_OMBRE_WIN_IMG_ID



															GUI__PROP_PX 			= CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__FENETRE(_INDEX_FENETRE_).POS_X
															GUI__PROP_PY 			= CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__FENETRE(_INDEX_FENETRE_).POS_Y

															GUI__PROP_TX 			= CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__FENETRE(_INDEX_FENETRE_).SIZ_X
															GUI__PROP_TY 			= CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__FENETRE(_INDEX_FENETRE_).SIZ_Y

															GUI__PROP_TYPE 			= CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__FENETRE(_INDEX_FENETRE_).PROP_TYPE.LES_TYPES

															GUI__PROP_CONTENEUR_COMPLET = CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__FENETRE(_INDEX_FENETRE_).CONTENEUR_COMPLET

															GUI__PROP_ALPHA_MODE	= CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__FENETRE(_INDEX_FENETRE_).Alpha_Mode

															GUI__PROP_IMGTITRE 		= CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__FENETRE(_INDEX_FENETRE_).IMG_TITRE

															' Icone application
															GUI__PROP_ICONE 				= CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__FENETRE(_INDEX_FENETRE_).ICONE

															GUI__PROP_ICONE_IMG_ID 			= CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__FENETRE(_INDEX_FENETRE_).ICONE_IMG_ID
															GUI__PROP_ICONE_ORG_IMG_ID 		= CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__FENETRE(_INDEX_FENETRE_).ICONE_ORG_IMG_ID

															GUI__PROP_ICONE_PX 				= CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__FENETRE(_INDEX_FENETRE_).POS_ICONE_X
															GUI__PROP_ICONE_PY 				= CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__FENETRE(_INDEX_FENETRE_).POS_ICONE_Y
															GUI__PROP_ICONE_POS				= CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__FENETRE(_INDEX_FENETRE_).POS_ICONE_POS
															GUI__PROP_ICONE_TX 				= CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__FENETRE(_INDEX_FENETRE_).SIZ_ICONE_X
															GUI__PROP_ICONE_TY 				= CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__FENETRE(_INDEX_FENETRE_).SIZ_ICONE_Y
															GUI__PROP_ICONE_T 				= CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__FENETRE(_INDEX_FENETRE_).SIZ_ICONE


															' Icone bouton fermeture
															GUI__PROP_BT_CLOSE 				= CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__FENETRE(_INDEX_FENETRE_).BT_CLOSE

															GUI__PROP_BT_CLOSE_IMG_ID 		= CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__FENETRE(_INDEX_FENETRE_).BT_CLOSE_IMG_ID
															GUI__PROP_BT_CLOSE_ORG_IMG_ID	= CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__FENETRE(_INDEX_FENETRE_).BT_CLOSE_ORG_IMG_ID

															GUI__PROP_BT_CLOSE_PX 	= CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__FENETRE(_INDEX_FENETRE_).POS_BT_CLOSE_X
															GUI__PROP_BT_CLOSE_PY 	= CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__FENETRE(_INDEX_FENETRE_).POS_BT_CLOSE_Y
															GUI__PROP_BT_CLOSE_POS 	= CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__FENETRE(_INDEX_FENETRE_).POS_BT_CLOSE_POS
															GUI__PROP_BT_CLOSE_TX 	= CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__FENETRE(_INDEX_FENETRE_).SIZ_BT_CLOSE_X
															GUI__PROP_BT_CLOSE_TY 	= CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__FENETRE(_INDEX_FENETRE_).SIZ_BT_CLOSE_Y
															GUI__PROP_BT_CLOSE_T 	= CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__FENETRE(_INDEX_FENETRE_).SIZ_BT_CLOSE


															' Icone bouton agrandissement
															GUI__PROP_BT_SIZEUP 		= CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__FENETRE(_INDEX_FENETRE_).BT_SIZEUP
															GUI__PROP_BT_SIZEUP_PX 	= CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__FENETRE(_INDEX_FENETRE_).POS_BT_SIZEUP_X
															GUI__PROP_BT_SIZEUP_PY 	= CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__FENETRE(_INDEX_FENETRE_).POS_BT_SIZEUP_Y
															GUI__PROP_BT_SIZEUP_TX 	= CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__FENETRE(_INDEX_FENETRE_).SIZ_BT_SIZEUP_X
															GUI__PROP_BT_SIZEUP_TY 	= CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__FENETRE(_INDEX_FENETRE_).SIZ_BT_SIZEUP_Y
															GUI__PROP_BT_SIZEUP_T 	= CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__FENETRE(_INDEX_FENETRE_).SIZ_BT_SIZEUP

															' Icone retrecissement
															GUI__PROP_BT_SIZEDOWN 	= CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__FENETRE(_INDEX_FENETRE_).BT_SIZEDOWN
															GUI__PROP_BT_SIZEDOWN_PX 	= CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__FENETRE(_INDEX_FENETRE_).POS_BT_SIZEDOWN_X
															GUI__PROP_BT_SIZEDOWN_PY 	= CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__FENETRE(_INDEX_FENETRE_).POS_BT_SIZEDOWN_Y
															GUI__PROP_BT_SIZEDOWN_TX 	= CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__FENETRE(_INDEX_FENETRE_).SIZ_BT_SIZEDOWN_X
															GUI__PROP_BT_SIZEDOWN_TY 	= CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__FENETRE(_INDEX_FENETRE_).SIZ_BT_SIZEDOWN_Y
															GUI__PROP_BT_SIZEDOWN_T 	= CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__FENETRE(_INDEX_FENETRE_).SIZ_BT_SIZEDOWN

															' Icone reduction
															GUI__PROP_BT_REDUCT 		= CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__FENETRE(_INDEX_FENETRE_).BT_REDUCT
															GUI__PROP_BT_REDUCT_PX 	= CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__FENETRE(_INDEX_FENETRE_).POS_BT_REDUCT_X
															GUI__PROP_BT_REDUCT_PY 	= CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__FENETRE(_INDEX_FENETRE_).POS_BT_REDUCT_Y
															GUI__PROP_BT_REDUCT_TX 	= CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__FENETRE(_INDEX_FENETRE_).SIZ_BT_REDUCT_X
															GUI__PROP_BT_REDUCT_TY 	= CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__FENETRE(_INDEX_FENETRE_).SIZ_BT_REDUCT_Y
															GUI__PROP_BT_REDUCT_T 	= CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__FENETRE(_INDEX_FENETRE_).SIZ_BT_REDUCT


															GUI__PROP_TTITRE 		= CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__FENETRE(_INDEX_FENETRE_).SIZ_TITRE


															' Couleur de la fenetre en general  ===> GUI__PROP_COULEURFENETRE
															IF CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__FENETRE(_INDEX_FENETRE_).PROP_TYPE.Couleur_R < 1 Then
																ADD_NUM_R = "000"
															ElseIF CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__FENETRE(_INDEX_FENETRE_).PROP_TYPE.Couleur_R < 10 Then
																ADD_NUM_R = "00"
															ElseIF CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__FENETRE(_INDEX_FENETRE_).PROP_TYPE.Couleur_R < 100 Then
																ADD_NUM_R = "0"
															End if

															IF CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__FENETRE(_INDEX_FENETRE_).PROP_TYPE.Couleur_V < 1 Then
																ADD_NUM_V = "000"
															ElseIF CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__FENETRE(_INDEX_FENETRE_).PROP_TYPE.Couleur_V < 10 Then
																ADD_NUM_V = "00"
															ElseIF CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__FENETRE(_INDEX_FENETRE_).PROP_TYPE.Couleur_V < 100 Then
																ADD_NUM_V = "0"
															End if

															IF CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__FENETRE(_INDEX_FENETRE_).PROP_TYPE.Couleur_B < 1 Then
																ADD_NUM_B = "000"
															ElseIF CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__FENETRE(_INDEX_FENETRE_).PROP_TYPE.Couleur_B < 10 Then
																ADD_NUM_B = "00"
															ElseIF CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__FENETRE(_INDEX_FENETRE_).PROP_TYPE.Couleur_B < 100 Then
																ADD_NUM_B = "0"
															End if
															GUI__PROP_COULEURFENETRE = ADD_NUM_R & CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__FENETRE(_INDEX_FENETRE_).PROP_TYPE.Couleur_R & "," _
																						& ADD_NUM_V & CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__FENETRE(_INDEX_FENETRE_).PROP_TYPE.Couleur_V & ","_
																						& ADD_NUM_B & CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__FENETRE(_INDEX_FENETRE_).PROP_TYPE.Couleur_B

															ADD_NUM_R = "" : ADD_NUM_V = "" : ADD_NUM_B = ""

															' Couleur du conteneur  ===> GUI__PROP_COULEURFOND
															IF CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__FENETRE(_INDEX_FENETRE_).PROP_TYPE.Couleur_CTN_R < 1 Then
																ADD_NUM_R = "000"
															ElseIF CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__FENETRE(_INDEX_FENETRE_).PROP_TYPE.Couleur_CTN_R < 10 Then
																ADD_NUM_R = "00"
															ElseIF CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__FENETRE(_INDEX_FENETRE_).PROP_TYPE.Couleur_CTN_R < 100 Then
																ADD_NUM_R = "0"
															End if

															IF CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__FENETRE(_INDEX_FENETRE_).PROP_TYPE.Couleur_CTN_V < 1 Then
																ADD_NUM_V = "000"
															ElseIF CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__FENETRE(_INDEX_FENETRE_).PROP_TYPE.Couleur_CTN_V < 10 Then
																ADD_NUM_V = "00"
															ElseIF CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__FENETRE(_INDEX_FENETRE_).PROP_TYPE.Couleur_CTN_V < 100 Then
																ADD_NUM_V = "0"
															End if

															IF CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__FENETRE(_INDEX_FENETRE_).PROP_TYPE.Couleur_CTN_B < 1 Then
																ADD_NUM_B = "000"
															ElseIF CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__FENETRE(_INDEX_FENETRE_).PROP_TYPE.Couleur_CTN_B < 10 Then
																ADD_NUM_B = "00"
															ElseIF CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__FENETRE(_INDEX_FENETRE_).PROP_TYPE.Couleur_CTN_B < 100 Then
																ADD_NUM_B = "0"
															End if
															GUI__PROP_COULEURFOND = ADD_NUM_R & CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__FENETRE(_INDEX_FENETRE_).PROP_TYPE.Couleur_CTN_R & "," _
																						& ADD_NUM_V & CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__FENETRE(_INDEX_FENETRE_).PROP_TYPE.Couleur_CTN_V & ","_
																						& ADD_NUM_B & CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__FENETRE(_INDEX_FENETRE_).PROP_TYPE.Couleur_CTN_B

															ADD_NUM_R = "" : ADD_NUM_V = "" : ADD_NUM_B = ""

															' Couleur du titre de la fenetre  ===> GUI__PROP_COULEURTITRE
															IF CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__FENETRE(_INDEX_FENETRE_).PROP_TYPE.Couleur_TITRE_R < 1 Then
																ADD_NUM_R = "000"
															ElseIF CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__FENETRE(_INDEX_FENETRE_).PROP_TYPE.Couleur_TITRE_R < 10 Then
																ADD_NUM_R = "00"
															ElseIF CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__FENETRE(_INDEX_FENETRE_).PROP_TYPE.Couleur_TITRE_R < 100 Then
																ADD_NUM_R = "0"
															End if

															IF CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__FENETRE(_INDEX_FENETRE_).PROP_TYPE.Couleur_TITRE_V < 1 Then
																ADD_NUM_V = "000"
															ElseIF CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__FENETRE(_INDEX_FENETRE_).PROP_TYPE.Couleur_TITRE_V < 10 Then
																ADD_NUM_V = "00"
															ElseIF CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__FENETRE(_INDEX_FENETRE_).PROP_TYPE.Couleur_TITRE_V < 100 Then
																ADD_NUM_V = "0"
															End if

															IF CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__FENETRE(_INDEX_FENETRE_).PROP_TYPE.Couleur_TITRE_B < 1 Then
																ADD_NUM_B = "000"
															ElseIF CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__FENETRE(_INDEX_FENETRE_).PROP_TYPE.Couleur_TITRE_B < 10 Then
																ADD_NUM_B = "00"
															ElseIF CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__FENETRE(_INDEX_FENETRE_).PROP_TYPE.Couleur_TITRE_B < 100 Then
																ADD_NUM_B = "0"
															End if
															GUI__PROP_COULEURTITRE = ADD_NUM_R & CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__FENETRE(_INDEX_FENETRE_).PROP_TYPE.Couleur_TITRE_R & "," _
																						& ADD_NUM_V & CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__FENETRE(_INDEX_FENETRE_).PROP_TYPE.Couleur_TITRE_V & ","_
																						& ADD_NUM_B & CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__FENETRE(_INDEX_FENETRE_).PROP_TYPE.Couleur_TITRE_B

															ADD_NUM_R = "" : ADD_NUM_V = "" : ADD_NUM_B = ""

															' Couleur de l'ombre sous la fenetre  ===> GUI__PROP_TYPE_Ombre_RVB
															IF CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__FENETRE(_INDEX_FENETRE_).PROP_TYPE.Couleur_OMBRE_R < 1 Then
																ADD_NUM_R = "000"
															ElseIF CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__FENETRE(_INDEX_FENETRE_).PROP_TYPE.Couleur_OMBRE_R < 10 Then
																ADD_NUM_R = "00"
															ElseIF CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__FENETRE(_INDEX_FENETRE_).PROP_TYPE.Couleur_OMBRE_R < 100 Then
																ADD_NUM_R = "0"
															End if

															IF CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__FENETRE(_INDEX_FENETRE_).PROP_TYPE.Couleur_OMBRE_V < 1 Then
																ADD_NUM_V = "000"
															ElseIF CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__FENETRE(_INDEX_FENETRE_).PROP_TYPE.Couleur_OMBRE_V < 10 Then
																ADD_NUM_V = "00"
															ElseIF CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__FENETRE(_INDEX_FENETRE_).PROP_TYPE.Couleur_OMBRE_V < 100 Then
																ADD_NUM_V = "0"
															End if

															IF CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__FENETRE(_INDEX_FENETRE_).PROP_TYPE.Couleur_OMBRE_B < 1 Then
																ADD_NUM_B = "000"
															ElseIF CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__FENETRE(_INDEX_FENETRE_).PROP_TYPE.Couleur_OMBRE_B < 10 Then
																ADD_NUM_B = "00"
															ElseIF CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__FENETRE(_INDEX_FENETRE_).PROP_TYPE.Couleur_OMBRE_B < 100 Then
																ADD_NUM_B = "0"
															End if
															GUI__PROP_TYPE_Ombre_RVB = ADD_NUM_R & CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__FENETRE(_INDEX_FENETRE_).PROP_TYPE.Couleur_OMBRE_R & "," _
																						& ADD_NUM_V & CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__FENETRE(_INDEX_FENETRE_).PROP_TYPE.Couleur_OMBRE_V & ","_
																						& ADD_NUM_B & CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__FENETRE(_INDEX_FENETRE_).PROP_TYPE.Couleur_OMBRE_B

															ADD_NUM_R = "" : ADD_NUM_V = "" : ADD_NUM_B = ""

															GUI__PROP_OMBRE_PX 		= CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__FENETRE(_INDEX_FENETRE_).PROP_TYPE.Ombre_PX
															GUI__PROP_OMBRE_PY 		= CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__FENETRE(_INDEX_FENETRE_).PROP_TYPE.Ombre_PY

															' Type
															GUI__PROP_TYPE_OBJ 		= CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__FENETRE(_INDEX_FENETRE_).PROP_TYPE.TYPE_OBJ

															' Bordure
															GUI__PROP_TYPE_BORDURE 	= CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__FENETRE(_INDEX_FENETRE_).PROP_TYPE.Bordure

															' Deplacable
															GUI__PROP_DEPLACABLE 	= CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__FENETRE(_INDEX_FENETRE_).PROP_TYPE.Deplacable

															GUI__PROP_REDUCTABLE	= CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__FENETRE(_INDEX_FENETRE_).PROP_TYPE.Reductable
															GUI__PROP_SIZEABLE		= CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__FENETRE(_INDEX_FENETRE_).PROP_TYPE.Sizeable
															GUI__PROP_SIZEABLE_ANGL	= CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__FENETRE(_INDEX_FENETRE_).PROP_TYPE.Sizeable_ANGL
															GUI__PROP_FERMABLE		= CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__FENETRE(_INDEX_FENETRE_).PROP_TYPE.Fermable

															' Ombre sous la fenetre
															GUI__PROP_TYPE_Ombre	= CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__FENETRE(_INDEX_FENETRE_).PROP_TYPE.Ombre

															' Transparence generale  ===> GUI__PROP_COULEURALPHA
															GUI__PROP_COULEURALPHA 	= str(CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__FENETRE(_INDEX_FENETRE_).PROP_TYPE.Alpha)

															' Fichier de fonction source pour les evenement des objets
															GUI__PROP_EVENEMENT 	= CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__FENETRE(_INDEX_FENETRE_).PROP_TYPE.Fichier_evenement
															GUI__PROP_EVENEMENT_DISPO = Ucase(CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__FENETRE(_INDEX_FENETRE_).PROP_TYPE.Liste_Evenements)
															Exit for
														End if
													End if
												Next _INDEX_FENETRE_

											End if
										ElseIF Instr(RetourCCP, ":BOUTON_NOM=") > 0 Then
											IUG_CREATION_BOUTON = MID(RetourCCP, Instr(RetourCCP, ":BOUTON_NOM=") + 12)


											IF Modification_IUG = True Then
												For _INDEX_BOUTON_ = 0 to CPCDOS_INSTANCE._MAX_GUI_BOUTON

													IF IUG_CREATION_BOUTON = CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__BOUTON(_INDEX_BOUTON_).Identification_Objet.Nom Then
														' Verifier si la cle d'identification KERNEL, OS, USER, et PID est identique
														IF CPCDOS_INSTANCE.get_id_kernel(_CLE_) 		= CPCDOS_INSTANCE.get_id_kernel(CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__BOUTON(_INDEX_BOUTON_).Identification_Objet._CLE_) AND _
															CPCDOS_INSTANCE.get_id_OS(_CLE_) 			= CPCDOS_INSTANCE.get_id_OS(CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__BOUTON(_INDEX_BOUTON_).Identification_Objet._CLE_) AND _
															CPCDOS_INSTANCE.get_id_Utilisateur(_CLE_) 	= CPCDOS_INSTANCE.get_id_Utilisateur(CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__BOUTON(_INDEX_BOUTON_).Identification_Objet._CLE_) AND _
															CPCDOS_INSTANCE.get_id_PID(_CLE_) 			= CPCDOS_INSTANCE.get_id_PID(CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__BOUTON(_INDEX_BOUTON_).Identification_Objet._CLE_) Then



															Dim ADD_NUM_R as String
															Dim ADD_NUM_V as String
															Dim ADD_NUM_B as String

															IF CPCDOS_INSTANCE.SYSTEME_INSTANCE.get_DBG_DEBUG() > 0 Then
																IF CPCDOS_INSTANCE.Utilisateur_Langage = 0 Then
																	DEBUG("[CpcdosC+] GUI --> Mode edition du bouton '" & IUG_CREATION_BOUTON & "' UID:" & CPCDOS_INSTANCE.get_id_Utilisateur(_CLE_) & " PID:" & CPCDOS_INSTANCE.get_id_PID(_CLE_) & " TID:" & CPCDOS_INSTANCE.get_id_TID(_CLE_), Affichage, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_ACTION, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.AvecDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_CPCDOS, RetourVAR)
																Else
																	DEBUG("[CpcdosC+] GUI --> Button edition mode for '" & IUG_CREATION_BOUTON & "' UID:" & CPCDOS_INSTANCE.get_id_Utilisateur(_CLE_) & " PID:" & CPCDOS_INSTANCE.get_id_PID(_CLE_) & " TID:" & CPCDOS_INSTANCE.get_id_TID(_CLE_), Affichage, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_ACTION, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.AvecDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_CPCDOS, RetourVAR)
																End If
															End if

															IF CPCDOS_INSTANCE.SYSTEME_INSTANCE.get_DBG_DEBUG() > 0 Then
																IF CPCDOS_INSTANCE.Utilisateur_Langage = 0 Then
																	DEBUG("[CpcdosC+] Recuperation des proprietes grahpiques en memoire...", Affichage, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_ACTION, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.AvecDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_CPCDOS, RetourVAR)
																Else
																	DEBUG("[CpcdosC+] Recovery graphical properties in memory...", Affichage, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_ACTION, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.AvecDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_CPCDOS, RetourVAR)
																End If
															End if

															' Couleur du picturebox ===> GUI__PROP_COULEURFOND
															CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.TEMP_GUI__BOUTON.PROP_TYPE.Couleur_CTN_R = val(Mid(GUI__PROP_COULEURFOND, 1, 3))
															CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.TEMP_GUI__BOUTON.PROP_TYPE.Couleur_CTN_V = val(Mid(GUI__PROP_COULEURFOND, 5, 3))
															CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.TEMP_GUI__BOUTON.PROP_TYPE.Couleur_CTN_B = val(Mid(GUI__PROP_COULEURFOND, 9, 3))

															' Couleur de la police d'ecriture ===> GUI__PROP_COULEURTEXTE
															CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.TEMP_GUI__BOUTON.PROP_TYPE.Couleur_FNT_R = val(Mid(GUI__PROP_COULEURTEXTE, 1, 3))
															CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.TEMP_GUI__BOUTON.PROP_TYPE.Couleur_FNT_V = val(Mid(GUI__PROP_COULEURTEXTE, 5, 3))
															CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.TEMP_GUI__BOUTON.PROP_TYPE.Couleur_FNT_B = val(Mid(GUI__PROP_COULEURTEXTE, 9, 3))

															' Transparence generale  ===> GUI_PROP_COULEURALPHA
															CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.TEMP_GUI__BOUTON.PROP_TYPE.Alpha = val(GUI__PROP_COULEURALPHA)

															' Bordure
															if GUI__PROP_TYPE_BORDURE >= 1 then GUI__PROP_TYPE_BORDURE = 1 else GUI__PROP_TYPE_BORDURE = 0

															CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.TEMP_GUI__BOUTON.PROP_TYPE.Bordure = GUI__PROP_TYPE_BORDURE

															' Evenement
															CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.TEMP_GUI__BOUTON.PROP_TYPE.Fichier_evenement = GUI__PROP_EVENEMENT
															CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.TEMP_GUI__BOUTON.PROP_TYPE.Liste_Evenements = GUI__PROP_EVENEMENT_DISPO

															GUI__DEJA_INITIALISE	= TRUE

															' Proprietes d'identification du Processus hebergeur
															GUI__PROC_PARENT	 	= CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__BOUTON(_INDEX_BOUTON_).Identification_Objet.Proc_PARENT
															GUI__PID_PARENT			= CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__BOUTON(_INDEX_BOUTON_).Identification_Objet.PID_PARENT

															' Proprietes d'identification du Thread executif
															GUI__THREAD_PARENT	 	= CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__BOUTON(_INDEX_BOUTON_).Identification_Objet.THREAD_PARENT
															GUI__TID_PARENT			= CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__BOUTON(_INDEX_BOUTON_).Identification_Objet.TID_PARENT

															' Proprietes d'identification d'Objet graphique hebergeur
															GUI__Fenetre_PARENT 	= CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__BOUTON(_INDEX_BOUTON_).Identification_Objet.Fenetre_PARENT
															GUI__Index_FNT_PARENT 	= CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__BOUTON(_INDEX_BOUTON_).Identification_Objet.Index_FNT_PARENT
															GUI__Handle_PARENT 		= CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__BOUTON(_INDEX_BOUTON_).Identification_Objet.Handle_PARENT

															' Proprietes d'identification de l'Objet concerne
															GUI__Nom				= CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__BOUTON(_INDEX_BOUTON_).Identification_Objet.Nom
															CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__BOUTON(_INDEX_BOUTON_).Identification_Objet.Index_ENFANT = _INDEX_BOUTON_
															GUI__Index_ENFANT		= _INDEX_BOUTON_
															GUI__Handle				= CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__BOUTON(_INDEX_BOUTON_).Identification_Objet.handle

															IUG_CREATION_BOUTON 	= GUI__Nom

															Nouvelle_Cle_GUI 		= CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__BOUTON(_INDEX_BOUTON_).Identification_Objet._CLE_

															Nouvelle_OS_ID 			= CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__BOUTON(_INDEX_BOUTON_).Identification_Objet.OS_id

															' Proprietes uniques de l'objet concerne
															GUI__PROP_UPDATER 		= CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__BOUTON(_INDEX_BOUTON_).IUG_UPDATER
															GUI__THREAD_OK	 		= CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__BOUTON(_INDEX_BOUTON_).THREAD_OK

															GUI__PROP_PX 			= CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__BOUTON(_INDEX_BOUTON_).POS_X
															GUI__PROP_PY 			= CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__BOUTON(_INDEX_BOUTON_).POS_Y

															GUI__PROP_TX 			= CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__BOUTON(_INDEX_BOUTON_).SIZ_X
															GUI__PROP_TY 			= CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__BOUTON(_INDEX_BOUTON_).SIZ_Y

															GUI__PROP_IMAGE 		= CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__BOUTON(_INDEX_BOUTON_).IMAGE
															GUI__PROP_IMAGE_ANCIEN 	= CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__BOUTON(_INDEX_BOUTON_).IMAGE_ANCIEN

															GUI__PROP_IMAGE_ID		= CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__BOUTON(_INDEX_BOUTON_).IMG_ID
															GUI__PROP_IMAGE_ORG_ID	= CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__BOUTON(_INDEX_BOUTON_).IMG_ORG_ID
															GUI__PROP_IMAGE_SURVOLE_ID		= CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__BOUTON(_INDEX_BOUTON_).IMG_SURVOLE_ID
															GUI__PROP_IMAGE_SURVOLE_ORG_ID	= CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__BOUTON(_INDEX_BOUTON_).IMG_SURVOLE_ORG_ID

															' GUI__PROP_IMAGEPTR 		= CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__BOUTON(_INDEX_BOUTON_).IMG_PTR
															' GUI__PROP_IMAGEPTR_ORG	= CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__BOUTON(_INDEX_BOUTON_).IMG_PTR_ORG
															' GUI__PROP_IMAGEPTR_ANCIEN	= CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__BOUTON(_INDEX_BOUTON_).IMG_PTR_ANCIEN

															GUI__PROP_BIT_ORG		= CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__BOUTON(_INDEX_BOUTON_).BIT_ORG

															GUI__PROP_TEXTE			= CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__BOUTON(_INDEX_BOUTON_).TEXTE


															GUI__PROP_TYPE 			= CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__BOUTON(_INDEX_BOUTON_).PROP_TYPE.LES_TYPES

															GUI__PROP_AUTOSIZE 		= CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__BOUTON(_INDEX_BOUTON_).PROP_TYPE.AutoSizeIMG

															CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__BOUTON(_INDEX_BOUTON_).DejaSize = FALSE


															' Couleur de la fenetre en general  ===> GUI__PROP_COULEURFENETRE
															IF CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__BOUTON(_INDEX_BOUTON_).PROP_TYPE.Couleur_FNT_R < 1 Then
																ADD_NUM_R = "000"
															ElseIF CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__BOUTON(_INDEX_BOUTON_).PROP_TYPE.Couleur_R < 10 Then
																ADD_NUM_R = "00"
															ElseIF CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__BOUTON(_INDEX_BOUTON_).PROP_TYPE.Couleur_R < 100 Then
																ADD_NUM_R = "0"
															End if

															IF CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__BOUTON(_INDEX_BOUTON_).PROP_TYPE.Couleur_FNT_V < 1 Then
																ADD_NUM_V = "000"
															ElseIF CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__BOUTON(_INDEX_BOUTON_).PROP_TYPE.Couleur_FNT_V < 10 Then
																ADD_NUM_V = "00"
															ElseIF CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__BOUTON(_INDEX_BOUTON_).PROP_TYPE.Couleur_FNT_V < 100 Then
																ADD_NUM_V = "0"
															End if

															IF CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__BOUTON(_INDEX_BOUTON_).PROP_TYPE.Couleur_FNT_B < 1 Then
																ADD_NUM_B = "000"
															ElseIF CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__BOUTON(_INDEX_BOUTON_).PROP_TYPE.Couleur_FNT_B < 10 Then
																ADD_NUM_B = "00"
															ElseIF CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__BOUTON(_INDEX_BOUTON_).PROP_TYPE.Couleur_FNT_B < 100 Then
																ADD_NUM_B = "0"
															End if
															GUI__PROP_COULEURFENETRE = ADD_NUM_R & CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__BOUTON(_INDEX_BOUTON_).PROP_TYPE.Couleur_FNT_R & "," _
																						& ADD_NUM_V & CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__BOUTON(_INDEX_BOUTON_).PROP_TYPE.Couleur_FNT_V & ","_
																						& ADD_NUM_B & CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__BOUTON(_INDEX_BOUTON_).PROP_TYPE.Couleur_FNT_B

															ADD_NUM_R = "" : ADD_NUM_V = "" : ADD_NUM_B = ""

															' Couleur du conteneur  ===> GUI__PROP_COULEURFOND
															IF CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__BOUTON(_INDEX_BOUTON_).PROP_TYPE.Couleur_CTN_R < 1 Then
																ADD_NUM_R = "000"
															ElseIF CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__BOUTON(_INDEX_BOUTON_).PROP_TYPE.Couleur_CTN_R < 10 Then
																ADD_NUM_R = "00"
															ElseIF CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__BOUTON(_INDEX_BOUTON_).PROP_TYPE.Couleur_CTN_R < 100 Then
																ADD_NUM_R = "0"
															End if

															IF CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__BOUTON(_INDEX_BOUTON_).PROP_TYPE.Couleur_CTN_V < 1 Then
																ADD_NUM_V = "000"
															ElseIF CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__BOUTON(_INDEX_BOUTON_).PROP_TYPE.Couleur_CTN_V < 10 Then
																ADD_NUM_V = "00"
															ElseIF CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__BOUTON(_INDEX_BOUTON_).PROP_TYPE.Couleur_CTN_V < 100 Then
																ADD_NUM_V = "0"
															End if

															IF CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__BOUTON(_INDEX_BOUTON_).PROP_TYPE.Couleur_CTN_B < 1 Then
																ADD_NUM_B = "000"
															ElseIF CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__BOUTON(_INDEX_BOUTON_).PROP_TYPE.Couleur_CTN_B < 10 Then
																ADD_NUM_B = "00"
															ElseIF CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__BOUTON(_INDEX_BOUTON_).PROP_TYPE.Couleur_CTN_B < 100 Then
																ADD_NUM_B = "0"
															End if
															GUI__PROP_COULEURFOND = ADD_NUM_R & CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__BOUTON(_INDEX_BOUTON_).PROP_TYPE.Couleur_CTN_R & "," _
																						& ADD_NUM_V & CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__BOUTON(_INDEX_BOUTON_).PROP_TYPE.Couleur_CTN_V & ","_
																						& ADD_NUM_B & CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__BOUTON(_INDEX_BOUTON_).PROP_TYPE.Couleur_CTN_B

															ADD_NUM_R = "" : ADD_NUM_V = "" : ADD_NUM_B = ""

															' Type
															GUI__PROP_TYPE_OBJ 		= CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__BOUTON(_INDEX_BOUTON_).PROP_TYPE.TYPE_OBJ

															' Bordure
															if CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__BOUTON(_INDEX_BOUTON_).PROP_TYPE.Bordure >= 1 then CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__BOUTON(_INDEX_BOUTON_).PROP_TYPE.Bordure = 1 else CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__BOUTON(_INDEX_BOUTON_).PROP_TYPE.Bordure = 0

															GUI__PROP_TYPE_BORDURE 	= CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__BOUTON(_INDEX_BOUTON_).PROP_TYPE.Bordure

															' Transparence generale  ===> GUI__PROP_COULEURALPHA
															GUI__PROP_COULEURALPHA 	= str(CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__BOUTON(_INDEX_BOUTON_).PROP_TYPE.Alpha)

															' Fichier de fonction source pour les evenement des objets
															GUI__PROP_EVENEMENT 	= CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__BOUTON(_INDEX_BOUTON_).PROP_TYPE.Fichier_evenement
															GUI__PROP_EVENEMENT_DISPO 	= Ucase(CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__BOUTON(_INDEX_BOUTON_).PROP_TYPE.Liste_Evenements)

															Exit for
														End if
													End if
												Next _INDEX_BOUTON_

											End if
										ElseIF Instr(RetourCCP, ":PICTUREBOX_NOM=") > 0 Then
											IUG_CREATION_PICTUREBOX = MID(RetourCCP, Instr(RetourCCP, ":PICTUREBOX_NOM=") + 16)


											IF Modification_IUG = True Then
												For _INDEX_PICTUREBOX_ = 0 to CPCDOS_INSTANCE._MAX_GUI_PICTUREBOX

													IF IUG_CREATION_PICTUREBOX = CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__PICTUREBOX(_INDEX_PICTUREBOX_).Identification_Objet.Nom Then
														' Verifier si la cle d'identification KERNEL, OS, USER, et PID est identique
														IF CPCDOS_INSTANCE.get_id_kernel(_CLE_) 		= CPCDOS_INSTANCE.get_id_kernel(CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__PICTUREBOX(_INDEX_PICTUREBOX_).Identification_Objet._CLE_) AND _
															CPCDOS_INSTANCE.get_id_OS(_CLE_) 			= CPCDOS_INSTANCE.get_id_OS(CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__PICTUREBOX(_INDEX_PICTUREBOX_).Identification_Objet._CLE_) AND _
															CPCDOS_INSTANCE.get_id_Utilisateur(_CLE_) 	= CPCDOS_INSTANCE.get_id_Utilisateur(CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__PICTUREBOX(_INDEX_PICTUREBOX_).Identification_Objet._CLE_) AND _
															CPCDOS_INSTANCE.get_id_PID(_CLE_) 			= CPCDOS_INSTANCE.get_id_PID(CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__PICTUREBOX(_INDEX_PICTUREBOX_).Identification_Objet._CLE_) Then



															Dim ADD_NUM_R as String
															Dim ADD_NUM_V as String
															Dim ADD_NUM_B as String

															IF CPCDOS_INSTANCE.SYSTEME_INSTANCE.get_DBG_DEBUG() > 0 Then
																IF CPCDOS_INSTANCE.Utilisateur_Langage = 0 Then
																	DEBUG("[CpcdosC+] GUI --> Mode edition du picturebox '" & IUG_CREATION_PICTUREBOX & "' UID:" & CPCDOS_INSTANCE.get_id_Utilisateur(_CLE_) & " PID:" & CPCDOS_INSTANCE.get_id_PID(_CLE_) & " TID:" & CPCDOS_INSTANCE.get_id_TID(_CLE_), Affichage, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_ACTION, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.AvecDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_CPCDOS, RetourVAR)
																Else
																	DEBUG("[CpcdosC+] GUI --> Picturebox edition mode for '" & IUG_CREATION_PICTUREBOX & "' UID:" & CPCDOS_INSTANCE.get_id_Utilisateur(_CLE_) & " PID:" & CPCDOS_INSTANCE.get_id_PID(_CLE_) & " TID:" & CPCDOS_INSTANCE.get_id_TID(_CLE_), Affichage, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_ACTION, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.AvecDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_CPCDOS, RetourVAR)
																End If
															End if

															IF CPCDOS_INSTANCE.SYSTEME_INSTANCE.get_DBG_DEBUG() > 0 Then
																IF CPCDOS_INSTANCE.Utilisateur_Langage = 0 Then
																	DEBUG("[CpcdosC+] Recuperation des proprietes grahpiques en memoire...", Affichage, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_ACTION, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.AvecDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_CPCDOS, RetourVAR)
																Else
																	DEBUG("[CpcdosC+] Recovery graphical properties in memory...", Affichage, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_ACTION, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.AvecDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_CPCDOS, RetourVAR)
																End If
															End if

															' Couleur du picturebox ===> GUI__PROP_COULEURFOND
															CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.TEMP_GUI__PICTUREBOX.PROP_TYPE.Couleur_CTN_R = val(Mid(GUI__PROP_COULEURFOND, 1, 3))
															CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.TEMP_GUI__PICTUREBOX.PROP_TYPE.Couleur_CTN_V = val(Mid(GUI__PROP_COULEURFOND, 5, 3))
															CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.TEMP_GUI__PICTUREBOX.PROP_TYPE.Couleur_CTN_B = val(Mid(GUI__PROP_COULEURFOND, 9, 3))

															' Couleur de la police d'ecriture ===> GUI__PROP_COULEURTEXTE
															CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.TEMP_GUI__PICTUREBOX.PROP_TYPE.Couleur_FNT_R = val(Mid(GUI__PROP_COULEURTEXTE, 1, 3))
															CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.TEMP_GUI__PICTUREBOX.PROP_TYPE.Couleur_FNT_V = val(Mid(GUI__PROP_COULEURTEXTE, 5, 3))
															CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.TEMP_GUI__PICTUREBOX.PROP_TYPE.Couleur_FNT_B = val(Mid(GUI__PROP_COULEURTEXTE, 9, 3))

															' Transparence generale  ===> GUI_PROP_COULEURALPHA
															CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.TEMP_GUI__PICTUREBOX.PROP_TYPE.Alpha = val(GUI__PROP_COULEURALPHA)

															' Bordure
															CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.TEMP_GUI__PICTUREBOX.PROP_TYPE.Bordure = GUI__PROP_TYPE_BORDURE

															' Evenement
															CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.TEMP_GUI__PICTUREBOX.PROP_TYPE.Fichier_evenement = GUI__PROP_EVENEMENT
															CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.TEMP_GUI__PICTUREBOX.PROP_TYPE.Liste_Evenements = GUI__PROP_EVENEMENT_DISPO



															GUI__DEJA_INITIALISE	= TRUE

															' Proprietes d'identification du Processus hebergeur
															GUI__PROC_PARENT	 	= CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__PICTUREBOX(_INDEX_PICTUREBOX_).Identification_Objet.Proc_PARENT
															GUI__PID_PARENT			= CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__PICTUREBOX(_INDEX_PICTUREBOX_).Identification_Objet.PID_PARENT

															' Proprietes d'identification du Thread executif
															GUI__THREAD_PARENT	 	= CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__PICTUREBOX(_INDEX_PICTUREBOX_).Identification_Objet.THREAD_PARENT
															GUI__TID_PARENT			= CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__PICTUREBOX(_INDEX_PICTUREBOX_).Identification_Objet.TID_PARENT

															' Proprietes d'identification d'Objet graphique hebergeur
															GUI__Fenetre_PARENT 	= CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__PICTUREBOX(_INDEX_PICTUREBOX_).Identification_Objet.Fenetre_PARENT
															GUI__Index_FNT_PARENT 	= CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__PICTUREBOX(_INDEX_PICTUREBOX_).Identification_Objet.Index_FNT_PARENT
															GUI__Handle_PARENT 		= CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__PICTUREBOX(_INDEX_PICTUREBOX_).Identification_Objet.Handle_PARENT



															' Proprietes d'identification de l'Objet concerne
															GUI__Nom				= CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__PICTUREBOX(_INDEX_PICTUREBOX_).Identification_Objet.Nom
															CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__PICTUREBOX(_INDEX_PICTUREBOX_).Identification_Objet.Index_ENFANT = _INDEX_PICTUREBOX_
															GUI__Index_ENFANT		= _INDEX_PICTUREBOX_
															GUI__Handle				= CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__PICTUREBOX(_INDEX_PICTUREBOX_).Identification_Objet.handle

															IUG_CREATION_PICTUREBOX	= GUI__Nom

															Nouvelle_Cle_GUI 		= CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__PICTUREBOX(_INDEX_PICTUREBOX_).Identification_Objet._CLE_

															Nouvelle_OS_ID 			= CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__PICTUREBOX(_INDEX_PICTUREBOX_).Identification_Objet.OS_id

															' Proprietes uniques de l'objet concerne
															GUI__PROP_UPDATER 		= CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__PICTUREBOX(_INDEX_PICTUREBOX_).IUG_UPDATER
															GUI__THREAD_OK	 		= CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__PICTUREBOX(_INDEX_PICTUREBOX_).THREAD_OK

															GUI__PROP_PX 			= CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__PICTUREBOX(_INDEX_PICTUREBOX_).POS_X
															GUI__PROP_PY 			= CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__PICTUREBOX(_INDEX_PICTUREBOX_).POS_Y

															GUI__PROP_TX 			= CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__PICTUREBOX(_INDEX_PICTUREBOX_).SIZ_X
															GUI__PROP_TY 			= CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__PICTUREBOX(_INDEX_PICTUREBOX_).SIZ_Y

															GUI__PROP_IMAGE 		= CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__PICTUREBOX(_INDEX_PICTUREBOX_).IMAGE
															GUI__PROP_IMAGE_ANCIEN 	= CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__PICTUREBOX(_INDEX_PICTUREBOX_).IMAGE_ANCIEN

															GUI__PROP_IMAGE_ID		= CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__PICTUREBOX(_INDEX_PICTUREBOX_).IMG_ID
															GUI__PROP_IMAGE_ORG_ID	= CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__PICTUREBOX(_INDEX_PICTUREBOX_).IMG_ORG_ID

															' GUI__PROP_IMAGEPTR 		= CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__PICTUREBOX(_INDEX_PICTUREBOX_).IMG_PTR
															' GUI__PROP_IMAGEPTR_ORG	= CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__PICTUREBOX(_INDEX_PICTUREBOX_).IMG_PTR_ORG
															' GUI__PROP_IMAGEPTR_ANCIEN	= CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__PICTUREBOX(_INDEX_PICTUREBOX_).IMG_PTR_ANCIEN

															GUI__PROP_BIT_ORG		= CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__PICTUREBOX(_INDEX_PICTUREBOX_).BIT_ORG

															GUI__PROP_TEXTE			= CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__PICTUREBOX(_INDEX_PICTUREBOX_).TEXTE

															GUI__PROP_TYPE 			= CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__PICTUREBOX(_INDEX_PICTUREBOX_).PROP_TYPE.LES_TYPES

															GUI__PROP_AUTOSIZE 		= CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__PICTUREBOX(_INDEX_PICTUREBOX_).PROP_TYPE.AutoSizeIMG

															CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__PICTUREBOX(_INDEX_PICTUREBOX_).DejaSize = FALSE


															' Couleur de la fenetre en general  ===> GUI__PROP_COULEURFENETRE
															IF CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__PICTUREBOX(_INDEX_PICTUREBOX_).PROP_TYPE.Couleur_FNT_R < 1 Then
																ADD_NUM_R = "000"
															ElseIF CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__PICTUREBOX(_INDEX_PICTUREBOX_).PROP_TYPE.Couleur_R < 10 Then
																ADD_NUM_R = "00"
															ElseIF CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__PICTUREBOX(_INDEX_PICTUREBOX_).PROP_TYPE.Couleur_R < 100 Then
																ADD_NUM_R = "0"
															End if

															IF CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__PICTUREBOX(_INDEX_PICTUREBOX_).PROP_TYPE.Couleur_FNT_V < 1 Then
																ADD_NUM_V = "000"
															ElseIF CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__PICTUREBOX(_INDEX_PICTUREBOX_).PROP_TYPE.Couleur_FNT_V < 10 Then
																ADD_NUM_V = "00"
															ElseIF CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__PICTUREBOX(_INDEX_PICTUREBOX_).PROP_TYPE.Couleur_FNT_V < 100 Then
																ADD_NUM_V = "0"
															End if

															IF CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__PICTUREBOX(_INDEX_PICTUREBOX_).PROP_TYPE.Couleur_FNT_B < 1 Then
																ADD_NUM_B = "000"
															ElseIF CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__PICTUREBOX(_INDEX_PICTUREBOX_).PROP_TYPE.Couleur_FNT_B < 10 Then
																ADD_NUM_B = "00"
															ElseIF CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__PICTUREBOX(_INDEX_PICTUREBOX_).PROP_TYPE.Couleur_FNT_B < 100 Then
																ADD_NUM_B = "0"
															End if
															GUI__PROP_COULEURFENETRE = ADD_NUM_R & CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__PICTUREBOX(_INDEX_PICTUREBOX_).PROP_TYPE.Couleur_FNT_R & "," _
																						& ADD_NUM_V & CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__PICTUREBOX(_INDEX_PICTUREBOX_).PROP_TYPE.Couleur_FNT_V & ","_
																						& ADD_NUM_B & CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__PICTUREBOX(_INDEX_PICTUREBOX_).PROP_TYPE.Couleur_FNT_B

															ADD_NUM_R = "" : ADD_NUM_V = "" : ADD_NUM_B = ""

															' Couleur du conteneur  ===> GUI__PROP_COULEURFOND
															IF CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__PICTUREBOX(_INDEX_PICTUREBOX_).PROP_TYPE.Couleur_CTN_R < 1 Then
																ADD_NUM_R = "000"
															ElseIF CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__PICTUREBOX(_INDEX_PICTUREBOX_).PROP_TYPE.Couleur_CTN_R < 10 Then
																ADD_NUM_R = "00"
															ElseIF CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__PICTUREBOX(_INDEX_PICTUREBOX_).PROP_TYPE.Couleur_CTN_R < 100 Then
																ADD_NUM_R = "0"
															End if

															IF CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__PICTUREBOX(_INDEX_PICTUREBOX_).PROP_TYPE.Couleur_CTN_V < 1 Then
																ADD_NUM_V = "000"
															ElseIF CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__PICTUREBOX(_INDEX_PICTUREBOX_).PROP_TYPE.Couleur_CTN_V < 10 Then
																ADD_NUM_V = "00"
															ElseIF CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__PICTUREBOX(_INDEX_PICTUREBOX_).PROP_TYPE.Couleur_CTN_V < 100 Then
																ADD_NUM_V = "0"
															End if

															IF CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__PICTUREBOX(_INDEX_PICTUREBOX_).PROP_TYPE.Couleur_CTN_B < 1 Then
																ADD_NUM_B = "000"
															ElseIF CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__PICTUREBOX(_INDEX_PICTUREBOX_).PROP_TYPE.Couleur_CTN_B < 10 Then
																ADD_NUM_B = "00"
															ElseIF CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__PICTUREBOX(_INDEX_PICTUREBOX_).PROP_TYPE.Couleur_CTN_B < 100 Then
																ADD_NUM_B = "0"
															End if
															GUI__PROP_COULEURFOND = ADD_NUM_R & CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__PICTUREBOX(_INDEX_PICTUREBOX_).PROP_TYPE.Couleur_CTN_R & "," _
																						& ADD_NUM_V & CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__PICTUREBOX(_INDEX_PICTUREBOX_).PROP_TYPE.Couleur_CTN_V & ","_
																						& ADD_NUM_B & CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__PICTUREBOX(_INDEX_PICTUREBOX_).PROP_TYPE.Couleur_CTN_B

															ADD_NUM_R = "" : ADD_NUM_V = "" : ADD_NUM_B = ""

															' Type
															GUI__PROP_TYPE_OBJ 		= CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__PICTUREBOX(_INDEX_PICTUREBOX_).PROP_TYPE.TYPE_OBJ

															' Bordure
															GUI__PROP_TYPE_BORDURE 	= CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__PICTUREBOX(_INDEX_PICTUREBOX_).PROP_TYPE.Bordure

															' Transparence generale  ===> GUI__PROP_COULEURALPHA
															GUI__PROP_COULEURALPHA 	= str(CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__PICTUREBOX(_INDEX_PICTUREBOX_).PROP_TYPE.Alpha)

															' Fichier de fonction source pour les evenement des objets
															GUI__PROP_EVENEMENT 	= CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__PICTUREBOX(_INDEX_PICTUREBOX_).PROP_TYPE.Fichier_evenement
															GUI__PROP_EVENEMENT_DISPO 	= Ucase(CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__PICTUREBOX(_INDEX_PICTUREBOX_).PROP_TYPE.Liste_Evenements)



															Exit for
														End if
													End if
												Next _INDEX_PICTUREBOX_

											End if
										ElseIF Instr(RetourCCP, ":TEXTEBLOC_NOM=") > 0 Then
											IUG_CREATION_TEXTEBLOCK = MID(RetourCCP, Instr(RetourCCP, ":TEXTEBLOC_NOM=") + 15)


											IF Modification_IUG = True Then
												For _INDEX_TEXTBLOCK_ = 0 to CPCDOS_INSTANCE._MAX_GUI_TEXTBLOCK

													IF IUG_CREATION_TEXTEBLOCK = CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__TEXTBLOCK(_INDEX_TEXTBLOCK_).Identification_Objet.Nom Then
														' Verifier si la cle d'identification KERNEL, OS, USER, et PID est identique
														IF CPCDOS_INSTANCE.get_id_kernel(_CLE_) 		= CPCDOS_INSTANCE.get_id_kernel(CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__TEXTBLOCK(_INDEX_TEXTBLOCK_).Identification_Objet._CLE_) AND _
															CPCDOS_INSTANCE.get_id_OS(_CLE_) 			= CPCDOS_INSTANCE.get_id_OS(CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__TEXTBLOCK(_INDEX_TEXTBLOCK_).Identification_Objet._CLE_) AND _
															CPCDOS_INSTANCE.get_id_Utilisateur(_CLE_) 	= CPCDOS_INSTANCE.get_id_Utilisateur(CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__TEXTBLOCK(_INDEX_TEXTBLOCK_).Identification_Objet._CLE_) AND _
															CPCDOS_INSTANCE.get_id_PID(_CLE_) 			= CPCDOS_INSTANCE.get_id_PID(CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__TEXTBLOCK(_INDEX_TEXTBLOCK_).Identification_Objet._CLE_) Then



															Dim ADD_NUM_R as String
															Dim ADD_NUM_V as String
															Dim ADD_NUM_B as String

															IF CPCDOS_INSTANCE.SYSTEME_INSTANCE.get_DBG_DEBUG() > 0 Then
																IF CPCDOS_INSTANCE.Utilisateur_Langage = 0 Then
																	DEBUG("[CpcdosC+] GUI --> Mode edition du textebloc '" & IUG_CREATION_TEXTEBLOCK & "' UID:" & CPCDOS_INSTANCE.get_id_Utilisateur(_CLE_) & " PID:" & CPCDOS_INSTANCE.get_id_PID(_CLE_) & " TID:" & CPCDOS_INSTANCE.get_id_TID(_CLE_), Affichage, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_ACTION, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.AvecDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_CPCDOS, RetourVAR)
																Else
																	DEBUG("[CpcdosC+] GUI --> Textblock edition mode for '" & IUG_CREATION_TEXTEBLOCK & "' UID:" & CPCDOS_INSTANCE.get_id_Utilisateur(_CLE_) & " PID:" & CPCDOS_INSTANCE.get_id_PID(_CLE_) & " TID:" & CPCDOS_INSTANCE.get_id_TID(_CLE_), Affichage, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_ACTION, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.AvecDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_CPCDOS, RetourVAR)
																End If
															End if

															IF CPCDOS_INSTANCE.SYSTEME_INSTANCE.get_DBG_DEBUG() > 0 Then
																IF CPCDOS_INSTANCE.Utilisateur_Langage = 0 Then
																	DEBUG("[CpcdosC+] Recuperation des proprietes grahpiques en memoire...", Affichage, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_ACTION, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.AvecDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_CPCDOS, RetourVAR)
																Else
																	DEBUG("[CpcdosC+] Recovery graphical properties in memory...", Affichage, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_ACTION, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.AvecDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_CPCDOS, RetourVAR)
																End If
															End if

															' Couleur du picturebox ===> GUI__PROP_COULEURFOND
															CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.TEMP_GUI__TEXTBLOCK.PROP_TYPE.Couleur_CTN_R = val(Mid(GUI__PROP_COULEURFOND, 1, 3))
															CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.TEMP_GUI__TEXTBLOCK.PROP_TYPE.Couleur_CTN_V = val(Mid(GUI__PROP_COULEURFOND, 5, 3))
															CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.TEMP_GUI__TEXTBLOCK.PROP_TYPE.Couleur_CTN_B = val(Mid(GUI__PROP_COULEURFOND, 9, 3))

															' Couleur de la police d'ecriture ===> GUI__PROP_COULEURTEXTE
															CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.TEMP_GUI__TEXTBLOCK.PROP_TYPE.Couleur_FNT_R = val(Mid(GUI__PROP_COULEURTEXTE, 1, 3))
															CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.TEMP_GUI__TEXTBLOCK.PROP_TYPE.Couleur_FNT_V = val(Mid(GUI__PROP_COULEURTEXTE, 5, 3))
															CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.TEMP_GUI__TEXTBLOCK.PROP_TYPE.Couleur_FNT_B = val(Mid(GUI__PROP_COULEURTEXTE, 9, 3))

															' Transparence generale  ===> GUI_PROP_COULEURALPHA
															CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.TEMP_GUI__TEXTBLOCK.PROP_TYPE.Alpha = val(GUI__PROP_COULEURALPHA)

															' Bordure
															CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.TEMP_GUI__TEXTBLOCK.PROP_TYPE.Bordure = GUI__PROP_TYPE_BORDURE

															'Fond couleur
															CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.TEMP_GUI__TEXTBLOCK.PROP_TYPE.Fond_Couleur = GUI__PROP_FOND_COULEUR

															' Evenement
															CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.TEMP_GUI__TEXTBLOCK.PROP_TYPE.Fichier_evenement = GUI__PROP_EVENEMENT
															CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.TEMP_GUI__TEXTBLOCK.PROP_TYPE.Liste_Evenements = GUI__PROP_EVENEMENT_DISPO


															GUI__DEJA_INITIALISE	= TRUE

															' Proprietes d'identification du Processus hebergeur
															GUI__PROC_PARENT	 	= CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__TEXTBLOCK(_INDEX_TEXTBLOCK_).Identification_Objet.Proc_PARENT
															GUI__PID_PARENT			= CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__TEXTBLOCK(_INDEX_TEXTBLOCK_).Identification_Objet.PID_PARENT

															' Proprietes d'identification du Thread executif
															GUI__THREAD_PARENT	 	= CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__TEXTBLOCK(_INDEX_TEXTBLOCK_).Identification_Objet.THREAD_PARENT
															GUI__TID_PARENT			= CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__TEXTBLOCK(_INDEX_TEXTBLOCK_).Identification_Objet.TID_PARENT

															' Proprietes d'identification d'Objet graphique hebergeur
															GUI__Fenetre_PARENT 	= CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__TEXTBLOCK(_INDEX_TEXTBLOCK_).Identification_Objet.Fenetre_PARENT
															GUI__Index_FNT_PARENT 	= CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__TEXTBLOCK(_INDEX_TEXTBLOCK_).Identification_Objet.Index_FNT_PARENT
															GUI__Handle_PARENT 		= CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__TEXTBLOCK(_INDEX_TEXTBLOCK_).Identification_Objet.Handle_PARENT

															' Proprietes d'identification de l'Objet concerne
															GUI__Nom				= CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__TEXTBLOCK(_INDEX_TEXTBLOCK_).Identification_Objet.Nom
															CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__TEXTBLOCK(_INDEX_TEXTBLOCK_).Identification_Objet.Index_ENFANT = _INDEX_TEXTBLOCK_
															GUI__Index_ENFANT		= _INDEX_TEXTBLOCK_

															GUI__Handle				= CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__TEXTBLOCK(_INDEX_TEXTBLOCK_).Identification_Objet.handle

															IUG_CREATION_TEXTEBLOCK	= GUI__Nom

															Nouvelle_Cle_GUI 		= CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__TEXTBLOCK(_INDEX_TEXTBLOCK_).Identification_Objet._CLE_

															Nouvelle_OS_ID 			= CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__TEXTBLOCK(_INDEX_TEXTBLOCK_).Identification_Objet.OS_id

															' Proprietes uniques de l'objet concerne
															GUI__PROP_UPDATER 		= CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__TEXTBLOCK(_INDEX_TEXTBLOCK_).IUG_UPDATER
															GUI__THREAD_OK	 		= CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__TEXTBLOCK(_INDEX_TEXTBLOCK_).THREAD_OK

															GUI__PROP_PX 			= CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__TEXTBLOCK(_INDEX_TEXTBLOCK_).POS_X
															GUI__PROP_PY 			= CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__TEXTBLOCK(_INDEX_TEXTBLOCK_).POS_Y

															GUI__PROP_TX 			= CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__TEXTBLOCK(_INDEX_TEXTBLOCK_).SIZ_X
															GUI__PROP_TY 			= CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__TEXTBLOCK(_INDEX_TEXTBLOCK_).SIZ_Y



															GUI__PROP_TEXTE			= CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__TEXTBLOCK(_INDEX_TEXTBLOCK_).TEXTE


															GUI__PROP_TYPE 			= CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__TEXTBLOCK(_INDEX_TEXTBLOCK_).PROP_TYPE.LES_TYPES

															GUI__PROP_AUTOSIZE 		= CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__TEXTBLOCK(_INDEX_TEXTBLOCK_).PROP_TYPE.AutoSizeIMG

															CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__TEXTBLOCK(_INDEX_TEXTBLOCK_).DejaSize = FALSE


															' Couleur de la fenetre en general  ===> GUI__PROP_COULEURFENETRE
															IF CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__TEXTBLOCK(_INDEX_TEXTBLOCK_).PROP_TYPE.Couleur_FNT_R < 1 Then
																ADD_NUM_R = "000"
															ElseIF CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__TEXTBLOCK(_INDEX_TEXTBLOCK_).PROP_TYPE.Couleur_R < 10 Then
																ADD_NUM_R = "00"
															ElseIF CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__TEXTBLOCK(_INDEX_TEXTBLOCK_).PROP_TYPE.Couleur_R < 100 Then
																ADD_NUM_R = "0"
															End if

															IF CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__TEXTBLOCK(_INDEX_TEXTBLOCK_).PROP_TYPE.Couleur_FNT_V < 1 Then
																ADD_NUM_V = "000"
															ElseIF CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__TEXTBLOCK(_INDEX_TEXTBLOCK_).PROP_TYPE.Couleur_FNT_V < 10 Then
																ADD_NUM_V = "00"
															ElseIF CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__TEXTBLOCK(_INDEX_TEXTBLOCK_).PROP_TYPE.Couleur_FNT_V < 100 Then
																ADD_NUM_V = "0"
															End if

															IF CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__TEXTBLOCK(_INDEX_TEXTBLOCK_).PROP_TYPE.Couleur_FNT_B < 1 Then
																ADD_NUM_B = "000"
															ElseIF CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__TEXTBLOCK(_INDEX_TEXTBLOCK_).PROP_TYPE.Couleur_FNT_B < 10 Then
																ADD_NUM_B = "00"
															ElseIF CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__TEXTBLOCK(_INDEX_TEXTBLOCK_).PROP_TYPE.Couleur_FNT_B < 100 Then
																ADD_NUM_B = "0"
															End if
															GUI__PROP_COULEURFENETRE = ADD_NUM_R & CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__TEXTBLOCK(_INDEX_TEXTBLOCK_).PROP_TYPE.Couleur_FNT_R & "," _
																						& ADD_NUM_V & CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__TEXTBLOCK(_INDEX_TEXTBLOCK_).PROP_TYPE.Couleur_FNT_V & ","_
																						& ADD_NUM_B & CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__TEXTBLOCK(_INDEX_TEXTBLOCK_).PROP_TYPE.Couleur_FNT_B

															ADD_NUM_R = "" : ADD_NUM_V = "" : ADD_NUM_B = ""

															' Couleur du conteneur  ===> GUI__PROP_COULEURFOND
															IF CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__TEXTBLOCK(_INDEX_TEXTBLOCK_).PROP_TYPE.Couleur_CTN_R < 1 Then
																ADD_NUM_R = "000"
															ElseIF CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__TEXTBLOCK(_INDEX_TEXTBLOCK_).PROP_TYPE.Couleur_CTN_R < 10 Then
																ADD_NUM_R = "00"
															ElseIF CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__TEXTBLOCK(_INDEX_TEXTBLOCK_).PROP_TYPE.Couleur_CTN_R < 100 Then
																ADD_NUM_R = "0"
															End if

															IF CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__TEXTBLOCK(_INDEX_TEXTBLOCK_).PROP_TYPE.Couleur_CTN_V < 1 Then
																ADD_NUM_V = "000"
															ElseIF CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__TEXTBLOCK(_INDEX_TEXTBLOCK_).PROP_TYPE.Couleur_CTN_V < 10 Then
																ADD_NUM_V = "00"
															ElseIF CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__TEXTBLOCK(_INDEX_TEXTBLOCK_).PROP_TYPE.Couleur_CTN_V < 100 Then
																ADD_NUM_V = "0"
															End if

															IF CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__TEXTBLOCK(_INDEX_TEXTBLOCK_).PROP_TYPE.Couleur_CTN_B < 1 Then
																ADD_NUM_B = "000"
															ElseIF CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__TEXTBLOCK(_INDEX_TEXTBLOCK_).PROP_TYPE.Couleur_CTN_B < 10 Then
																ADD_NUM_B = "00"
															ElseIF CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__TEXTBLOCK(_INDEX_TEXTBLOCK_).PROP_TYPE.Couleur_CTN_B < 100 Then
																ADD_NUM_B = "0"
															End if
															GUI__PROP_COULEURFOND = ADD_NUM_R & CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__TEXTBLOCK(_INDEX_TEXTBLOCK_).PROP_TYPE.Couleur_CTN_R & "," _
																						& ADD_NUM_V & CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__TEXTBLOCK(_INDEX_TEXTBLOCK_).PROP_TYPE.Couleur_CTN_V & ","_
																						& ADD_NUM_B & CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__TEXTBLOCK(_INDEX_TEXTBLOCK_).PROP_TYPE.Couleur_CTN_B

															ADD_NUM_R = "" : ADD_NUM_V = "" : ADD_NUM_B = ""

															' Type
															GUI__PROP_TYPE_OBJ 		= CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__TEXTBLOCK(_INDEX_TEXTBLOCK_).PROP_TYPE.TYPE_OBJ

															' Couleur de fond OUI ou NON
															GUI__PROP_FOND_COULEUR  = CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__TEXTBLOCK(_INDEX_TEXTBLOCK_).PROP_TYPE.Fond_Couleur

															' Bordure
															GUI__PROP_TYPE_BORDURE 	= CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__TEXTBLOCK(_INDEX_TEXTBLOCK_).PROP_TYPE.Bordure

															' Transparence generale  ===> GUI__PROP_COULEURALPHA
															GUI__PROP_COULEURALPHA 	= str(CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__TEXTBLOCK(_INDEX_TEXTBLOCK_).PROP_TYPE.Alpha)

															' Fichier de fonction source pour les evenement des objets
															GUI__PROP_EVENEMENT 	= CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__TEXTBLOCK(_INDEX_TEXTBLOCK_).PROP_TYPE.Fichier_evenement
															GUI__PROP_EVENEMENT_DISPO 	= Ucase(CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__TEXTBLOCK(_INDEX_TEXTBLOCK_).PROP_TYPE.Liste_Evenements)


															Exit for
														End if
													End if
												Next _INDEX_TEXTBLOCK_

											End if
										ElseIF Instr(RetourCCP, ":TEXTEBOX_NOM=") > 0 Then
											IUG_CREATION_TEXTEBOX = MID(RetourCCP, Instr(RetourCCP, ":TEXTEBOX_NOM=") + 14)

											IF Modification_IUG = True Then
												For _INDEX_TEXTBOX_ = 0 to CPCDOS_INSTANCE._MAX_GUI_TEXTBOX

													IF IUG_CREATION_TEXTEBOX = CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__TEXTBOX(_INDEX_TEXTBOX_).Identification_Objet.Nom Then

														' Verifier si la cle d'identification KERNEL, OS, USER, et PID est identique
														IF CPCDOS_INSTANCE.get_id_kernel(_CLE_) 		= CPCDOS_INSTANCE.get_id_kernel(CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__TEXTBOX(_INDEX_TEXTBOX_).Identification_Objet._CLE_) AND _
															CPCDOS_INSTANCE.get_id_OS(_CLE_) 			= CPCDOS_INSTANCE.get_id_OS(CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__TEXTBOX(_INDEX_TEXTBOX_).Identification_Objet._CLE_) AND _
															CPCDOS_INSTANCE.get_id_Utilisateur(_CLE_) 	= CPCDOS_INSTANCE.get_id_Utilisateur(CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__TEXTBOX(_INDEX_TEXTBOX_).Identification_Objet._CLE_) AND _
															CPCDOS_INSTANCE.get_id_PID(_CLE_) 			= CPCDOS_INSTANCE.get_id_PID(CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__TEXTBOX(_INDEX_TEXTBOX_).Identification_Objet._CLE_) Then

															Dim ADD_NUM_R as String
															Dim ADD_NUM_V as String
															Dim ADD_NUM_B as String

															IF CPCDOS_INSTANCE.SYSTEME_INSTANCE.get_DBG_DEBUG() > 0 Then
																IF CPCDOS_INSTANCE.Utilisateur_Langage = 0 Then
																	DEBUG("[CpcdosC+] GUI --> Mode edition du textebox '" & IUG_CREATION_TEXTEBOX & "' UID:" & CPCDOS_INSTANCE.get_id_Utilisateur(_CLE_) & " PID:" & CPCDOS_INSTANCE.get_id_PID(_CLE_) & " TID:" & CPCDOS_INSTANCE.get_id_TID(_CLE_), Affichage, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_ACTION, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.AvecDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_CPCDOS, RetourVAR)
																Else
																	DEBUG("[CpcdosC+] GUI --> Textbox edition mode for '" & IUG_CREATION_TEXTEBOX & "' UID:" & CPCDOS_INSTANCE.get_id_Utilisateur(_CLE_) & " PID:" & CPCDOS_INSTANCE.get_id_PID(_CLE_) & " TID:" & CPCDOS_INSTANCE.get_id_TID(_CLE_), Affichage, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_ACTION, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.AvecDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_CPCDOS, RetourVAR)
																End If
															End if

															IF CPCDOS_INSTANCE.SYSTEME_INSTANCE.get_DBG_DEBUG() > 0 Then
																IF CPCDOS_INSTANCE.Utilisateur_Langage = 0 Then
																	DEBUG("[CpcdosC+] Recuperation des proprietes grahpiques en memoire...", Affichage, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_ACTION, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.AvecDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_CPCDOS, RetourVAR)
																Else
																	DEBUG("[CpcdosC+] Recovery graphical properties in memory...", Affichage, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_ACTION, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.AvecDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_CPCDOS, RetourVAR)
																End If
															End if

															' Couleur du textebox ===> GUI__PROP_COULEURFOND
															CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.TEMP_GUI__TEXTBOX.PROP_TYPE.Couleur_CTN_R = val(Mid(GUI__PROP_COULEURFOND, 1, 3))
															CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.TEMP_GUI__TEXTBOX.PROP_TYPE.Couleur_CTN_V = val(Mid(GUI__PROP_COULEURFOND, 5, 3))
															CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.TEMP_GUI__TEXTBOX.PROP_TYPE.Couleur_CTN_B = val(Mid(GUI__PROP_COULEURFOND, 9, 3))

															' Couleur de la police d'ecriture ===> GUI__PROP_COULEURTEXTE
															CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.TEMP_GUI__TEXTBOX.PROP_TYPE.Couleur_FNT_R = val(Mid(GUI__PROP_COULEURTEXTE, 1, 3))
															CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.TEMP_GUI__TEXTBOX.PROP_TYPE.Couleur_FNT_V = val(Mid(GUI__PROP_COULEURTEXTE, 5, 3))
															CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.TEMP_GUI__TEXTBOX.PROP_TYPE.Couleur_FNT_B = val(Mid(GUI__PROP_COULEURTEXTE, 9, 3))

															' Transparence generale  ===> GUI_PROP_COULEURALPHA
															CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.TEMP_GUI__TEXTBOX.PROP_TYPE.Alpha = val(GUI__PROP_COULEURALPHA)

															' Bordure
															CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.TEMP_GUI__TEXTBOX.PROP_TYPE.Bordure = GUI__PROP_TYPE_BORDURE

															'Fond couleur
															CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.TEMP_GUI__TEXTBOX.PROP_TYPE.Fond_Couleur = GUI__PROP_FOND_COULEUR

															' Evenement
															CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.TEMP_GUI__TEXTBOX.PROP_TYPE.Fichier_evenement = GUI__PROP_EVENEMENT
															CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.TEMP_GUI__TEXTBOX.PROP_TYPE.Liste_Evenements = GUI__PROP_EVENEMENT_DISPO


															GUI__DEJA_INITIALISE	= TRUE

															' Proprietes d'identification du Processus hebergeur
															GUI__PROC_PARENT	 	= CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__TEXTBOX(_INDEX_TEXTBOX_).Identification_Objet.Proc_PARENT
															GUI__PID_PARENT			= CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__TEXTBOX(_INDEX_TEXTBOX_).Identification_Objet.PID_PARENT

															' Proprietes d'identification du Thread executif
															GUI__THREAD_PARENT	 	= CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__TEXTBOX(_INDEX_TEXTBOX_).Identification_Objet.THREAD_PARENT
															GUI__TID_PARENT			= CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__TEXTBOX(_INDEX_TEXTBOX_).Identification_Objet.TID_PARENT

															' Proprietes d'identification d'Objet graphique hebergeur
															GUI__Fenetre_PARENT 	= CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__TEXTBOX(_INDEX_TEXTBOX_).Identification_Objet.Fenetre_PARENT
															GUI__Index_FNT_PARENT 	= CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__TEXTBOX(_INDEX_TEXTBOX_).Identification_Objet.Index_FNT_PARENT
															GUI__Handle_PARENT 		= CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__TEXTBOX(_INDEX_TEXTBOX_).Identification_Objet.Handle_PARENT

															' Proprietes d'identification de l'Objet concerne
															GUI__Nom				= CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__TEXTBOX(_INDEX_TEXTBOX_).Identification_Objet.Nom
															CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__TEXTBOX(_INDEX_TEXTBOX_).Identification_Objet.Index_ENFANT = _INDEX_TEXTBOX_
															GUI__Index_ENFANT		= _INDEX_TEXTBOX_
															GUI__Handle				= CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__TEXTBOX(_INDEX_TEXTBOX_).Identification_Objet.handle

															IUG_CREATION_TEXTEBOX	= GUI__Nom

															Nouvelle_Cle_GUI 		= CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__TEXTBOX(_INDEX_TEXTBOX_).Identification_Objet._CLE_

															Nouvelle_OS_ID 			= CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__TEXTBOX(_INDEX_TEXTBOX_).Identification_Objet.OS_id

															GUI__PROP_TYPE 			= CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__TEXTBOX(_INDEX_TEXTBOX_).PROP_TYPE.LES_TYPES

															' Proprietes uniques de l'objet concerne
															GUI__PROP_UPDATER 		= CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__TEXTBOX(_INDEX_TEXTBOX_).IUG_UPDATER
															GUI__THREAD_OK	 		= CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__TEXTBOX(_INDEX_TEXTBOX_).THREAD_OK

															GUI__PROP_PX 			= CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__TEXTBOX(_INDEX_TEXTBOX_).POS_X
															GUI__PROP_PY 			= CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__TEXTBOX(_INDEX_TEXTBOX_).POS_Y

															GUI__PROP_TX 			= CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__TEXTBOX(_INDEX_TEXTBOX_).SIZ_X
															GUI__PROP_TY 			= CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__TEXTBOX(_INDEX_TEXTBOX_).SIZ_Y

															GUI__PROP_IMAGE_ID		= CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__TEXTBOX(_INDEX_TEXTBOX_).IMG_ID
															GUI__PROP_IMAGE_ORG_ID	= CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__TEXTBOX(_INDEX_TEXTBOX_).IMG_ORG_ID

															' Texte par defaut
															GUI__PROP_TEXTE			= CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__TEXTBOX(_INDEX_TEXTBOX_).TEXTE

															' Si ce texte est editable
															GUI__PROP_TYPE_Editable	= CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__TEXTBOX(_INDEX_TEXTBOX_).PROP_TYPE.Editable

															GUI__PROP_TYPE_MultiLignes	= CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__TEXTBOX(_INDEX_TEXTBOX_).PROP_TYPE.Multi_Lignes
															GUI__PROP_TYPE_Console	= CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__TEXTBOX(_INDEX_TEXTBOX_).PROP_TYPE.Console

															GUI__PROP_AUTOSIZE 		= CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__TEXTBOX(_INDEX_TEXTBOX_).PROP_TYPE.AutoSizeIMG

															CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__TEXTBOX(_INDEX_TEXTBOX_).DejaSize = FALSE


															' Couleur de la fenetre en general  ===> GUI__PROP_COULEURFENETRE
															IF CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__TEXTBOX(_INDEX_TEXTBOX_).PROP_TYPE.Couleur_FNT_R < 1 Then
																ADD_NUM_R = "000"
															ElseIF CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__TEXTBOX(_INDEX_TEXTBOX_).PROP_TYPE.Couleur_R < 10 Then
																ADD_NUM_R = "00"
															ElseIF CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__TEXTBOX(_INDEX_TEXTBOX_).PROP_TYPE.Couleur_R < 100 Then
																ADD_NUM_R = "0"
															End if

															IF CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__TEXTBOX(_INDEX_TEXTBOX_).PROP_TYPE.Couleur_FNT_V < 1 Then
																ADD_NUM_V = "000"
															ElseIF CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__TEXTBOX(_INDEX_TEXTBOX_).PROP_TYPE.Couleur_FNT_V < 10 Then
																ADD_NUM_V = "00"
															ElseIF CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__TEXTBOX(_INDEX_TEXTBOX_).PROP_TYPE.Couleur_FNT_V < 100 Then
																ADD_NUM_V = "0"
															End if

															IF CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__TEXTBOX(_INDEX_TEXTBOX_).PROP_TYPE.Couleur_FNT_B < 1 Then
																ADD_NUM_B = "000"
															ElseIF CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__TEXTBOX(_INDEX_TEXTBOX_).PROP_TYPE.Couleur_FNT_B < 10 Then
																ADD_NUM_B = "00"
															ElseIF CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__TEXTBOX(_INDEX_TEXTBOX_).PROP_TYPE.Couleur_FNT_B < 100 Then
																ADD_NUM_B = "0"
															End if
															GUI__PROP_COULEURFENETRE = ADD_NUM_R & CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__TEXTBOX(_INDEX_TEXTBOX_).PROP_TYPE.Couleur_FNT_R & "," _
																						& ADD_NUM_V & CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__TEXTBOX(_INDEX_TEXTBOX_).PROP_TYPE.Couleur_FNT_V & ","_
																						& ADD_NUM_B & CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__TEXTBOX(_INDEX_TEXTBOX_).PROP_TYPE.Couleur_FNT_B

															ADD_NUM_R = "" : ADD_NUM_V = "" : ADD_NUM_B = ""

															' Couleur du conteneur  ===> GUI__PROP_COULEURFOND
															IF CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__TEXTBOX(_INDEX_TEXTBOX_).PROP_TYPE.Couleur_CTN_R < 1 Then
																ADD_NUM_R = "000"
															ElseIF CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__TEXTBOX(_INDEX_TEXTBOX_).PROP_TYPE.Couleur_CTN_R < 10 Then
																ADD_NUM_R = "00"
															ElseIF CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__TEXTBOX(_INDEX_TEXTBOX_).PROP_TYPE.Couleur_CTN_R < 100 Then
																ADD_NUM_R = "0"
															End if

															IF CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__TEXTBOX(_INDEX_TEXTBOX_).PROP_TYPE.Couleur_CTN_V < 1 Then
																ADD_NUM_V = "000"
															ElseIF CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__TEXTBOX(_INDEX_TEXTBOX_).PROP_TYPE.Couleur_CTN_V < 10 Then
																ADD_NUM_V = "00"
															ElseIF CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__TEXTBOX(_INDEX_TEXTBOX_).PROP_TYPE.Couleur_CTN_V < 100 Then
																ADD_NUM_V = "0"
															End if

															IF CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__TEXTBOX(_INDEX_TEXTBOX_).PROP_TYPE.Couleur_CTN_B < 1 Then
																ADD_NUM_B = "000"
															ElseIF CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__TEXTBOX(_INDEX_TEXTBOX_).PROP_TYPE.Couleur_CTN_B < 10 Then
																ADD_NUM_B = "00"
															ElseIF CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__TEXTBOX(_INDEX_TEXTBOX_).PROP_TYPE.Couleur_CTN_B < 100 Then
																ADD_NUM_B = "0"
															End if
															GUI__PROP_COULEURFOND = ADD_NUM_R & CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__TEXTBOX(_INDEX_TEXTBOX_).PROP_TYPE.Couleur_CTN_R & "," _
																						& ADD_NUM_V & CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__TEXTBOX(_INDEX_TEXTBOX_).PROP_TYPE.Couleur_CTN_V & ","_
																						& ADD_NUM_B & CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__TEXTBOX(_INDEX_TEXTBOX_).PROP_TYPE.Couleur_CTN_B

															ADD_NUM_R = "" : ADD_NUM_V = "" : ADD_NUM_B = ""

															' Type
															GUI__PROP_TYPE_OBJ 		= CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__TEXTBOX(_INDEX_TEXTBOX_).PROP_TYPE.TYPE_OBJ

															' Couleur de fond OUI ou NON
															GUI__PROP_FOND_COULEUR  = CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__TEXTBOX(_INDEX_TEXTBOX_).PROP_TYPE.Fond_Couleur

															' Bordure
															GUI__PROP_TYPE_BORDURE 	= CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__TEXTBOX(_INDEX_TEXTBOX_).PROP_TYPE.Bordure

															' Transparence generale  ===> GUI__PROP_COULEURALPHA
															GUI__PROP_COULEURALPHA 	= str(CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__TEXTBOX(_INDEX_TEXTBOX_).PROP_TYPE.Alpha)

															' Fichier de fonction source pour les evenement des objets
															GUI__PROP_EVENEMENT 	= CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__TEXTBOX(_INDEX_TEXTBOX_).PROP_TYPE.Fichier_evenement
															GUI__PROP_EVENEMENT_DISPO 	= Ucase(CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__TEXTBOX(_INDEX_TEXTBOX_).PROP_TYPE.Liste_Evenements)


															Exit for
														End if
													End if
												Next _INDEX_TEXTBOX_

											End if
										ElseIF Instr(RetourCCP, ":PROGRESSBAR_NOM=") > 0 Then
											IUG_CREATION_PROGRESSBAR = MID(RetourCCP, Instr(RetourCCP, ":PROGRESSBAR_NOM=") + 17)

											GUI__PROP_AUTOSIZE = 2

											IF Modification_IUG = True Then
												For _INDEX_PROGRESSBAR_ = 0 to CPCDOS_INSTANCE._MAX_GUI_PROGRESSBAR

													IF IUG_CREATION_PROGRESSBAR = CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__PROGRESSBAR(_INDEX_PROGRESSBAR_).Identification_Objet.Nom Then

														' Verifier si la cle d'identification KERNEL, OS, USER, et PID est identique
														IF CPCDOS_INSTANCE.get_id_kernel(_CLE_) 		= CPCDOS_INSTANCE.get_id_kernel(CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__PROGRESSBAR(_INDEX_PROGRESSBAR_).Identification_Objet._CLE_) AND _
															CPCDOS_INSTANCE.get_id_OS(_CLE_) 			= CPCDOS_INSTANCE.get_id_OS(CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__PROGRESSBAR(_INDEX_PROGRESSBAR_).Identification_Objet._CLE_) AND _
															CPCDOS_INSTANCE.get_id_Utilisateur(_CLE_) 	= CPCDOS_INSTANCE.get_id_Utilisateur(CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__PROGRESSBAR(_INDEX_PROGRESSBAR_).Identification_Objet._CLE_) AND _
															CPCDOS_INSTANCE.get_id_PID(_CLE_) 			= CPCDOS_INSTANCE.get_id_PID(CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__PROGRESSBAR(_INDEX_PROGRESSBAR_).Identification_Objet._CLE_) Then

															Dim ADD_NUM_R as String
															Dim ADD_NUM_V as String
															Dim ADD_NUM_B as String


															IF CPCDOS_INSTANCE.SYSTEME_INSTANCE.get_DBG_DEBUG() > 0 Then
																IF CPCDOS_INSTANCE.Utilisateur_Langage = 0 Then
																	DEBUG("[CpcdosC+] GUI --> Mode edition de la barre de progression '" & IUG_CREATION_PROGRESSBAR & "' UID:" & CPCDOS_INSTANCE.get_id_Utilisateur(_CLE_) & " PID:" & CPCDOS_INSTANCE.get_id_PID(_CLE_) & " TID:" & CPCDOS_INSTANCE.get_id_TID(_CLE_), Affichage, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_ACTION, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.AvecDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_CPCDOS, RetourVAR)
																Else
																	DEBUG("[CpcdosC+] GUI --> Progress Bar edition mode for '" & IUG_CREATION_PROGRESSBAR & "' UID:" & CPCDOS_INSTANCE.get_id_Utilisateur(_CLE_) & " PID:" & CPCDOS_INSTANCE.get_id_PID(_CLE_) & " TID:" & CPCDOS_INSTANCE.get_id_TID(_CLE_), Affichage, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_ACTION, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.AvecDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_CPCDOS, RetourVAR)
																End If
															End if

															IF CPCDOS_INSTANCE.SYSTEME_INSTANCE.get_DBG_DEBUG() > 0 Then
																IF CPCDOS_INSTANCE.Utilisateur_Langage = 0 Then
																	DEBUG("[CpcdosC+] Recuperation des proprietes grahpiques en memoire...", Affichage, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_ACTION, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.AvecDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_CPCDOS, RetourVAR)
																Else
																	DEBUG("[CpcdosC+] Recovery graphical properties in memory...", Affichage, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_ACTION, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.AvecDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_CPCDOS, RetourVAR)
																End If
															End if

															' Couleur du textebox ===> GUI__PROP_COULEURFOND
															CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.TEMP_GUI__PROGRESSBAR.PROP_TYPE.Couleur_CTN_R = val(Mid(GUI__PROP_COULEURFOND, 1, 3))
															CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.TEMP_GUI__PROGRESSBAR.PROP_TYPE.Couleur_CTN_V = val(Mid(GUI__PROP_COULEURFOND, 5, 3))
															CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.TEMP_GUI__PROGRESSBAR.PROP_TYPE.Couleur_CTN_B = val(Mid(GUI__PROP_COULEURFOND, 9, 3))

															' Couleur de la police d'ecriture ===> GUI__PROP_COULEURTEXTE
															CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.TEMP_GUI__PROGRESSBAR.PROP_TYPE.Couleur_FNT_R = val(Mid(GUI__PROP_COULEURTEXTE, 1, 3))
															CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.TEMP_GUI__PROGRESSBAR.PROP_TYPE.Couleur_FNT_V = val(Mid(GUI__PROP_COULEURTEXTE, 5, 3))
															CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.TEMP_GUI__PROGRESSBAR.PROP_TYPE.Couleur_FNT_B = val(Mid(GUI__PROP_COULEURTEXTE, 9, 3))

															' Transparence generale  ===> GUI_PROP_COULEURALPHA
															CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.TEMP_GUI__PROGRESSBAR.PROP_TYPE.Alpha = val(GUI__PROP_COULEURALPHA)

															' Bordure
															CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.TEMP_GUI__PROGRESSBAR.PROP_TYPE.Bordure = GUI__PROP_TYPE_BORDURE

															'Fond couleur
															CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.TEMP_GUI__PROGRESSBAR.PROP_TYPE.Fond_Couleur = GUI__PROP_FOND_COULEUR

															' Evenement
															CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.TEMP_GUI__PROGRESSBAR.PROP_TYPE.Fichier_evenement = GUI__PROP_EVENEMENT
															CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.TEMP_GUI__PROGRESSBAR.PROP_TYPE.Liste_Evenements = GUI__PROP_EVENEMENT_DISPO

															GUI__DEJA_INITIALISE	= TRUE

															' Proprietes d'identification du Processus hebergeur
															GUI__PROC_PARENT	 	= CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__PROGRESSBAR(_INDEX_PROGRESSBAR_).Identification_Objet.Proc_PARENT
															GUI__PID_PARENT			= CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__PROGRESSBAR(_INDEX_PROGRESSBAR_).Identification_Objet.PID_PARENT

															' Proprietes d'identification du Thread executif
															GUI__THREAD_PARENT	 	= CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__PROGRESSBAR(_INDEX_PROGRESSBAR_).Identification_Objet.THREAD_PARENT
															GUI__TID_PARENT			= CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__PROGRESSBAR(_INDEX_PROGRESSBAR_).Identification_Objet.TID_PARENT

															' Proprietes d'identification d'Objet graphique hebergeur
															GUI__Fenetre_PARENT 	= CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__PROGRESSBAR(_INDEX_PROGRESSBAR_).Identification_Objet.Fenetre_PARENT
															GUI__Index_FNT_PARENT 	= CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__PROGRESSBAR(_INDEX_PROGRESSBAR_).Identification_Objet.Index_FNT_PARENT
															GUI__Handle_PARENT 		= CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__PROGRESSBAR(_INDEX_PROGRESSBAR_).Identification_Objet.Handle_PARENT

															' Proprietes d'identification de l'Objet concerne
															GUI__Nom				= CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__PROGRESSBAR(_INDEX_PROGRESSBAR_).Identification_Objet.Nom
															CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__PROGRESSBAR(_INDEX_PROGRESSBAR_).Identification_Objet.Index_ENFANT = _INDEX_PROGRESSBAR_
															GUI__Index_ENFANT		= _INDEX_PROGRESSBAR_
															GUI__Handle				= CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__PROGRESSBAR(_INDEX_PROGRESSBAR_).Identification_Objet.handle

															IUG_CREATION_PROGRESSBAR = GUI__Nom

															Nouvelle_Cle_GUI 		= CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__PROGRESSBAR(_INDEX_PROGRESSBAR_).Identification_Objet._CLE_
															Nouvelle_OS_ID 			= CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__PROGRESSBAR(_INDEX_PROGRESSBAR_).Identification_Objet.OS_id

															GUI__PROP_TYPE 			= CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__PROGRESSBAR(_INDEX_PROGRESSBAR_).PROP_TYPE.LES_TYPES

															' Proprietes uniques de l'objet concerne
															GUI__PROP_UPDATER 		= CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__PROGRESSBAR(_INDEX_PROGRESSBAR_).IUG_UPDATER
															GUI__THREAD_OK	 		= CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__PROGRESSBAR(_INDEX_PROGRESSBAR_).THREAD_OK

															GUI__PROP_PX 			= CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__PROGRESSBAR(_INDEX_PROGRESSBAR_).POS_X
															GUI__PROP_PY 			= CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__PROGRESSBAR(_INDEX_PROGRESSBAR_).POS_Y

															GUI__PROP_TX 			= CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__PROGRESSBAR(_INDEX_PROGRESSBAR_).SIZ_X
															GUI__PROP_TY 			= CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__PROGRESSBAR(_INDEX_PROGRESSBAR_).SIZ_Y


															GUI__PROP_IMAGE 		= CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__PROGRESSBAR(_INDEX_PROGRESSBAR_).IMAGE
															GUI__PROP_IMAGE_ANCIEN 	= CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__PROGRESSBAR(_INDEX_PROGRESSBAR_).IMAGE_ANCIEN

															GUI__PROP_IMAGE_ID		= CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__PROGRESSBAR(_INDEX_PROGRESSBAR_).IMG_ID
															GUI__PROP_IMAGE_prog_ID	= CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__PROGRESSBAR(_INDEX_PROGRESSBAR_).IMG_prog_ID
															GUI__PROP_IMAGE_ORG_ID	= CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__PROGRESSBAR(_INDEX_PROGRESSBAR_).IMG_ORG_ID

															' GUI__PROP_IMAGEPTR 		= CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__PROGRESSBAR(_INDEX_PROGRESSBAR_).IMG_PTR	 		' Obtenir le pointeur du context GZE
															' GUI__PROP_IMAGEPTR_ORG	= CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__PROGRESSBAR(_INDEX_PROGRESSBAR_).IMG_PTR_ORG	 	' Obtenir le pointeur du context GZE
															' GUI__PROP_IMAGEPTR_ANCIEN = CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__PROGRESSBAR(_INDEX_PROGRESSBAR_).IMG_PTR_ANCIEN	' Obtenir le pointeur du context GZE

															GUI__PROP_BIT_ORG		= CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__PROGRESSBAR(_INDEX_PROGRESSBAR_).BIT_ORG ' precedent BIT

															' Texte par defaut
															GUI__PROP_TEXTE			= CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__PROGRESSBAR(_INDEX_PROGRESSBAR_).TEXTE


															GUI__PROP_VALEUR		= CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__PROGRESSBAR(_INDEX_PROGRESSBAR_).VALEUR

															' Pour la barre de progression, ne pas passer en dessous de 0% et pas depasser 100%
															IF GUI__PROP_VALEUR > 100 Then
																GUI__PROP_VALEUR = 100
															ElseIf GUI__PROP_VALEUR < 0 Then
																GUI__PROP_VALEUR = 0
															End if


															' Si ce texte est editable
															GUI__PROP_TYPE_Editable	= CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__PROGRESSBAR(_INDEX_PROGRESSBAR_).PROP_TYPE.Editable

															GUI__PROP_TYPE_MultiLignes	= CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__PROGRESSBAR(_INDEX_PROGRESSBAR_).PROP_TYPE.Multi_Lignes

															GUI__PROP_AUTOSIZE 		= CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__PROGRESSBAR(_INDEX_PROGRESSBAR_).PROP_TYPE.AutoSizeIMG

															CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__PROGRESSBAR(_INDEX_PROGRESSBAR_).DejaSize = FALSE


															' Couleur de la fenetre en general  ===> GUI__PROP_COULEURFENETRE
															IF CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__PROGRESSBAR(_INDEX_PROGRESSBAR_).PROP_TYPE.Couleur_FNT_R < 1 Then
																ADD_NUM_R = "000"
															ElseIF CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__PROGRESSBAR(_INDEX_PROGRESSBAR_).PROP_TYPE.Couleur_R < 10 Then
																ADD_NUM_R = "00"
															ElseIF CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__PROGRESSBAR(_INDEX_PROGRESSBAR_).PROP_TYPE.Couleur_R < 100 Then
																ADD_NUM_R = "0"
															End if

															IF CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__PROGRESSBAR(_INDEX_PROGRESSBAR_).PROP_TYPE.Couleur_FNT_V < 1 Then
																ADD_NUM_V = "000"
															ElseIF CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__PROGRESSBAR(_INDEX_PROGRESSBAR_).PROP_TYPE.Couleur_FNT_V < 10 Then
																ADD_NUM_V = "00"
															ElseIF CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__PROGRESSBAR(_INDEX_PROGRESSBAR_).PROP_TYPE.Couleur_FNT_V < 100 Then
																ADD_NUM_V = "0"
															End if

															IF CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__PROGRESSBAR(_INDEX_PROGRESSBAR_).PROP_TYPE.Couleur_FNT_B < 1 Then
																ADD_NUM_B = "000"
															ElseIF CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__PROGRESSBAR(_INDEX_PROGRESSBAR_).PROP_TYPE.Couleur_FNT_B < 10 Then
																ADD_NUM_B = "00"
															ElseIF CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__PROGRESSBAR(_INDEX_PROGRESSBAR_).PROP_TYPE.Couleur_FNT_B < 100 Then
																ADD_NUM_B = "0"
															End if
															GUI__PROP_COULEURFENETRE = ADD_NUM_R & CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__PROGRESSBAR(_INDEX_PROGRESSBAR_).PROP_TYPE.Couleur_FNT_R & "," _
																						& ADD_NUM_V & CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__PROGRESSBAR(_INDEX_PROGRESSBAR_).PROP_TYPE.Couleur_FNT_V & ","_
																						& ADD_NUM_B & CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__PROGRESSBAR(_INDEX_PROGRESSBAR_).PROP_TYPE.Couleur_FNT_B

															ADD_NUM_R = "" : ADD_NUM_V = "" : ADD_NUM_B = ""

															' Couleur du conteneur  ===> GUI__PROP_COULEURFOND
															IF CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__PROGRESSBAR(_INDEX_PROGRESSBAR_).PROP_TYPE.Couleur_CTN_R < 1 Then
																ADD_NUM_R = "000"
															ElseIF CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__PROGRESSBAR(_INDEX_PROGRESSBAR_).PROP_TYPE.Couleur_CTN_R < 10 Then
																ADD_NUM_R = "00"
															ElseIF CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__PROGRESSBAR(_INDEX_PROGRESSBAR_).PROP_TYPE.Couleur_CTN_R < 100 Then
																ADD_NUM_R = "0"
															End if

															IF CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__PROGRESSBAR(_INDEX_PROGRESSBAR_).PROP_TYPE.Couleur_CTN_V < 1 Then
																ADD_NUM_V = "000"
															ElseIF CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__PROGRESSBAR(_INDEX_PROGRESSBAR_).PROP_TYPE.Couleur_CTN_V < 10 Then
																ADD_NUM_V = "00"
															ElseIF CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__PROGRESSBAR(_INDEX_PROGRESSBAR_).PROP_TYPE.Couleur_CTN_V < 100 Then
																ADD_NUM_V = "0"
															End if

															IF CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__PROGRESSBAR(_INDEX_PROGRESSBAR_).PROP_TYPE.Couleur_CTN_B < 1 Then
																ADD_NUM_B = "000"
															ElseIF CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__PROGRESSBAR(_INDEX_PROGRESSBAR_).PROP_TYPE.Couleur_CTN_B < 10 Then
																ADD_NUM_B = "00"
															ElseIF CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__PROGRESSBAR(_INDEX_PROGRESSBAR_).PROP_TYPE.Couleur_CTN_B < 100 Then
																ADD_NUM_B = "0"
															End if
															GUI__PROP_COULEURFOND = ADD_NUM_R & CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__PROGRESSBAR(_INDEX_PROGRESSBAR_).PROP_TYPE.Couleur_CTN_R & "," _
																						& ADD_NUM_V & CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__PROGRESSBAR(_INDEX_PROGRESSBAR_).PROP_TYPE.Couleur_CTN_V & ","_
																						& ADD_NUM_B & CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__PROGRESSBAR(_INDEX_PROGRESSBAR_).PROP_TYPE.Couleur_CTN_B

															ADD_NUM_R = "" : ADD_NUM_V = "" : ADD_NUM_B = ""

															' Type
															GUI__PROP_TYPE_OBJ 		= CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__PROGRESSBAR(_INDEX_PROGRESSBAR_).PROP_TYPE.TYPE_OBJ

															' Couleur de fond OUI ou NON
															GUI__PROP_FOND_COULEUR  = CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__PROGRESSBAR(_INDEX_PROGRESSBAR_).PROP_TYPE.Fond_Couleur

															' Bordure
															GUI__PROP_TYPE_BORDURE 	= CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__PROGRESSBAR(_INDEX_PROGRESSBAR_).PROP_TYPE.Bordure

															' Transparence generale  ===> GUI__PROP_COULEURALPHA
															GUI__PROP_COULEURALPHA 	= str(CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__PROGRESSBAR(_INDEX_PROGRESSBAR_).PROP_TYPE.Alpha)

															' Fichier de fonction source pour les evenement des objets
															GUI__PROP_EVENEMENT 	= CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__PROGRESSBAR(_INDEX_PROGRESSBAR_).PROP_TYPE.Fichier_evenement
															GUI__PROP_EVENEMENT_DISPO 	= Ucase(CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__PROGRESSBAR(_INDEX_PROGRESSBAR_).PROP_TYPE.Liste_Evenements)


															Exit for
														End if
													End if
												Next _INDEX_PROGRESSBAR_

											End if

										ElseIF Instr(RetourCCP, ":CHECKBOX_NOM=") > 0 Then
											IUG_CREATION_CHECKBOX = MID(RetourCCP, Instr(RetourCCP, ":CHECKBOX_NOM=") + 14)

											GUI__PROP_AUTOSIZE = 1

											IF Modification_IUG = True Then
												For _INDEX_CHECKBOX_ = 0 to CPCDOS_INSTANCE._MAX_GUI_CHECKBOX

													IF IUG_CREATION_CHECKBOX = CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__CHECKBOX(_INDEX_CHECKBOX_).Identification_Objet.Nom Then

														' Verifier si la cle d'identification KERNEL, OS, USER, et PID est identique
														IF CPCDOS_INSTANCE.get_id_kernel(_CLE_) 		= CPCDOS_INSTANCE.get_id_kernel(CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__CHECKBOX(_INDEX_CHECKBOX_).Identification_Objet._CLE_) AND _
															CPCDOS_INSTANCE.get_id_OS(_CLE_) 			= CPCDOS_INSTANCE.get_id_OS(CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__CHECKBOX(_INDEX_CHECKBOX_).Identification_Objet._CLE_) AND _
															CPCDOS_INSTANCE.get_id_Utilisateur(_CLE_) 	= CPCDOS_INSTANCE.get_id_Utilisateur(CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__CHECKBOX(_INDEX_CHECKBOX_).Identification_Objet._CLE_) AND _
															CPCDOS_INSTANCE.get_id_PID(_CLE_) 			= CPCDOS_INSTANCE.get_id_PID(CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__CHECKBOX(_INDEX_CHECKBOX_).Identification_Objet._CLE_) Then

															Dim ADD_NUM_R as String
															Dim ADD_NUM_V as String
															Dim ADD_NUM_B as String


															IF CPCDOS_INSTANCE.SYSTEME_INSTANCE.get_DBG_DEBUG() > 0 Then
																IF CPCDOS_INSTANCE.Utilisateur_Langage = 0 Then
																	DEBUG("[CpcdosC+] GUI --> Mode edition d'un check box'" & IUG_CREATION_CHECKBOX & "' UID:" & CPCDOS_INSTANCE.get_id_Utilisateur(_CLE_) & " PID:" & CPCDOS_INSTANCE.get_id_PID(_CLE_) & " TID:" & CPCDOS_INSTANCE.get_id_TID(_CLE_), Affichage, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_ACTION, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.AvecDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_CPCDOS, RetourVAR)
																Else
																	DEBUG("[CpcdosC+] GUI --> Check box edition mode for '" & IUG_CREATION_CHECKBOX & "' UID:" & CPCDOS_INSTANCE.get_id_Utilisateur(_CLE_) & " PID:" & CPCDOS_INSTANCE.get_id_PID(_CLE_) & " TID:" & CPCDOS_INSTANCE.get_id_TID(_CLE_), Affichage, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_ACTION, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.AvecDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_CPCDOS, RetourVAR)
																End If
															End if

															IF CPCDOS_INSTANCE.SYSTEME_INSTANCE.get_DBG_DEBUG() > 0 Then
																IF CPCDOS_INSTANCE.Utilisateur_Langage = 0 Then
																	DEBUG("[CpcdosC+] Recuperation des proprietes grahpiques en memoire...", Affichage, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_ACTION, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.AvecDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_CPCDOS, RetourVAR)
																Else
																	DEBUG("[CpcdosC+] Recovery graphical properties in memory...", Affichage, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_ACTION, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.AvecDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_CPCDOS, RetourVAR)
																End If
															End if

															' Couleur du textebox ===> GUI__PROP_COULEURFOND
															CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.TEMP_GUI__CHECKBOX.PROP_TYPE.Couleur_CTN_R = val(Mid(GUI__PROP_COULEURFOND, 1, 3))
															CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.TEMP_GUI__CHECKBOX.PROP_TYPE.Couleur_CTN_V = val(Mid(GUI__PROP_COULEURFOND, 5, 3))
															CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.TEMP_GUI__CHECKBOX.PROP_TYPE.Couleur_CTN_B = val(Mid(GUI__PROP_COULEURFOND, 9, 3))

															' Couleur de la police d'ecriture ===> GUI__PROP_COULEURTEXTE
															CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.TEMP_GUI__CHECKBOX.PROP_TYPE.Couleur_FNT_R = val(Mid(GUI__PROP_COULEURTEXTE, 1, 3))
															CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.TEMP_GUI__CHECKBOX.PROP_TYPE.Couleur_FNT_V = val(Mid(GUI__PROP_COULEURTEXTE, 5, 3))
															CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.TEMP_GUI__CHECKBOX.PROP_TYPE.Couleur_FNT_B = val(Mid(GUI__PROP_COULEURTEXTE, 9, 3))

															' Transparence generale  ===> GUI_PROP_COULEURALPHA
															CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.TEMP_GUI__CHECKBOX.PROP_TYPE.Alpha = val(GUI__PROP_COULEURALPHA)

															' Bordure
															CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.TEMP_GUI__CHECKBOX.PROP_TYPE.Bordure = GUI__PROP_TYPE_BORDURE

															'Fond couleur
															CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.TEMP_GUI__CHECKBOX.PROP_TYPE.Fond_Couleur = GUI__PROP_FOND_COULEUR

															' Evenement
															CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.TEMP_GUI__CHECKBOX.PROP_TYPE.Fichier_evenement = GUI__PROP_EVENEMENT
															CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.TEMP_GUI__CHECKBOX.PROP_TYPE.Liste_Evenements = GUI__PROP_EVENEMENT_DISPO

															GUI__DEJA_INITIALISE	= TRUE

															' Proprietes d'identification du Processus hebergeur
															GUI__PROC_PARENT	 	= CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__CHECKBOX(_INDEX_CHECKBOX_).Identification_Objet.Proc_PARENT
															GUI__PID_PARENT			= CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__CHECKBOX(_INDEX_CHECKBOX_).Identification_Objet.PID_PARENT

															' Proprietes d'identification du Thread executif
															GUI__THREAD_PARENT	 	= CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__CHECKBOX(_INDEX_CHECKBOX_).Identification_Objet.THREAD_PARENT
															GUI__TID_PARENT			= CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__CHECKBOX(_INDEX_CHECKBOX_).Identification_Objet.TID_PARENT

															' Proprietes d'identification d'Objet graphique hebergeur
															GUI__Fenetre_PARENT 	= CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__CHECKBOX(_INDEX_CHECKBOX_).Identification_Objet.Fenetre_PARENT
															GUI__Index_FNT_PARENT 	= CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__CHECKBOX(_INDEX_CHECKBOX_).Identification_Objet.Index_FNT_PARENT
															GUI__Handle_PARENT 		= CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__CHECKBOX(_INDEX_CHECKBOX_).Identification_Objet.Handle_PARENT

															' Proprietes d'identification de l'Objet concerne
															GUI__Nom				= CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__CHECKBOX(_INDEX_CHECKBOX_).Identification_Objet.Nom
															CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__CHECKBOX(_INDEX_CHECKBOX_).Identification_Objet.Index_ENFANT = _INDEX_CHECKBOX_
															GUI__Index_ENFANT		= _INDEX_PROGRESSBAR_
															GUI__Handle				= CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__CHECKBOX(_INDEX_CHECKBOX_).Identification_Objet.handle

															IUG_CREATION_CHECKBOX = GUI__Nom

															Nouvelle_Cle_GUI 		= CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__CHECKBOX(_INDEX_CHECKBOX_).Identification_Objet._CLE_
															Nouvelle_OS_ID 			= CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__CHECKBOX(_INDEX_CHECKBOX_).Identification_Objet.OS_id

															GUI__PROP_TYPE 			= CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__CHECKBOX(_INDEX_CHECKBOX_).PROP_TYPE.LES_TYPES

															' Proprietes uniques de l'objet concerne
															GUI__PROP_UPDATER 		= CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__CHECKBOX(_INDEX_CHECKBOX_).IUG_UPDATER
															GUI__THREAD_OK	 		= CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__CHECKBOX(_INDEX_CHECKBOX_).THREAD_OK

															GUI__PROP_PX 			= CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__CHECKBOX(_INDEX_CHECKBOX_).POS_X
															GUI__PROP_PY 			= CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__CHECKBOX(_INDEX_CHECKBOX_).POS_Y

															GUI__PROP_TX 			= CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__CHECKBOX(_INDEX_CHECKBOX_).SIZ_X
															GUI__PROP_TY 			= CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__CHECKBOX(_INDEX_CHECKBOX_).SIZ_Y


															GUI__PROP_IMAGE_ID		= CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__CHECKBOX(_INDEX_CHECKBOX_).IMG_ID
															GUI__PROP_IMAGE_fond_ID	= CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__CHECKBOX(_INDEX_CHECKBOX_).IMG_fond_ID
															GUI__PROP_IMAGE_ORG_ID	= CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__CHECKBOX(_INDEX_CHECKBOX_).IMG_ORG_ID


															' Texte par defaut
															GUI__PROP_TEXTE			= CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__CHECKBOX(_INDEX_CHECKBOX_).TEXTE


															GUI__PROP_VALEUR		= CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__CHECKBOX(_INDEX_CHECKBOX_).VALEUR

															' Pour la barre de progression, ne pas passer en dessous de 0% et pas depasser 100%
															IF GUI__PROP_VALEUR > 100 Then
																GUI__PROP_VALEUR = 100
															ElseIf GUI__PROP_VALEUR < 0 Then
																GUI__PROP_VALEUR = 0
															End if


															' Si ce texte est editable
															GUI__PROP_TYPE_Editable	= CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__CHECKBOX(_INDEX_CHECKBOX_).PROP_TYPE.Editable

															GUI__PROP_AUTOSIZE 		= CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__CHECKBOX(_INDEX_CHECKBOX_).PROP_TYPE.AutoSizeIMG

															CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__CHECKBOX(_INDEX_CHECKBOX_).DejaSize = FALSE


															' Couleur de la fenetre en general  ===> GUI__PROP_COULEURFENETRE
															IF CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__CHECKBOX(_INDEX_CHECKBOX_).PROP_TYPE.Couleur_FNT_R < 1 Then
																ADD_NUM_R = "000"
															ElseIF CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__CHECKBOX(_INDEX_CHECKBOX_).PROP_TYPE.Couleur_R < 10 Then
																ADD_NUM_R = "00"
															ElseIF CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__CHECKBOX(_INDEX_CHECKBOX_).PROP_TYPE.Couleur_R < 100 Then
																ADD_NUM_R = "0"
															End if

															IF CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__CHECKBOX(_INDEX_CHECKBOX_).PROP_TYPE.Couleur_FNT_V < 1 Then
																ADD_NUM_V = "000"
															ElseIF CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__CHECKBOX(_INDEX_CHECKBOX_).PROP_TYPE.Couleur_FNT_V < 10 Then
																ADD_NUM_V = "00"
															ElseIF CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__CHECKBOX(_INDEX_CHECKBOX_).PROP_TYPE.Couleur_FNT_V < 100 Then
																ADD_NUM_V = "0"
															End if

															IF CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__CHECKBOX(_INDEX_CHECKBOX_).PROP_TYPE.Couleur_FNT_B < 1 Then
																ADD_NUM_B = "000"
															ElseIF CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__CHECKBOX(_INDEX_CHECKBOX_).PROP_TYPE.Couleur_FNT_B < 10 Then
																ADD_NUM_B = "00"
															ElseIF CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__CHECKBOX(_INDEX_CHECKBOX_).PROP_TYPE.Couleur_FNT_B < 100 Then
																ADD_NUM_B = "0"
															End if
															GUI__PROP_COULEURFENETRE = ADD_NUM_R & CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__CHECKBOX(_INDEX_CHECKBOX_).PROP_TYPE.Couleur_FNT_R & "," _
																						& ADD_NUM_V & CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__CHECKBOX(_INDEX_CHECKBOX_).PROP_TYPE.Couleur_FNT_V & ","_
																						& ADD_NUM_B & CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__CHECKBOX(_INDEX_CHECKBOX_).PROP_TYPE.Couleur_FNT_B

															ADD_NUM_R = "" : ADD_NUM_V = "" : ADD_NUM_B = ""

															' Couleur du conteneur  ===> GUI__PROP_COULEURFOND
															IF CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__CHECKBOX(_INDEX_CHECKBOX_).PROP_TYPE.Couleur_CTN_R < 1 Then
																ADD_NUM_R = "000"
															ElseIF CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__CHECKBOX(_INDEX_CHECKBOX_).PROP_TYPE.Couleur_CTN_R < 10 Then
																ADD_NUM_R = "00"
															ElseIF CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__CHECKBOX(_INDEX_CHECKBOX_).PROP_TYPE.Couleur_CTN_R < 100 Then
																ADD_NUM_R = "0"
															End if

															IF CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__CHECKBOX(_INDEX_CHECKBOX_).PROP_TYPE.Couleur_CTN_V < 1 Then
																ADD_NUM_V = "000"
															ElseIF CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__CHECKBOX(_INDEX_CHECKBOX_).PROP_TYPE.Couleur_CTN_V < 10 Then
																ADD_NUM_V = "00"
															ElseIF CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__CHECKBOX(_INDEX_CHECKBOX_).PROP_TYPE.Couleur_CTN_V < 100 Then
																ADD_NUM_V = "0"
															End if

															IF CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__CHECKBOX(_INDEX_CHECKBOX_).PROP_TYPE.Couleur_CTN_B < 1 Then
																ADD_NUM_B = "000"
															ElseIF CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__CHECKBOX(_INDEX_CHECKBOX_).PROP_TYPE.Couleur_CTN_B < 10 Then
																ADD_NUM_B = "00"
															ElseIF CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__CHECKBOX(_INDEX_CHECKBOX_).PROP_TYPE.Couleur_CTN_B < 100 Then
																ADD_NUM_B = "0"
															End if
															GUI__PROP_COULEURFOND = ADD_NUM_R & CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__CHECKBOX(_INDEX_CHECKBOX_).PROP_TYPE.Couleur_CTN_R & "," _
																						& ADD_NUM_V & CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__CHECKBOX(_INDEX_CHECKBOX_).PROP_TYPE.Couleur_CTN_V & ","_
																						& ADD_NUM_B & CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__CHECKBOX(_INDEX_CHECKBOX_).PROP_TYPE.Couleur_CTN_B

															ADD_NUM_R = "" : ADD_NUM_V = "" : ADD_NUM_B = ""

															' Type
															GUI__PROP_TYPE_OBJ 		= CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__CHECKBOX(_INDEX_CHECKBOX_).PROP_TYPE.TYPE_OBJ

															' Couleur de fond OUI ou NON
															GUI__PROP_FOND_COULEUR  = CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__CHECKBOX(_INDEX_CHECKBOX_).PROP_TYPE.Fond_Couleur

															' Bordure
															GUI__PROP_TYPE_BORDURE 	= CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__CHECKBOX(_INDEX_CHECKBOX_).PROP_TYPE.Bordure

															' Transparence generale  ===> GUI__PROP_COULEURALPHA
															GUI__PROP_COULEURALPHA 	= str(CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__CHECKBOX(_INDEX_CHECKBOX_).PROP_TYPE.Alpha)

															' Fichier de fonction source pour les evenement des objets
															GUI__PROP_EVENEMENT 	= CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__CHECKBOX(_INDEX_CHECKBOX_).PROP_TYPE.Fichier_evenement
															GUI__PROP_EVENEMENT_DISPO 	= Ucase(CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__CHECKBOX(_INDEX_CHECKBOX_).PROP_TYPE.Liste_Evenements)

															Exit for
														End if
													End if
												Next _INDEX_CHECKBOX_

											End if


										' Les fins des declaration d'objets
										ELSEIF Instr(RetourCCP, "IUG:FENETRE_FIN") > 0 Then
											IUG_CREATION_FENETRE = ""
										ELSEIF Instr(RetourCCP, "IUG:BOUTON_FIN") > 0 Then
											IUG_CREATION_BOUTON = ""
										ELSEIF Instr(RetourCCP, "IUG:PICTUREBOX_FIN") > 0 Then
											IUG_CREATION_PICTUREBOX = ""
										ELSEIF Instr(RetourCCP, "IUG:TEXTEBLOC_FIN") > 0 Then
											IUG_CREATION_TEXTEBLOCK = ""
										ELSEIF Instr(RetourCCP, "IUG:TEXTBOX_FIN") > 0 Then
											IUG_CREATION_TEXTEBOX = ""
										ELSEIF Instr(RetourCCP, "IUG:PROGRESSBAR_FIN") > 0 Then
											IUG_CREATION_PROGRESSBAR = ""
										ELSEIF Instr(RetourCCP, "IUG:CHECKBOX_FIN") > 0 Then
											IUG_CREATION_CHECKBOX = ""


										' **** Proprietes graphiques ****
										ELSEIF Instr(RetourCCP, "IUG:PROP_TITRE=") > 0 Then
											IF Instr(RetourCCP, "#@#RETOUR-VAL#") > 0 Then
												CpcdosCP_SHELL("FIX/ " & MID(RetourCCP, Instr(RetourCCP, "#@#RETOUR-VAL#") + 14) & " = " & GUI__PROP_TITRE, Nouvelle_Cle, Niveau_2, Param_1, Param_2)
												DEBUG(GUI__PROP_TITRE, Affichage, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_Normal, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.SansDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_AFF, RetourVAR)
											else
												GUI__PROP_TITRE = MID(RetourCCP, Instr(RetourCCP, ":PROP_TITRE=") + 12)
											End if
										ELSEIF Instr(RetourCCP, "IUG:PROP_TEXTE=") > 0 Then
											IF Instr(RetourCCP, "#@#RETOUR-VAL#") > 0 Then
												CpcdosCP_SHELL("FIX/ " & MID(RetourCCP, Instr(RetourCCP, "#@#RETOUR-VAL#") + 14) & " = " & GUI__PROP_TEXTE, Nouvelle_Cle, Niveau_2, Param_1, Param_2)
												DEBUG(GUI__PROP_TEXTE, Affichage, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_Normal, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.SansDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_AFF, RetourVAR)
											else
												GUI__PROP_TEXTE = MID(RetourCCP, Instr(RetourCCP, ":PROP_TEXTE=") + 12)
											End if
										ELSEIF Instr(RetourCCP, "IUG:PROP_NOM=") > 0 Then
											IF Instr(RetourCCP, "#@#RETOUR-VAL#") > 0 Then
												CpcdosCP_SHELL("FIX/ " & MID(RetourCCP, Instr(RetourCCP, "#@#RETOUR-VAL#") + 14) & " = " & GUI__Nom, Nouvelle_Cle, Niveau_2, Param_1, Param_2)
												DEBUG(GUI__Nom, Affichage, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_Normal, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.SansDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_AFF, RetourVAR)
											else
												GUI__Nom = MID(RetourCCP, Instr(RetourCCP, ":PROP_NOM=") + 10)
											End if
										ELSEIF Instr(RetourCCP, "IUG:PROP_PID=") > 0 Then
											IF Instr(RetourCCP, "#@#RETOUR-VAL#") > 0 Then
												CpcdosCP_SHELL("FIX/ " & MID(RetourCCP, Instr(RetourCCP, "#@#RETOUR-VAL#") + 14) & " = " & GUI__PID_PARENT, Nouvelle_Cle, Niveau_2, Param_1, Param_2)
												DEBUG(str(GUI__PID_PARENT), Affichage, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_Normal, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.SansDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_AFF, RetourVAR)
											else
												GUI__PID_PARENT = Val(MID(RetourCCP, Instr(RetourCCP, ":PROP_PID=") + 10))
											End if
										ELSEIF Instr(RetourCCP, "IUG:PROP_HANDLE=") > 0 Then
											IF Instr(RetourCCP, "#@#RETOUR-VAL#") > 0 Then
												CpcdosCP_SHELL("FIX/ " & MID(RetourCCP, Instr(RetourCCP, "#@#RETOUR-VAL#") + 14) & " = " & GUI__Handle_PARENT, Nouvelle_Cle, Niveau_2, Param_1, Param_2)
												DEBUG(str(GUI__Handle_PARENT), Affichage, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_Normal, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.SansDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_AFF, RetourVAR)
											else
												GUI__Handle_PARENT = Val(MID(RetourCCP, Instr(RetourCCP, ":PROP_HANDLE=") + 13))
											End if
										ELSEIF Instr(RetourCCP, "IUG:PROP_TYPE=") > 0 Then
											IF Instr(RetourCCP, "#@#RETOUR-VAL#") > 0 Then
												CpcdosCP_SHELL("FIX/ " & MID(RetourCCP, Instr(RetourCCP, "#@#RETOUR-VAL#") + 14) & " = " & GUI__PROP_TYPE, Nouvelle_Cle, Niveau_2, Param_1, Param_2)
												DEBUG(GUI__PROP_TYPE, Affichage, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_Normal, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.SansDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_AFF, RetourVAR)
											else
												GUI__PROP_TYPE = ucase(MID(RetourCCP, Instr(RetourCCP, ":PROP_TYPE=") + 11))




												' *** Detection des parametres ***

												' UPD=UPDate pour creer un thread qui met a jour constament le contenu
												IF INSTR(GUI__PROP_TYPE, "UPD:0") > 0 Then GUI__PROP_UPDATER = 0
												IF INSTR(GUI__PROP_TYPE, "UPD:1") > 0 Then GUI__PROP_UPDATER = 1

												' Afficher barre de titre cliquable
												IF INSTR(GUI__PROP_TYPE, "CTN:0") > 0 Then GUI__PROP_CONTENEUR_COMPLET = FALSE
												IF INSTR(GUI__PROP_TYPE, "CTN:1") > 0 Then GUI__PROP_CONTENEUR_COMPLET = TRUE


												' Modes d'alpha (0: (defaut) TOUT , 1:Conteneur, 2:Barre de titre)
												IF INSTR(GUI__PROP_TYPE, "ALPHAMODE:0") > 0 Then GUI__PROP_ALPHA_MODE = 0
												IF INSTR(GUI__PROP_TYPE, "ALPHAMODE:1") > 0 Then GUI__PROP_ALPHA_MODE = 1
												IF INSTR(GUI__PROP_TYPE, "ALPHAMODE:2") > 0 Then GUI__PROP_ALPHA_MODE = 2

												IF INSTR(GUI__PROP_TYPE, "COL:0") > 0 Then GUI__PROP_FOND_COULEUR = FALSE
												IF INSTR(GUI__PROP_TYPE, "COL:1") > 0 Then GUI__PROP_FOND_COULEUR = TRUE

												' Mode d'affichage image
												IF INSTR(GUI__PROP_TYPE, "IMGAUTO:0") > 0 Then GUI__PROP_AUTOSIZE = 0 ' Par defaut
												IF INSTR(GUI__PROP_TYPE, "IMGAUTO:1") > 0 Then GUI__PROP_AUTOSIZE = 1 ' Adapte a l'image
												IF INSTR(GUI__PROP_TYPE, "IMGAUTO:2") > 0 Then GUI__PROP_AUTOSIZE = 2 ' Adapte au picturebox appel les fonctions de resize

												' Type de fenetre
												IF INSTR(GUI__PROP_TYPE, "TYPE:0") > 0 Then GUI__PROP_TYPE_OBJ = 0
												IF INSTR(GUI__PROP_TYPE, "TYPE:1") > 0 Then GUI__PROP_TYPE_OBJ = 1
												IF INSTR(GUI__PROP_TYPE, "TYPE:2") > 0 Then GUI__PROP_TYPE_OBJ = 2
												IF INSTR(GUI__PROP_TYPE, "TYPE:3") > 0 Then GUI__PROP_TYPE_OBJ = 3
												IF INSTR(GUI__PROP_TYPE, "TYPE:4") > 0 Then GUI__PROP_TYPE_OBJ = 4
												IF INSTR(GUI__PROP_TYPE, "TYPE:5") > 0 Then GUI__PROP_TYPE_OBJ = 5
												IF INSTR(GUI__PROP_TYPE, "TYPE:6") > 0 Then GUI__PROP_TYPE_OBJ = 6
												IF INSTR(GUI__PROP_TYPE, "TYPE:7") > 0 Then GUI__PROP_TYPE_OBJ = 7
												IF INSTR(GUI__PROP_TYPE, "TYPE:8") > 0 Then GUI__PROP_TYPE_OBJ = 8

												IF INSTR(GUI__PROP_TYPE, "BORD:0") > 0 Then GUI__PROP_TYPE_BORDURE = 0
												IF INSTR(GUI__PROP_TYPE, "BORD:1") > 0 Then GUI__PROP_TYPE_BORDURE = 1
												IF INSTR(GUI__PROP_TYPE, "BORD:2") > 0 Then GUI__PROP_TYPE_BORDURE = 2
												IF INSTR(GUI__PROP_TYPE, "BORD:3") > 0 Then GUI__PROP_TYPE_BORDURE = 3
												IF INSTR(GUI__PROP_TYPE, "BORD:4") > 0 Then GUI__PROP_TYPE_BORDURE = 4
												IF INSTR(GUI__PROP_TYPE, "BORD:5") > 0 Then GUI__PROP_TYPE_BORDURE = 5

												IF INSTR(GUI__PROP_TYPE, "MOVE:0") > 0 Then GUI__PROP_DEPLACABLE = False
												IF INSTR(GUI__PROP_TYPE, "MOVE:1") > 0 Then GUI__PROP_DEPLACABLE = True

												IF INSTR(GUI__PROP_TYPE, "SIZ:0") > 0 Then GUI__PROP_SIZEABLE_ANGL = False
												IF INSTR(GUI__PROP_TYPE, "SIZ:1") > 0 Then GUI__PROP_SIZEABLE_ANGL = True

												IF INSTR(GUI__PROP_TYPE, "CLOSE:1") > 0 Then GUI__PROP_FERMABLE = True
												IF INSTR(GUI__PROP_TYPE, "CLOSE:0") > 0 Then GUI__PROP_FERMABLE = false

												IF INSTR(GUI__PROP_TYPE, "SIZBTN:0") > 0 Then GUI__PROP_SIZEABLE = False
												IF INSTR(GUI__PROP_TYPE, "SIZBTN:1") > 0 Then GUI__PROP_SIZEABLE = True

												IF INSTR(GUI__PROP_TYPE, "REDUC:0") > 0 Then GUI__PROP_REDUCTABLE = False
												IF INSTR(GUI__PROP_TYPE, "REDUC:1") > 0 Then GUI__PROP_REDUCTABLE = True

												IF INSTR(GUI__PROP_TYPE, "SHADOW:") > 0 Then GUI__PROP_TYPE_Ombre = VAL(MID(GUI__PROP_TYPE, INSTR(GUI__PROP_TYPE, "SHADOW:") + 7, 3))
												IF INSTR(GUI__PROP_TYPE, "OMBRE:") > 0 Then GUI__PROP_TYPE_Ombre = VAL(MID(GUI__PROP_TYPE, INSTR(GUI__PROP_TYPE, "OMBRE:") + 6, 3))

												IF INSTR(GUI__PROP_TYPE, "EDIT:0") > 0 Then GUI__PROP_TYPE_Editable = FALSE
												IF INSTR(GUI__PROP_TYPE, "EDIT:1") > 0 Then GUI__PROP_TYPE_Editable = TRUE

												IF INSTR(GUI__PROP_TYPE, "MODIF:0") > 0 Then GUI__PROP_TYPE_Editable = FALSE
												IF INSTR(GUI__PROP_TYPE, "MODIF:1") > 0 Then GUI__PROP_TYPE_Editable = TRUE


												IF INSTR(GUI__PROP_TYPE, "MULTILINES:0") > 0 Then GUI__PROP_TYPE_MultiLignes = FALSE
												IF INSTR(GUI__PROP_TYPE, "MULTILINES:1") > 0 Then GUI__PROP_TYPE_MultiLignes = TRUE

												IF INSTR(GUI__PROP_TYPE, "MULTILINE:0") > 0 Then GUI__PROP_TYPE_MultiLignes = FALSE
												IF INSTR(GUI__PROP_TYPE, "MULTILINE:1") > 0 Then GUI__PROP_TYPE_MultiLignes = TRUE

												IF INSTR(GUI__PROP_TYPE, "MULTILIGNE:0") > 0 Then GUI__PROP_TYPE_MultiLignes = FALSE
												IF INSTR(GUI__PROP_TYPE, "MULTILIGNE:1") > 0 Then GUI__PROP_TYPE_MultiLignes = TRUE

												IF INSTR(GUI__PROP_TYPE, "MULTILIGNES:0") > 0 Then GUI__PROP_TYPE_MultiLignes = FALSE
												IF INSTR(GUI__PROP_TYPE, "MULTILIGNES:1") > 0 Then GUI__PROP_TYPE_MultiLignes = TRUE

												IF INSTR(GUI__PROP_TYPE, "CONSOLE:0") > 0 Then GUI__PROP_TYPE_Console = FALSE
												IF INSTR(GUI__PROP_TYPE, "CONSOLE:1") > 0 Then GUI__PROP_TYPE_Console = TRUE



											End if

										ELSEIF Instr(RetourCCP, "IUG:PROP_COULEURFENETRE=") > 0 Then
											IF Instr(RetourCCP, "#@#RETOUR-VAL#") > 0 Then
												CpcdosCP_SHELL("FIX/ " & MID(RetourCCP, Instr(RetourCCP, "#@#RETOUR-VAL#") + 14) & " = " & GUI__PROP_COULEURFENETRE, Nouvelle_Cle, Niveau_2, Param_1, Param_2)
												DEBUG(GUI__PROP_COULEURFENETRE, Affichage, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_Normal, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.SansDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_AFF, RetourVAR)
											else
												GUI__PROP_COULEURFENETRE = MID(RetourCCP, Instr(RetourCCP, ":PROP_COULEURFENETRE=") + 21)
											End if
										ELSEIF Instr(RetourCCP, "IUG:PROP_COULEURFOND=") > 0 Then
											IF Instr(RetourCCP, "#@#RETOUR-VAL#") > 0 Then
												CpcdosCP_SHELL("FIX/ " & MID(RetourCCP, Instr(RetourCCP, "#@#RETOUR-VAL#") + 14) & " = " & GUI__PROP_COULEURFOND, Nouvelle_Cle, Niveau_2, Param_1, Param_2)
												DEBUG(GUI__PROP_COULEURFOND, Affichage, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_Normal, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.SansDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_AFF, RetourVAR)
											else
												GUI__PROP_COULEURFOND = MID(RetourCCP, Instr(RetourCCP, ":PROP_COULEURFOND=") + 18)
											End if
										ELSEIF Instr(RetourCCP, "IUG:PROP_COULEURTITRE=") > 0 Then
											IF Instr(RetourCCP, "#@#RETOUR-VAL#") > 0 Then
												CpcdosCP_SHELL("FIX/ " & MID(RetourCCP, Instr(RetourCCP, "#@#RETOUR-VAL#") + 14) & " = " & GUI__PROP_COULEURTITRE, Nouvelle_Cle, Niveau_2, Param_1, Param_2)
												DEBUG(GUI__PROP_COULEURTITRE, Affichage, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_Normal, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.SansDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_AFF, RetourVAR)
											else
												GUI__PROP_COULEURTITRE = MID(RetourCCP, Instr(RetourCCP, ":PROP_COULEURTITRE=") + 19)
											End if
										ELSEIF Instr(RetourCCP, "IUG:PROP_COULEURTEXTE=") > 0 Then
											IF Instr(RetourCCP, "#@#RETOUR-VAL#") > 0 Then
												CpcdosCP_SHELL("FIX/ " & MID(RetourCCP, Instr(RetourCCP, "#@#RETOUR-VAL#") + 14) & " = " & GUI__PROP_COULEURTEXTE, Nouvelle_Cle, Niveau_2, Param_1, Param_2)
												DEBUG(GUI__PROP_COULEURTEXTE, Affichage, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_Normal, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.SansDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_AFF, RetourVAR)
											else
												GUI__PROP_COULEURTEXTE = MID(RetourCCP, Instr(RetourCCP, ":PROP_COULEURTEXTE=") + 19)
											End if
										ELSEIF Instr(RetourCCP, "IUG:PROP_PX=") > 0 Then
											IF Instr(RetourCCP, "#@#RETOUR-VAL#") > 0 Then
												CpcdosCP_SHELL("FIX/ " & MID(RetourCCP, Instr(RetourCCP, "#@#RETOUR-VAL#") + 14) & " = " & GUI__PROP_PX, Nouvelle_Cle, Niveau_2, Param_1, Param_2)
												DEBUG(str(GUI__PROP_PX), Affichage, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_Normal, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.SansDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_AFF, RetourVAR)
											else
												GUI__PROP_PX = Val(MID(RetourCCP, Instr(RetourCCP, ":PROP_PX=") + 9))
											End if
										ELSEIF Instr(RetourCCP, "IUG:PROP_PY=") > 0 Then
											IF Instr(RetourCCP, "#@#RETOUR-VAL#") > 0 Then
												CpcdosCP_SHELL("FIX/ " & MID(RetourCCP, Instr(RetourCCP, "#@#RETOUR-VAL#") + 14) & " = " & GUI__PROP_PY, Nouvelle_Cle, Niveau_2, Param_1, Param_2)
												DEBUG(str(GUI__PROP_PY), Affichage, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_Normal, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.SansDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_AFF, RetourVAR)
											else
												GUI__PROP_PY = Val(MID(RetourCCP, Instr(RetourCCP, ":PROP_PY=") + 9))
											End if
										ELSEIF Instr(RetourCCP, "IUG:PROP_TX=") > 0 Then
											IF Instr(RetourCCP, "#@#RETOUR-VAL#") > 0 Then
												CpcdosCP_SHELL("FIX/ " & MID(RetourCCP, Instr(RetourCCP, "#@#RETOUR-VAL#") + 14) & " = " & GUI__PROP_TX, Nouvelle_Cle, Niveau_2, Param_1, Param_2)
												DEBUG(str(GUI__PROP_TX), Affichage, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_Normal, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.SansDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_AFF, RetourVAR)
											else
												GUI__PROP_TX = Val(MID(RetourCCP, Instr(RetourCCP, ":PROP_TX=") + 9))
											End if
										ELSEIF Instr(RetourCCP, "IUG:PROP_TY=") > 0 Then
											IF Instr(RetourCCP, "#@#RETOUR-VAL#") > 0 Then
												CpcdosCP_SHELL("FIX/ " & MID(RetourCCP, Instr(RetourCCP, "#@#RETOUR-VAL#") + 14) & " = " & GUI__PROP_TY, Nouvelle_Cle, Niveau_2, Param_1, Param_2)
												DEBUG(str(GUI__PROP_TY), Affichage, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_Normal, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.SansDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_AFF, RetourVAR)
											else
												GUI__PROP_TY = Val(MID(RetourCCP, Instr(RetourCCP, ":PROP_TY=") + 9))
											End if
										ELSEIF Instr(RetourCCP, "IUG:ICONE=") > 0 Then
											IF Instr(RetourCCP, "#@#RETOUR-VAL#") > 0 Then
												CpcdosCP_SHELL("FIX/ " & MID(RetourCCP, Instr(RetourCCP, "#@#RETOUR-VAL#") + 14) & " = " & GUI__PROP_ICONE, Nouvelle_Cle, Niveau_2, Param_1, Param_2)
												DEBUG(GUI__PROP_ICONE, Affichage, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_Normal, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.SansDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_AFF, RetourVAR)
											else
												GUI__PROP_ICONE = MID(RetourCCP, Instr(RetourCCP, ":ICONE=") + 7)
											End if
										ELSEIF Instr(RetourCCP, "IUG:IMGTITRE=") > 0 Then
											IF Instr(RetourCCP, "#@#RETOUR-VAL#") > 0 Then
												CpcdosCP_SHELL("FIX/ " & MID(RetourCCP, Instr(RetourCCP, "#@#RETOUR-VAL#") + 14) & " = " & GUI__PROP_IMGTITRE, Nouvelle_Cle, Niveau_2, Param_1, Param_2)
												DEBUG(GUI__PROP_IMGTITRE, Affichage, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_Normal, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.SansDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_AFF, RetourVAR)
											else
												GUI__PROP_IMGTITRE = MID(RetourCCP, Instr(RetourCCP, ":IMGTITRE=") + 10)
											End if
										ELSEIF Instr(RetourCCP, "IUG:IMAGE=") > 0 Then
											IF Instr(RetourCCP, "#@#RETOUR-VAL#") > 0 Then
												CpcdosCP_SHELL("FIX/ " & MID(RetourCCP, Instr(RetourCCP, "#@#RETOUR-VAL#") + 14) & " = " & GUI__PROP_IMAGE, Nouvelle_Cle, Niveau_2, Param_1, Param_2)
												DEBUG(GUI__PROP_IMAGE, Affichage, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_Normal, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.SansDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_AFF, RetourVAR)
											else
												GUI__PROP_IMAGE = LTRIM(MID(RetourCCP, Instr(RetourCCP, ":IMAGE=") + 7))
											End if
										ELSEIF Instr(RetourCCP, "IUG:VALEUR=") > 0 Then
											IF Instr(RetourCCP, "#@#RETOUR-VAL#") > 0 Then


												CpcdosCP_SHELL("FIX/ " & MID(RetourCCP, Instr(RetourCCP, "#@#RETOUR-VAL#") + 14) & " = " & GUI__PROP_VALEUR, Nouvelle_Cle, Niveau_2, Param_1, Param_2)
												DEBUG(str(GUI__PROP_VALEUR), Affichage, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_Normal, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.SansDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_AFF, RetourVAR)
											else
												GUI__PROP_VALEUR = val(LTRIM(MID(RetourCCP, Instr(RetourCCP, ":VALEUR=") + 8)))

											End if
										ELSEIF Instr(RetourCCP, "IUG:PROP_ALPHA=") > 0 Then
											IF Instr(RetourCCP, "#@#RETOUR-VAL#") > 0 Then
												CpcdosCP_SHELL("FIX/ " & MID(RetourCCP, Instr(RetourCCP, "#@#RETOUR-VAL#") + 14) & " = " & GUI__PROP_COULEURALPHA, Nouvelle_Cle, Niveau_2, Param_1, Param_2)
												DEBUG(GUI__PROP_COULEURALPHA, Affichage, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_Normal, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.SansDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_AFF, RetourVAR)
											else
												GUI__PROP_COULEURALPHA = LTRIM(MID(RetourCCP, Instr(RetourCCP, ":PROP_ALPHA=") + 12))
											End if
										ELSEIF Instr(RetourCCP, "IUG:PROP_EVENEMENT=") > 0 Then

											IF Instr(RetourCCP, "#@#RETOUR-VAL#") > 0 Then
												CpcdosCP_SHELL("FIX/ " & MID(RetourCCP, Instr(RetourCCP, "#@#RETOUR-VAL#") + 14) & " = " & GUI__PROP_EVENEMENT, Nouvelle_Cle, Niveau_2, Param_1, Param_2)
												DEBUG(GUI__PROP_EVENEMENT, Affichage, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_Normal, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.SansDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_AFF, RetourVAR)
											else
												GUI__PROP_EVENEMENT = LTRIM(MID(RetourCCP, Instr(RetourCCP, ":PROP_EVENEMENT=") + 16))
												' Si la liste des evenements est indique
												IF Instr(GUI__PROP_EVENEMENT, "=") > 0 Then
													GUI__PROP_EVENEMENT_DISPO = Ucase(LTRIM(MID(GUI__PROP_EVENEMENT, Instr(GUI__PROP_EVENEMENT, "=") + 1)))
													GUI__PROP_EVENEMENT = LTRIM(MID(GUI__PROP_EVENEMENT, 1, Instr(GUI__PROP_EVENEMENT, "=") - 1))
												Else
													GUI__PROP_EVENEMENT_DISPO = ""
												End if
											End if

										' CREATION GRAPHIQUE FINAL !
										ELSEIF Instr(RetourCCP, "IUG:CREER!") > 0 Then
											IF NOT IUG_CREATION_FENETRE = "" Then
												Dim Retour_Resultat as string



												IF Modification_IUG = True Then

													IF GUI__Handle_PARENT > 0  Then
														CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.TEMP_GUI__FENETRE.identification_objet.Handle_PARENT 	= GUI__Handle_PARENT
														' GUI__Handle_PARENT = 0
													End if
												else
													Nouvelle_Cle_GUI = Nouvelle_Cle
												End if


												CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.TEMP_GUI__FENETRE.identification_objet._CLE_ 			= Nouvelle_Cle_GUI
												CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.TEMP_GUI__FENETRE.Identification_Objet.OS_id 			= Nouvelle_OS_ID

												CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.TEMP_GUI__FENETRE.identification_objet.PROC_PARENT		= GUI__PROC_PARENT 		' Nom du processus parent (Optionnel)
												CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.TEMP_GUI__FENETRE.identification_objet.PID_PARENT		= GUI__PID_PARENT 		' PID du parent

												CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.TEMP_GUI__FENETRE.identification_objet.THREAD_PARENT		= GUI__THREAD_PARENT 	' Nom du thread parent (Optionnel)
												CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.TEMP_GUI__FENETRE.identification_objet.TID_PARENT		= GUI__TID_PARENT	 	' Nom du thread parent (Optionnel)

												CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.TEMP_GUI__FENETRE.identification_objet.Fenetre_PARENT 	= GUI__Fenetre_PARENT 	' Nom de la fenetre
												CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.TEMP_GUI__FENETRE.identification_objet.Index_FNT_PARENT 	= GUI__Index_FNT_PARENT ' Index de la fenetre
												CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.TEMP_GUI__FENETRE.identification_objet.Handle_PARENT 	= GUI__Handle_PARENT 	' Handle de la fenetre hebergeur

												CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.TEMP_GUI__FENETRE.identification_objet.NOM				= IUG_CREATION_FENETRE	' Nom de l'objet
												CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.TEMP_GUI__FENETRE.identification_objet.Index_ENFANT		= GUI__Index_ENFANT		' Index de l'objet
												CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.TEMP_GUI__FENETRE.identification_objet.Handle			= GUI__Handle			' Handle de l'objet (Unique)

												CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.TEMP_GUI__FENETRE.TITRE 				= GUI__PROP_TITRE
												CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.TEMP_GUI__FENETRE.POS_TITRE_X		= GUI__PROP_TITRE_PX
												CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.TEMP_GUI__FENETRE.POS_TITRE_Y		= GUI__PROP_TITRE_PY

												CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.TEMP_GUI__FENETRE.TITRE_IMG_ID 			= GUI__PROP_TITRE_IMG_ID
												CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.TEMP_GUI__FENETRE.BUFFER_TITRE_IMG_ID 	= GUI__PROP_BUFFER_TITRE_IMG_ID
												CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.TEMP_GUI__FENETRE.BUFFER_TITRE_2_IMG_ID 	= GUI__PROP_BUFFER_TITRE_2_IMG_ID
												CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.TEMP_GUI__FENETRE.BUFFER_WIN_IMG_ID 		= GUI__PROP_BUFFER_WIN_IMG_ID
												CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.TEMP_GUI__FENETRE.BUFFER_OMBRE_WIN_IMG_ID = GUI__PROP_BUFFER_OMBRE_WIN_IMG_ID


												CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.TEMP_GUI__FENETRE.Initialisation_OK 	= GUI__DEJA_INITIALISE

												CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.TEMP_GUI__FENETRE.POS_X				= GUI__PROP_PX
												CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.TEMP_GUI__FENETRE.POS_Y				= GUI__PROP_PY

												CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.TEMP_GUI__FENETRE.SIZ_X				= GUI__PROP_TX
												CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.TEMP_GUI__FENETRE.SIZ_Y				= GUI__PROP_TY

												CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.TEMP_GUI__FENETRE.CONTENEUR_COMPLET 	= GUI__PROP_CONTENEUR_COMPLET

												CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.TEMP_GUI__FENETRE.Alpha_Mode 		= GUI__PROP_ALPHA_MODE

												CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.TEMP_GUI__FENETRE.IMG_TITRE			= GUI__PROP_IMGTITRE


												' Icone application
												CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.TEMP_GUI__FENETRE.ICONE 						= GUI__PROP_ICONE
												CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.TEMP_GUI__FENETRE.ICONE_IMG_ID				= GUI__PROP_ICONE_IMG_ID
												CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.TEMP_GUI__FENETRE.ICONE_ORG_IMG_ID			= GUI__PROP_ICONE_ORG_IMG_ID
												CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.TEMP_GUI__FENETRE.POS_ICONE_X 				= GUI__PROP_ICONE_PX
												CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.TEMP_GUI__FENETRE.POS_ICONE_Y 				= GUI__PROP_ICONE_PY
												CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.TEMP_GUI__FENETRE.POS_ICONE_POS 				= GUI__PROP_ICONE_POS
												CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.TEMP_GUI__FENETRE.SIZ_ICONE_X 				= GUI__PROP_ICONE_TX
												CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.TEMP_GUI__FENETRE.SIZ_ICONE_Y 				= GUI__PROP_ICONE_TY
												CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.TEMP_GUI__FENETRE.SIZ_ICONE 					= GUI__PROP_ICONE_T

												' Icone bouton fermeture
												CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.TEMP_GUI__FENETRE.BT_CLOSE					= GUI__PROP_BT_CLOSE
												CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.TEMP_GUI__FENETRE.BT_CLOSE_IMG_ID 			= GUI__PROP_BT_CLOSE_IMG_ID
												CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.TEMP_GUI__FENETRE.BT_CLOSE_ORG_IMG_ID 		= GUI__PROP_BT_CLOSE_ORG_IMG_ID


												CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.TEMP_GUI__FENETRE.POS_BT_CLOSE_X			= GUI__PROP_BT_CLOSE_PX
												CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.TEMP_GUI__FENETRE.POS_BT_CLOSE_Y			= GUI__PROP_BT_CLOSE_PY
												CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.TEMP_GUI__FENETRE.POS_BT_CLOSE_POS		= GUI__PROP_BT_CLOSE_POS
												CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.TEMP_GUI__FENETRE.SIZ_BT_CLOSE_X			= GUI__PROP_BT_CLOSE_TX
												CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.TEMP_GUI__FENETRE.SIZ_BT_CLOSE_Y			= GUI__PROP_BT_CLOSE_TY
												CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.TEMP_GUI__FENETRE.SIZ_BT_CLOSE			= GUI__PROP_BT_CLOSE_T

												' Icone bouton agrandissement
												CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.TEMP_GUI__FENETRE.BT_SIZEUP				= GUI__PROP_BT_SIZEUP
												CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.TEMP_GUI__FENETRE.POS_BT_SIZEUP_X		= GUI__PROP_BT_SIZEUP_PX
												CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.TEMP_GUI__FENETRE.POS_BT_SIZEUP_Y		= GUI__PROP_BT_SIZEUP_PY
												CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.TEMP_GUI__FENETRE.POS_BT_SIZEUP_POS		= GUI__PROP_BT_SIZEUP_POS
												CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.TEMP_GUI__FENETRE.SIZ_BT_SIZEUP_X		= GUI__PROP_BT_SIZEUP_TX
												CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.TEMP_GUI__FENETRE.SIZ_BT_SIZEUP_Y		= GUI__PROP_BT_SIZEUP_TY
												CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.TEMP_GUI__FENETRE.SIZ_BT_SIZEUP			= GUI__PROP_BT_SIZEUP_T

												' Icone application
												CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.TEMP_GUI__FENETRE.BT_SIZEDOWN			= GUI__PROP_BT_SIZEDOWN
												CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.TEMP_GUI__FENETRE.POS_BT_SIZEDOWN_X 		= GUI__PROP_BT_SIZEDOWN_PX
												CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.TEMP_GUI__FENETRE.POS_BT_SIZEDOWN_Y		= GUI__PROP_BT_SIZEDOWN_PY
												CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.TEMP_GUI__FENETRE.POS_BT_SIZEDOWN_POS 	= GUI__PROP_BT_SIZEDOWN_POS
												CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.TEMP_GUI__FENETRE.SIZ_BT_SIZEDOWN_X		= GUI__PROP_BT_SIZEDOWN_TX
												CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.TEMP_GUI__FENETRE.SIZ_BT_SIZEDOWN_Y		= GUI__PROP_BT_SIZEDOWN_TY
												CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.TEMP_GUI__FENETRE.SIZ_BT_SIZEDOWN		= GUI__PROP_BT_SIZEDOWN_T

												' Icone application
												CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.TEMP_GUI__FENETRE.BT_REDUCT				= GUI__PROP_BT_REDUCT
												CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.TEMP_GUI__FENETRE.POS_BT_REDUCT_X		= GUI__PROP_BT_REDUCT_PX
												CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.TEMP_GUI__FENETRE.POS_BT_REDUCT_Y		= GUI__PROP_BT_REDUCT_PY
												CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.TEMP_GUI__FENETRE.POS_BT_REDUCT_POS		= GUI__PROP_BT_REDUCT_POS
												CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.TEMP_GUI__FENETRE.SIZ_BT_REDUCT_X		= GUI__PROP_BT_REDUCT_TX
												CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.TEMP_GUI__FENETRE.SIZ_BT_REDUCT_Y		= GUI__PROP_BT_REDUCT_TY
												CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.TEMP_GUI__FENETRE.SIZ_BT_REDUCT			= GUI__PROP_BT_REDUCT_T

												IF GUI__PROP_CONTENEUR_COMPLET = FALSE Then
													CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.TEMP_GUI__FENETRE.SIZ_TITRE		= GUI__PROP_TTITRE
												Else
													CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.TEMP_GUI__FENETRE.SIZ_TITRE		= 0
												End if

												CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.TEMP_GUI__FENETRE.PROP_TYPE.LES_TYPES = GUI__PROP_TYPE

												' Couleur de la fenetre en general  ===> GUI__PROP_COULEURFENETRE
												CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.TEMP_GUI__FENETRE.PROP_TYPE.Couleur_R = val(Mid(GUI__PROP_COULEURFENETRE, 1, 3))
												CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.TEMP_GUI__FENETRE.PROP_TYPE.Couleur_V = val(Mid(GUI__PROP_COULEURFENETRE, 5, 3))
												CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.TEMP_GUI__FENETRE.PROP_TYPE.Couleur_B = val(Mid(GUI__PROP_COULEURFENETRE, 9, 3))

												' Couleur du conteneur  ===> GUI__PROP_COULEURFOND
												CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.TEMP_GUI__FENETRE.PROP_TYPE.Couleur_CTN_R = val(Mid(GUI__PROP_COULEURFOND, 1, 3))
												CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.TEMP_GUI__FENETRE.PROP_TYPE.Couleur_CTN_V = val(Mid(GUI__PROP_COULEURFOND, 5, 3))
												CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.TEMP_GUI__FENETRE.PROP_TYPE.Couleur_CTN_B = val(Mid(GUI__PROP_COULEURFOND, 9, 3))

												' Couleur du titre de la fenetre  ===> GUI__PROP_COULEURTITRE
												CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.TEMP_GUI__FENETRE.PROP_TYPE.Couleur_TITRE_R = val(Mid(GUI__PROP_COULEURTITRE, 1, 3))
												CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.TEMP_GUI__FENETRE.PROP_TYPE.Couleur_TITRE_V = val(Mid(GUI__PROP_COULEURTITRE, 5, 3))
												CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.TEMP_GUI__FENETRE.PROP_TYPE.Couleur_TITRE_B = val(Mid(GUI__PROP_COULEURTITRE, 9, 3))

												' Couleur de l'ombre sous la fenetre  ===> GUI__PROP_TYPE_Ombre_RVB
												CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.TEMP_GUI__FENETRE.PROP_TYPE.Couleur_OMBRE_R = val(Mid(GUI__PROP_TYPE_Ombre_RVB, 1, 3))
												CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.TEMP_GUI__FENETRE.PROP_TYPE.Couleur_OMBRE_V = val(Mid(GUI__PROP_TYPE_Ombre_RVB, 5, 3))
												CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.TEMP_GUI__FENETRE.PROP_TYPE.Couleur_OMBRE_B = val(Mid(GUI__PROP_TYPE_Ombre_RVB, 9, 3))

												CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.TEMP_GUI__FENETRE.PROP_TYPE.Ombre_PX = GUI__PROP_OMBRE_PX
												CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.TEMP_GUI__FENETRE.PROP_TYPE.Ombre_PY = GUI__PROP_OMBRE_PY

												' Type
												CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.TEMP_GUI__FENETRE.PROP_TYPE.TYPE_OBJ = GUI__PROP_TYPE_OBJ

												' Bordure
												CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.TEMP_GUI__FENETRE.PROP_TYPE.Bordure = GUI__PROP_TYPE_BORDURE

												' Deplacable
												CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.TEMP_GUI__FENETRE.PROP_TYPE.Deplacable 		= GUI__PROP_DEPLACABLE

												CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.TEMP_GUI__FENETRE.PROP_TYPE.Reductable 		= GUI__PROP_REDUCTABLE
												CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.TEMP_GUI__FENETRE.PROP_TYPE.Sizeable 		= GUI__PROP_SIZEABLE
												CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.TEMP_GUI__FENETRE.PROP_TYPE.Sizeable_ANGL 	= GUI__PROP_SIZEABLE_ANGL
												CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.TEMP_GUI__FENETRE.PROP_TYPE.Fermable 		= GUI__PROP_FERMABLE

												' Ombre sous la fenetre
												CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.TEMP_GUI__FENETRE.PROP_TYPE.Ombre = GUI__PROP_TYPE_Ombre


												' Transparence generale  ===> GUI__PROP_COULEURALPHA
												CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.TEMP_GUI__FENETRE.PROP_TYPE.Alpha = val(GUI__PROP_COULEURALPHA)

												' Fichier de fonction source pour les evenement des objets
												CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.TEMP_GUI__FENETRE.PROP_TYPE.Fichier_evenement = GUI__PROP_EVENEMENT
												CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.TEMP_GUI__FENETRE.PROP_TYPE.Liste_Evenements = GUI__PROP_EVENEMENT_DISPO


												' Cette partie permet de gagner des performances en autorisant seulement la recherche
												'  de quelques evenements. Si rien n'est precise, il recherchera tout.
												IF Len(GUI__PROP_EVENEMENT_DISPO) > 0 Then

													' Si le developpeur precise les evenements alors on interdit tout
													CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.TEMP_GUI__FENETRE.PROP_TYPE.EV_Click			= FALSE
													CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.TEMP_GUI__FENETRE.PROP_TYPE.EV_MouseEnter	= FALSE
													CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.TEMP_GUI__FENETRE.PROP_TYPE.EV_MouseMove		= FALSE
													CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.TEMP_GUI__FENETRE.PROP_TYPE.EV_MouseLeave	= FALSE
													CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.TEMP_GUI__FENETRE.PROP_TYPE.EV_MouseClick	= FALSE
													CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.TEMP_GUI__FENETRE.PROP_TYPE.EV_KeyPress		= FALSE

													' Et on autorise certain evenements
													IF Instr(GUI__PROP_EVENEMENT_DISPO, "CLICK") 		> 0 Then CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.TEMP_GUI__FENETRE.PROP_TYPE.EV_Click 		= TRUE
													IF Instr(GUI__PROP_EVENEMENT_DISPO, "MOUSEENTER") 	> 0 Then CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.TEMP_GUI__FENETRE.PROP_TYPE.EV_MouseEnter 	= TRUE
													IF Instr(GUI__PROP_EVENEMENT_DISPO, "MOUSELEAVE") 	> 0 Then CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.TEMP_GUI__FENETRE.PROP_TYPE.EV_MouseLeave 	= TRUE
													IF Instr(GUI__PROP_EVENEMENT_DISPO, "MOUSEMOVE") 	> 0 Then CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.TEMP_GUI__FENETRE.PROP_TYPE.EV_MouseMove 	= TRUE
													IF Instr(GUI__PROP_EVENEMENT_DISPO, "MOUSECLICK") 	> 0 Then CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.TEMP_GUI__FENETRE.PROP_TYPE.EV_MouseClick 	= TRUE
													IF Instr(GUI__PROP_EVENEMENT_DISPO, "KEYPRESS") 	> 0 Then CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.TEMP_GUI__FENETRE.PROP_TYPE.EV_KeyPress 	= TRUE

												End if

												' On cree la fenetre
												if Modification_IUG = True Then
													Retour_Resultat = str(CPCDOS_INSTANCE.SCI_INSTANCE.CPC__GUI_Init_obj(CPCDOS_INSTANCE.SCI_INSTANCE.GUI_TYPE.Fenetre, CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI, Nouvelle_Cle_GUI, Modification_IUG, GUI__Index_ENFANT))
												else
													Retour_Resultat = str(CPCDOS_INSTANCE.SCI_INSTANCE.CPC__GUI_Init_obj(CPCDOS_INSTANCE.SCI_INSTANCE.GUI_TYPE.Fenetre, CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI, Nouvelle_Cle_GUI, Modification_IUG, 0))
												End if


												' On re-execute la commande mais uniquement pour faire un debug pour recuperer
												'  le numero de PID et pouvoir le socker dans une variable
												' Ca ne vas pas re-creer la fenetre mais ca va simplement renvoyer un texte garce a /#RENVOIDEBUG:
												RetourCCP = CpcdosCP_SHELL(Buffer_lecture & " /#RENVOIDEBUG:" & Retour_Resultat, Nouvelle_Cle_GUI, Niveau_2, Param_1, Param_2)

											ELSEIF NOT IUG_CREATION_BOUTON = "" Then
												Dim Retour_Resultat as string



												IF Modification_IUG = True Then
													IF GUI__Handle_PARENT > 0  Then
														CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.TEMP_GUI__BOUTON.identification_objet.Handle_PARENT = GUI__Handle_PARENT
														' GUI__Handle_PARENT = 0
													End if
												else
													Nouvelle_Cle_GUI = Nouvelle_Cle
												End if

												CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.TEMP_GUI__BOUTON.identification_objet._CLE_ 		= Nouvelle_Cle_GUI
												CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.TEMP_GUI__BOUTON.Identification_Objet.OS_id 		= Nouvelle_OS_ID

												CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.TEMP_GUI__BOUTON.Initialisation_OK = GUI__DEJA_INITIALISE


												CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.TEMP_GUI__BOUTON.identification_objet.PROC_PARENT		= GUI__PROC_PARENT 		' Nom du processus parent (Optionnel)
												CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.TEMP_GUI__BOUTON.identification_objet.PID_PARENT			= GUI__PID_PARENT 		' PID du parent

												CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.TEMP_GUI__BOUTON.identification_objet.THREAD_PARENT		= GUI__THREAD_PARENT 	' Nom du thread parent (Optionnel)
												CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.TEMP_GUI__BOUTON.identification_objet.TID_PARENT			= GUI__TID_PARENT	 	' Nom du thread parent (Optionnel)

												CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.TEMP_GUI__BOUTON.identification_objet.Fenetre_PARENT 	= GUI__Fenetre_PARENT 	' Nom de la fenetre
												CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.TEMP_GUI__BOUTON.identification_objet.Index_FNT_PARENT 	= GUI__Index_FNT_PARENT ' Index de la fenetre
												CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.TEMP_GUI__BOUTON.identification_objet.Handle_PARENT 		= GUI__Handle_PARENT 	' Handle de la fenetre hebergeur

												CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.TEMP_GUI__BOUTON.identification_objet.NOM				= IUG_CREATION_BOUTON	' Nom de l'objet
												CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.TEMP_GUI__BOUTON.identification_objet.Index_ENFANT		= GUI__Index_ENFANT		' Index de l'objet
												CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.TEMP_GUI__BOUTON.identification_objet.Handle				= GUI__Handle			' Handle de l'objet (Unique)

												CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.TEMP_GUI__BOUTON.IMAGE_SURVOLE			= UCASE(CPCDOS_INSTANCE.SHELLCCP_INSTANCE.CCP_Lire_Variable("CPC_GUI.BUTTON.SURVOLE", 3, _CLE_))

												CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.TEMP_GUI__BOUTON.IMAGE_SURVOLE_OPACITE	= Val(CPCDOS_INSTANCE.SHELLCCP_INSTANCE.CCP_Lire_Variable("CPC_GUI.BUTTON.SURVOLE_OPACITE", 3, _CLE_))

												IF CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.TEMP_GUI__BOUTON.IMAGE_SURVOLE_OPACITE < 0 Then
													CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.TEMP_GUI__BOUTON.IMAGE_SURVOLE_OPACITE = 0
												ElseIf CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.TEMP_GUI__BOUTON.IMAGE_SURVOLE_OPACITE > 255 Then
													CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.TEMP_GUI__BOUTON.IMAGE_SURVOLE_OPACITE = 255
												End if

												CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.TEMP_GUI__BOUTON.IMAGE			= GUI__PROP_IMAGE
												CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.TEMP_GUI__BOUTON.IMAGE_ANCIEN 	= GUI__PROP_IMAGE_ANCIEN

												CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.TEMP_GUI__BOUTON.IMG_ID				= GUI__PROP_IMAGE_ID
												CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.TEMP_GUI__BOUTON.IMG_ORG_ID 			= GUI__PROP_IMAGE_ORG_ID
												CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.TEMP_GUI__BOUTON.IMG_SURVOLE_ID 		= GUI__PROP_IMAGE_SURVOLE_ID
												CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.TEMP_GUI__BOUTON.IMG_SURVOLE_ORG_ID 	= GUI__PROP_IMAGE_SURVOLE_ORG_ID

												CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.TEMP_GUI__BOUTON.BIT_ORG			= GUI__PROP_BIT_ORG ' Obtenir le pointeur du context GZE



												CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.TEMP_GUI__BOUTON.IUG_UPDATER = GUI__PROP_UPDATER
												CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.RefreshGUI_Elements_BOUTON += 1

												CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.TEMP_GUI__BOUTON.TEXTE 		= GUI__PROP_TEXTE

												CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.TEMP_GUI__BOUTON.POS_X		= GUI__PROP_PX
												CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.TEMP_GUI__BOUTON.POS_Y		= GUI__PROP_PY

												CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.TEMP_GUI__BOUTON.SIZ_X		= GUI__PROP_TX
												CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.TEMP_GUI__BOUTON.SIZ_Y		= GUI__PROP_TY


												CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.TEMP_GUI__BOUTON.PROP_TYPE.LES_TYPES = GUI__PROP_TYPE

												CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.TEMP_GUI__BOUTON.PROP_TYPE.AutoSizeIMG = GUI__PROP_AUTOSIZE

												' Couleur du picturebox ===> GUI__PROP_COULEURFOND
												CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.TEMP_GUI__BOUTON.PROP_TYPE.Couleur_CTN_R = val(Mid(GUI__PROP_COULEURFOND, 1, 3))
												CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.TEMP_GUI__BOUTON.PROP_TYPE.Couleur_CTN_V = val(Mid(GUI__PROP_COULEURFOND, 5, 3))
												CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.TEMP_GUI__BOUTON.PROP_TYPE.Couleur_CTN_B = val(Mid(GUI__PROP_COULEURFOND, 9, 3))

												' Couleur de la police d'ecriture ===> GUI__PROP_COULEURTEXTE
												CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.TEMP_GUI__BOUTON.PROP_TYPE.Couleur_FNT_R = val(Mid(GUI__PROP_COULEURTEXTE, 1, 3))
												CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.TEMP_GUI__BOUTON.PROP_TYPE.Couleur_FNT_V = val(Mid(GUI__PROP_COULEURTEXTE, 5, 3))
												CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.TEMP_GUI__BOUTON.PROP_TYPE.Couleur_FNT_B = val(Mid(GUI__PROP_COULEURTEXTE, 9, 3))

												' Transparence generale  ===> GUI_PROP_COULEURALPHA
												CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.TEMP_GUI__BOUTON.PROP_TYPE.Alpha = val(GUI__PROP_COULEURALPHA)

												' Bordure
												CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.TEMP_GUI__BOUTON.PROP_TYPE.Bordure = GUI__PROP_TYPE_BORDURE

												' Evenement
												CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.TEMP_GUI__BOUTON.PROP_TYPE.Fichier_evenement = GUI__PROP_EVENEMENT
												CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.TEMP_GUI__BOUTON.PROP_TYPE.Liste_Evenements = GUI__PROP_EVENEMENT_DISPO


												' Cette partie permet de gagner des performances en autorisant seulement la recherche
												'  de quelques evenements. Si rien n'est precise, il recherchera tout.
												IF Len(GUI__PROP_EVENEMENT_DISPO) > 0 Then

													' Si le developpeur precise les evenements alors on interdit tout
													CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.TEMP_GUI__BOUTON.PROP_TYPE.EV_Click		= FALSE
													CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.TEMP_GUI__BOUTON.PROP_TYPE.EV_MouseEnter	= FALSE
													CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.TEMP_GUI__BOUTON.PROP_TYPE.EV_MouseMove	= FALSE
													CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.TEMP_GUI__BOUTON.PROP_TYPE.EV_MouseLeave	= FALSE
													CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.TEMP_GUI__BOUTON.PROP_TYPE.EV_MouseClick	= FALSE
													CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.TEMP_GUI__BOUTON.PROP_TYPE.EV_KeyPress	= FALSE

													' Et on autorise certain evenements
													IF Instr(GUI__PROP_EVENEMENT_DISPO, "CLICK") 		> 0 Then CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.TEMP_GUI__BOUTON.PROP_TYPE.EV_Click		 	= TRUE
													IF Instr(GUI__PROP_EVENEMENT_DISPO, "MOUSEENTER") 	> 0 Then CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.TEMP_GUI__BOUTON.PROP_TYPE.EV_MouseEnter 	= TRUE
													IF Instr(GUI__PROP_EVENEMENT_DISPO, "MOUSELEAVE") 	> 0 Then CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.TEMP_GUI__BOUTON.PROP_TYPE.EV_MouseLeave 	= TRUE
													IF Instr(GUI__PROP_EVENEMENT_DISPO, "MOUSEMOVE") 	> 0 Then CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.TEMP_GUI__BOUTON.PROP_TYPE.EV_MouseMove 	= TRUE
													IF Instr(GUI__PROP_EVENEMENT_DISPO, "MOUSECLICK") 	> 0 Then CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.TEMP_GUI__BOUTON.PROP_TYPE.EV_MouseClick 	= TRUE
													IF Instr(GUI__PROP_EVENEMENT_DISPO, "KEYPRESS") 	> 0 Then CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.TEMP_GUI__BOUTON.PROP_TYPE.EV_KeyPress 		= TRUE


												End if



												' Creer le bouton
												if Modification_IUG = True Then
													Retour_Resultat = str(CPCDOS_INSTANCE.SCI_INSTANCE.CPC__GUI_Init_obj(CPCDOS_INSTANCE.SCI_INSTANCE.GUI_TYPE.Bouton, CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI, Nouvelle_Cle_GUI, Modification_IUG, GUI__Index_ENFANT))
												Else
													Retour_Resultat = str(CPCDOS_INSTANCE.SCI_INSTANCE.CPC__GUI_Init_obj(CPCDOS_INSTANCE.SCI_INSTANCE.GUI_TYPE.Bouton, CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI, Nouvelle_Cle_GUI, Modification_IUG, 0))
												End if

												' On re-execute la commande mais uniquement pour faire un debug pour recuperer
												'  le numero de PID et pouvoir le socker dans une variable
												' Ca ne vas pas re-creer la fenetre mais ca va simplement renvoyer un texte garce a /#RENVOIDEBUG:
												RetourCCP = CpcdosCP_SHELL(Buffer_lecture & " /#RENVOIDEBUG:" & Retour_Resultat, Nouvelle_Cle_GUI, Niveau_2, Param_1, Param_2)

											ELSEIF NOT IUG_CREATION_PICTUREBOX = "" Then
												Dim Retour_Resultat as string



												IF Modification_IUG = True Then
													IF GUI__Handle_PARENT > 0  Then
														CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.TEMP_GUI__PICTUREBOX.identification_objet.Handle_PARENT = GUI__Handle_PARENT
														' GUI__Handle_PARENT = 0
													End if
												else
													Nouvelle_Cle_GUI = Nouvelle_Cle
												End if

												CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.TEMP_GUI__PICTUREBOX.identification_objet._CLE_ 		= Nouvelle_Cle_GUI
												CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.TEMP_GUI__PICTUREBOX.Identification_Objet.OS_id 		= Nouvelle_OS_ID

												CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.TEMP_GUI__PICTUREBOX.Initialisation_OK 	= GUI__DEJA_INITIALISE

												CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.TEMP_GUI__PICTUREBOX.identification_objet.PROC_PARENT		= GUI__PROC_PARENT 		' Nom du processus parent (Optionnel)
												CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.TEMP_GUI__PICTUREBOX.identification_objet.PID_PARENT			= GUI__PID_PARENT 		' PID du parent

												CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.TEMP_GUI__PICTUREBOX.identification_objet.THREAD_PARENT		= GUI__THREAD_PARENT 	' Nom du thread parent (Optionnel)
												CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.TEMP_GUI__PICTUREBOX.identification_objet.TID_PARENT			= GUI__TID_PARENT	 	' Nom du thread parent (Optionnel)

												CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.TEMP_GUI__PICTUREBOX.identification_objet.Fenetre_PARENT 	= GUI__Fenetre_PARENT 	' Nom de la fenetre
												CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.TEMP_GUI__PICTUREBOX.identification_objet.Index_FNT_PARENT 	= GUI__Index_FNT_PARENT ' Index de la fenetre
												CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.TEMP_GUI__PICTUREBOX.identification_objet.Handle_PARENT 		= GUI__Handle_PARENT 	' Handle de la fenetre hebergeur

												CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.TEMP_GUI__PICTUREBOX.identification_objet.NOM				= IUG_CREATION_PICTUREBOX ' Nom de l'objet
												CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.TEMP_GUI__PICTUREBOX.identification_objet.Index_ENFANT		= GUI__Index_ENFANT		' Index de l'objet
												CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.TEMP_GUI__PICTUREBOX.identification_objet.Handle				= GUI__Handle			' Handle de l'objet (Unique)

												CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.TEMP_GUI__PICTUREBOX.IMAGE			= GUI__PROP_IMAGE
												CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.TEMP_GUI__PICTUREBOX.IMAGE_ANCIEN 	= GUI__PROP_IMAGE_ANCIEN

												CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.TEMP_GUI__PICTUREBOX.IMG_ID		 	= GUI__PROP_IMAGE_ID
												CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.TEMP_GUI__PICTUREBOX.IMG_ORG_ID		= GUI__PROP_IMAGE_ORG_ID

												' CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.TEMP_GUI__PICTUREBOX.IMG_PTR			= GUI__PROP_IMAGEPTR ' Obtenir le pointeur du context GZE
												' CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.TEMP_GUI__PICTUREBOX.IMG_PTR_ORG		= GUI__PROP_IMAGEPTR_ORG ' Obtenir le pointeur du context GZE
												' CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.TEMP_GUI__PICTUREBOX.IMG_PTR_ANCIEN	= GUI__PROP_IMAGEPTR_ANCIEN ' Obtenir le pointeur du context GZE

												CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.TEMP_GUI__PICTUREBOX.BIT_ORG			= GUI__PROP_BIT_ORG

												CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.TEMP_GUI__PICTUREBOX.IUG_UPDATER = GUI__PROP_UPDATER
												CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.RefreshGUI_Elements_PICTUREBOX += 1

												CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.TEMP_GUI__PICTUREBOX.POS_X		= GUI__PROP_PX
												CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.TEMP_GUI__PICTUREBOX.POS_Y		= GUI__PROP_PY

												CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.TEMP_GUI__PICTUREBOX.SIZ_X		= GUI__PROP_TX
												CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.TEMP_GUI__PICTUREBOX.SIZ_Y		= GUI__PROP_TY

												CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.TEMP_GUI__PICTUREBOX.PROP_TYPE.LES_TYPES = GUI__PROP_TYPE

												CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.TEMP_GUI__PICTUREBOX.PROP_TYPE.AutoSizeIMG = GUI__PROP_AUTOSIZE

												' Couleur du picturebox ===> GUI__PROP_COULEURFOND
												CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.TEMP_GUI__PICTUREBOX.PROP_TYPE.Couleur_CTN_R = val(Mid(GUI__PROP_COULEURFOND, 1, 3))
												CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.TEMP_GUI__PICTUREBOX.PROP_TYPE.Couleur_CTN_V = val(Mid(GUI__PROP_COULEURFOND, 5, 3))
												CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.TEMP_GUI__PICTUREBOX.PROP_TYPE.Couleur_CTN_B = val(Mid(GUI__PROP_COULEURFOND, 9, 3))

												' Couleur de la police d'ecriture ===> GUI__PROP_COULEURTEXTE
												CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.TEMP_GUI__PICTUREBOX.PROP_TYPE.Couleur_FNT_R = val(Mid(GUI__PROP_COULEURTEXTE, 1, 3))
												CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.TEMP_GUI__PICTUREBOX.PROP_TYPE.Couleur_FNT_V = val(Mid(GUI__PROP_COULEURTEXTE, 5, 3))
												CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.TEMP_GUI__PICTUREBOX.PROP_TYPE.Couleur_FNT_B = val(Mid(GUI__PROP_COULEURTEXTE, 9, 3))

												' Transparence generale  ===> GUI_PROP_COULEURALPHA
												CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.TEMP_GUI__PICTUREBOX.PROP_TYPE.Alpha = val(GUI__PROP_COULEURALPHA)

												' Couleur fond OUI ou NON
												CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.TEMP_GUI__PICTUREBOX.PROP_TYPE.Fond_Couleur = GUI__PROP_FOND_COULEUR

												' Bordure
												CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.TEMP_GUI__PICTUREBOX.PROP_TYPE.Bordure = GUI__PROP_TYPE_BORDURE

												' Evenement
												CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.TEMP_GUI__PICTUREBOX.PROP_TYPE.Fichier_evenement = GUI__PROP_EVENEMENT
												CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.TEMP_GUI__PICTUREBOX.PROP_TYPE.Liste_Evenements = GUI__PROP_EVENEMENT_DISPO

												' Cette partie permet de gagner des performances en autorisant seulement la recherche
												'  de quelques evenements. Si rien n'est precise, il recherchera tout.
												IF Len(GUI__PROP_EVENEMENT_DISPO) > 0 Then

													' Si le developpeur precise les evenements alors on interdit tout
													CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.TEMP_GUI__PICTUREBOX.PROP_TYPE.EV_Click		= FALSE
													CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.TEMP_GUI__PICTUREBOX.PROP_TYPE.EV_MouseEnter	= FALSE
													CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.TEMP_GUI__PICTUREBOX.PROP_TYPE.EV_MouseMove	= FALSE
													CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.TEMP_GUI__PICTUREBOX.PROP_TYPE.EV_MouseLeave	= FALSE
													CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.TEMP_GUI__PICTUREBOX.PROP_TYPE.EV_MouseClick	= FALSE
													CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.TEMP_GUI__PICTUREBOX.PROP_TYPE.EV_KeyPress	= FALSE

													' Et on autorise certain evenements
													IF Instr(GUI__PROP_EVENEMENT_DISPO, "CLICK") 		> 0 Then CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.TEMP_GUI__PICTUREBOX.PROP_TYPE.EV_Click 		= TRUE
													IF Instr(GUI__PROP_EVENEMENT_DISPO, "MOUSEENTER") 	> 0 Then CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.TEMP_GUI__PICTUREBOX.PROP_TYPE.EV_MouseEnter 	= TRUE
													IF Instr(GUI__PROP_EVENEMENT_DISPO, "MOUSELEAVE") 	> 0 Then CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.TEMP_GUI__PICTUREBOX.PROP_TYPE.EV_MouseLeave 	= TRUE
													IF Instr(GUI__PROP_EVENEMENT_DISPO, "MOUSEMOVE") 	> 0 Then CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.TEMP_GUI__PICTUREBOX.PROP_TYPE.EV_MouseMove 	= TRUE
													IF Instr(GUI__PROP_EVENEMENT_DISPO, "MOUSECLICK") 	> 0 Then CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.TEMP_GUI__PICTUREBOX.PROP_TYPE.EV_MouseClick 	= TRUE
													IF Instr(GUI__PROP_EVENEMENT_DISPO, "KEYPRESS") 	> 0 Then CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.TEMP_GUI__PICTUREBOX.PROP_TYPE.EV_KeyPress 		= TRUE

												End if


												' Creer le picturebox
												if Modification_IUG = True Then
													Retour_Resultat = str(CPCDOS_INSTANCE.SCI_INSTANCE.CPC__GUI_Init_obj(CPCDOS_INSTANCE.SCI_INSTANCE.GUI_TYPE.PictureBox, CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI, Nouvelle_Cle_GUI, Modification_IUG, GUI__Index_ENFANT))
												Else
													Retour_Resultat = str(CPCDOS_INSTANCE.SCI_INSTANCE.CPC__GUI_Init_obj(CPCDOS_INSTANCE.SCI_INSTANCE.GUI_TYPE.PictureBox, CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI, Nouvelle_Cle_GUI, Modification_IUG, 0))
												End if

												' On re-execute la commande mais uniquement pour faire un debug pour recuperer
												'  le numero de PID et pouvoir le socker dans une variable
												' Ca ne vas pas re-creer la fenetre mais ca va simplement renvoyer un texte garce a /#RENVOIDEBUG:
												RetourCCP = CpcdosCP_SHELL(Buffer_lecture & " /#RENVOIDEBUG:" & Retour_Resultat, Nouvelle_Cle_GUI, Niveau_2, Param_1, Param_2)

											ELSEIF NOT IUG_CREATION_TEXTEBLOCK = "" Then
												Dim Retour_Resultat as string



												IF Modification_IUG = True Then
													IF GUI__Handle_PARENT > 0  Then
														CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.TEMP_GUI__TEXTBLOCK.identification_objet.Handle_PARENT = GUI__Handle_PARENT
														' GUI__Handle_PARENT = 0
													End if
												else
													Nouvelle_Cle_GUI = Nouvelle_Cle
												End if

												CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.TEMP_GUI__TEXTBLOCK.identification_objet._CLE_ 		= Nouvelle_Cle_GUI
												CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.TEMP_GUI__TEXTBLOCK.Identification_Objet.OS_id 		= Nouvelle_OS_ID

												CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.TEMP_GUI__TEXTBLOCK.Initialisation_OK = GUI__DEJA_INITIALISE

												CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.TEMP_GUI__TEXTBLOCK.identification_objet.PROC_PARENT		= GUI__PROC_PARENT 		' Nom du processus parent (Optionnel)
												CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.TEMP_GUI__TEXTBLOCK.identification_objet.PID_PARENT		= GUI__PID_PARENT 		' PID du parent

												CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.TEMP_GUI__TEXTBLOCK.identification_objet.THREAD_PARENT	= GUI__THREAD_PARENT 	' Nom du thread parent (Optionnel)
												CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.TEMP_GUI__TEXTBLOCK.identification_objet.TID_PARENT		= GUI__TID_PARENT	 	' Nom du thread parent (Optionnel)

												CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.TEMP_GUI__TEXTBLOCK.identification_objet.Fenetre_PARENT 	= GUI__Fenetre_PARENT 	' Nom de la fenetre
												CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.TEMP_GUI__TEXTBLOCK.identification_objet.Index_FNT_PARENT = GUI__Index_FNT_PARENT ' Index de la fenetre
												CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.TEMP_GUI__TEXTBLOCK.identification_objet.Handle_PARENT 	= GUI__Handle_PARENT 	' Handle de la fenetre hebergeur

												CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.TEMP_GUI__TEXTBLOCK.identification_objet.NOM				= IUG_CREATION_TEXTEBLOCK	' Nom de l'objet
												CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.TEMP_GUI__TEXTBLOCK.identification_objet.Index_ENFANT		= GUI__Index_ENFANT		' Index de l'objet
												CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.TEMP_GUI__TEXTBLOCK.identification_objet.Handle			= GUI__Handle			' Handle de l'objet (Unique)

												CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.TEMP_GUI__TEXTBLOCK.IUG_UPDATER = GUI__PROP_UPDATER
												CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.RefreshGUI_Elements_TEXTBLOCK += 1

												CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.TEMP_GUI__TEXTBLOCK.TEXTE 		= GUI__PROP_TEXTE


												CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.TEMP_GUI__TEXTBLOCK.POS_X		= GUI__PROP_PX
												CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.TEMP_GUI__TEXTBLOCK.POS_Y		= GUI__PROP_PY

												CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.TEMP_GUI__TEXTBLOCK.SIZ_X		= GUI__PROP_TX
												CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.TEMP_GUI__TEXTBLOCK.SIZ_Y		= GUI__PROP_TY

												CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.TEMP_GUI__TEXTBLOCK.PROP_TYPE.LES_TYPES = GUI__PROP_TYPE

												CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.TEMP_GUI__TEXTBLOCK.PROP_TYPE.AutoSizeIMG = GUI__PROP_AUTOSIZE

												' Couleur du picturebox ===> GUI__PROP_COULEURFOND
												CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.TEMP_GUI__TEXTBLOCK.PROP_TYPE.Couleur_CTN_R = val(Mid(GUI__PROP_COULEURFOND, 1, 3))
												CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.TEMP_GUI__TEXTBLOCK.PROP_TYPE.Couleur_CTN_V = val(Mid(GUI__PROP_COULEURFOND, 5, 3))
												CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.TEMP_GUI__TEXTBLOCK.PROP_TYPE.Couleur_CTN_B = val(Mid(GUI__PROP_COULEURFOND, 9, 3))

												' Couleur de la police d'ecriture ===> GUI__PROP_COULEURTEXTE
												CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.TEMP_GUI__TEXTBLOCK.PROP_TYPE.Couleur_FNT_R = val(Mid(GUI__PROP_COULEURTEXTE, 1, 3))
												CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.TEMP_GUI__TEXTBLOCK.PROP_TYPE.Couleur_FNT_V = val(Mid(GUI__PROP_COULEURTEXTE, 5, 3))
												CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.TEMP_GUI__TEXTBLOCK.PROP_TYPE.Couleur_FNT_B = val(Mid(GUI__PROP_COULEURTEXTE, 9, 3))

												' Transparence generale  ===> GUI_PROP_COULEURALPHA
												CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.TEMP_GUI__TEXTBLOCK.PROP_TYPE.Alpha = val(GUI__PROP_COULEURALPHA)

												' Bordure
												CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.TEMP_GUI__TEXTBLOCK.PROP_TYPE.Bordure = GUI__PROP_TYPE_BORDURE

												' Couleur de fond OUI ou NON
												CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.TEMP_GUI__TEXTBLOCK.PROP_TYPE.Fond_Couleur = GUI__PROP_Fond_Couleur

												' Evenement
												CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.TEMP_GUI__TEXTBLOCK.PROP_TYPE.Fichier_evenement = GUI__PROP_EVENEMENT
												CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.TEMP_GUI__TEXTBLOCK.PROP_TYPE.Liste_Evenements = GUI__PROP_EVENEMENT_DISPO

												' Cette partie permet de gagner des performances en autorisant seulement la recherche
												'  de quelques evenements. Si rien n'est precise, il recherchera tout.
												IF Len(GUI__PROP_EVENEMENT_DISPO) > 0 Then

													' Si le developpeur precise les evenements alors on interdit tout
													CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.TEMP_GUI__TEXTBLOCK.PROP_TYPE.EV_Click		= FALSE
													CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.TEMP_GUI__TEXTBLOCK.PROP_TYPE.EV_MouseEnter	= FALSE
													CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.TEMP_GUI__TEXTBLOCK.PROP_TYPE.EV_MouseMove	= FALSE
													CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.TEMP_GUI__TEXTBLOCK.PROP_TYPE.EV_MouseLeave	= FALSE
													CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.TEMP_GUI__TEXTBLOCK.PROP_TYPE.EV_MouseClick	= FALSE
													CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.TEMP_GUI__TEXTBLOCK.PROP_TYPE.EV_KeyPress	= FALSE

													' Et on autorise certain evenements
													IF Instr(GUI__PROP_EVENEMENT_DISPO, "CLICK") 		> 0 Then CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.TEMP_GUI__TEXTBLOCK.PROP_TYPE.EV_Click 		= TRUE
													IF Instr(GUI__PROP_EVENEMENT_DISPO, "MOUSEENTER") 	> 0 Then CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.TEMP_GUI__TEXTBLOCK.PROP_TYPE.EV_MouseEnter = TRUE
													IF Instr(GUI__PROP_EVENEMENT_DISPO, "MOUSELEAVE") 	> 0 Then CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.TEMP_GUI__TEXTBLOCK.PROP_TYPE.EV_MouseLeave = TRUE
													IF Instr(GUI__PROP_EVENEMENT_DISPO, "MOUSEMOVE") 	> 0 Then CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.TEMP_GUI__TEXTBLOCK.PROP_TYPE.EV_MouseMove 	= TRUE
													IF Instr(GUI__PROP_EVENEMENT_DISPO, "MOUSECLICK")	> 0 Then CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.TEMP_GUI__TEXTBLOCK.PROP_TYPE.EV_MouseClick = TRUE
													IF Instr(GUI__PROP_EVENEMENT_DISPO, "KEYPRESS") 	> 0 Then CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.TEMP_GUI__TEXTBLOCK.PROP_TYPE.EV_KeyPress 	= TRUE

												End if

												' Creer le bouton
												if Modification_IUG = True Then
													Retour_Resultat = str(CPCDOS_INSTANCE.SCI_INSTANCE.CPC__GUI_Init_obj(CPCDOS_INSTANCE.SCI_INSTANCE.GUI_TYPE.TextBlock, CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI, Nouvelle_Cle_GUI, Modification_IUG, GUI__Index_ENFANT))
												Else
													Retour_Resultat = str(CPCDOS_INSTANCE.SCI_INSTANCE.CPC__GUI_Init_obj(CPCDOS_INSTANCE.SCI_INSTANCE.GUI_TYPE.TextBlock, CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI, Nouvelle_Cle_GUI, Modification_IUG, 0))
												End if

												' On re-execute la commande mais uniquement pour faire un debug pour recuperer
												'  le numero de PID et pouvoir le socker dans une variable
												' Ca ne vas pas re-creer la fenetre mais ca va simplement renvoyer un texte garce a /#RENVOIDEBUG:
												RetourCCP = CpcdosCP_SHELL(Buffer_lecture & " /#RENVOIDEBUG:" & Retour_Resultat, Nouvelle_Cle_GUI, Niveau_2, Param_1, Param_2)

											ELSEIF NOT IUG_CREATION_TEXTEBOX = "" Then
												Dim Retour_Resultat as string



												IF Modification_IUG = True Then
													IF GUI__Handle_PARENT > 0  Then
														CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.TEMP_GUI__TEXTBOX.identification_objet.Handle_PARENT = GUI__Handle_PARENT
														' GUI__Handle_PARENT = 0
													End if
												else
													Nouvelle_Cle_GUI = Nouvelle_Cle
												End if

												CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.TEMP_GUI__TEXTBOX.identification_objet._CLE_ 		= Nouvelle_Cle_GUI
												CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.TEMP_GUI__TEXTBOX.Identification_Objet.OS_id 		= Nouvelle_OS_ID

												CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.TEMP_GUI__TEXTBOX.Initialisation_OK = GUI__DEJA_INITIALISE

												CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.TEMP_GUI__TEXTBOX.identification_objet.PROC_PARENT		= GUI__PROC_PARENT 		' Nom du processus parent (Optionnel)
												CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.TEMP_GUI__TEXTBOX.identification_objet.PID_PARENT		= GUI__PID_PARENT 		' PID du parent

												CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.TEMP_GUI__TEXTBOX.identification_objet.THREAD_PARENT	= GUI__THREAD_PARENT 	' Nom du thread parent (Optionnel)
												CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.TEMP_GUI__TEXTBOX.identification_objet.TID_PARENT		= GUI__TID_PARENT	 	' Nom du thread parent (Optionnel)

												CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.TEMP_GUI__TEXTBOX.identification_objet.Fenetre_PARENT 	= GUI__Fenetre_PARENT 	' Nom de la fenetre
												CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.TEMP_GUI__TEXTBOX.identification_objet.Index_FNT_PARENT = GUI__Index_FNT_PARENT ' Index de la fenetre
												CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.TEMP_GUI__TEXTBOX.identification_objet.Handle_PARENT 	= GUI__Handle_PARENT 	' Handle de la fenetre hebergeur


												CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.TEMP_GUI__TEXTBOX.identification_objet.NOM				= IUG_CREATION_TEXTEBOX	' Nom de l'objet
												CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.TEMP_GUI__TEXTBOX.identification_objet.Index_ENFANT		= GUI__Index_ENFANT		' Index de l'objet
												CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.TEMP_GUI__TEXTBOX.identification_objet.Handle			= GUI__Handle			' Handle de l'objet (Unique)

												CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.TEMP_GUI__TEXTBOX.IUG_UPDATER 		= GUI__PROP_UPDATER
												CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.RefreshGUI_Elements_TEXTBOX += 1

												CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.TEMP_GUI__TEXTBOX.TEXTE 				= GUI__PROP_TEXTE

												CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.TEMP_GUI__TEXTBOX.Image 				= GUI__PROP_EditBar
												CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.TEMP_GUI__TEXTBOX.Image_2 			= GUI__PROP_EditBar_L


												CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.TEMP_GUI__TEXTBOX.IMG_ID		 		= GUI__PROP_IMAGE_ID
												CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.TEMP_GUI__TEXTBOX.IMG_ORG_ID		 	= GUI__PROP_IMAGE_ORG_ID

												CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.TEMP_GUI__TEXTBOX.PROP_TYPE.Editable = GUI__PROP_TYPE_Editable

												CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.TEMP_GUI__TEXTBOX.PROP_TYPE.Multi_Lignes = GUI__PROP_TYPE_MultiLignes

												CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.TEMP_GUI__TEXTBOX.PROP_TYPE.Console = GUI__PROP_TYPE_Console

												CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.TEMP_GUI__TEXTBOX.POS_X				= GUI__PROP_PX
												CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.TEMP_GUI__TEXTBOX.POS_Y				= GUI__PROP_PY

												CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.TEMP_GUI__TEXTBOX.SIZ_X				= GUI__PROP_TX
												CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.TEMP_GUI__TEXTBOX.SIZ_Y				= GUI__PROP_TY

												CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.TEMP_GUI__TEXTBOX.PROP_TYPE.LES_TYPES = GUI__PROP_TYPE

												CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.TEMP_GUI__TEXTBOX.PROP_TYPE.AutoSizeIMG = GUI__PROP_AUTOSIZE

												' Couleur du picturebox ===> GUI__PROP_COULEURFOND
												CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.TEMP_GUI__TEXTBOX.PROP_TYPE.Couleur_CTN_R = val(Mid(GUI__PROP_COULEURFOND, 1, 3))
												CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.TEMP_GUI__TEXTBOX.PROP_TYPE.Couleur_CTN_V = val(Mid(GUI__PROP_COULEURFOND, 5, 3))
												CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.TEMP_GUI__TEXTBOX.PROP_TYPE.Couleur_CTN_B = val(Mid(GUI__PROP_COULEURFOND, 9, 3))

												' Couleur de la police d'ecriture ===> GUI__PROP_COULEURTEXTE
												CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.TEMP_GUI__TEXTBOX.PROP_TYPE.Couleur_FNT_R = val(Mid(GUI__PROP_COULEURTEXTE, 1, 3))
												CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.TEMP_GUI__TEXTBOX.PROP_TYPE.Couleur_FNT_V = val(Mid(GUI__PROP_COULEURTEXTE, 5, 3))
												CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.TEMP_GUI__TEXTBOX.PROP_TYPE.Couleur_FNT_B = val(Mid(GUI__PROP_COULEURTEXTE, 9, 3))

												' Transparence generale  ===> GUI_PROP_COULEURALPHA
												CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.TEMP_GUI__TEXTBOX.PROP_TYPE.Alpha = val(GUI__PROP_COULEURALPHA)

												' Bordure
												CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.TEMP_GUI__TEXTBOX.PROP_TYPE.Bordure = GUI__PROP_TYPE_BORDURE

												' Couleur de fond OUI ou NON
												CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.TEMP_GUI__TEXTBOX.PROP_TYPE.Fond_Couleur = GUI__PROP_Fond_Couleur

												' Evenement
												CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.TEMP_GUI__TEXTBOX.PROP_TYPE.Fichier_evenement = GUI__PROP_EVENEMENT
												CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.TEMP_GUI__TEXTBOX.PROP_TYPE.Liste_Evenements = GUI__PROP_EVENEMENT_DISPO

												' Cette partie permet de gagner des performances en autorisant seulement la recherche
												'  de quelques evenements. Si rien n'est precise, il recherchera tout.
												IF Len(GUI__PROP_EVENEMENT_DISPO) > 0 Then

													' Si le developpeur precise les evenements alors on interdit tout
													CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.TEMP_GUI__TEXTBOX.PROP_TYPE.EV_Click			= FALSE
													CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.TEMP_GUI__TEXTBOX.PROP_TYPE.EV_MouseEnter	= FALSE
													CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.TEMP_GUI__TEXTBOX.PROP_TYPE.EV_MouseMove		= FALSE
													CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.TEMP_GUI__TEXTBOX.PROP_TYPE.EV_MouseLeave	= FALSE
													CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.TEMP_GUI__TEXTBOX.PROP_TYPE.EV_MouseClick	= FALSE
													CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.TEMP_GUI__TEXTBOX.PROP_TYPE.EV_KeyPress		= FALSE

													' Et on autorise certain evenements
													IF Instr(GUI__PROP_EVENEMENT_DISPO, "CLICK") 		> 0 Then CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.TEMP_GUI__TEXTBOX.PROP_TYPE.EV_Click 		= TRUE
													IF Instr(GUI__PROP_EVENEMENT_DISPO, "MOUSEENTER") 	> 0 Then CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.TEMP_GUI__TEXTBOX.PROP_TYPE.EV_MouseEnter	= TRUE
													IF Instr(GUI__PROP_EVENEMENT_DISPO, "MOUSELEAVE") 	> 0 Then CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.TEMP_GUI__TEXTBOX.PROP_TYPE.EV_MouseLeave 	= TRUE
													IF Instr(GUI__PROP_EVENEMENT_DISPO, "MOUSEMOVE") 	> 0 Then CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.TEMP_GUI__TEXTBOX.PROP_TYPE.EV_MouseMove 	= TRUE
													IF Instr(GUI__PROP_EVENEMENT_DISPO, "MOUSECLICK") 	> 0 Then CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.TEMP_GUI__TEXTBOX.PROP_TYPE.EV_MouseClick 	= TRUE
													IF Instr(GUI__PROP_EVENEMENT_DISPO, "KEYPRESS") 	> 0 Then CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.TEMP_GUI__TEXTBOX.PROP_TYPE.EV_KeyPress 	= TRUE

												End if

												' Creer le bouton
												if Modification_IUG = True Then
													Retour_Resultat = str(CPCDOS_INSTANCE.SCI_INSTANCE.CPC__GUI_Init_obj(CPCDOS_INSTANCE.SCI_INSTANCE.GUI_TYPE.TextBox, CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI, Nouvelle_Cle_GUI, Modification_IUG, _INDEX_TEXTBOX_))
												Else
													Retour_Resultat = str(CPCDOS_INSTANCE.SCI_INSTANCE.CPC__GUI_Init_obj(CPCDOS_INSTANCE.SCI_INSTANCE.GUI_TYPE.TextBox, CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI, Nouvelle_Cle_GUI, Modification_IUG, 0))
												End if

												' On re-execute la commande mais uniquement pour faire un debug pour recuperer
												'  le numero de PID et pouvoir le socker dans une variable
												' Ca ne vas pas re-creer la fenetre mais ca va simplement renvoyer un texte garce a /#RENVOIDEBUG:
												RetourCCP = CpcdosCP_SHELL(Buffer_lecture & " /#RENVOIDEBUG:" & Retour_Resultat, Nouvelle_Cle_GUI, Niveau_2, Param_1, Param_2)
											ELSEIF NOT IUG_CREATION_PROGRESSBAR = "" Then
												Dim Retour_Resultat as string



												IF Modification_IUG = True Then
													IF GUI__Handle_PARENT > 0  Then
														CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.TEMP_GUI__PROGRESSBAR.identification_objet.Handle_PARENT = GUI__Handle_PARENT
														' GUI__Handle_PARENT = 0
													End if
												else
													Nouvelle_Cle_GUI = Nouvelle_Cle
												End if

												CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.TEMP_GUI__PROGRESSBAR.identification_objet._CLE_ 			= Nouvelle_Cle_GUI
												CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.TEMP_GUI__PROGRESSBAR.Identification_Objet.OS_id 			= Nouvelle_OS_ID

												CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.TEMP_GUI__PROGRESSBAR.Initialisation_OK 						= GUI__DEJA_INITIALISE

												CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.TEMP_GUI__PROGRESSBAR.identification_objet.PROC_PARENT		= GUI__PROC_PARENT 		' Nom du processus parent (Optionnel)
												CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.TEMP_GUI__PROGRESSBAR.identification_objet.PID_PARENT		= GUI__PID_PARENT 		' PID du parent

												CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.TEMP_GUI__PROGRESSBAR.identification_objet.THREAD_PARENT		= GUI__THREAD_PARENT 	' Nom du thread parent (Optionnel)
												CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.TEMP_GUI__PROGRESSBAR.identification_objet.TID_PARENT		= GUI__TID_PARENT	 	' Nom du thread parent (Optionnel)

												CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.TEMP_GUI__PROGRESSBAR.identification_objet.Fenetre_PARENT 	= GUI__Fenetre_PARENT 	' Nom de la fenetre
												CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.TEMP_GUI__PROGRESSBAR.identification_objet.Index_FNT_PARENT 	= GUI__Index_FNT_PARENT ' Index de la fenetre
												CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.TEMP_GUI__PROGRESSBAR.identification_objet.Handle_PARENT 	= GUI__Handle_PARENT 	' Handle de la fenetre hebergeur


												CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.TEMP_GUI__PROGRESSBAR.identification_objet.NOM				= IUG_CREATION_PROGRESSBAR	' Nom de l'objet
												CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.TEMP_GUI__PROGRESSBAR.identification_objet.Index_ENFANT		= GUI__Index_ENFANT		' Index de l'objet
												CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.TEMP_GUI__PROGRESSBAR.identification_objet.Handle			= GUI__Handle			' Handle de l'objet (Unique)

												CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.TEMP_GUI__PROGRESSBAR.IUG_UPDATER 							= GUI__PROP_UPDATER
												CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.RefreshGUI_Elements_PROGRESSBAR += 1

												CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.TEMP_GUI__PROGRESSBAR.TEXTE 									= GUI__PROP_TEXTE


												CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.TEMP_GUI__PROGRESSBAR.VALEUR 								= GUI__PROP_VALEUR


												CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.TEMP_GUI__PROGRESSBAR.IMAGE									= GUI__PROP_IMAGE
												CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.TEMP_GUI__PROGRESSBAR.IMAGE_ANCIEN 							= GUI__PROP_IMAGE_ANCIEN

												CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.TEMP_GUI__PROGRESSBAR.IMG_ID		 							= GUI__PROP_IMAGE_ID
												CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.TEMP_GUI__PROGRESSBAR.IMG_prog_ID		 					= GUI__PROP_IMAGE_prog_ID
												CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.TEMP_GUI__PROGRESSBAR.IMG_ORG_ID								= GUI__PROP_IMAGE_ORG_ID


												' CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.TEMP_GUI__PROGRESSBAR.IMG_PTR								= GUI__PROP_IMAGEPTR ' Obtenir le pointeur du context GZE
												' CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.TEMP_GUI__PROGRESSBAR.IMG_PTR_ORG							= GUI__PROP_IMAGEPTR_ORG ' Obtenir le pointeur du context GZE
												' CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.TEMP_GUI__PROGRESSBAR.IMG_PTR_ANCIEN							= GUI__PROP_IMAGEPTR_ANCIEN ' Obtenir le pointeur du context GZE

												CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.TEMP_GUI__PROGRESSBAR.BIT_ORG								= GUI__PROP_BIT_ORG

												CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.TEMP_GUI__PROGRESSBAR.PROP_TYPE.Multi_Lignes 				= GUI__PROP_TYPE_MultiLignes

												CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.TEMP_GUI__PROGRESSBAR.POS_X									= GUI__PROP_PX
												CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.TEMP_GUI__PROGRESSBAR.POS_Y									= GUI__PROP_PY

												CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.TEMP_GUI__PROGRESSBAR.SIZ_X									= GUI__PROP_TX
												CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.TEMP_GUI__PROGRESSBAR.SIZ_Y									= GUI__PROP_TY

												CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.TEMP_GUI__PROGRESSBAR.PROP_TYPE.LES_TYPES 					= GUI__PROP_TYPE

												CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.TEMP_GUI__PROGRESSBAR.PROP_TYPE.AutoSizeIMG 					= GUI__PROP_AUTOSIZE

												' Couleur du picturebox ===> GUI__PROP_COULEURFOND
												CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.TEMP_GUI__PROGRESSBAR.PROP_TYPE.Couleur_CTN_R = val(Mid(GUI__PROP_COULEURFOND, 1, 3))
												CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.TEMP_GUI__PROGRESSBAR.PROP_TYPE.Couleur_CTN_V = val(Mid(GUI__PROP_COULEURFOND, 5, 3))
												CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.TEMP_GUI__PROGRESSBAR.PROP_TYPE.Couleur_CTN_B = val(Mid(GUI__PROP_COULEURFOND, 9, 3))

												' Couleur de la police d'ecriture ===> GUI__PROP_COULEURTEXTE
												CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.TEMP_GUI__PROGRESSBAR.PROP_TYPE.Couleur_FNT_R = val(Mid(GUI__PROP_COULEURTEXTE, 1, 3))
												CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.TEMP_GUI__PROGRESSBAR.PROP_TYPE.Couleur_FNT_V = val(Mid(GUI__PROP_COULEURTEXTE, 5, 3))
												CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.TEMP_GUI__PROGRESSBAR.PROP_TYPE.Couleur_FNT_B = val(Mid(GUI__PROP_COULEURTEXTE, 9, 3))

												' Transparence generale  ===> GUI_PROP_COULEURALPHA
												CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.TEMP_GUI__PROGRESSBAR.PROP_TYPE.Alpha 						= val(GUI__PROP_COULEURALPHA)

												' Bordure
												CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.TEMP_GUI__PROGRESSBAR.PROP_TYPE.Bordure 						= GUI__PROP_TYPE_BORDURE

												' Couleur de fond OUI ou NON
												CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.TEMP_GUI__PROGRESSBAR.PROP_TYPE.Fond_Couleur 				= GUI__PROP_Fond_Couleur

												' Evenement
												CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.TEMP_GUI__PROGRESSBAR.PROP_TYPE.Fichier_evenement 			= GUI__PROP_EVENEMENT
												CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.TEMP_GUI__PROGRESSBAR.PROP_TYPE.Liste_Evenements				= GUI__PROP_EVENEMENT_DISPO

												' Cette partie permet de gagner des performances en autorisant seulement la recherche
												'  de quelques evenements. Si rien n'est precise, il recherchera tout.
												IF Len(GUI__PROP_EVENEMENT_DISPO) > 0 Then

													' Si le developpeur precise les evenements alors on interdit tout
													CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.TEMP_GUI__PROGRESSBAR.PROP_TYPE.EV_Click			= FALSE
													CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.TEMP_GUI__PROGRESSBAR.PROP_TYPE.EV_MouseEnter	= FALSE
													CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.TEMP_GUI__PROGRESSBAR.PROP_TYPE.EV_MouseMove		= FALSE
													CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.TEMP_GUI__PROGRESSBAR.PROP_TYPE.EV_MouseLeave	= FALSE
													CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.TEMP_GUI__PROGRESSBAR.PROP_TYPE.EV_MouseClick	= FALSE
													CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.TEMP_GUI__PROGRESSBAR.PROP_TYPE.EV_KeyPress		= FALSE

													' Et on autorise certain evenements
													IF Instr(GUI__PROP_EVENEMENT_DISPO, "CLICK") 		> 0 Then CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.TEMP_GUI__PROGRESSBAR.PROP_TYPE.EV_Click		= TRUE
													IF Instr(GUI__PROP_EVENEMENT_DISPO, "MOUSEENTER") 	> 0 Then CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.TEMP_GUI__PROGRESSBAR.PROP_TYPE.EV_MouseEnter 	= TRUE
													IF Instr(GUI__PROP_EVENEMENT_DISPO, "MOUSELEAVE") 	> 0 Then CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.TEMP_GUI__PROGRESSBAR.PROP_TYPE.EV_MouseLeave 	= TRUE
													IF Instr(GUI__PROP_EVENEMENT_DISPO, "MOUSEMOVE") 	> 0 Then CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.TEMP_GUI__PROGRESSBAR.PROP_TYPE.EV_MouseMove 	= TRUE
													IF Instr(GUI__PROP_EVENEMENT_DISPO, "MOUSECLICK") 	> 0 Then CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.TEMP_GUI__PROGRESSBAR.PROP_TYPE.EV_MouseClick 	= TRUE
													IF Instr(GUI__PROP_EVENEMENT_DISPO, "KEYPRESS") 	> 0 Then CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.TEMP_GUI__PROGRESSBAR.PROP_TYPE.EV_KeyPress 	= TRUE

												End if

												' Creer le bouton
												if Modification_IUG = True Then
													Retour_Resultat = str(CPCDOS_INSTANCE.SCI_INSTANCE.CPC__GUI_Init_obj(CPCDOS_INSTANCE.SCI_INSTANCE.GUI_TYPE.ProgressBar, CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI, Nouvelle_Cle_GUI, Modification_IUG, _INDEX_PROGRESSBAR_))
												Else
													Retour_Resultat = str(CPCDOS_INSTANCE.SCI_INSTANCE.CPC__GUI_Init_obj(CPCDOS_INSTANCE.SCI_INSTANCE.GUI_TYPE.ProgressBar, CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI, Nouvelle_Cle_GUI, Modification_IUG, 0))
												End if

												' On re-execute la commande mais uniquement pour faire un debug pour recuperer
												'  le numero de PID et pouvoir le socker dans une variable
												' Ca ne vas pas re-creer la fenetre mais ca va simplement renvoyer un texte garce a /#RENVOIDEBUG:
												RetourCCP = CpcdosCP_SHELL(Buffer_lecture & " /#RENVOIDEBUG:" & Retour_Resultat, Nouvelle_Cle_GUI, Niveau_2, Param_1, Param_2)
											ELSEIF NOT IUG_CREATION_CHECKBOX = "" Then
												Dim Retour_Resultat as string



												IF Modification_IUG = True Then
													IF GUI__Handle_PARENT > 0  Then
														CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.TEMP_GUI__CHECKBOX.identification_objet.Handle_PARENT = GUI__Handle_PARENT
														' GUI__Handle_PARENT = 0
													End if
												else
													Nouvelle_Cle_GUI = Nouvelle_Cle
												End if

												CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.TEMP_GUI__CHECKBOX.identification_objet._CLE_ 			= Nouvelle_Cle_GUI
												CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.TEMP_GUI__CHECKBOX.Identification_Objet.OS_id 			= Nouvelle_OS_ID

												CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.TEMP_GUI__CHECKBOX.Initialisation_OK 					= GUI__DEJA_INITIALISE

												CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.TEMP_GUI__CHECKBOX.identification_objet.PROC_PARENT		= GUI__PROC_PARENT 		' Nom du processus parent (Optionnel)
												CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.TEMP_GUI__CHECKBOX.identification_objet.PID_PARENT		= GUI__PID_PARENT 		' PID du parent

												CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.TEMP_GUI__CHECKBOX.identification_objet.THREAD_PARENT	= GUI__THREAD_PARENT 	' Nom du thread parent (Optionnel)
												CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.TEMP_GUI__CHECKBOX.identification_objet.TID_PARENT		= GUI__TID_PARENT	 	' Nom du thread parent (Optionnel)

												CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.TEMP_GUI__CHECKBOX.identification_objet.Fenetre_PARENT 	= GUI__Fenetre_PARENT 	' Nom de la fenetre
												CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.TEMP_GUI__CHECKBOX.identification_objet.Index_FNT_PARENT 	= GUI__Index_FNT_PARENT ' Index de la fenetre
												CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.TEMP_GUI__CHECKBOX.identification_objet.Handle_PARENT 	= GUI__Handle_PARENT 	' Handle de la fenetre hebergeur


												CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.TEMP_GUI__CHECKBOX.identification_objet.NOM				= IUG_CREATION_CHECKBOX	' Nom de l'objet
												CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.TEMP_GUI__CHECKBOX.identification_objet.Index_ENFANT		= GUI__Index_ENFANT		' Index de l'objet
												CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.TEMP_GUI__CHECKBOX.identification_objet.Handle			= GUI__Handle			' Handle de l'objet (Unique)

												CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.TEMP_GUI__CHECKBOX.IUG_UPDATER 							= GUI__PROP_UPDATER
												CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.RefreshGUI_Elements_CHECKBOX += 1

												CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.TEMP_GUI__CHECKBOX.TEXTE 								= GUI__PROP_TEXTE


												CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.TEMP_GUI__CHECKBOX.VALEUR 								= GUI__PROP_VALEUR


												CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.TEMP_GUI__CHECKBOX.IMAGE									= GUI__PROP_IMAGE
												CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.TEMP_GUI__CHECKBOX.IMAGE_ANCIEN 							= GUI__PROP_IMAGE_ANCIEN

												CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.TEMP_GUI__CHECKBOX.IMG_ID		 						= GUI__PROP_IMAGE_ID
												CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.TEMP_GUI__CHECKBOX.IMG_fond_ID		 					= GUI__PROP_IMAGE_fond_ID
												CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.TEMP_GUI__CHECKBOX.IMG_ORG_ID							= GUI__PROP_IMAGE_ORG_ID



												' CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.TEMP_GUI__CHECKBOX.IMG_PTR								= GUI__PROP_IMAGEPTR ' Obtenir le pointeur du context GZE
												' CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.TEMP_GUI__CHECKBOX.IMG_PTR_ORG							= GUI__PROP_IMAGEPTR_ORG ' Obtenir le pointeur du context GZE
												' CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.TEMP_GUI__CHECKBOX.IMG_PTR_ANCIEN						= GUI__PROP_IMAGEPTR_ANCIEN ' Obtenir le pointeur du context GZE

												CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.TEMP_GUI__CHECKBOX.BIT_ORG								= GUI__PROP_BIT_ORG

												CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.TEMP_GUI__CHECKBOX.PROP_TYPE.Multi_Lignes 				= GUI__PROP_TYPE_MultiLignes

												CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.TEMP_GUI__CHECKBOX.POS_X									= GUI__PROP_PX
												CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.TEMP_GUI__CHECKBOX.POS_Y									= GUI__PROP_PY

												CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.TEMP_GUI__CHECKBOX.SIZ_X									= GUI__PROP_TX
												CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.TEMP_GUI__CHECKBOX.SIZ_Y									= GUI__PROP_TY

												CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.TEMP_GUI__CHECKBOX.IMG_TX 								= Val(CPCDOS_INSTANCE.SHELLCCP_INSTANCE.CCP_Lire_Variable("CPC_GUI.CHECKBOX.SX", 3, _CLE_))
												CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.TEMP_GUI__CHECKBOX.IMG_TY								= Val(CPCDOS_INSTANCE.SHELLCCP_INSTANCE.CCP_Lire_Variable("CPC_GUI.CHECKBOX.SX", 3, _CLE_))

												CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.TEMP_GUI__CHECKBOX.IMG_CHECKED 							= UCASE(CPCDOS_INSTANCE.SHELLCCP_INSTANCE.CCP_Lire_Variable("CPC_GUI.CHECKBOX.IMG_CHECKED", 3, _CLE_))
												CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.TEMP_GUI__CHECKBOX.IMG_CHECKED_SURVOLE					= UCASE(CPCDOS_INSTANCE.SHELLCCP_INSTANCE.CCP_Lire_Variable("CPC_GUI.CHECKBOX.IMG_SURVOLE_CHECKED", 3, _CLE_))
												CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.TEMP_GUI__CHECKBOX.IMG_NCHECKED							= UCASE(CPCDOS_INSTANCE.SHELLCCP_INSTANCE.CCP_Lire_Variable("CPC_GUI.CHECKBOX.IMG_NOCHECKED", 3, _CLE_))
												CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.TEMP_GUI__CHECKBOX.IMG_NCHECKED_SURVOLE					= UCASE(CPCDOS_INSTANCE.SHELLCCP_INSTANCE.CCP_Lire_Variable("CPC_GUI.CHECKBOX.IMG_SURVOLE_NOCHECKED", 3, _CLE_))


												CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.TEMP_GUI__CHECKBOX.PROP_TYPE.LES_TYPES 					= GUI__PROP_TYPE

												CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.TEMP_GUI__CHECKBOX.PROP_TYPE.AutoSizeIMG 				= GUI__PROP_AUTOSIZE

												' Couleur du picturebox ===> GUI__PROP_COULEURFOND
												CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.TEMP_GUI__CHECKBOX.PROP_TYPE.Couleur_CTN_R = val(Mid(GUI__PROP_COULEURFOND, 1, 3))
												CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.TEMP_GUI__CHECKBOX.PROP_TYPE.Couleur_CTN_V = val(Mid(GUI__PROP_COULEURFOND, 5, 3))
												CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.TEMP_GUI__CHECKBOX.PROP_TYPE.Couleur_CTN_B = val(Mid(GUI__PROP_COULEURFOND, 9, 3))

												' Couleur de la police d'ecriture ===> GUI__PROP_COULEURTEXTE
												CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.TEMP_GUI__CHECKBOX.PROP_TYPE.Couleur_FNT_R = val(Mid(GUI__PROP_COULEURTEXTE, 1, 3))
												CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.TEMP_GUI__CHECKBOX.PROP_TYPE.Couleur_FNT_V = val(Mid(GUI__PROP_COULEURTEXTE, 5, 3))
												CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.TEMP_GUI__CHECKBOX.PROP_TYPE.Couleur_FNT_B = val(Mid(GUI__PROP_COULEURTEXTE, 9, 3))

												' Transparence generale  ===> GUI_PROP_COULEURALPHA
												CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.TEMP_GUI__CHECKBOX.PROP_TYPE.Alpha 						= val(GUI__PROP_COULEURALPHA)

												' Bordure
												CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.TEMP_GUI__CHECKBOX.PROP_TYPE.Bordure 						= GUI__PROP_TYPE_BORDURE

												' Couleur de fond OUI ou NON
												CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.TEMP_GUI__CHECKBOX.PROP_TYPE.Fond_Couleur 				= GUI__PROP_Fond_Couleur

												' Evenement
												CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.TEMP_GUI__CHECKBOX.PROP_TYPE.Fichier_evenement 			= GUI__PROP_EVENEMENT
												CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.TEMP_GUI__CHECKBOX.PROP_TYPE.Liste_Evenements				= GUI__PROP_EVENEMENT_DISPO

												' Cette partie permet de gagner des performances en autorisant seulement la recherche
												'  de quelques evenements. Si rien n'est precise, il recherchera tout.
												IF Len(GUI__PROP_EVENEMENT_DISPO) > 0 Then

													' Si le developpeur precise les evenements alors on interdit tout
													CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.TEMP_GUI__CHECKBOX.PROP_TYPE.EV_Click		= FALSE
													CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.TEMP_GUI__CHECKBOX.PROP_TYPE.EV_MouseEnter	= FALSE
													CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.TEMP_GUI__CHECKBOX.PROP_TYPE.EV_MouseMove	= FALSE
													CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.TEMP_GUI__CHECKBOX.PROP_TYPE.EV_MouseLeave	= FALSE
													CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.TEMP_GUI__CHECKBOX.PROP_TYPE.EV_MouseClick	= FALSE
													CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.TEMP_GUI__CHECKBOX.PROP_TYPE.EV_KeyPress		= FALSE

													' Et on autorise certain evenements
													IF Instr(GUI__PROP_EVENEMENT_DISPO, "CLICK") 		> 0 Then CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.TEMP_GUI__CHECKBOX.PROP_TYPE.EV_Click		= TRUE
													IF Instr(GUI__PROP_EVENEMENT_DISPO, "MOUSEENTER") 	> 0 Then CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.TEMP_GUI__CHECKBOX.PROP_TYPE.EV_MouseEnter 	= TRUE
													IF Instr(GUI__PROP_EVENEMENT_DISPO, "MOUSELEAVE") 	> 0 Then CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.TEMP_GUI__CHECKBOX.PROP_TYPE.EV_MouseLeave 	= TRUE
													IF Instr(GUI__PROP_EVENEMENT_DISPO, "MOUSEMOVE") 	> 0 Then CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.TEMP_GUI__CHECKBOX.PROP_TYPE.EV_MouseMove 	= TRUE
													IF Instr(GUI__PROP_EVENEMENT_DISPO, "MOUSECLICK") 	> 0 Then CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.TEMP_GUI__CHECKBOX.PROP_TYPE.EV_MouseClick 	= TRUE
													IF Instr(GUI__PROP_EVENEMENT_DISPO, "KEYPRESS") 	> 0 Then CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.TEMP_GUI__CHECKBOX.PROP_TYPE.EV_KeyPress 	= TRUE

												End if

												' Creer le bouton
												if Modification_IUG = True Then
													Retour_Resultat = str(CPCDOS_INSTANCE.SCI_INSTANCE.CPC__GUI_Init_obj(CPCDOS_INSTANCE.SCI_INSTANCE.GUI_TYPE.CheckBox, CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI, Nouvelle_Cle_GUI, Modification_IUG, _INDEX_CHECKBOX_))
												Else
													Retour_Resultat = str(CPCDOS_INSTANCE.SCI_INSTANCE.CPC__GUI_Init_obj(CPCDOS_INSTANCE.SCI_INSTANCE.GUI_TYPE.CheckBox, CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI, Nouvelle_Cle_GUI, Modification_IUG, 0))
												End if

												' On re-execute la commande mais uniquement pour faire un debug pour recuperer
												'  le numero de PID et pouvoir le socker dans une variable
												' Ca ne vas pas re-creer la fenetre mais ca va simplement renvoyer un texte garce a /#RENVOIDEBUG:
												RetourCCP = CpcdosCP_SHELL(Buffer_lecture & " /#RENVOIDEBUG:" & Retour_Resultat, Nouvelle_Cle_GUI, Niveau_2, Param_1, Param_2)

											End if

											Nouvelle_Cle_GUI = Nouvelle_Cle

											' Remettre les proprietes de type a zero
											GUI__PROP_UPDATER = 0
											GUI__PROP_AUTOSIZE = 0

											GUI__Index_ENFANT = 0
											GUI__Handle = 0

											IUG_CREATION_FENETRE 		= ""
											IUG_CREATION_BOUTON 		= ""
											IUG_CREATION_PICTUREBOX 	= ""
											IUG_CREATION_TEXTEBOX 		= ""
											IUG_CREATION_TEXTEBLOCK 	= ""
											IUG_CREATION_PROGRESSBAR 	= ""
											IUG_CREATION_CHECKBOX 		= ""

											GUI__PROP_VALEUR = 0

											GUI__PROP_CONTENEUR_COMPLET = false
											GUI__PROP_ALPHA_MODE = 0
											Modification_IUG = false
											GUI__PROP_TYPE_OBJ = 0
											GUI__PROP_DEPLACABLE		= true
											GUI__PROP_REDUCTABLE		= true
											GUI__PROP_SIZEABLE			= true
											GUI__PROP_SIZEABLE_ANGL	 	= true
											GUI__PROP_FERMABLE	 		= true
											GUI__PROP_TYPE_BORDURE 		= Val(CCP_Lire_Variable("CPC_GUI.WINDOW.BORD", 3, _CLE_))
											GUI__PROP_TYPE_Ombre 		= Val(CCP_Lire_Variable("CPC_GUI.WINDOW.SHADOW", 3, _CLE_))
											GUI__PROP_COULEURALPHA 		= CCP_Lire_Variable("CPC_GUI.WINDOW.ALPHA", 3, _CLE_)

											' Et les couleurs etc. par defaut
											GUI__PROP_COULEURTITRE  	= CCP_Lire_Variable("CPC_GUI.WINDOW.TITLE_RGB", 3, _CLE_)
											GUI__PROP_COULEURTEXTE   	= CCP_Lire_Variable("CPC_GUI.TEXT_RGB", 3, _CLE_)
											GUI__PROP_COULEURFENETRE  	= CCP_Lire_Variable("CPC_GUI.WINDOW.RGB", 3, _CLE_)
											GUI__PROP_COULEURFOND 		= CCP_Lire_Variable("CPC_GUI.WINDOW.BACKGROUND_RGB", 3, _CLE_)
											GUI__PROP_COULEUR		 	= CCP_Lire_Variable("CPC_GUI.RGB", 3, _CLE_)

											GUI__PROP_TYPE_Console		= FALSE

											' Pour eviter la redondance.
											GUI__PROP_EVENEMENT			= ""
											GUI__PROP_EVENEMENT_DISPO	= ""
										End if
									END IF


									If Instr(RetourCCP, "FIX_NIVEAU") > 0 Then
										IF RetourCCP = "FIX_NIVEAU1" Then Niveau_2 = 1
										ELSEIF RetourCCP = "FIX_NIVEAU2" Then Niveau_2 = 2
										ELSEIF RetourCCP = "FIX_NIVEAU3" Then Niveau_2 = 3
										ELSEIF RetourCCP = "FIX_NIVEAU4" Then Niveau_2 = 4
										ELSEIF RetourCCP = "FIX_NIVEAU5" Then Niveau_2 = 5
									END IF
								End if ' SI Buffer_lecture > 0
							End if

							Buffer_lecture = ""
							Position_DEBUT = Position_FIN
' NoLGNSaut:
						Wend
_FIN_EXE_CCP_EXE:

						' Fonction CpcdosC+ introuvable
						IF Si_Non_EXE_FONCT = 1 Then
							Message_erreur = ERRAVT("ERR_050", 0)
							IF CPCDOS_INSTANCE.Utilisateur_Langage = 0 Then
								DEBUG("[CpcdosC+] " & Message_erreur & ". Nom de la fonction : " & CCP_Fonction_EXEC & " avec " & CCP_Fonction_ARGS_N & " argument(s).", Affichage, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_ERREUR, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.AvecDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_AFF, RetourVAR)
							Else
								DEBUG("[CpcdosC+] " & Message_erreur & ". Function name : " & CCP_Fonction_EXEC & " with " & CCP_Fonction_ARGS_N & " argument(s).", Affichage, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_ERREUR, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.AvecDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_AFF, RetourVAR)
							End If
							CpcdosCP_SHELL = "ERR_050"
						End if

						ENTRER_SectionCritique()

						IF CPCDOS_INSTANCE.SYSTEME_INSTANCE.get_DBG_DEBUG() > 0 Then
							IF CPCDOS_INSTANCE.Utilisateur_Langage = 0 Then
								DEBUG("[CpcdosC+] Fin d'execution de " & Nom_Fichier, Affichage, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_Normal, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.AvecDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_CPCDOS, RetourVAR)
							Else
								DEBUG("[CpcdosC+] End executing " & Nom_Fichier, Affichage, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_Normal, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.AvecDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_CPCDOS, RetourVAR)
							End If
						End if

						' Vider les variables utilises pour la creation de l'instance en memoire pour l'execution du code CpcdosC+
						Gest_variables_Suppr ("_EXE_PATH_", 	2, Auth_Kernel, Auth_OS, Auth_Utilisateur, Auth_PID, Nouvelle_TID)
						Gest_variables_Suppr ("_EXE_PATH_F_", 	2, Auth_Kernel, Auth_OS, Auth_Utilisateur, Auth_PID, Nouvelle_TID)
						Gest_variables_Suppr ("_EXE_PID_", 		2, Auth_Kernel, Auth_OS, Auth_Utilisateur, Auth_PID, Nouvelle_TID)
						Gest_variables_Suppr ("_EXE_TID_", 		2, Auth_Kernel, Auth_OS, Auth_Utilisateur, Auth_PID, Nouvelle_TID)
						Gest_variables_Suppr ("_EXE_DATE_", 	2, Auth_Kernel, Auth_OS, Auth_Utilisateur, Auth_PID, Nouvelle_TID)

						IF CPCDOS_INSTANCE.SYSTEME_INSTANCE.get_DBG_DEBUG() > 0 Then
							IF CPCDOS_INSTANCE.Utilisateur_Langage = 0 Then
								DEBUG("[CpcdosC+] Nettoyage memoire [OK] (PID:" & Auth_PID & " TID:" & Nouvelle_TID & ")", Affichage, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_Normal, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.AvecDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_CPCDOS, RetourVAR)
							Else
								DEBUG("[CpcdosC+] Memory cleaning [OK] (PID:" & Auth_PID & " TID:" & Nouvelle_TID & ")", Affichage, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_Normal, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.AvecDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_CPCDOS, RetourVAR)
							End If
						End if

						SORTIR_SectionCritique()

						IF LEN(LabelAChercher) > 0 Then
							Message_erreur = ERRAVT("ERR_013", 0)
							DEBUG("[CpcdosC+] " & Message_erreur & " " & CHR(34) & Commande & CHR(34) & " --> :" & LabelAChercher & ":", Affichage, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_ERREUR, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.SansDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_AFF, RetourVAR)
						End if

					End scope

						if CCP_discretion = false Then CPCDOS_INSTANCE.En_Charge(false)

					End if ' Erreur interne de CPinti
				Else
					' Fichier existe pas
					Message_erreur = ERRAVT("ERR_015", 0)
					DEBUG("[CpcdosC+] " & Message_erreur & " " & CHR(34) & Param & CHR(34), Affichage, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_ERREUR, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.SansDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_AFF, RetourVAR)
				End if
			Else
				' Instance impossible
				Message_erreur = ERRAVT("ERR_048", 0)
				DEBUG("[CpcdosC+] " & Message_erreur & " " & CHR(34) & Param & CHR(34), Affichage, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_ERREUR, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.SansDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_AFF, RetourVAR)
			End if

			' ===================================================================
			END SCOPE



			exit _scope_CMD, _scope
		End if ' **** EXE/ ****

	_end_scope_CMD

	_scope_CMD

		' ===============================================================
		'  Commande affichage d'une boite de dialogue
		' ===============================================================
		CommLANG(1) = "message/"
		CommLANG(2) = "msgbox/"
		CommLANG(3) = "\\#//"
		CommTrouve = 0 : NoCMD = 0
		for boucle as integer = 1 to 2
			IF OnCherche = CommLANG(boucle) Then
				NoCMD = 0
				exit for
			Else
				NoCMD = 1
			End if
		Next boucle
		IF NoCMD = 1 then CommLANG(1) = "[F.#).|" : CommLANG(2) = "[F.#).|" : CommLANG(3) = "\\#//"
		rem Afficher la liste des commandes avec anglais / francais
		IF AfficherAide = 1 then
			IF CPCDOS_INSTANCE.Utilisateur_Langage = 0 then
				CommandesAide = CommandesAide & CRLF & " message/                   Affichage une boite de dialogue graphique"
			Else
				CommandesAide = CommandesAide & CRLF & " msgbox/                    Display an graphical message box"
			END IF
		END IF
		IF CommLANG(1) = OnCherche Then CommTrouve = 1
		IF CommLANG(2) = OnCherche Then CommTrouve = 2
		IF CommTrouve > 0 Then ' Afficher l'aide de la commande
			IF AfficherAide = 2 then
				Mess_Aide = ""
				IF CPCDOS_INSTANCE.Utilisateur_Langage = 0 THEN
					Mess_Aide = Mess_Aide & CRLF & "  'MeSsaGe'"
					Mess_Aide = Mess_Aide & CRLF
					Mess_Aide = Mess_Aide & CRLF & "  Fonctionnalit�e :"
					Mess_Aide = Mess_Aide & CRLF & "   Cette commande permet d'afficher une boite de dialogue graphique"
					Mess_Aide = Mess_Aide & CRLF & "    pour l'utilisateur. Il en existe 5 types avec 4 modes differents"
					Mess_Aide = Mess_Aide & CRLF
					Mess_Aide = Mess_Aide & CRLF & "   Arguments :"
					Mess_Aide = Mess_Aide & CRLF & "    /Titre:Titre du message"
					Mess_Aide = Mess_Aide & CRLF & "    /Erreur:Numero d'erreur"
					Mess_Aide = Mess_Aide & CRLF & "    /Type:Type de message (Oui,Non,Annuler...)"
					Mess_Aide = Mess_Aide & CRLF & "    /EVENEMENT:Fichier evenement"
					Mess_Aide = Mess_Aide & CRLF & "    /Nom:Nom de la fenetre"
					Mess_Aide = Mess_Aide & CRLF
					Mess_Aide = Mess_Aide & CRLF & "   Type d'erreur associe a une icone :"
					Mess_Aide = Mess_Aide & CRLF & "    - 0 : (Par defaut) Simple message"
					Mess_Aide = Mess_Aide & CRLF & "    - 1 : Information"
					Mess_Aide = Mess_Aide & CRLF & "    - 2 : Question"
					Mess_Aide = Mess_Aide & CRLF & "    - 3 : Avertissement"
					Mess_Aide = Mess_Aide & CRLF & "    - 4 : Erreur"
					Mess_Aide = Mess_Aide & CRLF
					Mess_Aide = Mess_Aide & CRLF & "   Evenement (Par defaut):"
					Mess_Aide = Mess_Aide & CRLF & "     OK_Button_MSGBOX.click()"
					Mess_Aide = Mess_Aide & CRLF & "     YES_Button_MSGBOX.click()"
					Mess_Aide = Mess_Aide & CRLF & "     NO_Button_MSGBOX.click()"
					Mess_Aide = Mess_Aide & CRLF & "     CANCEL_Button_MSGBOX.click()"
					Mess_Aide = Mess_Aide & CRLF
					Mess_Aide = Mess_Aide & CRLF
					Mess_Aide = Mess_Aide & CRLF & "   Type message :"
					Mess_Aide = Mess_Aide & CRLF & "    - 0 : (Par defaut) "
					Mess_Aide = Mess_Aide & CRLF & "    - 1 : Boutons Oui et Non"
					Mess_Aide = Mess_Aide & CRLF & "    - 2 : Boutons Oui, Non et Annuler"
					Mess_Aide = Mess_Aide & CRLF & "    - 3 : Bouton OK + TexteBox"
					Mess_Aide = Mess_Aide & CRLF
					Mess_Aide = Mess_Aide & CRLF & "   Exemple 1 - Affiche un simple message" :
					Mess_Aide = Mess_Aide & CRLF & "     Message/ Coucou je suis un msgbox !"
					Mess_Aide = Mess_Aide & CRLF
					Mess_Aide = Mess_Aide & CRLF & "   Exemple 2 - Affiche un message avec un titre + Avetissement"
					Mess_Aide = Mess_Aide & CRLF & "     Message/ J'aime QUE les frites ! /TITRE:Hello /ERREUR:3"
					Mess_Aide = Mess_Aide & CRLF
					Mess_Aide = Mess_Aide & CRLF & "   Exemple 3 - Question + Oui/Non + Evenement"
					Mess_Aide = Mess_Aide & CRLF & "     Message/ Arreter l'ordi ? /ERREUR:2 /TYPE:1 /EVENEMENT:Fichier.cpc"
					Mess_Aide = Mess_Aide & CRLF & "    Des que l'utilisateur va cliquer sur uns des boutons, Cpcdos"
					Mess_Aide = Mess_Aide & CRLF & "    va executer la fonction CLIC() correspondant"
					Mess_Aide = Mess_Aide & CRLF
					Mess_Aide = Mess_Aide & CRLF & "  Voir aussi : "
					Mess_Aide = Mess_Aide & CRLF
				ELSEIF CPCDOS_INSTANCE.Utilisateur_Langage = 1 THEN
					Mess_Aide = Mess_Aide & CRLF & "  'MSGBOX'"
					Mess_Aide = Mess_Aide & CRLF
					Mess_Aide = Mess_Aide & CRLF & "  Fuctionnality :"
					Mess_Aide = Mess_Aide & CRLF & "   This command allow to display an message box for user"
					Mess_Aide = Mess_Aide & CRLF & "    There are 5 types and 4 modes"
					Mess_Aide = Mess_Aide & CRLF
					Mess_Aide = Mess_Aide & CRLF & "   Arguments :"
					Mess_Aide = Mess_Aide & CRLF & "    /Title:Title of mesage"
					Mess_Aide = Mess_Aide & CRLF & "    /Error:Error type number"
					Mess_Aide = Mess_Aide & CRLF & "    /Type:Message type (yes,no,cancel..)"
					Mess_Aide = Mess_Aide & CRLF & "    /EVENT:Event file"
					Mess_Aide = Mess_Aide & CRLF & "    /Name:Window name"
					Mess_Aide = Mess_Aide & CRLF
					Mess_Aide = Mess_Aide & CRLF & "   Error type associated with an icon"
					Mess_Aide = Mess_Aide & CRLF & "    - 0 : (By default) Simple message"
					Mess_Aide = Mess_Aide & CRLF & "    - 1 : Information"
					Mess_Aide = Mess_Aide & CRLF & "    - 2 : Question"
					Mess_Aide = Mess_Aide & CRLF & "    - 3 : Caution"
					Mess_Aide = Mess_Aide & CRLF & "    - 4 : Error"
					Mess_Aide = Mess_Aide & CRLF
					Mess_Aide = Mess_Aide & CRLF & "   Event (By default):"
					Mess_Aide = Mess_Aide & CRLF & "     OK_Button_MSGBOX.click()"
					Mess_Aide = Mess_Aide & CRLF & "     YES_Button_MSGBOX.click()"
					Mess_Aide = Mess_Aide & CRLF & "     NO_Button_MSGBOX.click()"
					Mess_Aide = Mess_Aide & CRLF & "     CANCEL_Button_MSGBOX.click()"
					Mess_Aide = Mess_Aide & CRLF
					Mess_Aide = Mess_Aide & CRLF & "   Message type :"
					Mess_Aide = Mess_Aide & CRLF & "    - 0 : (By default) "
					Mess_Aide = Mess_Aide & CRLF & "    - 1 : Yes, No buttons"
					Mess_Aide = Mess_Aide & CRLF & "    - 2 : BYes, No and Cancel button"
					Mess_Aide = Mess_Aide & CRLF & "    - 3 : OK button + Textbox"
					Mess_Aide = Mess_Aide & CRLF
					Mess_Aide = Mess_Aide & CRLF & "   Example 1 - Display an simple message"
					Mess_Aide = Mess_Aide & CRLF & "     msgbox/ Hello, I'm msgbox !"
					Mess_Aide = Mess_Aide & CRLF
					Mess_Aide = Mess_Aide & CRLF & "   Example 2 - Display an message with title + Caution"
					Mess_Aide = Mess_Aide & CRLF & "     Msgbox/ I like ONLY bananas ! /TITLE:Hello /ERROR:3"
					Mess_Aide = Mess_Aide & CRLF
					Mess_Aide = Mess_Aide & CRLF & "   Example 3 - Yes/No question + Event"
					Mess_Aide = Mess_Aide & CRLF & "     Msgbox/ shutdown computer ? /ERROR:2 /TYPE:1 /EVENT:File.cpc"
					Mess_Aide = Mess_Aide & CRLF & "    When user will click on button, cpcdos will execute"
					Mess_Aide = Mess_Aide & CRLF & "    CLIC() function example"
					Mess_Aide = Mess_Aide & CRLF
					Mess_Aide = Mess_Aide & CRLF & "  See also : "
					Mess_Aide = Mess_Aide & CRLF
				END IF

				DEBUG(Mess_Aide, Affichage, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_SURBRILLE, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.SansDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_AFF, RetourVAR)
				testCMD = 0
				AfficherAide = 0
				exit _scope_CMD, _scope
			END IF
			' Tester la syntaxe
			testCMD	= CCP_Verifier_Syntaxe(Commande, CommPosition)
			IF testCMD > 10 Then exit _scope_CMD, _scope
			IF testCMD > 0 then  ' Entre 1-5 = Pas d'affichage via le @, @$ ou @#
				IF testCMD < 6 then
					Affichage = 0
					IF testCMD = 3 Then CpcdosCP_SHELL("FIX/ " & CPCDOS_INSTANCE.DEBUG_INSTANCE.LeRetour & " = \#NULL", _CLE_, NIVEAU_CCP, Param_1, Param_2) : RetourVAR = _CLE_ & "N" & NIVEAU_CCP & "->" & CPCDOS_INSTANCE.DEBUG_INSTANCE.LeRetour
					if testCMD = 2 Then RetourVAR = "$>" & CPCDOS_INSTANCE.DEBUG_INSTANCE.LeRetour ' ajouter une securite ?
				Else
					Affichage = 1
				END IF
			Else
				Affichage = 1
			END IF
			' Recuperer les Parametres
			Param = MID(Commande, CommPosition + TailleComm + 2)
			SCOPE
			' ====================================================================

			' Nettoyer les blancs

			Dim as integer FR_Titre, FR_Erreur, FR_Type, FR_EV, FR_Nom
			Dim as String STR_FR_Titre, STR_FR_Erreur, STR_FR_Type, STR_FR_EV, STR_FR_Nom

			Dim as integer EN_Titre, EN_Erreur, EN_Type, EN_EV, EN_Nom
			Dim as String STR_EN_Titre, STR_EN_Erreur, STR_EN_Type, STR_EN_EV, STR_EN_Nom

			Dim as String  STR_Titre, STR_Erreur, STR_Type, STR_EV, STR_Nom, STR_Message

			Dim Suite_msg as Integer

			STR_FR_Titre 	= "/TITRE:" 	: STR_EN_Titre 	= "/TITLE:"
			STR_FR_Erreur 	= "/ERREUR:" 	: STR_EN_Erreur = "/ERROR:"
			STR_FR_Type 	= "/TYPE:" 		: STR_EN_Type 	= "/TYPE:"
			STR_FR_EV 		= "/EVENEMENT:" : STR_EN_EV 	= "/EVENT:"
			STR_FR_Nom 		= "/NOM:" 		: STR_EN_Nom 	= "/NAME:"


			Param = Ltrim(Ltrim(Rtrim(Rtrim(Param), chr(09))), chr(09))

			Suite_msg = INSTR(Param, " /")
			STR_Message = Mid(Param, 1, Suite_msg - 1)

			FR_Titre = Instr(Ucase(Param), 	STR_FR_Titre)
			FR_Erreur = Instr(Ucase(Param), STR_FR_Erreur)
			FR_Type = Instr(Ucase(Param), 	STR_FR_Type)
			FR_EV = Instr(Ucase(Param), 	STR_FR_EV)
			FR_Nom = Instr(Ucase(Param), 	STR_FR_Nom)

			EN_Titre = Instr(Ucase(Param), 	STR_EN_Titre)
			EN_Erreur = Instr(Ucase(Param), STR_EN_Erreur)
			EN_Type = Instr(Ucase(Param), 	STR_EN_Type)
			EN_EV = Instr(Ucase(Param), 	STR_EN_EV)
			EN_Nom = Instr(Ucase(Param), 	STR_EN_Nom)

			' *****************
			' *** T I T R E ***
			' *****************

			IF FR_Titre > 0 Then
				Dim Suite as Integer = INSTR(FR_Titre, Param, " /")

				FR_Titre += Len(STR_FR_Titre)

				IF Suite > 0 Then
					STR_Titre = MID(Param, FR_Titre, Suite - FR_Titre) ' Capturer jusqu'au prochain ' /'
				ELSE
					STR_Titre = MID(Param, FR_Titre)
				End if
			ElseIf EN_Titre > 0 Then
				Dim Suite as Integer = INSTR(EN_Titre, Param, " /")

				EN_Titre += Len(STR_EN_Titre)

				IF Suite > 0 Then
					STR_Titre = MID(Param, EN_Titre, Suite - EN_Titre) ' Capturer jusqu'au prochain ' /'
				ELSE
					STR_Titre = MID(Param, EN_Titre)
				End if
			End if

			' *******************
			' *** E R R E U R ***
			' *******************

			IF FR_Erreur > 0 Then
				Dim Suite as Integer = INSTR(FR_Erreur, Param, " /")

				FR_Erreur += Len(STR_FR_Erreur)

				IF Suite > 0 Then
					STR_Erreur = MID(Param, FR_Erreur, Suite - FR_Erreur) ' Capturer jusqu'au prochain ' /'
				ELSE
					STR_Erreur = MID(Param, FR_Erreur)
				End if
			ElseIf EN_Erreur > 0 Then
				Dim Suite as Integer = INSTR(EN_Erreur, Param, " /")

				EN_Erreur += Len(STR_EN_Erreur)

				IF Suite > 0 Then
					STR_Erreur = MID(Param, EN_Erreur, Suite - EN_Erreur) ' Capturer jusqu'au prochain ' /'
				ELSE
					STR_Erreur = MID(Param, EN_Erreur)
				End if
			End if

			' ***************
			' *** T Y P E ***
			' ***************

			IF FR_Type > 0 Then
				Dim Suite as Integer = INSTR(FR_Type, Param, " /")

				FR_Type += Len(STR_FR_Type)

				IF Suite > 0 Then
					STR_Type = MID(Param, FR_Type, Suite - FR_Type) ' Capturer jusqu'au prochain ' /'
				ELSE
					STR_Type = MID(Param, FR_Type)
				End if
			ElseIf EN_Type > 0 Then
				Dim Suite as Integer = INSTR(EN_Type, Param, " /")

				EN_Type += Len(STR_EN_Type)

				IF Suite > 0 Then
					STR_Type = MID(Param, EN_Type, Suite - EN_Type) ' Capturer jusqu'au prochain ' /'
				ELSE
					STR_Type = MID(Param, EN_Type)
				End if
			End if

			' *************************
			' *** E V E N E M E N T ***
			' *************************

			IF FR_EV > 0 Then
				Dim Suite as Integer = INSTR(FR_EV, Param, " /")

				FR_EV += Len(STR_FR_EV)

				IF Suite > 0 Then
					STR_EV = MID(Param, FR_EV, Suite - FR_EV) ' Capturer jusqu'au prochain ' /'
				ELSE
					STR_EV = MID(Param, FR_EV)
				End if
			ElseIf EN_EV > 0 Then
				Dim Suite as Integer = INSTR(EN_EV, Param, " /")

				EN_EV += Len(STR_EN_EV)

				IF Suite > 0 Then
					STR_EV = MID(Param, EN_EV, Suite - EN_EV) ' Capturer jusqu'au prochain ' /'
				ELSE
					STR_EV = MID(Param, EN_EV)
				End if
			End if

			' *************
			' *** N O M ***
			' *************

			IF FR_Nom > 0 Then
				Dim Suite as Integer = INSTR(FR_Nom, Param, " /")

				FR_Nom += Len(STR_FR_Nom)

				IF Suite > 0 Then
					STR_Nom = MID(Param, FR_Nom, Suite - FR_Nom) ' Capturer jusqu'au prochain ' /'
				ELSE
					STR_Nom = MID(Param, FR_Nom)
				End if
			ElseIf EN_Nom > 0 Then
				Dim Suite as Integer = INSTR(EN_Nom, Param, " /")

				EN_Nom += Len(STR_EN_Nom)

				IF Suite > 0 Then
					STR_Nom = MID(Param, EN_Nom, Suite - EN_Nom) ' Capturer jusqu'au prochain ' /'
				ELSE
					STR_Nom = MID(Param, EN_Nom)
				End if
			End if

			IF CPCDOS_INSTANCE.Utilisateur_Langage = 0 then
				DEBUG("[CpcdosC+] Creation d'un message box " & CRLF _
						& "Texte  '" & STR_Message & "'" & CRLF _
						& "Titre  '" & STR_Titre & "'" & CRLF _
						& "Erreur '" & STR_Erreur & "'" & CRLF _
						& "Type   '" & STR_Type & "'" & CRLF _
						& "Ev     '" & STR_EV & "'" & CRLF _
						& "Nom    '" & STR_Nom & "'" & CRLF, _
						Affichage, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_AVERTISSEMENT, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.AvecDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_AFF, RetourVAR)
			Else
				DEBUG("[CpcdosC+] Creating msgbox " & CRLF _
						& "Texte  '" & STR_Message & "'" & CRLF _
						& "Titre  '" & STR_Titre & "'" & CRLF _
						& "Erreur '" & STR_Erreur & "'" & CRLF _
						& "Type   '" & STR_Type & "'" & CRLF _
						& "Ev     '" & STR_EV & "'" & CRLF _
						& "Nom    '" & STR_Nom & "'" & CRLF, _
						Affichage, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_AVERTISSEMENT, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.AvecDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_AFF, RetourVAR)
			End if

			Scope
				Dim handle_num 	as Integer
				Dim Arguments 	as String = STR_Message

				' Concatener les arguments selon ce qui a ete ecrit
				if NOT STR_Titre = "" Then 	Arguments += "," & STR_Titre
				if NOT STR_Erreur = "" Then Arguments += "," & STR_Erreur
				if NOT STR_Type = "" Then 	Arguments += "," & STR_Type
				if NOT STR_EV = "" Then 	Arguments += "," & STR_EV
				if NOT STR_Nom = "" Then 	Arguments += "," & STR_Nom


				' Pour recuperer le numero de PID si le @# a ete definit
				if NOT CPCDOS_INSTANCE.DEBUG_INSTANCE.LeRetour = "" Then
					CpcdosCP_SHELL("@#" & CPCDOS_INSTANCE.DEBUG_INSTANCE.LeRetour & " txt/ /F:Gui.MsgBox(" & Arguments & ")", _CLE_, NIVEAU_CCP, Param_1, Param_2)
				Else
					CpcdosCP_SHELL("txt/ /F:Gui.MsgBox(" & Arguments & ")", _CLE_, NIVEAU_CCP, Param_1, Param_2)
				End if

			End Scope

			' ====================================================================
			END SCOPE

			exit _scope_CMD, _scope
		End if ' **** MSGBOX/ ****

	_end_scope_CMD


	_scope_CMD

		' ===============================================================
		'  Commande pour creer / stopper un serveur TCP
		' ===============================================================
		CommLANG(1) = "serveur/"
		CommLANG(2) = "server/"
		CommLANG(3) = "\\#//"
		CommTrouve = 0 : NoCMD = 0
		for boucle as integer = 1 to 2
			IF OnCherche = CommLANG(boucle) Then
				NoCMD = 0
				exit for
			Else
				NoCMD = 1
			End if
		Next boucle
		IF NoCMD = 1 then CommLANG(1) = "[F.#).|" : CommLANG(2) = "[F.#).|" : CommLANG(3) = "\\#//"

		'Afficher la liste des commandes avec anglais / francais
		IF AfficherAide = 1 then
			IF CPCDOS_INSTANCE.Utilisateur_Langage = 0 then
				CommandesAide = CommandesAide & CRLF & " Serveur/                   Demarre ou stoppe un serveur TCP avec un numero de port desir�"
			Else
				CommandesAide = CommandesAide & CRLF & " Server/                    Start or stop a TCP server with your port number"
			END IF
		END IF
		IF CommLANG(1) = OnCherche Then CommTrouve = 1
		IF CommLANG(2) = OnCherche Then CommTrouve = 2
		IF CommTrouve > 0 Then ' Afficher l'aide de la commande
			IF AfficherAide = 2 then
				Mess_Aide = ""
				IF CPCDOS_INSTANCE.Utilisateur_Langage = 0 THEN
					Mess_Aide = Mess_Aide & CRLF & "  Fonctionnalit�e :"
					Mess_Aide = Mess_Aide & CRLF & "   Cette commande permet de creer ou stopper un serveur TCP/UDP"
					Mess_Aide = Mess_Aide & CRLF
					Mess_Aide = Mess_Aide & CRLF & "  Mode CCP=Interpretation en ligne de commandes CpcdosC+"
					Mess_Aide = Mess_Aide & CRLF & "  Mode TEL=Interpretation en telnet depuis la console CpcdosC+"
					Mess_Aide = Mess_Aide & CRLF
					Mess_Aide = Mess_Aide & CRLF & "  Exemples creation d'un serveur:"
					Mess_Aide = Mess_Aide & CRLF & "   - Demarrer un serveur sur le port 1234 (Mode GET par defaut):"
					Mess_Aide = Mess_Aide & CRLF & "      Serveur/ /TCP:1234"
					Mess_Aide = Mess_Aide & CRLF & "   - Demarrer un serveur d'interpreteur CpcdosC+ avec le mode CCP"
					Mess_Aide = Mess_Aide & CRLF & "      Serveur/ /MODE:CCP /TCP:1234"
					Mess_Aide = Mess_Aide & CRLF & "   - Demarrer un serveur Telnet avec le mode TELNET ou TEL"
					Mess_Aide = Mess_Aide & CRLF & "      Serveur/ /MODE:TEL /TCP:1234"
					Mess_Aide = Mess_Aide & CRLF & "   - Demarrer un serveur de renvoi de requetes avec le mode ECHO"
					Mess_Aide = Mess_Aide & CRLF & "      Serveur/ /MODE:ECHO /TCP:1234"
					Mess_Aide = Mess_Aide & CRLF & "   - Arreter un serveur via son numero de port (ex:1234):"
					Mess_Aide = Mess_Aide & CRLF & "      Serveur/ /Stop:1234"
					Mess_Aide = Mess_Aide & CRLF & "   - Envoyer un message a un client via son numero de port (socket 8):"
					Mess_Aide = Mess_Aide & CRLF & "      Serveur/ /envoyer:1234 TCP#8=Salut toi!"
					Mess_Aide = Mess_Aide & CRLF & "   - Envoyer un message a tous les clients:"
					Mess_Aide = Mess_Aide & CRLF & "      Serveur/ /envoyer:1234 Salut tous le monde!"
					Mess_Aide = Mess_Aide & CRLF
					Mess_Aide = Mess_Aide & CRLF & " Remarque: Cette commande renvoie '1' si le serveur a bien ete cree"
					Mess_Aide = Mess_Aide & CRLF
					Mess_Aide = Mess_Aide & CRLF & "  Voir aussi : ping/ , telecharger/ , client/ "
					Mess_Aide = Mess_Aide & CRLF
				ELSEIF CPCDOS_INSTANCE.Utilisateur_Langage = 1 THEN
					Mess_Aide = Mess_Aide & CRLF & "  Fonctionnality :"
					Mess_Aide = Mess_Aide & CRLF & "   This command allow to start or stop a TCP/UDP server"
					Mess_Aide = Mess_Aide & CRLF & "   You can also start a TCP client connection"
					Mess_Aide = Mess_Aide & CRLF
					Mess_Aide = Mess_Aide & CRLF & "  CCP mode=Line command interpretation in CpcdosC+"
					Mess_Aide = Mess_Aide & CRLF & "  TEL mode=Telnet interpretation under CpcdosC+ console"
					Mess_Aide = Mess_Aide & CRLF
					Mess_Aide = Mess_Aide & CRLF
					Mess_Aide = Mess_Aide & CRLF & "  Exemples sreate a TCP server :"
					Mess_Aide = Mess_Aide & CRLF & "   - Start 1 simple server on 1234 port (VAR mode by default) :"
					Mess_Aide = Mess_Aide & CRLF & "      Server/ /TCP:1234"
					Mess_Aide = Mess_Aide & CRLF & "   - Start 1 simple server on 1234 port with CCP mode specified:"
					Mess_Aide = Mess_Aide & CRLF & "      Server/ /MODE:CCP /TCP:1234"
					Mess_Aide = Mess_Aide & CRLF & "   - Start 1 simple server on 1234 port with TELNET or TEL mode specified:"
					Mess_Aide = Mess_Aide & CRLF & "      Server/ /MODE:TELNET /TCP:1234"
					Mess_Aide = Mess_Aide & CRLF & "   - Start 1 simple echo server on 1234 port with ECHO mode specified:"
					Mess_Aide = Mess_Aide & CRLF & "      Server/ /MODE:ECHO /TCP:1234"
					Mess_Aide = Mess_Aide & CRLF & "   - Stopping server with his port number:"
					Mess_Aide = Mess_Aide & CRLF & "      Server/ /Stop:1234"
					Mess_Aide = Mess_Aide & CRLF & "   - Send message for specific connected client (socket number:8):"
					Mess_Aide = Mess_Aide & CRLF & "      Server/ /send:1234 TCP#8=Hello!"
					Mess_Aide = Mess_Aide & CRLF & "   - Send message for all connected client (ex:4321):"
					Mess_Aide = Mess_Aide & CRLF & "      Server/ /send:1234 Hello all!"
					Mess_Aide = Mess_Aide & CRLF
					Mess_Aide = Mess_Aide & CRLF & " Remark: This command return '1' if server has been created."
					Mess_Aide = Mess_Aide & CRLF
					Mess_Aide = Mess_Aide & CRLF & "  See also : ping/ , download/ , client/ "
					Mess_Aide = Mess_Aide & CRLF
				END IF
				DEBUG(Mess_Aide, Affichage, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_SURBRILLE, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.SansDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_AFF, RetourVAR)
				testCMD = 0
				AfficherAide = 0
				exit _scope_CMD, _scope
			END IF
			' Tester la syntaxe
			testCMD	= CCP_Verifier_Syntaxe(Commande, CommPosition)
			IF testCMD > 10 Then exit _scope_CMD, _scope
			IF testCMD > 0 then  ' Entre 1-5 = Pas d'affichage via le @, @$ ou @#
				IF testCMD < 6 then
					Affichage = 0
					IF testCMD = 3 Then CpcdosCP_SHELL("FIX/ " & CPCDOS_INSTANCE.DEBUG_INSTANCE.LeRetour & " = \#NULL", _CLE_, NIVEAU_CCP, Param_1, Param_2) : RetourVAR = _CLE_ & "N" & NIVEAU_CCP & "->" & CPCDOS_INSTANCE.DEBUG_INSTANCE.LeRetour
					if testCMD = 2 Then RetourVAR = "$>" & CPCDOS_INSTANCE.DEBUG_INSTANCE.LeRetour ' ajouter une securite ?
				Else
					Affichage = 1
				END IF
			Else
				Affichage = 1
			END IF
			Dim posCMD2deSRV as integer
			' Recuperer les Parametres
			Param = MID(Commande, CommPosition + TailleComm + 2)
			SCOPE
			' ====================================================================


			' Numero de port du serveur
			Dim Port_du_Serveur 		as Integer

			' Mode : RAW ou Admin
			Dim ModeDuServeurR			as String

			' Resultat: 1:TCP raw , 2:TCP admin , 3:UDP raw, 23:Telnet
			Dim Type_Serveur			as Integer

			' 0:Creer serveur , 1:Envoyer , 2:Recevoir , 3:STOP
			Dim Action					as integer

			Dim NombreUtilisateur		as integer = 8 ' 8 par defaut

			' Donnees recu ou a envoyer
			Dim DONNEES					as String

			' Arguments checker
			Dim PosSrvMode				as Integer
			Dim Pos2pTcp				as Integer
			Dim Pos2pUdp				as Integer

			Dim Pos2PStop				as Integer
			Dim Pos2PEnvoyer			as Integer
			Dim Pos2PSend				as Integer
			Dim Pos2PRecevoir			as Integer
			Dim Pos2PReceive			as Integer

			Dim Pos2ATTENDRE			as integer
			Dim Pos2WAIT				as integer
			Dim TempsAttente			as Double

			' IF Len(Param) < 4 then Goto SERVEUR_ParamDispo

			' Creation d'un serveur TCP/UDP
			Pos2pTcp 		= Instr(UCASE(Param), "/TCP:")
			Pos2pUdp 		= Instr(UCASE(Param), "/UDP:")

			' Mode CONSOLE ou Mode RAW (par defaut)
			PosSrvMode 		= instr(UCASE(Param), "/MODE:")

			' Discuter avec le buffer
			Pos2PEnvoyer	= Instr(UCASE(Param), "/ENVOYER:") ' Envoyer
			Pos2PSend		= Instr(UCASE(Param), "/SEND:") 	' Envoyer
			Pos2PRecevoir	= Instr(UCASE(Param), "/RECEVOIR:")' Receptionner
			Pos2PReceive	= Instr(UCASE(Param), "/RECEIVE:") ' Receptionner

			Pos2ATTENDRE	= Instr(UCASE(Param), "/ATTENDRE") ' Attendre la reception
			Pos2WAIT		= Instr(UCASE(Param), "/WAIT") 	' Attendre la reception

			' Arreter un serveur ou client
			Pos2PStop 		= Instr(UCASE(Param), "/STOP:")

			posCMD2deSRV 	= Instr(UCASE(Param), "SERVEUR/")
			if posCMD2deSRV < 1 then posCMD2deSRV = Instr(UCASE(Param), "SERVER/")


			' Verifier si les parametres ne sont pas suivit via une autre instance de 'SERVEUR/
			if posCMD2deSRV > 0 then
				if PosSrvMode 		>= posCMD2deSRV+5 then PosSrvMode 		= 0
				if Pos2PEnvoyer		>= posCMD2deSRV+8 then Pos2PEnvoyer		= 0
				if Pos2PSend		>= posCMD2deSRV+5 then Pos2PSend 		= 0
				if Pos2PRecevoir 	>= posCMD2deSRV+9 then Pos2PRecevoir 	= 0
				if Pos2PReceive		>= posCMD2deSRV+8 then Pos2PReceive 	= 0
				if Pos2pTcp 		>= posCMD2deSRV+4 then Pos2pTcp 		= 0
				if Pos2pUdp 		>= posCMD2deSRV+4 then Pos2pUdp 		= 0
				if Pos2PStop 		>= posCMD2deSRV+5 then Pos2PStop 		= 0
				if Pos2ATTENDRE		>= posCMD2deSRV+8 then Pos2ATTENDRE		= 0
				if Pos2WAIT			>= posCMD2deSRV+4 then Pos2WAIT			= 0
			end if

			' Envoyer les donnees
			If Pos2PEnvoyer > 0 then ' (SERVEUR/ /ENVOYER:[NoPort] Blablablabla..)
				Action = 1 ' Envoyer

				' Position de l'espace entre le NoPort et les donnees
				Dim PosEspace as integer = INSTR(Pos2PEnvoyer, Param, " ")

				' Recuperer le port du serveur
				Port_du_Serveur = val(RTRIM(LTRIM(LTRIM(MID(Param, Pos2PEnvoyer + 9, PosEspace - (Pos2PEnvoyer + 9)))), CHR(09)))

				' Recuperer les donnees a envoyer
				DONNEES = MID(Param, PosEspace + 1)

			Elseif Pos2PSend > 0 then ' (SERVEUR/ /SEND:[NoPort] Blablablabla..)
				Action = 1 ' Send

				' Position de l'espace entre le NoPort et les donnees
				Dim PosEspace as integer = INSTR(Pos2PSend, Param, " ")

				' Recuperer le port du serveur
				Port_du_Serveur = val(RTRIM(LTRIM(LTRIM(MID(Param, Pos2PSend + 6, PosEspace - (Pos2PSend + 6))), CHR(09))))

				' Recuperer les donnees a envoyer
				DONNEES = MID(Param, PosEspace + 1)

			' Recevoir des donnees
			Elseif Pos2PRecevoir > 0 then ' (SERVEUR/ /RECEVOIR:[NoPort])
				Action = 2 ' Recevoir

				' Recuperer le port du serveur
				Port_du_Serveur = val(RTRIM(LTRIM(LTRIM(MID(Param, Pos2PRecevoir + 10)), CHR(09))))

				IF Pos2ATTENDRE > 0 Then
					TempsAttente = val(RTRIM(LTRIM(LTRIM(MID(Param, Pos2ATTENDRE + 10))), CHR(09)))
				ElseIF Pos2WAIT > 0 Then
					TempsAttente = val(RTRIM(LTRIM(LTRIM(MID(Param, Pos2WAIT + 5))), CHR(09)))
				End if

				' Si le temps est inferieur ou egale a zero, pas de pause
				IF TempsAttente <= 0 Then TempsAttente = 0

			Elseif Pos2PReceive > 0 then ' (SERVEUR/ /RECEIVE:[NoPort])
				Action = 2 ' Recevoir

				' Recuperer le port du serveur
				Port_du_Serveur = val(RTRIM(LTRIM(LTRIM(MID(Param, Pos2PReceive + 9))), CHR(09)))

				IF Pos2ATTENDRE > 0 Then
					TempsAttente = val(RTRIM(LTRIM(LTRIM(MID(Param, Pos2ATTENDRE + 10))), CHR(09)))
				ElseIF Pos2WAIT > 0 Then
					TempsAttente = val(RTRIM(LTRIM(LTRIM(MID(Param, Pos2WAIT + 5))), CHR(09)))
				End if

				' Si le temps est inferieur ou egale a zero, pas de pause
				IF TempsAttente <= 0 Then TempsAttente = 0

			' ==== Protocole   T C P ==== (SERVEUR/ /TCP:[NoPort])
			ElseIf Pos2pTcp > 0 Then ' TCP
				Type_Serveur = 1
				Action = 0 ' creer

				' Recuperer le port du serveur
				Port_du_Serveur = val(RTRIM(LTRIM(LTRIM(MID(Param, Pos2pTcp + 5)), CHR(09))))

			' ==== Protocole   U D P ====
			ElseIF Pos2pUdp > 0 Then ' UDP (SERVEUR/ /UDP:[NoPort])
				Type_Serveur = 2
				Action = 0 ' creer

				' Recuperer le port du serveur
				Port_du_Serveur = val(RTRIM(LTRIM(LTRIM(MID(Param, Pos2pUdp + 5)), CHR(09))))

			' Arreter le serveur
			Elseif Pos2PStop > 0 Then ' (SERVEUR/ /STOP:[NoPort])
				Action = 3 ' arreter

				' Recuperer le port du serveur
				Port_du_Serveur = val(RTRIM(LTRIM(LTRIM(MID(Param, Pos2PStop + 6)), CHR(09))))

			Else
	SERVEUR_ParamDispo:
				IF CPCDOS_INSTANCE.Utilisateur_Langage = 0 Then
					DEBUG("[CpcdosC+] Parametres disponibles : /TCP:[No Port], /UDP:[No Port] , /ENVOYER:[No Port] [TCP#[NoSocket]=] [UDP#[NoSocket]=]Donnees, /RECEVOIR:[No Port]  , /STOP:[No Port]", Affichage, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_AVERTISSEMENT, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.AvecDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_AFF, RetourVAR)
				Else
					DEBUG("[CpcdosC+] Avaiable Parameters : /TCP:[No Port], /UDP:[No Port] , /SEND:[No Port] [TCP#[NoSocket]=] [UDP#[NoSocket]=]Data, /RECEIVE:[No Port]  , /STOP:[No Port]", Affichage, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_AVERTISSEMENT, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.AvecDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_AFF, RetourVAR)
				End if
				exit _scope_CMD, _scope
			End if

			' Mode du serveur (TCP, UDP, TCP admin (CCP) , Telnet ou Echo
			if PosSrvMode > 0 then
				ModeDuServeurR = Ucase(MID(Param, PosSrvMode + 6, 3))
				If ModeDuServeurR = "CCP" OR ModeDuServeurR = "TEL" OR ModeDuServeurR = "ECH" then
					' Acc�s a la console d'administration en CpcdosC+

					if Type_Serveur = 3 then
						' Serveur d'administrateur en UDP --> A eviter!

						Message_erreur = ERRAVT("AVT_067", 0) ' UDP en admin
						IF CPCDOS_INSTANCE.Utilisateur_Langage = 0 Then
							DEBUG("[CpcdosC+] " & Message_erreur & ". Le TCP sera utilise.", Affichage, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_AVERTISSEMENT, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.AvecDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_AFF, RetourVAR)
						Else
							DEBUG("[CpcdosC+] " & Message_erreur & ". TCP will be used.", Affichage, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_AVERTISSEMENT, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.AvecDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_AFF, RetourVAR)
						End if
					end if

					if ModeDuServeurR = "CCP" Then
						Type_Serveur = 3 ' TCP admin (CCP)
					ElseIF ModeDuServeurR = "TEL" Then
						Type_Serveur = 4 ' TCP admin (Telnet)
					ElseIF ModeDuServeurR = "ECH" Then
						Type_Serveur = 5 ' TCP Echo
					End if

				Elseif ModeDuServeurR = "STD" then
					' STanDard (Defaut) : Reception&Envoie des donnees via un buffer publique

				else
					' Si le mode specifie n'existe pas
					IF CPCDOS_INSTANCE.Utilisateur_Langage = 0 Then
						DEBUG("[CpcdosC+] Modes disponibles : STD, CCP.", Affichage, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_AVERTISSEMENT, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.AvecDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_AFF, RetourVAR)
					Else
						DEBUG("[CpcdosC+] Avaiable modes : STD, CCP.", Affichage, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_AVERTISSEMENT, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.AvecDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_AFF, RetourVAR)
					End if
					exit _scope_CMD, _scope
				End if
			else
				' Si aucun mode est specifie, par defaut il s'agit de STD
				ModeDuServeurR = "STD"
			End if
			Dim Resultat as integer = 0

			If Action = 1 Then ' Envoyer
				' **** Receptionner les donnees ****

				Resultat = CPCDOS_INSTANCE.RESEAU_INSTANCE.ENVOYER_Serveur(DONNEES, Port_du_Serveur, Auth_PID, RetourVAR)

			ElseIf Action = 2 Then
				' **** Receptionner les donnees ****

				IF Pos2ATTENDRE > 0 OR Pos2WAIT > 0 Then
					Resultat = CPCDOS_INSTANCE.RESEAU_INSTANCE.RECEVOIR_Serveur(Port_du_Serveur, Auth_PID, RetourVAR, TRUE, TempsAttente)
				Else
					Resultat = CPCDOS_INSTANCE.RESEAU_INSTANCE.RECEVOIR_Serveur(Port_du_Serveur, Auth_PID, RetourVAR, FALSE, 0)
				End if

			ElseIf Action = 3 Then
				' **** Arreter un serveur ****

				Resultat = CPCDOS_INSTANCE.RESEAU_INSTANCE.STOP_Serveur(Port_du_Serveur, Auth_PID, RetourVAR)

			ElseIf Action = 0 Then
				' **** Creer un serveur TCP/UDP ****

				if Type_Serveur = 1 OR Type_Serveur = 3 OR Type_Serveur = 4 OR Type_Serveur = 5 Then

					' Creer un serveur TCP
					Resultat = CPCDOS_INSTANCE.RESEAU_INSTANCE.Serveur_TCP(Port_du_Serveur, NombreUtilisateur, Auth_PID, Type_Serveur, RetourVAR)

				ElseIf Type_Serveur = 2 OR Type_Serveur = 6 Then

					' Creer un serveur UDP
					Resultat = CPCDOS_INSTANCE.RESEAU_INSTANCE.Serveur_UDP(Port_du_Serveur, NombreUtilisateur, Auth_PID, RetourVAR)

				End if
			Else ' Aucun



			end if


			IF Resultat = CPCDOS_INSTANCE._DOSBOX Then ' Mode DOSBOX
				Message_erreur = ERRAVT("AVT_055", 0)
				IF CPCDOS_INSTANCE.Utilisateur_Langage = 0 Then
					DEBUG("[Reseau] AVT_055:" & Message_erreur & ". Impossible de demarrer le serveur.", Affichage, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_AVERTISSEMENT, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.SansDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_AFF, RetourVAR)
				Else
					DEBUG("[Network] AVT_055:" & Message_erreur & ". Unable to starting server.", Affichage, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_AVERTISSEMENT, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.SansDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_AFF, RetourVAR)
				End if
			ElseIf Resultat = CPCDOS_INSTANCE._SANS_Reseau Then ' Mode sans reseau ( Mode avion )
				Message_erreur = ERRAVT("AVT_072", 0)
				IF CPCDOS_INSTANCE.Utilisateur_Langage = 0 Then
					DEBUG("[Reseau] AVT_072:" & Message_erreur & ". Impossible de demarrer le serveur.", Affichage, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_AVERTISSEMENT, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.SansDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_AFF, RetourVAR)
				Else
					DEBUG("[Network] AVT_072:" & Message_erreur & ". Unable to starting server.", Affichage, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_AVERTISSEMENT, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.SansDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_AFF, RetourVAR)
				End if
			ELSEIF Resultat = -2 Then ' Erreur config socket
				Message_erreur = ERRAVT("ERR_054", 0)
				IF CPCDOS_INSTANCE.Utilisateur_Langage = 0 Then
					DEBUG("[Reseau] ERR_054:" & Message_erreur & ". Impossible de demarrer le serveur.", Affichage, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_AVERTISSEMENT, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.SansDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_AFF, RetourVAR)
				Else
					DEBUG("[Network]ERR_054: " & Message_erreur & ". Unable to starting server.", Affichage, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_AVERTISSEMENT, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.SansDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_AFF, RetourVAR)
				End if
			ELSEIF Resultat = -3 Then ' Driver manquant
				Message_erreur = ERRAVT("AVT_023", 0)
				IF CPCDOS_INSTANCE.Utilisateur_Langage = 0 Then
					DEBUG("[Reseau] AVT_023:" & Message_erreur & ". Impossible de demarrer le serveur.", Affichage, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_AVERTISSEMENT, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.SansDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_AFF, RetourVAR)
				Else
					DEBUG("[Network] AVT_023:" & Message_erreur & ". Unable to starting server.", Affichage, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_AVERTISSEMENT, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.SansDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_AFF, RetourVAR)
				End if
			ELSEIF Resultat = -4 Then ' Erreur binding
				Message_erreur = ERRAVT("ERR_055", 0)
				IF CPCDOS_INSTANCE.Utilisateur_Langage = 0 Then
					DEBUG("[Reseau] ERR_055:" & Message_erreur & ". Impossible de demarrer le serveur.", Affichage, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_AVERTISSEMENT, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.SansDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_AFF, RetourVAR)
				Else
					DEBUG("[Network] ERR_055" & Message_erreur & ". Unable to starting server.", Affichage, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_AVERTISSEMENT, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.SansDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_AFF, RetourVAR)
				End if
			ELSEIF Resultat = -5 Then ' Erreur ecoute
				Message_erreur = ERRAVT("ERR_056", 0)
				IF CPCDOS_INSTANCE.Utilisateur_Langage = 0 Then
					DEBUG("[Reseau] ERR_056:" & Message_erreur & ". Impossible de demarrer le serveur.", Affichage, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_AVERTISSEMENT, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.SansDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_AFF, RetourVAR)
				Else
					DEBUG("[Network] ERR_056" & Message_erreur & ". Unable to starting server.", Affichage, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_AVERTISSEMENT, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.SansDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_AFF, RetourVAR)
				End if
			ELSEIF Resultat = -6 Then ' Erreur Select()
				Message_erreur = ERRAVT("ERR_057", 0)
				IF CPCDOS_INSTANCE.Utilisateur_Langage = 0 Then
					DEBUG("[Reseau] ERR_057:" & Message_erreur & ". Impossible de demarrer le serveur.", Affichage, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_AVERTISSEMENT, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.SansDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_AFF, RetourVAR)
				Else
					DEBUG("[Network] ERR_057:" & Message_erreur & ". Unable to starting server.", Affichage, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_AVERTISSEMENT, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.SansDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_AFF, RetourVAR)
				End if
			ELSEIF Resultat = -7 Then ' Erreur ERRPIPE
				Message_erreur = ERRAVT("ERR_058", 0)
				IF CPCDOS_INSTANCE.Utilisateur_Langage = 0 Then
					DEBUG("[Reseau] ERR_058:" & Message_erreur & ". Impossible de demarrer le serveur.", Affichage, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_AVERTISSEMENT, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.SansDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_AFF, RetourVAR)
				Else
					DEBUG("[Network] ERR_058:" & Message_erreur & ". Unable to starting server.", Affichage, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_AVERTISSEMENT, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.SansDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_AFF, RetourVAR)
				End if
			ELSEIF Resultat = -8 Then ' Erreur DNS (pour client!)
				Message_erreur = ERRAVT("AVT_071", 0)
				IF CPCDOS_INSTANCE.Utilisateur_Langage = 0 Then
					DEBUG("[Reseau] AVT_071:" & Message_erreur & ". Impossible de demarrer le serveur.", Affichage, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_AVERTISSEMENT, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.SansDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_AFF, RetourVAR)
				Else
					DEBUG("[Network] AVT_071:" & Message_erreur & ". Unable to starting server.", Affichage, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_AVERTISSEMENT, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.SansDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_AFF, RetourVAR)
				End if
			ELSEIF Resultat = -9 Then ' Erreur Memoire
				Message_erreur = ERRAVT("ERR_059", 0)
				IF CPCDOS_INSTANCE.Utilisateur_Langage = 0 Then
					DEBUG("[Reseau] ERR_059:" & Message_erreur & ". Impossible de demarrer le serveur.", Affichage, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_AVERTISSEMENT, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.SansDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_AFF, RetourVAR)
				Else
					DEBUG("[Network] ERR_059:" & Message_erreur & ". Unable to starting server.", Affichage, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_AVERTISSEMENT, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.SansDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_AFF, RetourVAR)
				End if

			' ----------------------------------------------------------------

			ElseIf Resultat = -10 Then ' Port introuvable
				Dim Message_erreur as String = ERRAVT("AVT_068", 0)
				IF CPCDOS_INSTANCE.Utilisateur_Langage = 0 Then
					DEBUG("[Reseau] AVT_068:" & Message_erreur & " (" & Port_du_Serveur & ")", CPCDOS_INSTANCE.DEBUG_INSTANCE.Ecran, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_AVERTISSEMENT, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.AvecDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_CPCDOS, "")
				Else
					DEBUG("[Network] AVT_068:" & Message_erreur & " (" & Port_du_Serveur & ")", CPCDOS_INSTANCE.DEBUG_INSTANCE.Ecran, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_AVERTISSEMENT, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.AvecDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_CPCDOS, "")
				End if
			ElseIf Resultat = -11 Then ' Port deja existant
				dim Message_erreur as String = ERRAVT("ERR_051", 0)
				IF CPCDOS_INSTANCE.Utilisateur_Langage = 0 Then
					DEBUG("[Reseau] ERR_051:" & Message_erreur, CPCDOS_INSTANCE.DEBUG_INSTANCE.Ecran, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_ERREUR, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.AvecDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_AFF, RetourVAR)
				Else
					DEBUG("[Network] ERR_051:" & Message_erreur, CPCDOS_INSTANCE.DEBUG_INSTANCE.Ecran, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_ERREUR, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.AvecDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_AFF, RetourVAR)
				End if
			ElseIf Resultat = -12 Then ' Impossible de creer d'AUTRES serveurs
				dim Message_erreur as String = ERRAVT("AVT_070", 0)
				IF CPCDOS_INSTANCE.Utilisateur_Langage = 0 Then
					DEBUG("[Reseau] AVT_070:" & Message_erreur, CPCDOS_INSTANCE.DEBUG_INSTANCE.Ecran, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_ERREUR, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.AvecDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_AFF, RetourVAR)
				Else
					DEBUG("[Network] AVT_070:" & Message_erreur, CPCDOS_INSTANCE.DEBUG_INSTANCE.Ecran, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_ERREUR, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.AvecDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_AFF, RetourVAR)
				End if
			else
				IF Action = 0 Then
					' Serveur cree!
					DEBUG("1", CPCDOS_INSTANCE.DEBUG_INSTANCE.Ecran, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_Normal, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.SansDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_AFF, RetourVAR)
				End if
			END IF

			' ===================================================================
			END SCOPE
			' Fin de l'operation
			exit _scope_CMD, _scope
		End if ' **** SERVEUR/ ****

	_end_scope_CMD

	_scope_CMD

		' ===============================================================
		'  Commande pour creer / stopper un client TCP/UDP
		' ===============================================================
		CommLANG(1) = "client/"
		CommLANG(2) = "client/"
		CommLANG(3) = "\\#//"
		CommTrouve = 0 : NoCMD = 0
		for boucle as integer = 1 to 2
			IF OnCherche = CommLANG(boucle) Then
				NoCMD = 0
				exit for
			Else
				NoCMD = 1
			End if
		Next boucle
		IF NoCMD = 1 then CommLANG(1) = "[F.#).|" : CommLANG(2) = "[F.#).|" : CommLANG(3) = "\\#//"

		'Afficher la liste des commandes avec anglais / francais
		IF AfficherAide = 1 then
			IF CPCDOS_INSTANCE.Utilisateur_Langage = 0 then
				CommandesAide = CommandesAide & CRLF & " Client/                    Etablie/Stoppe une connexion client a un serveur TCP/UDP"
			Else
				CommandesAide = CommandesAide & CRLF & " Client/                    Start or stop a TCP/UDP client connection"
			END IF
		END IF
		IF CommLANG(1) = OnCherche Then CommTrouve = 1
		IF CommLANG(2) = OnCherche Then CommTrouve = 2
		IF CommTrouve > 0 Then ' Afficher l'aide de la commande
			IF AfficherAide = 2 then
				Mess_Aide = ""
				IF CPCDOS_INSTANCE.Utilisateur_Langage = 0 THEN
					Mess_Aide = Mess_Aide & CRLF & "  Fonctionnalit�e :"
					Mess_Aide = Mess_Aide & CRLF & "   Cette commande permet de creer ou stopper un client TCP ou UDP"
					Mess_Aide = Mess_Aide & CRLF
					Mess_Aide = Mess_Aide & CRLF & "  Exemples connexion a un serveur tant que client: (TCP par defaut)"
					Mess_Aide = Mess_Aide & CRLF & "    - Demarrer une connexion (ex:192.168.1.7:1234):"
					Mess_Aide = Mess_Aide & CRLF & "       Client/ 192.168.1.7:1234"
					Mess_Aide = Mess_Aide & CRLF & "       (Cette commande renvoit un numero de TID --> A garder!!)"
					Mess_Aide = Mess_Aide & CRLF & "    - Arreter la connexion (Exemple de TID 2803):"
					Mess_Aide = Mess_Aide & CRLF & "       client/ /stop:2803"
					Mess_Aide = Mess_Aide & CRLF & "    - Envoyer un message a un serveur (Exemple de TID 2803):"
					Mess_Aide = Mess_Aide & CRLF & "       Client/ /Envoyer:2803 Bonjour serveur!"
					Mess_Aide = Mess_Aide & CRLF & "    - Recevoir un message (Exemple de TID 2803):"
					Mess_Aide = Mess_Aide & CRLF & "       Client/ /Recevoir:2803"
					Mess_Aide = Mess_Aide & CRLF & "       ( Si le serveur a ferme la connexion, vous receverez '#DECO')"
					Mess_Aide = Mess_Aide & CRLF & "    - Configurer fichier tempon pour creation d'un fichier binaire"
					Mess_Aide = Mess_Aide & CRLF & "       client/ /envoyer:2803 #CFG_TMPFILE TEMP/NET/Fichier.ZIP"
					Mess_Aide = Mess_Aide & CRLF
					Mess_Aide = Mess_Aide & CRLF & " Remarque: Vous pouvez stocker le numero de TID du client directement"
					Mess_Aide = Mess_Aide & CRLF & "           dans une variable ex:"
					Mess_Aide = Mess_Aide & CRLF & "            @#MyTIDNumber Client/ 192.168.1.7:1234"
					Mess_Aide = Mess_Aide & CRLF & "            txt/ Votre numero de TID du client est %MyTIDNumber%"
					Mess_Aide = Mess_Aide & CRLF
					Mess_Aide = Mess_Aide & CRLF & "  Voir aussi : serveur/ , ping/ , telecharger/"
					Mess_Aide = Mess_Aide & CRLF
				ELSEIF CPCDOS_INSTANCE.Utilisateur_Langage = 1 THEN
					Mess_Aide = Mess_Aide & CRLF & "  Fonctionnality :"
					Mess_Aide = Mess_Aide & CRLF & "   This command allow to start or stop a TCP server in CPinti"
					Mess_Aide = Mess_Aide & CRLF & "   You can also start a TCP client connection"
					Mess_Aide = Mess_Aide & CRLF
					Mess_Aide = Mess_Aide & CRLF
					Mess_Aide = Mess_Aide & CRLF & "  Example connection to server as TCP client:"
					Mess_Aide = Mess_Aide & CRLF & "       Client/ 192.168.1.7:1234"
					Mess_Aide = Mess_Aide & CRLF & "       (This command return a TID number --> Important!!)"
					Mess_Aide = Mess_Aide & CRLF & "    - Stop connection  (TID example 2803):"
					Mess_Aide = Mess_Aide & CRLF & "       client/ /stop:2803"
					Mess_Aide = Mess_Aide & CRLF & "    - Send a message to server: (Example, TID:2803):"
					Mess_Aide = Mess_Aide & CRLF & "       Client/ /Send:2803 Hello server!"
					Mess_Aide = Mess_Aide & CRLF & "    - Receive a message (Exemple, TID:2803):"
					Mess_Aide = Mess_Aide & CRLF & "       Client/ /Receive:2803"
					Mess_Aide = Mess_Aide & CRLF & "       (If server has closed connection, you will receive '#DECO')"
					Mess_Aide = Mess_Aide & CRLF
					Mess_Aide = Mess_Aide & CRLF & " Remark: You can redirect the TID number directly on a variable. Ex:"
					Mess_Aide = Mess_Aide & CRLF & "            @#MyTIDNumber SERVER/ /CLIENT 192.168.1.7:1234"
					Mess_Aide = Mess_Aide & CRLF & "            txt/ You TID number is %MyTIDNumber%"
					Mess_Aide = Mess_Aide & CRLF
					Mess_Aide = Mess_Aide & CRLF & "  See also : Server/ , ping/ , download/"
					Mess_Aide = Mess_Aide & CRLF
				END IF
				DEBUG(Mess_Aide, Affichage, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_SURBRILLE, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.SansDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_AFF, RetourVAR)
				testCMD = 0
				AfficherAide = 0
				exit _scope_CMD, _scope
			END IF
			' Tester la syntaxe
			testCMD	= CCP_Verifier_Syntaxe(Commande, CommPosition)
			IF testCMD > 10 Then exit _scope_CMD, _scope
			IF testCMD > 0 then  ' Entre 1-5 = Pas d'affichage via le @, @$ ou @#
				IF testCMD < 6 then
					Affichage = 0
					IF testCMD = 3 Then CpcdosCP_SHELL("FIX/ " & CPCDOS_INSTANCE.DEBUG_INSTANCE.LeRetour & " = \#NULL", _CLE_, NIVEAU_CCP, Param_1, Param_2) : RetourVAR = _CLE_ & "N" & NIVEAU_CCP & "->" & CPCDOS_INSTANCE.DEBUG_INSTANCE.LeRetour
					if testCMD = 2 Then RetourVAR = "$>" & CPCDOS_INSTANCE.DEBUG_INSTANCE.LeRetour ' ajouter une securite ?
				Else
					Affichage = 1
				END IF
			Else
				Affichage = 1
			END IF
			Dim posCMD2deCLIENT as integer
			' Recuperer les Parametres
			Param = MID(Commande, CommPosition + TailleComm + 2)
			SCOPE
			' ====================================================================

			' Numero de port du serveur
			Dim Port_du_Serveur as Integer
			Dim TID_CLIENT 		as uInteger

			' Adresse du serveur
			Dim Adresse_du_Serveur		as String

			' 1:TCP , 2:TCP admin , 3:UDP
			Dim Type_Client				as integer

			' 0:Creer client , 1:Envoyer , 2:Recevoir , 3:STOP
			Dim Action					as integer
			' Donnees recu ou a envoyer
			Dim DONNEES					as String


			' Arguments checker
			Dim Pos2pTcp				as Integer
			Dim Pos2pUdp				as Integer

			Dim Pos2PStop				as Integer
			Dim Pos2PEnvoyer			as Integer
			Dim Pos2PSend				as Integer
			Dim Pos2PRecevoir			as Integer
			Dim Pos2PReceive			as Integer

			Dim Pos2ATTENDRE			as integer
			Dim Pos2WAIT				as integer
			Dim TempsAttente			as integer

			' IF Len(Param) < 4 then Goto SERVEUR_ParamDispo

			' Creation d'un client TCP/UDP
			Pos2pTcp 		= Instr(UCASE(Param), "/TCP:")
			Pos2pUdp 		= Instr(UCASE(Param), "/UDP:")


			' Discuter avec le buffer
			Pos2PEnvoyer	= Instr(UCASE(Param), "/ENVOYER:") ' Envoyer
			Pos2PSend		= Instr(UCASE(Param), "/SEND:") ' Envoyer
			Pos2PRecevoir	= Instr(UCASE(Param), "/RECEVOIR:") ' Receptionner
			Pos2PReceive	= Instr(UCASE(Param), "/RECEIVE:") ' Receptionner

			Pos2ATTENDRE	= Instr(UCASE(Param), "/ATTENDRE") ' Attendre la reception
			Pos2WAIT		= Instr(UCASE(Param), "/WAIT") 	' Attendre la reception

			' Arreter un client
			Pos2PStop 		= Instr(UCASE(Param), "/STOP:")

			posCMD2deCLIENT 	= Instr(UCASE(Param), "CLIENT/")
			if posCMD2deCLIENT < 1 then posCMD2deCLIENT = Instr(UCASE(Param), "CLIENT/")


			' Verifier si les parametres ne sont pas suivit via une autre instance de 'CLIENT/
			if posCMD2deCLIENT > 0 then

				if Pos2PEnvoyer		>= posCMD2deCLIENT+8 then Pos2PEnvoyer		= 0
				if Pos2PSend		>= posCMD2deCLIENT+5 then Pos2PSend 		= 0
				if Pos2PRecevoir 	>= posCMD2deCLIENT+9 then Pos2PRecevoir 	= 0
				if Pos2PReceive		>= posCMD2deCLIENT+8 then Pos2PReceive 		= 0
				if Pos2pTcp 		>= posCMD2deCLIENT+4 then Pos2pTcp 			= 0
				if Pos2pUdp 		>= posCMD2deCLIENT+4 then Pos2pUdp 			= 0
				if Pos2PStop 		>= posCMD2deCLIENT+5 then Pos2PStop 		= 0
				if Pos2ATTENDRE		>= posCMD2deCLIENT+8 then Pos2ATTENDRE		= 0
				if Pos2WAIT			>= posCMD2deCLIENT+8 then Pos2WAIT			= 0
			end if

			' ==== Protocole   T C P ==== (CLIENT/ /TCP:[NoPort])
			' Envoyer des donnees
			if Pos2PEnvoyer > 0 then ' (client/ /ENVOYER:[NoPort] Blablablabla..)
				Action = 1 ' Envoyer

				' Position de l'espace entre le NoPort et les donnees
				Dim PosEspace as integer = INSTR(Pos2PEnvoyer, Param, " ")

				' Recuperer le port du client
				TID_CLIENT = val(RTRIM(LTRIM(LTRIM(MID(Param, Pos2PEnvoyer + 9, PosEspace - (Pos2PEnvoyer + 9)))), CHR(09)))

				' Recuperer les donnees a envoyer
				DONNEES = MID(Param, PosEspace + 1)

			Elseif Pos2PSend > 0 then ' (client/ /SEND:[NoPort] Blablablabla..)
				Action = 1 ' Send

				' Position de l'espace entre le NoPort et les donnees
				Dim PosEspace as integer = INSTR(Pos2PSend, Param, " ")

				' Recuperer le port du client
				TID_CLIENT = val(RTRIM(LTRIM(LTRIM(MID(Param, Pos2PSend + 6, PosEspace - (Pos2PSend + 6))), CHR(09))))

				' Recuperer les donnees a envoyer
				DONNEES = MID(Param, PosEspace + 1)

			' Recevoir des donnees
			Elseif Pos2PRecevoir > 0 then ' (client/ /RECEVOIR:[NoPort])
				Action = 2 ' Recevoir

				' Recuperer le port du client
				TID_CLIENT = val(RTRIM(LTRIM(LTRIM(MID(Param, Pos2PRecevoir + 10)), CHR(09))))

				IF Pos2ATTENDRE > 0 Then
					TempsAttente = val(RTRIM(LTRIM(LTRIM(MID(Param, Pos2ATTENDRE + 10))), CHR(09)))
				ElseIF Pos2WAIT > 0 Then
					TempsAttente = val(RTRIM(LTRIM(LTRIM(MID(Param, Pos2WAIT + 5))), CHR(09)))
				End if

				' Si le temps est inferieur ou egale a zero, pas de pause
				IF TempsAttente <= 0 Then TempsAttente = 0

			Elseif Pos2PReceive > 0 then ' (client/ /RECEIVE:[NoPort])
				Action = 2 ' Recevoir

				' Recuperer le port du client
				TID_CLIENT = val(RTRIM(LTRIM(LTRIM(MID(Param, Pos2PReceive + 9))), CHR(09)))

				IF Pos2ATTENDRE > 0 Then
					TempsAttente = val(RTRIM(LTRIM(LTRIM(MID(Param, Pos2ATTENDRE + 10))), CHR(09)))
				ElseIF Pos2WAIT > 0 Then
					TempsAttente = val(RTRIM(LTRIM(LTRIM(MID(Param, Pos2WAIT + 5))), CHR(09)))
				End if

				' Si le temps est inferieur ou egale a zero, pas de pause
				IF TempsAttente <= 0 Then TempsAttente = 0

			ElseIf Pos2pTcp > 0 Then ' TCP
				Type_Client = 1
				Action = 0 ' creer

				Dim Pos2points as integer = INSTR(Pos2pTcp + 5, Param, ":")

				' Verifier si l'utilisateur a specifie un numero de port. Sinon c'est 80 par defaut.
				if Pos2points > 0 Then
					' Recuperer l'adresse IP/Nom du client
					Adresse_du_Serveur = RTRIM(LTRIM(LTRIM(MID(Param, Pos2pTcp + 5, Pos2points - (Pos2pTcp +5))), CHR(09)))

					' Recuperer le port du client
					Port_du_Serveur = val(RTRIM(LTRIM(LTRIM(MID(Param, Pos2points + 1)), CHR(09))))
				Else
					' Aucun numero de port specifie, on lui indique 80 par defaut (WEB/HTTP)
					Port_du_Serveur = 80

					' Recuperer l'adresse IP/Nom du client
					Adresse_du_Serveur = RTRIM(LTRIM(LTRIM(Mid(Param, Pos2pTcp + 5)), CHR(09)))
				End if

			' ==== Protocole   U D P ====
			ElseIF Pos2pUdp > 0 Then ' UDP (client/ /UDP:[NoPort])
				Type_Client = 3
				Action = 0 ' creer

				Dim Pos2points as integer = INSTR(Pos2pUdp + 5, Param, ":")

				' Verifier si l'utilisateur a specifie un numero de port. Sinon c'est 80 par defaut.
				if Pos2points > 0 Then
					' Recuperer l'adresse IP/Nom du client
					Adresse_du_Serveur = RTRIM(LTRIM(LTRIM(MID(Param, Pos2pUdp + 5, Pos2points - (Pos2pUdp +5))), CHR(09)))

					' Recuperer le port du client
					Port_du_Serveur = val(RTRIM(LTRIM(LTRIM(MID(Param, Pos2points + 1)), CHR(09))))
				Else
					' Aucun numero de port specifie, on lui indique 80 par defaut (WEB/HTTP)
					Port_du_Serveur = 80

					' Recuperer l'adresse IP/Nom du client
					Adresse_du_Serveur = RTRIM(LTRIM(LTRIM(Mid(Param, Pos2pUdp + 5)), CHR(09)))
				End if

			' Arreter le client
			Elseif Pos2PStop > 0 Then ' (client/ /STOP:[NoPort])
				Action = 3 ' arreter

				' Recuperer le TID
				TID_CLIENT = val(RTRIM(LTRIM(LTRIM(MID(Param, Pos2PStop + 6)), CHR(09))))



			Else
				IF CPCDOS_INSTANCE.Utilisateur_Langage = 0 Then
					DEBUG("[CpcdosC+] Parametres disponibles : /TCP:[Adresse IP:port], /UDP:[Adresse IP:port] , /ENVOYER:[No TID] Donnees, /RECEVOIR:[No TID], /STOP:[No TID] ", Affichage, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_AVERTISSEMENT, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.AvecDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_AFF, RetourVAR)
				Else
					DEBUG("[CpcdosC+] Avaiable Parameters : /TCP:[IP address:port], /UDP:[IP address:port] , /SEND:[No TID] Data, /RECEIVE:[No TID], /STOP:[No TID]", Affichage, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_AVERTISSEMENT, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.AvecDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_AFF, RetourVAR)
				End if
				exit _scope_CMD, _scope
			End if

			Dim Resultat as integer

			If Action = 1 Then ' Envoyer
				' **** Envoyer les donnees ****

				Resultat = CPCDOS_INSTANCE.RESEAU_INSTANCE.ENVOYER_Client(DONNEES, Port_du_Serveur, TID_CLIENT, RetourVAR)

			ElseIf Action = 2 Then
				' **** Receptionner les donnees ****

				IF Pos2ATTENDRE > 0 OR Pos2WAIT > 0 Then
					Resultat = CPCDOS_INSTANCE.RESEAU_INSTANCE.RECEVOIR_Client(Port_du_Serveur, TID_CLIENT, RetourVAR, TRUE, TempsAttente)
				Else
					Resultat = CPCDOS_INSTANCE.RESEAU_INSTANCE.RECEVOIR_Client(Port_du_Serveur, TID_CLIENT, RetourVAR, FALSE, 0)
				End if

			ElseIf Action = 3 Then
				' **** Arreter un client ****

				Resultat = CPCDOS_INSTANCE.RESEAU_INSTANCE.STOP_Client(Adresse_du_Serveur, Port_du_Serveur, TID_CLIENT, RetourVAR)

			ElseIf Action = 0 Then
				' **** Creer un client TCP/UDP ****
				Dim Resultat_ as integer

				if Type_Client = 1 OR Type_Client = 2 Then

					' Creer un client TCP
					Resultat_ = CPCDOS_INSTANCE.RESEAU_INSTANCE.Client_TCP(Adresse_du_Serveur, Port_du_Serveur, Auth_PID, RetourVAR)

					if Resultat_ = 0 Then Resultat_ = -12
					if Resultat_ = 1 Then Resultat_ = CPCDOS_INSTANCE._DOSBOX
					if Resultat_ = 2 Then Resultat_ = CPCDOS_INSTANCE._SANS_Reseau

					if Resultat_ > 1 Then
						' Afficher le numero de TID
						DEBUG(STR(Resultat_), Affichage, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_SURBRILLE, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.SansDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_AFF, RetourVAR)
					End if


				ElseIf Type_Client = 3 Then


					' Creer un client UDP
					Resultat_ = CPCDOS_INSTANCE.RESEAU_INSTANCE.Client_UDP(Adresse_du_Serveur, Port_du_Serveur, Auth_PID, RetourVAR)

					if Resultat_ = 0 Then Resultat_ = -12
					if Resultat_ = 1 Then Resultat_ = CPCDOS_INSTANCE._DOSBOX
					if Resultat_ = 2 Then Resultat_ = CPCDOS_INSTANCE._SANS_Reseau

					if Resultat_ > 1 Then
						' Afficher le numero de TID
						DEBUG(STR(Resultat_), Affichage, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_SURBRILLE, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.SansDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_AFF, RetourVAR)
					End if
				End if


			Else ' Aucun

			End if

			IF Resultat = CPCDOS_INSTANCE._DOSBOX Then ' Mode DOSBOX
				Message_erreur = ERRAVT("AVT_055", 0)
				IF CPCDOS_INSTANCE.Utilisateur_Langage = 0 Then
					DEBUG("[Reseau] AVT_055:" & Message_erreur & ". Impossible de demarrer le client.", Affichage, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_AVERTISSEMENT, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.SansDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_AFF, RetourVAR)
				Else
					DEBUG("[Network] AVT_055:" & Message_erreur & ". Unable to starting client.", Affichage, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_AVERTISSEMENT, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.SansDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_AFF, RetourVAR)
				End if
			ElseIF Resultat = CPCDOS_INSTANCE._SANS_Reseau Then ' Mode sans reseau ( Mode avion )
				Message_erreur = ERRAVT("AVT_072", 0)
				IF CPCDOS_INSTANCE.Utilisateur_Langage = 0 Then
					DEBUG("[Reseau] AVT_072:" & Message_erreur & ". Impossible de demarrer le client.", Affichage, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_AVERTISSEMENT, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.SansDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_AFF, RetourVAR)
				Else
					DEBUG("[Network] AVT_072:" & Message_erreur & ". Unable to starting client.", Affichage, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_AVERTISSEMENT, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.SansDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_AFF, RetourVAR)
				End if
			ELSEIF Resultat = -2 Then ' Erreur config socket
				Message_erreur = ERRAVT("ERR_054", 0)
				IF CPCDOS_INSTANCE.Utilisateur_Langage = 0 Then
					DEBUG("[Reseau] ERR_054:" & Message_erreur & ". Impossible de demarrer le client.", Affichage, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_AVERTISSEMENT, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.SansDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_AFF, RetourVAR)
				Else
					DEBUG("[Network] ERR_054:" & Message_erreur & ". Unable to starting client.", Affichage, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_AVERTISSEMENT, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.SansDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_AFF, RetourVAR)
				End if
			ELSEIF Resultat = -3 Then ' Driver manquant
				Message_erreur = ERRAVT("AVT_023", 0)
				IF CPCDOS_INSTANCE.Utilisateur_Langage = 0 Then
					DEBUG("[Reseau] AVT_023:" & Message_erreur & ". Impossible de demarrer le client.", Affichage, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_AVERTISSEMENT, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.SansDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_AFF, RetourVAR)
				Else
					DEBUG("[Network] AVT_023:" & Message_erreur & ". Unable to starting client.", Affichage, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_AVERTISSEMENT, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.SansDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_AFF, RetourVAR)
				End if
			ELSEIF Resultat = -4 Then ' Erreur binding
				Message_erreur = ERRAVT("ERR_055", 0)
				IF CPCDOS_INSTANCE.Utilisateur_Langage = 0 Then
					DEBUG("[Reseau] ERR_055:" & Message_erreur & ". Impossible de demarrer le client.", Affichage, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_AVERTISSEMENT, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.SansDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_AFF, RetourVAR)
				Else
					DEBUG("[Network] ERR_055:" & Message_erreur & ". Unable to starting client.", Affichage, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_AVERTISSEMENT, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.SansDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_AFF, RetourVAR)
				End if
			ELSEIF Resultat = -5 Then ' Erreur ecoute
				Message_erreur = ERRAVT("ERR_056", 0)
				IF CPCDOS_INSTANCE.Utilisateur_Langage = 0 Then
					DEBUG("[Reseau] ERR_056:" & Message_erreur & ". Impossible de demarrer le client.", Affichage, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_AVERTISSEMENT, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.SansDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_AFF, RetourVAR)
				Else
					DEBUG("[Network] ERR_056:" & Message_erreur & ". Unable to starting client.", Affichage, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_AVERTISSEMENT, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.SansDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_AFF, RetourVAR)
				End if
			ELSEIF Resultat = -6 Then ' Erreur Select()
				Message_erreur = ERRAVT("ERR_057", 0)
				IF CPCDOS_INSTANCE.Utilisateur_Langage = 0 Then
					DEBUG("[Reseau] ERR_057:" & Message_erreur & ". Impossible de demarrer le client.", Affichage, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_AVERTISSEMENT, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.SansDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_AFF, RetourVAR)
				Else
					DEBUG("[Network] ERR_057:" & Message_erreur & ". Unable to starting client.", Affichage, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_AVERTISSEMENT, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.SansDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_AFF, RetourVAR)
				End if
			ELSEIF Resultat = -7 Then ' Erreur ERRPIPE
				Message_erreur = ERRAVT("ERR_058", 0)
				IF CPCDOS_INSTANCE.Utilisateur_Langage = 0 Then
					DEBUG("[Reseau] ERR_058:" & Message_erreur & ". Impossible de demarrer le client.", Affichage, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_AVERTISSEMENT, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.SansDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_AFF, RetourVAR)
				Else
					DEBUG("[Network] ERR_058:" & Message_erreur & ". Unable to starting client.", Affichage, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_AVERTISSEMENT, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.SansDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_AFF, RetourVAR)
				End if
			ELSEIF Resultat = -8 Then ' Erreur DNS (pour client!)
				Message_erreur = ERRAVT("AVT_071", 0)
				IF CPCDOS_INSTANCE.Utilisateur_Langage = 0 Then
					DEBUG("[Reseau] AVT_071:" & Message_erreur & ". Impossible de demarrer le client.", Affichage, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_AVERTISSEMENT, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.SansDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_AFF, RetourVAR)
				Else
					DEBUG("[Network] AVT_071:" & Message_erreur & ". Unable to starting client.", Affichage, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_AVERTISSEMENT, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.SansDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_AFF, RetourVAR)
				End if
			ELSEIF Resultat = -9 Then ' Erreur Memoire
				Message_erreur = ERRAVT("ERR_059", 0)
				IF CPCDOS_INSTANCE.Utilisateur_Langage = 0 Then
					DEBUG("[Reseau] ERR_059:" & Message_erreur & ". Impossible de demarrer le client.", Affichage, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_AVERTISSEMENT, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.SansDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_AFF, RetourVAR)
				Else
					DEBUG("[Network] ERR_059:" & Message_erreur & ". Unable to starting client.", Affichage, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_AVERTISSEMENT, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.SansDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_AFF, RetourVAR)
				End if

			' ----------------------------------------------------------------

			ElseIf Resultat = -10 Then ' Port introuvable
				Dim Message_erreur as String = ERRAVT("AVT_068", 0)
				IF CPCDOS_INSTANCE.Utilisateur_Langage = 0 Then
					DEBUG("[Reseau] AVT_068:" & Message_erreur & " (" & Port_du_Serveur & ")", CPCDOS_INSTANCE.DEBUG_INSTANCE.Ecran, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_AVERTISSEMENT, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.AvecDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_CPCDOS, "")
				Else
					DEBUG("[Network] AVT_068:" & Message_erreur & " (" & Port_du_Serveur & ")", CPCDOS_INSTANCE.DEBUG_INSTANCE.Ecran, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_AVERTISSEMENT, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.AvecDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_CPCDOS, "")
				End if
			ElseIf Resultat = -11 Then ' Port deja existant
				dim Message_erreur as String = ERRAVT("ERR_051", 0)
				IF CPCDOS_INSTANCE.Utilisateur_Langage = 0 Then
					DEBUG("[Reseau] ERR_051:" & Message_erreur, CPCDOS_INSTANCE.DEBUG_INSTANCE.Ecran, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_ERREUR, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.AvecDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_AFF, RetourVAR)
				Else
					DEBUG("[Network] ERR_051:" & Message_erreur, CPCDOS_INSTANCE.DEBUG_INSTANCE.Ecran, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_ERREUR, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.AvecDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_AFF, RetourVAR)
				End if
			ElseIf Resultat = -12 Then ' Impossible de creer d'AUTRES serveurs
				dim Message_erreur as String = ERRAVT("AVT_070", 0)
				IF CPCDOS_INSTANCE.Utilisateur_Langage = 0 Then
					DEBUG("[Reseau] AVT_070:" & Message_erreur, CPCDOS_INSTANCE.DEBUG_INSTANCE.Ecran, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_ERREUR, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.AvecDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_AFF, RetourVAR)
				Else
					DEBUG("[Network] AVT_070" & Message_erreur, CPCDOS_INSTANCE.DEBUG_INSTANCE.Ecran, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_ERREUR, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.AvecDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_AFF, RetourVAR)
				End if
			ElseIf Resultat = -13 Then ' TID introuvable
				Dim Message_erreur as String = ERRAVT("AVT_069", 0)
				IF CPCDOS_INSTANCE.Utilisateur_Langage = 0 Then
					DEBUG("[Reseau] AVT_069:" & Message_erreur & " (" & TID_CLIENT & ")", CPCDOS_INSTANCE.DEBUG_INSTANCE.Ecran, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_VALIDATION, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.AvecDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_CPCDOS, "")
				Else
					DEBUG("[Network] AVT_069:" & Message_erreur & " (" & TID_CLIENT & ")", CPCDOS_INSTANCE.DEBUG_INSTANCE.Ecran, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_VALIDATION, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.AvecDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_CPCDOS, "")
				End if
			END IF

			' Fin de l'operation

			' ===================================================================
			END SCOPE
			exit _scope_CMD, _scope
		End if ' **** CLIENT/ ****

	_end_scope_CMD

	_scope_CMD

		' ===============================================================
		'  Commande pour se loger, creer, parametrer les comptes
		' ===============================================================
		CommLANG(1) = "LOGIN/"
		CommLANG(2) = "LOGIN/"
		CommLANG(3) = "\\#//"
		CommTrouve = 0 : NoCMD = 0
		for boucle as integer = 1 to 2
			IF OnCherche = CommLANG(boucle) Then
				NoCMD = 0
				exit for
			Else
				NoCMD = 1
			End if
		Next boucle
		IF NoCMD = 1 then CommLANG(1) = "[F.#).|" : CommLANG(2) = "[F.#).|" : CommLANG(3) = "\\#//"

		'Afficher la liste des commandes avec anglais / francais
		IF AfficherAide = 1 then
			IF CPCDOS_INSTANCE.Utilisateur_Langage = 0 then
				CommandesAide = CommandesAide & CRLF & " Login/                     Ouvrir, creer, modifier un compte utilisateur"
			Else
				CommandesAide = CommandesAide & CRLF & " Login/                     Open, create, modify an user account"
			END IF
		END IF
		IF CommLANG(1) = OnCherche Then CommTrouve = 1
		IF CommLANG(2) = OnCherche Then CommTrouve = 2
		IF CommTrouve > 0 Then ' Afficher l'aide de la commande
			IF AfficherAide = 2 then
				Mess_Aide = ""
				IF CPCDOS_INSTANCE.Utilisateur_Langage = 0 THEN
					Mess_Aide = Mess_Aide & CRLF & "  Fonctionnalit�e :"
					Mess_Aide = Mess_Aide & CRLF & "   Cette commande permet de gerer les compte utilisateurs de Cpcdos"
					Mess_Aide = Mess_Aide & CRLF
					Mess_Aide = Mess_Aide & CRLF & "   * Les droits administrateur vous permet d'acces total du systeme, des commande et des autres comptes"
					Mess_Aide = Mess_Aide & CRLF & "   * Les droits standard vous permet l'acces assez etendu sur le systeme a l'exception de certains"
					Mess_Aide = Mess_Aide & CRLF & "     parametres.."
					Mess_Aide = Mess_Aide & CRLF & "   * Les droits limit�s ne permet que d'executer les application et parametres, impos�s par l'administrateur"
					Mess_Aide = Mess_Aide & CRLF
					Mess_Aide = Mess_Aide & CRLF & "   Si une action requiert les droits Administrateur, vous serez invit� a entrer le mot de passe Admin"
					Mess_Aide = Mess_Aide & CRLF
					Mess_Aide = Mess_Aide & CRLF & "  Exemples :"
					Mess_Aide = Mess_Aide & CRLF & "   Se connecter tant que 'admin' (Sans mot de passe)"
					Mess_Aide = Mess_Aide & CRLF & "    Login/ admin"
					Mess_Aide = Mess_Aide & CRLF
					Mess_Aide = Mess_Aide & CRLF & "   Se connecter tant que 'admin' (Avec mot de passe)"
					Mess_Aide = Mess_Aide & CRLF & "    Login/ admin MonMotDePasse123"
					Mess_Aide = Mess_Aide & CRLF
					Mess_Aide = Mess_Aide & CRLF & "   Se deconnecter d'un compte ouvert"
					Mess_Aide = Mess_Aide & CRLF & "    Login/ /fermer   ou   Login/ /deconnexion"
					Mess_Aide = Mess_Aide & CRLF
					Mess_Aide = Mess_Aide & CRLF & "   Verrouiller la session ouverte"
					Mess_Aide = Mess_Aide & CRLF & "    Login/ /Verrouiller"
					Mess_Aide = Mess_Aide & CRLF
					Mess_Aide = Mess_Aide & CRLF & "   (Previleges administrateur necessaire pour tout ce qui est en dessous)"
					Mess_Aide = Mess_Aide & CRLF & "   Creer un compte utilisateur standard et sans mot de passe"
					Mess_Aide = Mess_Aide & CRLF & "    Login/ /creer Florian    ou    Login/ /creer /std Florian"
					Mess_Aide = Mess_Aide & CRLF
					Mess_Aide = Mess_Aide & CRLF & "   Creer un compte utilisateur standard et avec mot de passe"
					Mess_Aide = Mess_Aide & CRLF & "    Login/ /creer Florian MotDePasse123    ou    Login/ /creer /std Florian MotDePasse123"
					Mess_Aide = Mess_Aide & CRLF
					Mess_Aide = Mess_Aide & CRLF & "   Creer un compte utilisateur administrateur"
					Mess_Aide = Mess_Aide & CRLF & "    Login/ /creer /admin Thomas"
					Mess_Aide = Mess_Aide & CRLF
					Mess_Aide = Mess_Aide & CRLF & "   Creer un compte utilisateur limit�"
					Mess_Aide = Mess_Aide & CRLF & "    Login/ /creer /lim Thomas"
					Mess_Aide = Mess_Aide & CRLF
					Mess_Aide = Mess_Aide & CRLF & "  Voir aussi : "
					Mess_Aide = Mess_Aide & CRLF
				ELSEIF CPCDOS_INSTANCE.Utilisateur_Langage = 1 THEN
					Mess_Aide = Mess_Aide & CRLF & "  Fonctionnality :"
					Mess_Aide = Mess_Aide & CRLF & "   This command allow to manage user accounts"
					Mess_Aide = Mess_Aide & CRLF
					Mess_Aide = Mess_Aide & CRLF & "   * Administrator privileges allow you to access in system without restrictions."
					Mess_Aide = Mess_Aide & CRLF & "   * Standard privileges allow you to access in system with some restrictions."
					Mess_Aide = Mess_Aide & CRLF & "   * Limited privileges allow you to access in imposed application by Administrator"
					Mess_Aide = Mess_Aide & CRLF
					Mess_Aide = Mess_Aide & CRLF & "   If an action want more privilege, you will be invited to type Admin password"
					Mess_Aide = Mess_Aide & CRLF
					Mess_Aide = Mess_Aide & CRLF & "  Examples :"
					Mess_Aide = Mess_Aide & CRLF & "   Login as admin' (Without password)"
					Mess_Aide = Mess_Aide & CRLF & "    Login/ admin"
					Mess_Aide = Mess_Aide & CRLF
					Mess_Aide = Mess_Aide & CRLF & "   Login as 'admin' (With password)"
					Mess_Aide = Mess_Aide & CRLF & "    Login/ admin MyPassword123"
					Mess_Aide = Mess_Aide & CRLF
					Mess_Aide = Mess_Aide & CRLF & "   Login as 'toto' (With password)"
					Mess_Aide = Mess_Aide & CRLF & "    Login/ toto MyPassword123"
					Mess_Aide = Mess_Aide & CRLF
					Mess_Aide = Mess_Aide & CRLF & "   Logout"
					Mess_Aide = Mess_Aide & CRLF & "    Login/ /close   or   Login/ /logout"
					Mess_Aide = Mess_Aide & CRLF
					Mess_Aide = Mess_Aide & CRLF & "   Lock opened session"
					Mess_Aide = Mess_Aide & CRLF & "    Login/ /lock"
					Mess_Aide = Mess_Aide & CRLF
					Mess_Aide = Mess_Aide & CRLF & "   (Administrator privileges is expected for this commands)"
					Mess_Aide = Mess_Aide & CRLF & "   Creer un compte utilisateur standard et sans mot de passe"
					Mess_Aide = Mess_Aide & CRLF & "    Login/ /create Florian    ou    Login/ /create /std Florian"
					Mess_Aide = Mess_Aide & CRLF
					Mess_Aide = Mess_Aide & CRLF & "   Create a standard accound (With password)"
					Mess_Aide = Mess_Aide & CRLF & "    Login/ /create Florian MyPassword123    ou    Login/ /create /std Florian MyPassword123"
					Mess_Aide = Mess_Aide & CRLF
					Mess_Aide = Mess_Aide & CRLF & "   Create a admin account"
					Mess_Aide = Mess_Aide & CRLF & "    Login/ /creer /admin Thomas"
					Mess_Aide = Mess_Aide & CRLF
					Mess_Aide = Mess_Aide & CRLF & "   Create a limited account"
					Mess_Aide = Mess_Aide & CRLF & "    Login/ /creer /lim Thomas"
					Mess_Aide = Mess_Aide & CRLF
					Mess_Aide = Mess_Aide & CRLF & "  See also : "
					Mess_Aide = Mess_Aide & CRLF
				END IF
				DEBUG(Mess_Aide, Affichage, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_SURBRILLE, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.SansDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_AFF, RetourVAR)
				testCMD = 0
				AfficherAide = 0
				exit _scope_CMD, _scope
			END IF
			' Tester la syntaxe
			testCMD	= CCP_Verifier_Syntaxe(Commande, CommPosition)
			IF testCMD > 10 Then exit _scope_CMD, _scope
			IF testCMD > 0 then  ' Entre 1-5 = Pas d'affichage via le @, @$ ou @#
				IF testCMD < 6 then
					Affichage = 0
					IF testCMD = 3 Then CpcdosCP_SHELL("FIX/ " & CPCDOS_INSTANCE.DEBUG_INSTANCE.LeRetour & " = \#NULL", _CLE_, NIVEAU_CCP, Param_1, Param_2) : RetourVAR = _CLE_ & "N" & NIVEAU_CCP & "->" & CPCDOS_INSTANCE.DEBUG_INSTANCE.LeRetour
					if testCMD = 2 Then RetourVAR = "$>" & CPCDOS_INSTANCE.DEBUG_INSTANCE.LeRetour ' ajouter une securite ?
				Else
					Affichage = 1
				END IF
			Else
				Affichage = 1
			END IF
			' Recuperer les Parametres
			Param = MID(Commande, CommPosition + TailleComm + 2)
			SCOPE
			' ====================================================================
			Debug(" La commande LOGIN/ n'est pas disponible, je sais que c'est pressant autant quand t-on a envie d'aller pisser, mais .. patience mon p'tit Cpcdosien! ;-)", Affichage, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_Normal, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.AvecDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_AFF, RetourVAR)

			' ===================================================================
			END SCOPE
			exit _scope_CMD, _scope
		End If ' **** LOGIN/ ****

	_end_scope_CMD

	_scope_CMD

		' ===============================================================
		'  Commande de fermeture d'un processus
		' ===============================================================
		CommLANG(1) = "fermer/"
		CommLANG(2) = "close/"
		CommLANG(3) = "\\#//"
		CommTrouve = 0 : NoCMD = 0
		for boucle as integer = 1 to 2
			IF OnCherche = CommLANG(boucle) Then
				NoCMD = 0
				exit for
			Else
				NoCMD = 1
			End if
		Next boucle
		IF NoCMD = 1 then CommLANG(1) = "[F.#).|" : CommLANG(2) = "[F.#).|" : CommLANG(3) = "\\#//"

		REM 'Afficher la liste des commandes avec anglais / francais
		IF AfficherAide = 1 then
			IF CPCDOS_INSTANCE.Utilisateur_Langage = 0 then
				CommandesAide = CommandesAide & CRLF & " fermer/                    Fermer un processus thread ou un objet"
			Else
				CommandesAide = CommandesAide & CRLF & " close/                     Kill a process, thread or an object"
			END IF
		END IF
		IF CommLANG(1) = OnCherche Then CommTrouve = 1
		IF CommLANG(2) = OnCherche Then CommTrouve = 2
		IF CommTrouve > 0 Then ' Afficher l'aide de la commande
			IF AfficherAide = 2 then
				Mess_Aide = ""
				IF CPCDOS_INSTANCE.Utilisateur_Langage = 0 THEN
					Mess_Aide = Mess_Aide & CRLF & "  Fonctionnalit�e :"
					Mess_Aide = Mess_Aide & CRLF & "   Cette commande permet de fermer un ou plusieurs processuss sp�cifi�s par son nom ou par son PID"
					Mess_Aide = Mess_Aide & CRLF
					Mess_Aide = Mess_Aide & CRLF & "  Exemple :"
					Mess_Aide = Mess_Aide & CRLF & "   Fermeture basique. Ferme tous les processus ayant le meme nom"
					Mess_Aide = Mess_Aide & CRLF & "    Fermer/ MA_FENETRE"
					Mess_Aide = Mess_Aide & CRLF & "    Fermer/ APP1"
					Mess_Aide = Mess_Aide & CRLF
					Mess_Aide = Mess_Aide & CRLF & "   Fermeture du processus par numero PID"
					Mess_Aide = Mess_Aide & CRLF & "    Fermer/ /PID 1234"
					Mess_Aide = Mess_Aide & CRLF
					Mess_Aide = Mess_Aide & CRLF & "   Femeture par le handle�"
					Mess_Aide = Mess_Aide & CRLF & "    Fermer/ /handle 1234"
					Mess_Aide = Mess_Aide & CRLF
					Mess_Aide = Mess_Aide & CRLF & "   Fermeture du processus/handle par CleID"
					Mess_Aide = Mess_Aide & CRLF & "    FERMER/ /CleID 123456789"
					Mess_Aide = Mess_Aide & CRLF
					Mess_Aide = Mess_Aide & CRLF & "  Voir aussi : exe/"
					Mess_Aide = Mess_Aide & CRLF
				ELSEIF CPCDOS_INSTANCE.Utilisateur_Langage = 1 THEN
					Mess_Aide = Mess_Aide & CRLF & "  Fonctionnality :"
					Mess_Aide = Mess_Aide & CRLF & "   This command allow to kill one or many process specified by his name or by his PID"
					Mess_Aide = Mess_Aide & CRLF
					Mess_Aide = Mess_Aide & CRLF & "  Exemple :"
					Mess_Aide = Mess_Aide & CRLF & "   Simple killing. Close all processus with the same name"
					Mess_Aide = Mess_Aide & CRLF & "    Close/ MY_WINDOW"
					Mess_Aide = Mess_Aide & CRLF & "    Close/ APP1"
					Mess_Aide = Mess_Aide & CRLF
					Mess_Aide = Mess_Aide & CRLF & "   Killing process by PID number"
					Mess_Aide = Mess_Aide & CRLF & "    Close/ /PID 1234"
					Mess_Aide = Mess_Aide & CRLF
					Mess_Aide = Mess_Aide & CRLF & "   Killing by handle number"
					Mess_Aide = Mess_Aide & CRLF & "    Close/ /handle 1234"
					Mess_Aide = Mess_Aide & CRLF
					Mess_Aide = Mess_Aide & CRLF & "   Killing process/handle by KeyID"
					Mess_Aide = Mess_Aide & CRLF & "    Close/ /KeyID 123456789"
					Mess_Aide = Mess_Aide & CRLF
					Mess_Aide = Mess_Aide & CRLF & "  See also : exe/"
					Mess_Aide = Mess_Aide & CRLF
				END IF

				DEBUG(Mess_Aide, Affichage, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_SURBRILLE, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.SansDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_AFF, RetourVAR)
				testCMD = 0
				AfficherAide = 0
				exit _scope_CMD, _scope
			END IF
			' Tester la syntaxe
			testCMD	= CCP_Verifier_Syntaxe(Commande, CommPosition)
			IF testCMD > 10 Then exit _scope_CMD, _scope
			IF testCMD > 0 then  ' Entre 1-5 = Pas d'affichage via le @, @$ ou @#
				IF testCMD < 6 then
					Affichage = 0
					IF testCMD = 3 Then CpcdosCP_SHELL("FIX/ " & CPCDOS_INSTANCE.DEBUG_INSTANCE.LeRetour & " = \#NULL", _CLE_, NIVEAU_CCP, Param_1, Param_2) : RetourVAR = _CLE_ & "N" & NIVEAU_CCP & "->" & CPCDOS_INSTANCE.DEBUG_INSTANCE.LeRetour
					if testCMD = 2 Then RetourVAR = "$>" & CPCDOS_INSTANCE.DEBUG_INSTANCE.LeRetour ' ajouter une securite ?
				Else
					Affichage = 1
				END IF
			Else
				Affichage = 1
			END IF
			' Recuperer les Parametres
			Param = MID(Commande, CommPosition + TailleComm + 2)
			SCOPE
			' ====================================================================
			Dim TypeOjetNOM		as String
			Dim Numero_INDEX	as integer = 0
			Dim TypeObjet		as integer = 0
			DIM Numero_KeyID 	as Double = 0
			DIM Numero_PID 		as integer = 0
			DIM Numero_TID 		as integer = 0
			DIM Numero_Handle 	as integer = 0

			Dim PosNUMcle	as integer = instr(UCASE(Param), "/CLEID") ' CleID (Decimal ou 0x hexa)
			Dim PosNUMKey	as integer = instr(UCASE(Param), "/KEYID") ' CleID (Decimal ou 0x hexa)
			Dim PosNUMCleB	as integer = instr(UCASE(Param), "/CLEIDB") ' CleID (Binaire)
			Dim PosNUMKeyB	as integer = instr(UCASE(Param), "/KEYIDB") ' CleID (Binaire)

			Dim PosNUMPid 	as integer = instr(UCASE(Param), "/PID") ' Procesus (Decimal ou 0x hexa)

			Dim PosNumTID 	as integer = instr(UCASE(Param), "/TID") ' Thread (Decimal ou 0x hexa)

			Dim PosNUMhandle as integer = instr(UCASE(Param), "/HANDLE") ' Handle

			' ===== Numero CleID =====
			IF PosNUMCle > 0 Then ' Numero de CleID
				Numero_KeyID = Val(MID(Param, PosNUMcle + 6))

			ElseIF PosNUMCle > 0 Then ' Numero de KeyID
				Numero_KeyID = Val(MID(Param, PosNUMcle + 6))

			ElseIF PosNUMCleB > 0 Then ' Numero de CleID binaire
				Numero_KeyID = Val(MID(Param, PosNUMCleB + 7))

			ElseIF PosNUMKeyB > 0 Then ' Numero de KeyID binaire
				Numero_KeyID = Val(MID(Param, PosNUMKeyB + 7))
			End if

			' ===== Numero Processus  =====
			IF PosNUMPid > 0 Then ' Numero de Processus
				IF Instr(Ucase(Param), "0X") > 0 Then
					' Nombre hexadecimal
					Numero_PID = Val("&h" & MID(Param, PosNUMPid + 5))
				else
					' Nombre decimal
					Numero_PID = Val(MID(Param, PosNUMPid + 5))
				End if
			End if

			' ===== Numero Thread =====
			IF PosNumTID > 0 Then ' Numero de Thread
				IF Instr(Ucase(Param), "0X") > 0 Then
					' Nombre hexadecimal
					Numero_TID = Val("&h" & MID(Param, PosNumTID + 5))
				else
					' Nombre decimal
					Numero_TID = Val(MID(Param, PosNumTID + 5))
				End if
			End if

			' ===== Numero Handle =====
			IF PosNumHandle > 0 Then ' Numero de handle
				IF Instr(Ucase(Param), "0X") > 0 Then
					' Nombre hexadecimal
					Numero_Handle = Val("&h" & MID(Param, PosNumHandle + 8))
				else
					' Nombre decimal
					Numero_Handle = Val(MID(Param, PosNumHandle + 8))
				End if
			End if

			' === On recupere le numero d'index et le type d'objet/instance ===
			IF Numero_KeyID > 0 Then

				' Chercher les fenetres
				For boucle as integer = 1 to CPCDOS_INSTANCE._MAX_GUI_FENETRE
					if CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__FENETRE(boucle).Identification_Objet._CLE_ = Numero_KeyID Then

						' Indiquer que c'est une fenetre qu'on veut supprimer
						TypeObjet = CPCDOS_INSTANCE.SCI_INSTANCE.GUI_TYPE.Fenetre

						' Et son numero d'index
						Numero_INDEX = boucle

						exit for
					End if
				Next boucle

				' Chercher les boutons
				For boucle as integer = 1 to CPCDOS_INSTANCE._MAX_GUI_BOUTON
					if CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__BOUTON(boucle).Identification_Objet._CLE_ = Numero_KeyID Then

						' Indiquer que c'est une fenetre qu'on veut supprimer
						TypeObjet = CPCDOS_INSTANCE.SCI_INSTANCE.GUI_TYPE.Bouton

						' Et son numero d'index
						Numero_INDEX = boucle

						exit for
					End if
				Next boucle

				' Chercher les picturebox
				For boucle as integer = 1 to CPCDOS_INSTANCE._MAX_GUI_PICTUREBOX
					if CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__PICTUREBOX(boucle).Identification_Objet._CLE_ = Numero_KeyID Then

						' Indiquer que c'est une fenetre qu'on veut supprimer
						TypeObjet = CPCDOS_INSTANCE.SCI_INSTANCE.GUI_TYPE.PICTUREBOX

						' Et son numero d'index
						Numero_INDEX = boucle

						exit for
					End if
				Next boucle

				' Chercher les textbloc
				For boucle as integer = 1 to CPCDOS_INSTANCE._MAX_GUI_TEXTBLOCK
					if CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__TEXTBLOCK(boucle).Identification_Objet._CLE_ = Numero_KeyID Then

						' Indiquer que c'est une fenetre qu'on veut supprimer
						TypeObjet = CPCDOS_INSTANCE.SCI_INSTANCE.GUI_TYPE.TEXTBLOCK

						' Et son numero d'index
						Numero_INDEX = boucle

						exit for
					End if
				Next boucle


				' Chercher les TextBox
				For boucle as integer = 1 to CPCDOS_INSTANCE._MAX_GUI_TEXTBOX
					if CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__TEXTBOX(boucle).Identification_Objet._CLE_ = Numero_KeyID Then

						' Indiquer que c'est une fenetre qu'on veut supprimer
						TypeObjet = CPCDOS_INSTANCE.SCI_INSTANCE.GUI_TYPE.TEXTBOX

						' Et son numero d'index
						Numero_INDEX = boucle

						exit for
					End if
				Next boucle

				' Chercher les checkbox
				For boucle as integer = 1 to CPCDOS_INSTANCE._MAX_GUI_CHECKBOX
					if CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__CHECKBOX(boucle).Identification_Objet._CLE_ = Numero_KeyID Then

						' Indiquer que c'est une fenetre qu'on veut supprimer
						TypeObjet = CPCDOS_INSTANCE.SCI_INSTANCE.GUI_TYPE.CHECKBOX

						' Et son numero d'index
						Numero_INDEX = boucle

						exit for
					End if
				Next boucle

				' Chercher les Progressbar
				For boucle as integer = 1 to CPCDOS_INSTANCE._MAX_GUI_PROGRESSBAR
					if CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__PROGRESSBAR(boucle).Identification_Objet._CLE_ = Numero_KeyID Then

						' Indiquer que c'est une fenetre qu'on veut supprimer
						TypeObjet = CPCDOS_INSTANCE.SCI_INSTANCE.GUI_TYPE.PROGRESSBAR

						' Et son numero d'index
						Numero_INDEX = boucle

						exit for
					End if
				Next boucle

			ElseIf Numero_PID > 0 Then
				' Supprimer un processus (Et tout ses threads)

				Dim NomPID as String = CPCDOS_INSTANCE.get_Nom_Processus(Numero_PID)

				' Detecter la presence d'objets graphiques

				IF CPCDOS_INSTANCE.SYSTEME_INSTANCE.get_DBG_DEBUG() > 0 Then
					IF CPCDOS_INSTANCE.Utilisateur_Langage = 0 Then
						DEBUG("[CpcdosC+] Recherche et suppression des objets graphiques (si present) ...", Affichage, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_ACTION, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.AvecDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_CPCDOS, RetourVAR)
					Else
						DEBUG("[CpcdosC+] Search and deleting graphic objects (If present) ...", Affichage, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_ACTION, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.AvecDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_CPCDOS, RetourVAR)
					End if
				End if

				scope
					Dim NombreObjetSuppreime as integer = 0
					' Chercher les fenetres
					For boucle as integer = 1 to CPCDOS_INSTANCE._MAX_GUI_FENETRE - 1 ' correction : Ajout du "-1" le 08/03/2019
						if CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__FENETRE(boucle).Identification_Objet.PID_PARENT > 0 AND CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__FENETRE(boucle).Identification_Objet.PID_PARENT = Numero_PID Then ' UN BUG ICI

							' Indiquer que c'est une fenetre qu'on veut supprimer
							TypeObjet = CPCDOS_INSTANCE.SCI_INSTANCE.GUI_TYPE.Fenetre

							' Et son numero d'index
							Numero_INDEX = boucle

							NombreObjetSuppreime = NombreObjetSuppreime + 1

							' Supprimer l'objet concerne
							CPCDOS_INSTANCE.SCI_INSTANCE.CPC__GUI_SUPPRIMER_obj(TypeObjet, Numero_INDEX)
						End if
					Next boucle

					For boucle as integer = 1 to CPCDOS_INSTANCE._MAX_GUI___OBJS - 1 ' correction : Ajout du "-1" le 08/03/2019
						if CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__BOUTON(boucle).Identification_Objet.PID_PARENT > 0 AND CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__BOUTON(boucle).Identification_Objet.PID_PARENT = Numero_PID Then

							' Indiquer que c'est une fenetre qu'on veut supprimer
							TypeObjet = CPCDOS_INSTANCE.SCI_INSTANCE.GUI_TYPE.Bouton

							' Et son numero d'index
							Numero_INDEX = boucle

							NombreObjetSuppreime = NombreObjetSuppreime + 1

							' Supprimer l'objet concerne
							CPCDOS_INSTANCE.SCI_INSTANCE.CPC__GUI_SUPPRIMER_obj(TypeObjet, Numero_INDEX)

						End if

						if CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__PICTUREBOX(boucle).Identification_Objet.PID_PARENT > 0 AND CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__PICTUREBOX(boucle).Identification_Objet.PID_PARENT = Numero_PID Then

							' Indiquer que c'est une fenetre qu'on veut supprimer
							TypeObjet = CPCDOS_INSTANCE.SCI_INSTANCE.GUI_TYPE.PICTUREBOX

							' Et son numero d'index
							Numero_INDEX = boucle

							NombreObjetSuppreime = NombreObjetSuppreime + 1

							' Supprimer l'objet concerne
							CPCDOS_INSTANCE.SCI_INSTANCE.CPC__GUI_SUPPRIMER_obj(TypeObjet, Numero_INDEX)
						End if

						if CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__TEXTBLOCK(boucle).Identification_Objet.PID_PARENT > 0 AND CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__TEXTBLOCK(boucle).Identification_Objet.PID_PARENT = Numero_PID Then

							' Indiquer que c'est une fenetre qu'on veut supprimer
							TypeObjet = CPCDOS_INSTANCE.SCI_INSTANCE.GUI_TYPE.TEXTBLOCK

							' Et son numero d'index
							Numero_INDEX = boucle

							NombreObjetSuppreime = NombreObjetSuppreime + 1

							' Supprimer l'objet concerne
							CPCDOS_INSTANCE.SCI_INSTANCE.CPC__GUI_SUPPRIMER_obj(TypeObjet, Numero_INDEX)
						End if

						if CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__TEXTBOX(boucle).Identification_Objet.PID_PARENT > 0 AND CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__TEXTBOX(boucle).Identification_Objet.PID_PARENT = Numero_PID Then

							' Indiquer que c'est une fenetre qu'on veut supprimer
							TypeObjet = CPCDOS_INSTANCE.SCI_INSTANCE.GUI_TYPE.TEXTBOX

							' Et son numero d'index
							Numero_INDEX = boucle

							NombreObjetSuppreime = NombreObjetSuppreime + 1

							' Supprimer l'objet concerne
							CPCDOS_INSTANCE.SCI_INSTANCE.CPC__GUI_SUPPRIMER_obj(TypeObjet, Numero_INDEX)
						End if

						if CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__CHECKBOX(boucle).Identification_Objet.PID_PARENT > 0 AND CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__CHECKBOX(boucle).Identification_Objet.PID_PARENT = Numero_PID Then

							' Indiquer que c'est une fenetre qu'on veut supprimer
							TypeObjet = CPCDOS_INSTANCE.SCI_INSTANCE.GUI_TYPE.CheckBox

							' Et son numero d'index
							Numero_INDEX = boucle

							NombreObjetSuppreime = NombreObjetSuppreime + 1

							' Supprimer l'objet concerne
							CPCDOS_INSTANCE.SCI_INSTANCE.CPC__GUI_SUPPRIMER_obj(TypeObjet, Numero_INDEX)
						End if

						if CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__PROGRESSBAR(boucle).Identification_Objet.PID_PARENT > 0 AND CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__PROGRESSBAR(boucle).Identification_Objet.PID_PARENT = Numero_PID Then

							' Indiquer que c'est une fenetre qu'on veut supprimer
							TypeObjet = CPCDOS_INSTANCE.SCI_INSTANCE.GUI_TYPE.ProgressBar

							' Et son numero d'index
							Numero_INDEX = boucle

							NombreObjetSuppreime = NombreObjetSuppreime + 1

							' Supprimer l'objet concerne
							CPCDOS_INSTANCE.SCI_INSTANCE.CPC__GUI_SUPPRIMER_obj(TypeObjet, Numero_INDEX)
						End if

					Next boucle



					IF CPCDOS_INSTANCE.SYSTEME_INSTANCE.get_DBG_DEBUG() > 0 Then
						If NombreObjetSuppreime > 0 Then
							IF CPCDOS_INSTANCE.Utilisateur_Langage = 0 Then
								DEBUG("[CpcdosC+] Suppression de " & NombreObjetSuppreime & "  terminee", Affichage, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_OK, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.AvecDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_CPCDOS, RetourVAR)
							Else
								DEBUG("[CpcdosC+] Deleting " & NombreObjetSuppreime & " terminated", Affichage, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_OK, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.AvecDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_CPCDOS, RetourVAR)
							End if
						Else
							IF CPCDOS_INSTANCE.Utilisateur_Langage = 0 Then
								DEBUG("[CpcdosC+] Aucun objets graphiques associes", Affichage, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_AVERTISSEMENT, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.AvecDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_CPCDOS, RetourVAR)
							Else
								DEBUG("[CpcdosC+] No graphic object associed", Affichage, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_AVERTISSEMENT, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.AvecDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_CPCDOS, RetourVAR)
							End if
						End if
					End if

					If NombreObjetSuppreime > 0 Then
						' Si l'interface graphique est executee
						IF CPCDOS_INSTANCE.SCI_INSTANCE.GUI_Mode = TRUE Then
							IF CPCDOS_INSTANCE.SYSTEME_INSTANCE.get_DBG_DEBUG() > 0 Then
								IF CPCDOS_INSTANCE.Utilisateur_Langage = 0 Then
									DEBUG("[CpcdosC+] Actualisation graphique", Affichage, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_ACTION, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.AvecDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_CPCDOS, RetourVAR)
								Else
									DEBUG("[CpcdosC+] Graphic actualisation", Affichage, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_ACTION, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.AvecDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_CPCDOS, RetourVAR)
								End if
							End if
							' Et actualiser l'interface graphique
							CPCDOS_INSTANCE.SCI_INSTANCE.ActualiserGUI(0, 0)
						End if
					End if

				End scope

				IF CPCDOS_INSTANCE.SYSTEME_INSTANCE.get_DBG_DEBUG() > 0 Then
					IF CPCDOS_INSTANCE.Utilisateur_Langage = 0 Then
						DEBUG("[CpcdosC+] Demande d'arret du processus " & NomPID & " (PID:" & Numero_PID & ") et de ses threads associes ...", Affichage, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_ACTION, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.AvecDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_CPCDOS, RetourVAR)
					Else
						DEBUG("[CpcdosC+] Asking killing process " & NomPID & " (PID:" & Numero_PID & ") and his associed threads) ...", Affichage, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_ACTION, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.AvecDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_CPCDOS, RetourVAR)
					End if
				End if

				CPCDOS_INSTANCE.Fermer_processus(Numero_PID)

				IF CPCDOS_INSTANCE.SYSTEME_INSTANCE.get_DBG_DEBUG() > 0 Then
					IF CPCDOS_INSTANCE.Utilisateur_Langage = 0 Then
						DEBUG("[CpcdosC+] Arret du processus " & NomPID & " (PID:" & Numero_PID & ") Envoye !", Affichage, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_OK, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.AvecDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_CPCDOS, RetourVAR)
					Else
						DEBUG("[CpcdosC+] Killing process " & NomPID & " (PID:" & Numero_PID & ") Sent!", Affichage, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_OK, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.AvecDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_CPCDOS, RetourVAR)
					End if
				End if

				exit _scope_CMD, _scope

			ElseIf Numero_TID > 0 Then
				' supprimer un thread

				Dim NomTID as String = CPCDOS_INSTANCE.get_Nom_Thread(Numero_TID)

				IF CPCDOS_INSTANCE.SYSTEME_INSTANCE.get_DBG_DEBUG() > 0 Then
					IF CPCDOS_INSTANCE.Utilisateur_Langage = 0 Then
						DEBUG("[CpcdosC+] Demande d'arret du thread '" & NomTiD & "' (PID:" & Auth_PID & " TID:" & Numero_TID & ") et de ses threads associes ...", Affichage, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_ACTION, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.AvecDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_CPCDOS, RetourVAR)
					Else
						DEBUG("[CpcdosC+] Asking killing thread '" & NomTiD & "' (PID:" & Auth_PID & "TID:" & Numero_TID & ") and his associed threads) ...", Affichage, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_ACTION, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.AvecDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_CPCDOS, RetourVAR)
					End if
				End if
				' On ne pourra supprimer le thread UNIQUEMENT du processus
				'  l'appelant ahah (Petite securite)
				CPCDOS_INSTANCE.Fermer_thread(Auth_PID, Numero_TID, false)

				IF CPCDOS_INSTANCE.SYSTEME_INSTANCE.get_DBG_DEBUG() > 0 Then
					IF CPCDOS_INSTANCE.Utilisateur_Langage = 0 Then
						DEBUG("[CpcdosC+] Demande d'arret du thread " & NomTID & " (PID:" & Auth_PID & " TID:" & Numero_TID & ") et de ses threads associes Envoye !", Affichage, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_OK, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.AvecDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_CPCDOS, RetourVAR)
					Else
						DEBUG("[CpcdosC+] Asking killing thread " & NomTID & " (PID:" & Auth_PID & " TID:" & Numero_TID & ") and his associed threads) Sent!", Affichage, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_OK, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.AvecDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_CPCDOS, RetourVAR)
					End if
				End if

				exit _scope_CMD, _scope

			ElseIf Numero_Handle > 0 Then
				' Supprimer l'objet correspondant au handle

				TypeObjet = 0

				' Chercher les fenetres
				For boucle as integer = 1 to CPCDOS_INSTANCE._MAX_GUI_FENETRE
					if CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__FENETRE(boucle).Identification_Objet.Handle = Numero_Handle Then

						' Indiquer que c'est une fenetre qu'on veut supprimer
						TypeObjet = CPCDOS_INSTANCE.SCI_INSTANCE.GUI_TYPE.Fenetre

						' Et son numero d'index
						Numero_INDEX = boucle

						exit for
					End if
				Next boucle


				if TypeObjet = 0 Then

					' Chercher les boutons
					For boucle as integer = 1 to CPCDOS_INSTANCE._MAX_GUI_BOUTON
						if CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__BOUTON(boucle).Identification_Objet.Handle = Numero_Handle Then

							' Indiquer que c'est une fenetre qu'on veut supprimer
							TypeObjet = CPCDOS_INSTANCE.SCI_INSTANCE.GUI_TYPE.Bouton

							' Et son numero d'index
							Numero_INDEX = boucle

							exit for
						End if
					Next boucle

				End if


				if TypeObjet = 0 Then
					' Chercher les picturebox
					For boucle as integer = 1 to CPCDOS_INSTANCE._MAX_GUI_PICTUREBOX
						if CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__PICTUREBOX(boucle).Identification_Objet.Handle = Numero_Handle Then

							' Indiquer que c'est une fenetre qu'on veut supprimer
							TypeObjet = CPCDOS_INSTANCE.SCI_INSTANCE.GUI_TYPE.PICTUREBOX

							' Et son numero d'index
							Numero_INDEX = boucle

							exit for
						End if
					Next boucle

				End if


				if TypeObjet = 0 Then
					' Chercher les textbloc
					For boucle as integer = 1 to CPCDOS_INSTANCE._MAX_GUI_TEXTBLOCK
						if CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__TEXTBLOCK(boucle).Identification_Objet.Handle = Numero_Handle Then

							' Indiquer que c'est une fenetre qu'on veut supprimer
							TypeObjet = CPCDOS_INSTANCE.SCI_INSTANCE.GUI_TYPE.TEXTBLOCK

							' Et son numero d'index
							Numero_INDEX = boucle

							exit for
						End if
					Next boucle

				End if


				if TypeObjet = 0 Then
					' Chercher les TextBox
					For boucle as integer = 1 to CPCDOS_INSTANCE._MAX_GUI_TEXTBOX
						if CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__TEXTBOX(boucle).Identification_Objet.Handle = Numero_Handle Then

							' Indiquer que c'est une fenetre qu'on veut supprimer
							TypeObjet = CPCDOS_INSTANCE.SCI_INSTANCE.GUI_TYPE.TEXTBOX

							' Et son numero d'index
							Numero_INDEX = boucle

							exit for
						End if
					Next boucle
				End if


				if TypeObjet = 0 Then
					' Chercher les checkbox
					For boucle as integer = 1 to CPCDOS_INSTANCE._MAX_GUI_CHECKBOX
						if CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__CHECKBOX(boucle).Identification_Objet.Handle = Numero_Handle Then

							' Indiquer que c'est une fenetre qu'on veut supprimer
							TypeObjet = CPCDOS_INSTANCE.SCI_INSTANCE.GUI_TYPE.CHECKBOX

							' Et son numero d'index
							Numero_INDEX = boucle

							exit for
						End if
					Next boucle
				End if


				if TypeObjet = 0 Then
					' Chercher les Progressbar
					For boucle as integer = 1 to CPCDOS_INSTANCE._MAX_GUI_PROGRESSBAR
						if CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__PROGRESSBAR(boucle).Identification_Objet.Handle = Numero_Handle Then

							' Indiquer que c'est une fenetre qu'on veut supprimer
							TypeObjet = CPCDOS_INSTANCE.SCI_INSTANCE.GUI_TYPE.PROGRESSBAR

							' Et son numero d'index
							Numero_INDEX = boucle

							exit for
						End if
					Next boucle
				End if


			Else
				IF NOT Param = "" Then

					TypeObjet = 0
					' Si les parametres ont quelque chose on cherche par le nom

					' Nettoyer
					Param = Ucase(RTRIM(RTRIM(LTRIM(LTRIM(Param, chr(09))), chr(09))))

					' Chercher les fenetres
					For boucle as integer = 1 to CPCDOS_INSTANCE._MAX_GUI_FENETRE
						if CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__FENETRE(boucle).Identification_Objet.Nom = Param Then

							' Indiquer que c'est une fenetre qu'on veut supprimer
							TypeObjet = CPCDOS_INSTANCE.SCI_INSTANCE.GUI_TYPE.Fenetre

							' Et son numero d'index
							Numero_INDEX = boucle

							exit for
						End if
					Next boucle



					if TypeObjet = 0 Then
						' Chercher les boutons
						For boucle as integer = 1 to CPCDOS_INSTANCE._MAX_GUI_BOUTON
							if CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__BOUTON(boucle).Identification_Objet.Nom = Param Then

								' Indiquer que c'est une fenetre qu'on veut supprimer
								TypeObjet = CPCDOS_INSTANCE.SCI_INSTANCE.GUI_TYPE.Bouton

								' Et son numero d'index
								Numero_INDEX = boucle

								exit for
							End if
						Next boucle
					End if


					if TypeObjet = 0 Then
						' Chercher les picturebox
						For boucle as integer = 1 to CPCDOS_INSTANCE._MAX_GUI_PICTUREBOX
							if CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__PICTUREBOX(boucle).Identification_Objet.Nom = Param Then

								' Indiquer que c'est une fenetre qu'on veut supprimer
								TypeObjet = CPCDOS_INSTANCE.SCI_INSTANCE.GUI_TYPE.PICTUREBOX

								' Et son numero d'index
								Numero_INDEX = boucle

								exit for
							End if
						Next boucle
					End if


					if TypeObjet = 0 Then
						' Chercher les textbloc
						For boucle as integer = 1 to CPCDOS_INSTANCE._MAX_GUI_TEXTBLOCK
							if CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__TEXTBLOCK(boucle).Identification_Objet.Nom = Param Then

								' Indiquer que c'est une fenetre qu'on veut supprimer
								TypeObjet = CPCDOS_INSTANCE.SCI_INSTANCE.GUI_TYPE.TEXTBLOCK

								' Et son numero d'index
								Numero_INDEX = boucle

								exit for
							End if
						Next boucle
					End if


					if TypeObjet = 0 Then
						' Chercher les TextBox
						For boucle as integer = 1 to CPCDOS_INSTANCE._MAX_GUI_TEXTBOX
							if CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__TEXTBOX(boucle).Identification_Objet.Nom = Param Then

								' Indiquer que c'est une fenetre qu'on veut supprimer
								TypeObjet = CPCDOS_INSTANCE.SCI_INSTANCE.GUI_TYPE.TEXTBOX

								' Et son numero d'index
								Numero_INDEX = boucle

								exit for
							End if
						Next boucle
					End if


					if TypeObjet = 0 Then
						' Chercher les checkbox
						For boucle as integer = 1 to CPCDOS_INSTANCE._MAX_GUI_CHECKBOX
							if CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__CHECKBOX(boucle).Identification_Objet.Nom = Param Then

								' Indiquer que c'est une fenetre qu'on veut supprimer
								TypeObjet = CPCDOS_INSTANCE.SCI_INSTANCE.GUI_TYPE.CHECKBOX

								' Et son numero d'index
								Numero_INDEX = boucle

								exit for
							End if
						Next boucle
					End if


					if TypeObjet = 0 Then
						' Chercher les Progressbar
						For boucle as integer = 1 to CPCDOS_INSTANCE._MAX_GUI_PROGRESSBAR
							if CPCDOS_INSTANCE.SCI_INSTANCE.INST_INIT_GUI.GUI__PROGRESSBAR(boucle).Identification_Objet.Nom = Param Then

								' Indiquer que c'est une fenetre qu'on veut supprimer
								TypeObjet = CPCDOS_INSTANCE.SCI_INSTANCE.GUI_TYPE.PROGRESSBAR

								' Et son numero d'index
								Numero_INDEX = boucle

								exit for
							End if
						Next boucle
					End if
				Else

					' L'utilisateur n'a rien indique
					Message_erreur = ERRAVT("AVT_078", 0)
					IF CPCDOS_INSTANCE.Utilisateur_Langage = 0 Then
						DEBUG("[CpcdosC+] AVT_078 : " & Message_erreur & ". Veuillez indiquer un nom ou un parametre.", Affichage, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_AVERTISSEMENT, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.AvecDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_CPCDOS, RetourVAR)
					Else
						DEBUG("[CpcdosC+] AVT_078 : " & Message_erreur & ". Please put name or parameter.", Affichage, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_AVERTISSEMENT, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.AvecDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_CPCDOS, RetourVAR)
					End if
					exit _scope_CMD, _scope
				End if
			End if

			' Si on a trouve quelque chose
			if Numero_INDEX > 0 Then


				IF CPCDOS_INSTANCE.SYSTEME_INSTANCE.get_DBG_DEBUG() > 0 Then
					IF CPCDOS_INSTANCE.Utilisateur_Langage = 0 Then
						DEBUG("[CpcdosC+] Suppression ...", Affichage, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_ACTION, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.AvecDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_CPCDOS, RetourVAR)
					Else
						DEBUG("[CpcdosC+] Deleting  ...", Affichage, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_ACTION, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.AvecDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_CPCDOS, RetourVAR)
					End if
				End if

				' Supprimer l'objet concerne
				CPCDOS_INSTANCE.SCI_INSTANCE.CPC__GUI_SUPPRIMER_obj(TypeObjet, Numero_INDEX)

				' Si l'interface graphique est executee
				IF CPCDOS_INSTANCE.SCI_INSTANCE.GUI_Mode = TRUE Then
					IF CPCDOS_INSTANCE.SYSTEME_INSTANCE.get_DBG_DEBUG() > 0 Then
						IF CPCDOS_INSTANCE.Utilisateur_Langage = 0 Then
							DEBUG("[CpcdosC+] Actualisation graphique ", Affichage, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_ACTION, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.AvecDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_CPCDOS, RetourVAR)
						Else
							DEBUG("[CpcdosC+] Graphic actualisation", Affichage, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_ACTION, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.AvecDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_CPCDOS, RetourVAR)
						End if
					End if
					' Et actualiser l'interface graphique
					CPCDOS_INSTANCE.SCI_INSTANCE.ActualiserGUI(0, 0)
				End if

			Else
				' Si on n'a pas trouve quelque chose
				Message_erreur = ERRAVT("AVT_077", 0)
				IF CPCDOS_INSTANCE.Utilisateur_Langage = 0 Then
					DEBUG("[CpcdosC+] AVT_077 : " & Message_erreur & ".", Affichage, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_AVERTISSEMENT, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.AvecDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_CPCDOS, RetourVAR)
				Else
					DEBUG("[CpcdosC+] AVT_077 : " & Message_erreur & ". ", Affichage, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_AVERTISSEMENT, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.AvecDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_CPCDOS, RetourVAR)
				End if
			End if
	'--------------------------- Fermer_Processus_par_PID(NumPID_2) --------------------------------------------

			' ===================================================================
			END SCOPE
			exit _scope_CMD, _scope

		END IF ' **** FERMER/ ****

	_end_scope_CMD

	_scope_CMD

		' ===============================================================
		'  Commande pour configurer/afficher des Parametres du systeme
		' ===============================================================
		CommLANG(1) = "sys/"
		CommLANG(2) = "sys/"
		CommLANG(3) = "\\#//"
		CommTrouve = 0 : NoCMD = 0
		for boucle as integer = 1 to 2
			IF OnCherche = CommLANG(boucle) Then
				NoCMD = 0
				exit for
			Else
				NoCMD = 1
			End if
		Next boucle
		IF NoCMD = 1 then CommLANG(1) = "[F.#).|" : CommLANG(2) = "[F.#).|" : CommLANG(3) = "\\#//"

		rem Afficher la liste des commandes avec anglais / francais
		IF AfficherAide = 1 then
			IF CPCDOS_INSTANCE.Utilisateur_Langage = 0 then
				CommandesAide = CommandesAide & CRLF & " sys/                       Configurer/afficher les informations du systeme"
			Else
				CommandesAide = CommandesAide & CRLF & " sys/                       Configure/display system informations"
			END IF
		END IF

		IF CommLANG(1) = OnCherche Then CommTrouve = 1
		IF CommLANG(2) = OnCherche Then CommTrouve = 2
		IF CommTrouve > 0 Then
		IF AfficherAide = 2 then
				Mess_Aide = ""
				IF CPCDOS_INSTANCE.Utilisateur_Langage = 0 THEN
					Mess_Aide = Mess_Aide & CRLF & "  'SYSteme'"
					Mess_Aide = Mess_Aide & CRLF
					Mess_Aide = Mess_Aide & CRLF & "  Fonctionnalit�e :"
					Mess_Aide = Mess_Aide & CRLF & "   Cette commande permet de configurer des Parametres, ou bien afficher"
					Mess_Aide = Mess_Aide & CRLF & "   des informations du systeme."
					Mess_Aide = Mess_Aide & CRLF
					Mess_Aide = Mess_Aide & CRLF & "   Afficher la memoire libre restante / Utilis�e en octets, Ko, Mo, Go"
					Mess_Aide = Mess_Aide & CRLF & "     Afficher la memoire restante en octets"
					Mess_Aide = Mess_Aide & CRLF & "      sys/ /mem"
					Mess_Aide = Mess_Aide & CRLF & "     Afficher la memoire Utilis�e en octets"
					Mess_Aide = Mess_Aide & CRLF & "      sys/ /memu"
					Mess_Aide = Mess_Aide & CRLF & "     Afficher la memoire restante en Mo"
					Mess_Aide = Mess_Aide & CRLF & "      sys/ /mem mo"
					Mess_Aide = Mess_Aide & CRLF & "     Afficher la memoire Utilis�e en Mo"
					Mess_Aide = Mess_Aide & CRLF & "      sys/ /memu mo"
					Mess_Aide = Mess_Aide & CRLF & "     ... aussi avec Go pour Giga Octets, To pour Tera Octets"
					Mess_Aide = Mess_Aide & CRLF
					Mess_Aide = Mess_Aide & CRLF
					Mess_Aide = Mess_Aide & CRLF & "    Deboguer le noyau. (Affiche toutes les activites du noyau)"
					Mess_Aide = Mess_Aide & CRLF & "      SYS/ /DEBUG {COMn} {/CPINTICORE} {/SERVEUR:TCP} = { 0, 1, 2, 3 }"
					Mess_Aide = Mess_Aide & CRLF
					Mess_Aide = Mess_Aide & CRLF & "      Exemples :"
					Mess_Aide = Mess_Aide & CRLF & "       Affiche les activit�es detaill�es du noyau"
					Mess_Aide = Mess_Aide & CRLF & "        sys/ /debug = 1"
					Mess_Aide = Mess_Aide & CRLF & "       Enregistre les activit�es detaill�es du noyau dans un fichier DEBUG.LOG"
					Mess_Aide = Mess_Aide & CRLF & "        sys/ /debug = 2"
					Mess_Aide = Mess_Aide & CRLF & "       Affiche et enregistre les activit�es detaill�es du noyau dans un fichier DEBUG.LOG"
					Mess_Aide = Mess_Aide & CRLF & "        sys/ /debug = 3"
					Mess_Aide = Mess_Aide & CRLF & "       Stoppe l'affichage des informatons detaill�es"
					Mess_Aide = Mess_Aide & CRLF & "        sys/ /debug = 0"
					Mess_Aide = Mess_Aide & CRLF
					Mess_Aide = Mess_Aide & CRLF & "       Affiche les activit�es detaill�es de CPinti core"
					Mess_Aide = Mess_Aide & CRLF & "        sys/ /debug /CPintiCore = 1"
					Mess_Aide = Mess_Aide & CRLF & "       Stoppe l'affichage des activit�es detaill�es de CPinti core"
					Mess_Aide = Mess_Aide & CRLF & "        sys/ /debug /CPintiCore = 0"
					Mess_Aide = Mess_Aide & CRLF
					Mess_Aide = Mess_Aide & CRLF & "	   Affiche le menu d'informations systeme CPinti Core"
					Mess_Aide = Mess_Aide & CRLF & "        sys/ /debug /menu = 1"
					Mess_Aide = Mess_Aide & CRLF & "	   Desactive l'affichage du menu d'informations systeme CPinti Core"
					Mess_Aide = Mess_Aide & CRLF & "        sys/ /debug /menu = 0"
					Mess_Aide = Mess_Aide & CRLF
					Mess_Aide = Mess_Aide & CRLF & "       Active le debogage par le port COM1 avec par defaut (9600,N,8,1)"
					Mess_Aide = Mess_Aide & CRLF & "        sys/ /debug /COM1 = 1"
					Mess_Aide = Mess_Aide & CRLF & "       IDEM mais de maniere plus precise 9600 baud, pas de parite, 8 bits de data, 1 bit de stop"
					Mess_Aide = Mess_Aide & CRLF & "        sys/ /debug /COM1:9600,N,8,1"
					Mess_Aide = Mess_Aide & CRLF & "       Desactive le debogage par le port COM1"
					Mess_Aide = Mess_Aide & CRLF & "        sys/ /debug /COM1 = 0"
					Mess_Aide = Mess_Aide & CRLF & "     --> Vous pouvez utiliser le COM1, COM2, COM3, COM4"
					Mess_Aide = Mess_Aide & CRLF
					Mess_Aide = Mess_Aide & CRLF & "       Affiche les informations concernant le Serveur TCP"
					Mess_Aide = Mess_Aide & CRLF & "        sys/ /debug /Serveur:TCP = 1"
					Mess_Aide = Mess_Aide & CRLF & "       Stoppe l'affichage des informations concernant le Serveur TCP"
					Mess_Aide = Mess_Aide & CRLF & "        sys/ /debug /Serveur:TCP = 0"
					Mess_Aide = Mess_Aide & CRLF
					Mess_Aide = Mess_Aide & CRLF & "   Afficher la resolution CONSOLE ou GRAPHIQUE actuelle"
					Mess_Aide = Mess_Aide & CRLF & "    SYS/ /ECRAN"
					Mess_Aide = Mess_Aide & CRLF
					Mess_Aide = Mess_Aide & CRLF
					Mess_Aide = Mess_Aide & CRLF & "   Changer la resolution d'ecran"
					Mess_Aide = Mess_Aide & CRLF & "    Vous pouvez changer la resolution CONSOLE ou GRAPHIQUE"
					Mess_Aide = Mess_Aide & CRLF & "    CONSOLE: SYS/ /ECRAN NumeroDuMode"
					Mess_Aide = Mess_Aide & CRLF & "     NumeroDuMode:"
					Mess_Aide = Mess_Aide & CRLF & "      - 1  : 320x200 (CGA)"
					Mess_Aide = Mess_Aide & CRLF & "      - 2  : 640x200 (CGA)"
					Mess_Aide = Mess_Aide & CRLF & "      - 7  : 320x200 (EGA)"
					Mess_Aide = Mess_Aide & CRLF & "      - 8  : 640x200 (EGA)"
					Mess_Aide = Mess_Aide & CRLF & "      - 9  : 640x350 (EGA)"
					Mess_Aide = Mess_Aide & CRLF & "      - 11 : 640x480 (VGA)"
					Mess_Aide = Mess_Aide & CRLF & "      - 12 : 640x480 (VGA)"
					Mess_Aide = Mess_Aide & CRLF & "      - 13 : 320x200 (MCGA)"
					Mess_Aide = Mess_Aide & CRLF & "      - 14 : 320x240 (SVGA)"
					Mess_Aide = Mess_Aide & CRLF & "      - 15 : 400x300 (SVGA)"
					Mess_Aide = Mess_Aide & CRLF & "      - 16 : 512x384 (SVGA)"
					Mess_Aide = Mess_Aide & CRLF & "      - 17 : 640x400 (SVGA)"
					Mess_Aide = Mess_Aide & CRLF & "      - 18 : 640x480 (SVGA)"
					Mess_Aide = Mess_Aide & CRLF & "      - 19 : 800x600 (SVGA)"
					Mess_Aide = Mess_Aide & CRLF & "      - 20 : 1024x768 (SVGA)"
					Mess_Aide = Mess_Aide & CRLF & "      - 21 : 1280x1024 (SVGA)"
					Mess_Aide = Mess_Aide & CRLF & "    GRAPHIC:"
					Mess_Aide = Mess_Aide & CRLF & "      Exemple: SYS/ /ECRAN 800x600"
					Mess_Aide = Mess_Aide & CRLF
					Mess_Aide = Mess_Aide & CRLF
					Mess_Aide = Mess_Aide & CRLF & "   Afficher la liste des resolutions d'ecran compatible"
					Mess_Aide = Mess_Aide & CRLF & "    Cette commande doit etre utilisee en precisant une resolution de couleurs 16, 24, 32 bits"
					Mess_Aide = Mess_Aide & CRLF & "     Exemples :"
					Mess_Aide = Mess_Aide & CRLF & "      Affiche la liste des resolutions disponibles pour 16 bits de couleurs"
					Mess_Aide = Mess_Aide & CRLF & "       SYS/ /ECRAN /LISTE 16"
					Mess_Aide = Mess_Aide & CRLF & "      Pour 24 bits"
					Mess_Aide = Mess_Aide & CRLF & "       SYS/ /ECRAN /LISTE 24"
					Mess_Aide = Mess_Aide & CRLF & "      Et pour 32 bits"
					Mess_Aide = Mess_Aide & CRLF & "       SYS/ /ECRAN /LISTE 32"
					Mess_Aide = Mess_Aide & CRLF & "   Obtenir le pointeur de l'affichage video"
					Mess_Aide = Mess_Aide & CRLF & "     Sys/ /ecran /ptr"
					Mess_Aide = Mess_Aide & CRLF & "    ou en hexadecimale"
					Mess_Aide = Mess_Aide & CRLF & "     Sys/ /ecran /hexaptr"
					Mess_Aide = Mess_Aide & CRLF
					Mess_Aide = Mess_Aide & CRLF
					Mess_Aide = Mess_Aide & CRLF & "   Utiliser une fonction wrapper (Experimentale)"
					Mess_Aide = Mess_Aide & CRLF & "    Ceci est reserve aux developpeurs du SDK Cpcdos"
					Mess_Aide = Mess_Aide & CRLF & "    Vous devez donc vous munir de votre FunctionID!"
					Mess_Aide = Mess_Aide & CRLF & "    Exemples :"
					Mess_Aide = Mess_Aide & CRLF & "	  pour la FunctionID 1234 :"
					Mess_Aide = Mess_Aide & CRLF & "      SYS/ /WRP 1234"
					Mess_Aide = Mess_Aide & CRLF
					Mess_Aide = Mess_Aide & CRLF
					Mess_Aide = Mess_Aide & CRLF & "   Recuperer le pointeur d'un tableau ARGB d'un bitmap depuis son handle"
					Mess_Aide = Mess_Aide & CRLF & "     sys/ /Bitmap /obtenir /ptrbyhandle"
					Mess_Aide = Mess_Aide & CRLF & "   Recuperer le bitmap ID depuis son numero de handle"
					Mess_Aide = Mess_Aide & CRLF & "    sys/ /Bitmap /obtenir /idbyhandle"
					Mess_Aide = Mess_Aide & CRLF
					Mess_Aide = Mess_Aide & CRLF & "   Mettre a jour la liste des OS presents via OS.LST"
					Mess_Aide = Mess_Aide & CRLF & "     sys/ /os /update"
					Mess_Aide = Mess_Aide & CRLF
					Mess_Aide = Mess_Aide & CRLF & "   Afficher la liste des OS presents via OS.LST"
					Mess_Aide = Mess_Aide & CRLF & "     sys/ /os /liste"
					Mess_Aide = Mess_Aide & CRLF
					Mess_Aide = Mess_Aide & CRLF & "   Afficher le nombre d'OS present"
					Mess_Aide = Mess_Aide & CRLF & "     sys/ /os /nb"
					Mess_Aide = Mess_Aide & CRLF
					Mess_Aide = Mess_Aide & CRLF & "   Switcher l'instant du shell courant sur un autre OS (OS id)"
					Mess_Aide = Mess_Aide & CRLF & "     sys/ /os NomDeVotreOS"
					Mess_Aide = Mess_Aide & CRLF & "    Ce qui va permettre d'utiliser l'OS id d'un autre OS pour que les"
					Mess_Aide = Mess_Aide & CRLF & "     interactions/variables/ev de niveau 3 soient traite par l'OS choisis"
					Mess_Aide = Mess_Aide & CRLF
					Mess_Aide = Mess_Aide & CRLF
					Mess_Aide = Mess_Aide & CRLF & "   Lister les variables en memoire depuis son numero de visibilite"
					Mess_Aide = Mess_Aide & CRLF & "     sys/ /listvar 5"
					Mess_Aide = Mess_Aide & CRLF
					Mess_Aide = Mess_Aide & CRLF
					Mess_Aide = Mess_Aide & CRLF & "  Creer un nouveau processus"
					Mess_Aide = Mess_Aide & CRLF & "   Ceci va vous permettre d'executer vos threads et votre code"
					Mess_Aide = Mess_Aide & CRLF & "   dans un autre processus que vous venez de creer."
					Mess_Aide = Mess_Aide & CRLF & "    sys/ /Processus NomDuProcessus"
					Mess_Aide = Mess_Aide & CRLF & "     --> Cette commande renvoi le numero de PID du nouveau processus"
					Mess_Aide = Mess_Aide & CRLF
					Mess_Aide = Mess_Aide & CRLF
					Mess_Aide = Mess_Aide & CRLF & " Verifier une nouvelle mise a jour du noyau :"
					Mess_Aide = Mess_Aide & CRLF & "   SYS/ /update"
					Mess_Aide = Mess_Aide & CRLF
					Mess_Aide = Mess_Aide & CRLF & " Telecharger une nouvelle version"
					Mess_Aide = Mess_Aide & CRLF & "   sys/ /update-get"
					Mess_Aide = Mess_Aide & CRLF
					Mess_Aide = Mess_Aide & CRLF & " Installer la version precedemment telechargee"
					Mess_Aide = Mess_Aide & CRLF & "   sys/ /update-install"
					Mess_Aide = Mess_Aide & CRLF
					Mess_Aide = Mess_Aide & CRLF & " Installer ET telecharger la derniere version"
					Mess_Aide = Mess_Aide & CRLF & "   sys/ /update-get-install"
					Mess_Aide = Mess_Aide & CRLF
					Mess_Aide = Mess_Aide & CRLF & " Telecharger le release notes :"
					Mess_Aide = Mess_Aide & CRLF & "   SYS/ /update-news"
					Mess_Aide = Mess_Aide & CRLF & "  Defiler ligne par ligne avec la touche ESPACE et ECHAP"
					Mess_Aide = Mess_Aide & CRLF & "   SYS/ /update-news \#pause"
					Mess_Aide = Mess_Aide & CRLF
					Mess_Aide = Mess_Aide & CRLF & " Pour utiliser la branche 'Hot-release' ajouter 'HR' a la fin de la commande"
					Mess_Aide = Mess_Aide & CRLF & "   sys/ /update hr"
					Mess_Aide = Mess_Aide & CRLF & "   sys/ /update-get hr"
					Mess_Aide = Mess_Aide & CRLF & "   sys/ /update-get-install hr"
					Mess_Aide = Mess_Aide & CRLF & "  !! Attention ces version sont en phase de developpement donc pas terminees."
					Mess_Aide = Mess_Aide & CRLF & "  !! vous etes reponsable de votre machine."
					Mess_Aide = Mess_Aide & CRLF
					Mess_Aide = Mess_Aide & CRLF & " Changer votre Cpcdos network ID (Vous pouvez mettre 'anonymous'):"
					Mess_Aide = Mess_Aide & CRLF & "   sys/ /netid = MonPseudo"
					Mess_Aide = Mess_Aide & CRLF
					Mess_Aide = Mess_Aide & CRLF
					Mess_Aide = Mess_Aide & CRLF & "  Arreter le noyau :"
					Mess_Aide = Mess_Aide & CRLF & "   SYS/ /STOPK"
					Mess_Aide = Mess_Aide & CRLF
					Mess_Aide = Mess_Aide & CRLF & "  Arreter le systeme :"
					Mess_Aide = Mess_Aide & CRLF & "   SYS/ /ARRETER"
					Mess_Aide = Mess_Aide & CRLF
					Mess_Aide = Mess_Aide & CRLF & "  Redemarrer le systeme :"
					Mess_Aide = Mess_Aide & CRLF & "   SYS/ /REDEMARRER"
					Mess_Aide = Mess_Aide & CRLF
					Mess_Aide = Mess_Aide & CRLF & "  Mettre en veille :"
					Mess_Aide = Mess_Aide & CRLF & "   SYS/ /VEILLE"
					Mess_Aide = Mess_Aide & CRLF
					Mess_Aide = Mess_Aide & CRLF & "  Voir aussi : fix/ , ccp/"
					Mess_Aide = Mess_Aide & CRLF
				ELSEIF CPCDOS_INSTANCE.Utilisateur_Langage = 1 THEN
					Mess_Aide = Mess_Aide & CRLF & "  'SYStem'"
					Mess_Aide = Mess_Aide & CRLF
					Mess_Aide = Mess_Aide & CRLF & "  Fonctionnality :"
					Mess_Aide = Mess_Aide & CRLF & "   This command allow to setup system, or display system informations."
					Mess_Aide = Mess_Aide & CRLF
					Mess_Aide = Mess_Aide & CRLF & "   Display free memory / used (bytes, Kb, Mb, Gb)"
					Mess_Aide = Mess_Aide & CRLF & "     Display free memory in bytes"
					Mess_Aide = Mess_Aide & CRLF & "      sys/ /mem"
					Mess_Aide = Mess_Aide & CRLF & "     Display used memory in bytes"
					Mess_Aide = Mess_Aide & CRLF & "      sys/ /memu"
					Mess_Aide = Mess_Aide & CRLF & "     Display free memory in Mb"
					Mess_Aide = Mess_Aide & CRLF & "      sys/ /mem mb"
					Mess_Aide = Mess_Aide & CRLF & "     Display used memory in Mb"
					Mess_Aide = Mess_Aide & CRLF & "      sys/ /memu mb"
					Mess_Aide = Mess_Aide & CRLF & "     ... also with Gb Giga Bytes, To for Tera Bytes."
					' Mess_Aide = Mess_Aide & CRLF
					' Mess_Aide = Mess_Aide & CRLF & "   Change font"
					' Mess_Aide = Mess_Aide & CRLF & "     Sys/ /font Arial"
					' Mess_Aide = Mess_Aide & CRLF & "     sys/ /Font Comic Sans MS"
					' Mess_Aide = Mess_Aide & CRLF & "     sys/ /font Segoe Script"
					' Mess_Aide = Mess_Aide & CRLF & "    Enable/disable font manager"
					' Mess_Aide = Mess_Aide & CRLF & "     Sys/ /font /Enable"
					' Mess_Aide = Mess_Aide & CRLF & "     Sys/ /font /Disable"
					Mess_Aide = Mess_Aide & CRLF & "    "
					Mess_Aide = Mess_Aide & CRLF & "    Debug kernel. (Display all kernel activities)"
					Mess_Aide = Mess_Aide & CRLF & "      SYS/ /DEBUG {/CPINTICORE} {/SERVER:NoPort} = { 0, 1, 2, 3 }"
					Mess_Aide = Mess_Aide & CRLF
					Mess_Aide = Mess_Aide & CRLF & "      Exemples :"
					Mess_Aide = Mess_Aide & CRLF & "       Display all detailled kernel activities"
					Mess_Aide = Mess_Aide & CRLF & "        sys/ /debug = 1"
					Mess_Aide = Mess_Aide & CRLF & "       Write all detailled kernel activities on DEBUG.LOG file"
					Mess_Aide = Mess_Aide & CRLF & "        sys/ /debug = 2"
					Mess_Aide = Mess_Aide & CRLF & "       Display and Write all detailled kernel activities on DEBUG.LOG file"
					Mess_Aide = Mess_Aide & CRLF & "        sys/ /debug = 3"
					Mess_Aide = Mess_Aide & CRLF & "       Stop this"
					Mess_Aide = Mess_Aide & CRLF & "        sys/ /debug = 0"
					Mess_Aide = Mess_Aide & CRLF
					Mess_Aide = Mess_Aide & CRLF & "       Display CPinti Core activities"
					Mess_Aide = Mess_Aide & CRLF & "        sys/ /debug /CPintiCore = 1"
					Mess_Aide = Mess_Aide & CRLF & "       Stop this"
					Mess_Aide = Mess_Aide & CRLF & "        sys/ /debug /CPintiCore = 0"
					Mess_Aide = Mess_Aide & CRLF
					Mess_Aide = Mess_Aide & CRLF & "       Enable COM1 debogger with by default (9600,N,8,1)"
					Mess_Aide = Mess_Aide & CRLF & "        sys/ /debug /COM1 = 1"
					Mess_Aide = Mess_Aide & CRLF & "       IDEM but more precise infos 9600 bauds, No parity, 8 data bits, 1 stop bit"
					Mess_Aide = Mess_Aide & CRLF & "        sys/ /debug /COM1:9600,N,8,1"
					Mess_Aide = Mess_Aide & CRLF & "       Disable debugger by COM1"
					Mess_Aide = Mess_Aide & CRLF & "        sys/ /debug /COM1 = 0"
					Mess_Aide = Mess_Aide & CRLF & "    --> You can use COM1, COM2, COM3, COM4"
					Mess_Aide = Mess_Aide & CRLF
					Mess_Aide = Mess_Aide & CRLF & "       Display server informations (eg:23)"
					Mess_Aide = Mess_Aide & CRLF & "        sys/ /debug /Server:23 = 1"
					Mess_Aide = Mess_Aide & CRLF & "       Stop this"
					Mess_Aide = Mess_Aide & CRLF & "        sys/ /debug /Server:23 = 0"
					Mess_Aide = Mess_Aide & CRLF
					Mess_Aide = Mess_Aide & CRLF & "   Display actually screen resolution CONSOLE or GRAPHIC"
					Mess_Aide = Mess_Aide & CRLF & "    SYS/ /SCREEN"
					Mess_Aide = Mess_Aide & CRLF
					Mess_Aide = Mess_Aide & CRLF & "   Change screen resolution"
					Mess_Aide = Mess_Aide & CRLF & "    You can change in console OR graphic resolution"
					Mess_Aide = Mess_Aide & CRLF & "    CONSOLE: SYS/ /SCREEN Number"
					Mess_Aide = Mess_Aide & CRLF & "     Number:"
					Mess_Aide = Mess_Aide & CRLF & "      - 1  : 320x200 (CGA)"
					Mess_Aide = Mess_Aide & CRLF & "      - 2  : 640x200 (CGA)"
					Mess_Aide = Mess_Aide & CRLF & "      - 7  : 320x200 (EGA)"
					Mess_Aide = Mess_Aide & CRLF & "      - 8  : 640x200 (EGA)"
					Mess_Aide = Mess_Aide & CRLF & "      - 9  : 640x350 (EGA)"
					Mess_Aide = Mess_Aide & CRLF & "      - 11 : 640x480 (VGA)"
					Mess_Aide = Mess_Aide & CRLF & "      - 12 : 640x480 (VGA)"
					Mess_Aide = Mess_Aide & CRLF & "      - 13 : 320x200 (MCGA)"
					Mess_Aide = Mess_Aide & CRLF & "      - 14 : 320x240 (SVGA)"
					Mess_Aide = Mess_Aide & CRLF & "      - 15 : 400x300 (SVGA)"
					Mess_Aide = Mess_Aide & CRLF & "      - 16 : 512x384 (SVGA)"
					Mess_Aide = Mess_Aide & CRLF & "      - 17 : 640x400 (SVGA)"
					Mess_Aide = Mess_Aide & CRLF & "      - 18 : 640x480 (SVGA)"
					Mess_Aide = Mess_Aide & CRLF & "      - 19 : 800x600 (SVGA)"
					Mess_Aide = Mess_Aide & CRLF & "      - 20 : 1024x768 (SVGA)"
					Mess_Aide = Mess_Aide & CRLF & "      - 21 : 1280x1024 (SVGA)"
					Mess_Aide = Mess_Aide & CRLF & "    GRAPHIC:"
					Mess_Aide = Mess_Aide & CRLF & "      Example: SYS/ /SCREEN 800x600"
					Mess_Aide = Mess_Aide & CRLF
					Mess_Aide = Mess_Aide & CRLF & "   Display compatible list screen resolution"
					Mess_Aide = Mess_Aide & CRLF & "    This command must contain bit resolution number. 16, 24, 32 bits"
					Mess_Aide = Mess_Aide & CRLF & "     Examples :"
					Mess_Aide = Mess_Aide & CRLF & "      Display list screen resolution for 16 bits of colors"
					Mess_Aide = Mess_Aide & CRLF & "       SYS/ /SCREEN /LIST 16"
					Mess_Aide = Mess_Aide & CRLF & "      For 24 bits"
					Mess_Aide = Mess_Aide & CRLF & "       SYS/ /SCREEN /LIST 24"
					Mess_Aide = Mess_Aide & CRLF & "      And for 32 bits"
					Mess_Aide = Mess_Aide & CRLF & "       SYS/ /SCREEN /LIST 32"
					Mess_Aide = Mess_Aide & CRLF & "   Getting video screen pointer"
					Mess_Aide = Mess_Aide & CRLF & "    Sys/ /screen /ptr"
					Mess_Aide = Mess_Aide & CRLF & "   or in hexadecimal"
					Mess_Aide = Mess_Aide & CRLF & "    Sys/ /screen /hexaptr"
					Mess_Aide = Mess_Aide & CRLF
					Mess_Aide = Mess_Aide & CRLF & "   Using wrapper function (Experimental)"
					Mess_Aide = Mess_Aide & CRLF & "    This is reserved to Cpcdos SDK devlopper"
					Mess_Aide = Mess_Aide & CRLF & "    You must have your FunctionID!"
					Mess_Aide = Mess_Aide & CRLF & "    Examples :"
					Mess_Aide = Mess_Aide & CRLF & "	  For FunctionID '1234' :"
					Mess_Aide = Mess_Aide & CRLF & "      SYS/ /WRP 1234"
					Mess_Aide = Mess_Aide & CRLF
					Mess_Aide = Mess_Aide & CRLF & "   Get bitmap ARGB array ptr from handle number"
					Mess_Aide = Mess_Aide & CRLF & "     sys/ /bitmap /get /ptrbyhandle 123"
					Mess_Aide = Mess_Aide & CRLF & "   Getting bitmap ID from handle number"
					Mess_Aide = Mess_Aide & CRLF & "     sys/ /bitmap /get /idbyhandle 123"
					Mess_Aide = Mess_Aide & CRLF
					Mess_Aide = Mess_Aide & CRLF & "   Update OS list from OS.LST"
					Mess_Aide = Mess_Aide & CRLF & "     sys/ /os /update"
					Mess_Aide = Mess_Aide & CRLF
					Mess_Aide = Mess_Aide & CRLF & "   Display OS list avaiable"
					Mess_Aide = Mess_Aide & CRLF & "     sys/ /os /list"
					Mess_Aide = Mess_Aide & CRLF
					Mess_Aide = Mess_Aide & CRLF & "   Display number of OS"
					Mess_Aide = Mess_Aide & CRLF & "     sys/ /os /nb"
					Mess_Aide = Mess_Aide & CRLF
					Mess_Aide = Mess_Aide & CRLF
					Mess_Aide = Mess_Aide & CRLF & "   List variables in memory with visibility level"
					Mess_Aide = Mess_Aide & CRLF & "     sys/ /listvar 4"
					Mess_Aide = Mess_Aide & CRLF
					Mess_Aide = Mess_Aide & CRLF
					Mess_Aide = Mess_Aide & CRLF & "  Create a new process"
					Mess_Aide = Mess_Aide & CRLF & "   This will able to host your threads, code in another"
					Mess_Aide = Mess_Aide & CRLF & "   process that you have created"
					Mess_Aide = Mess_Aide & CRLF & "    sys/ /process NameOfYourProcess"
					Mess_Aide = Mess_Aide & CRLF & "     --> This command return the new PID number"
					Mess_Aide = Mess_Aide & CRLF
					Mess_Aide = Mess_Aide & CRLF
					Mess_Aide = Mess_Aide & CRLF & " Check new kernel update:"
					Mess_Aide = Mess_Aide & CRLF & "   SYS/ /update"
					Mess_Aide = Mess_Aide & CRLF
					Mess_Aide = Mess_Aide & CRLF & " Download new last version"
					Mess_Aide = Mess_Aide & CRLF & "   sys/ /update-get"
					Mess_Aide = Mess_Aide & CRLF
					Mess_Aide = Mess_Aide & CRLF & " Install downloaded version"
					Mess_Aide = Mess_Aide & CRLF & "   sys/ /update-install"
					Mess_Aide = Mess_Aide & CRLF
					Mess_Aide = Mess_Aide & CRLF & " Download AND install the la avaiable version"
					Mess_Aide = Mess_Aide & CRLF & "   sys/ /update-get-install"
					Mess_Aide = Mess_Aide & CRLF
					Mess_Aide = Mess_Aide & CRLF & " Download releases notes :"
					Mess_Aide = Mess_Aide & CRLF & "   SYS/ /update-news"
					Mess_Aide = Mess_Aide & CRLF & "  Display line per line ESPACE et ECHAP"
					Mess_Aide = Mess_Aide & CRLF & "   SYS/ /update-news \#pause"
					Mess_Aide = Mess_Aide & CRLF
					Mess_Aide = Mess_Aide & CRLF & " For use 'Hot-release' version, add 'HR' at the end line."
					Mess_Aide = Mess_Aide & CRLF & "   sys/ /update hr"
					Mess_Aide = Mess_Aide & CRLF & "   sys/ /update-get hr"
					Mess_Aide = Mess_Aide & CRLF & "   sys/ /update-get-install hr"
					Mess_Aide = Mess_Aide & CRLF & "  !! Warning, version in test & developpment,"
					Mess_Aide = Mess_Aide & CRLF & "  !! Vous are responsible of your machine."
					Mess_Aide = Mess_Aide & CRLF
					Mess_Aide = Mess_Aide & CRLF & " Change your cpcdos network ID (You can put 'anonymous'):"
					Mess_Aide = Mess_Aide & CRLF & "   sys/ /netid = MyName"
					Mess_Aide = Mess_Aide & CRLF
					Mess_Aide = Mess_Aide & CRLF & "  Stopping kernel :"
					Mess_Aide = Mess_Aide & CRLF & "   SYS/ /STOPK"
					Mess_Aide = Mess_Aide & CRLF
					Mess_Aide = Mess_Aide & CRLF & "  Shutdown system :"
					Mess_Aide = Mess_Aide & CRLF & "   SYS/ /SHUTDOWN"
					Mess_Aide = Mess_Aide & CRLF
					Mess_Aide = Mess_Aide & CRLF & "  Restart system :"
					Mess_Aide = Mess_Aide & CRLF & "   SYS/ /RESTART    or   SYS/ /REBOOT"
					Mess_Aide = Mess_Aide & CRLF
					Mess_Aide = Mess_Aide & CRLF & "  Put in stand-by mode :"
					Mess_Aide = Mess_Aide & CRLF & "   SYS/ /STANDBY"
					Mess_Aide = Mess_Aide & CRLF
					Mess_Aide = Mess_Aide & CRLF & "  See also : fix/ , ccp/"
					Mess_Aide = Mess_Aide & CRLF
				END IF
				DEBUG(Mess_Aide, Affichage, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_SURBRILLE, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.SansDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_AFF, RetourVAR)
				testCMD = 0
				AfficherAide = 0
				exit _scope_CMD, _scope
			END IF
			' Tester la syntaxe
			testCMD	= CCP_Verifier_Syntaxe(Commande, CommPosition)
			IF testCMD > 10 Then exit _scope_CMD, _scope
			IF testCMD > 0 then  ' Entre 1-5 = Pas d'affichage via le @, @$ ou @#
				IF testCMD < 6 then
					Affichage = 0
					IF testCMD = 3 Then CpcdosCP_SHELL("FIX/ " & CPCDOS_INSTANCE.DEBUG_INSTANCE.LeRetour & " = \#NULL", _CLE_, NIVEAU_CCP, Param_1, Param_2) : RetourVAR = _CLE_ & "N" & NIVEAU_CCP & "->" & CPCDOS_INSTANCE.DEBUG_INSTANCE.LeRetour
					if testCMD = 2 Then RetourVAR = "$>" & CPCDOS_INSTANCE.DEBUG_INSTANCE.LeRetour ' ajouter une securite ?
				Else
					Affichage = 1
				END IF
			Else
				Affichage = 1
			END IF
			' Recuperer les Parametres
			Param = MID(Commande, CommPosition + TailleComm + 2)
			SCOPE
			' ====================================================================

			IF Instr(UCASE(Param), "/LISTVAR") > 0 Then
				Dim Chaine as String

				IF Instr(UCASE(Param), "1") > 0 Then
					DEBUG("[KERNEL SHELL] For kernel developpers. Listing raw variables level 1 in memory..." , Affichage, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_ACTION, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.SansDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_AFF, RetourVAR)
					for b as integer = 0 to CPCDOS_INSTANCE.SHELLCCP_INSTANCE.MEMOIRE_CCP.CpcdosCP_Variable_MAXI
						Chaine = "[Index:" & b & "] level 1 : '" & CPCDOS_INSTANCE.SHELLCCP_INSTANCE.MEMOIRE_CCP.CpcdosCP_Variable_Niveau1_nom(b) & "' Data size:" & Len(CPCDOS_INSTANCE.SHELLCCP_INSTANCE.MEMOIRE_CCP.CpcdosCP_Variable_Niveau1_Donnees) & "."

						if NOT CPCDOS_INSTANCE.SHELLCCP_INSTANCE.MEMOIRE_CCP.CpcdosCP_Variable_Niveau1_nom(b) = "" Then
							DEBUG(Chaine, Affichage, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_Normal, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.SansDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_AFF, RetourVAR)
						End if
					Next b
					DEBUG("[KERNEL SHELL] End" , Affichage, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_ACTION, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.SansDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_AFF, RetourVAR)
				End if

				IF Instr(UCASE(Param), "2") > 0 Then
					DEBUG("[KERNEL SHELL] For kernel developpers. Listing raw variables level 2 in memory..." , Affichage, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_ACTION, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.SansDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_AFF, RetourVAR)
					for b as integer = 0 to CPCDOS_INSTANCE.SHELLCCP_INSTANCE.MEMOIRE_CCP.CpcdosCP_Variable_MAXI
						Chaine = "[Index:" & b & "] level 2 : '" & CPCDOS_INSTANCE.SHELLCCP_INSTANCE.MEMOIRE_CCP.CpcdosCP_Variable_Niveau2_nom(b) & "' Data size:" & Len(CPCDOS_INSTANCE.SHELLCCP_INSTANCE.MEMOIRE_CCP.CpcdosCP_Variable_Niveau2_Donnees) & "."

						if NOT CPCDOS_INSTANCE.SHELLCCP_INSTANCE.MEMOIRE_CCP.CpcdosCP_Variable_Niveau2_nom(b) = "" Then
							DEBUG(Chaine, Affichage, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_Normal, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.SansDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_AFF, RetourVAR)
						End if
					Next b
					DEBUG("[KERNEL SHELL] End" , Affichage, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_ACTION, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.SansDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_AFF, RetourVAR)
				End if

				IF Instr(UCASE(Param), "3") > 0 Then
					DEBUG("[KERNEL SHELL] For kernel developpers. Listing raw variables level 3 in memory..." , Affichage, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_ACTION, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.SansDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_AFF, RetourVAR)
					for b as integer = 0 to CPCDOS_INSTANCE.SHELLCCP_INSTANCE.MEMOIRE_CCP.CpcdosCP_Variable_MAXI
						Chaine = "[Index:" & b & "] level 3 : '" & CPCDOS_INSTANCE.SHELLCCP_INSTANCE.MEMOIRE_CCP.CpcdosCP_Variable_Niveau3_nom(b) & "' Data size:" & Len(CPCDOS_INSTANCE.SHELLCCP_INSTANCE.MEMOIRE_CCP.CpcdosCP_Variable_Niveau3_Donnees) & "."

						if NOT CPCDOS_INSTANCE.SHELLCCP_INSTANCE.MEMOIRE_CCP.CpcdosCP_Variable_Niveau3_nom(b) = "" Then
							DEBUG(Chaine, Affichage, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_Normal, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.SansDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_AFF, RetourVAR)
						End if
					Next b
					DEBUG("[KERNEL SHELL] End" , Affichage, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_ACTION, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.SansDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_AFF, RetourVAR)
				End if

				IF Instr(UCASE(Param), "4") > 0 Then
					DEBUG("[KERNEL SHELL] For kernel developpers. Listing raw variables level 4 in memory..." , Affichage, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_ACTION, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.SansDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_AFF, RetourVAR)
					for b as integer = 0 to CPCDOS_INSTANCE.SHELLCCP_INSTANCE.MEMOIRE_CCP.CpcdosCP_Variable_MAXI
						Chaine = "[Index:" & b & "] level 4 : '" & CPCDOS_INSTANCE.SHELLCCP_INSTANCE.MEMOIRE_CCP.CpcdosCP_Variable_Niveau4_nom(b) & "' Data size:" & Len(CPCDOS_INSTANCE.SHELLCCP_INSTANCE.MEMOIRE_CCP.CpcdosCP_Variable_Niveau4_Donnees) & "."

						if NOT CPCDOS_INSTANCE.SHELLCCP_INSTANCE.MEMOIRE_CCP.CpcdosCP_Variable_Niveau4_nom(b) = "" Then
							DEBUG(Chaine, Affichage, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_Normal, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.SansDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_AFF, RetourVAR)
						End if
					Next b
					DEBUG("[KERNEL SHELL] End" , Affichage, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_ACTION, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.SansDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_AFF, RetourVAR)
				End if

				IF Instr(UCASE(Param), "5") > 0 Then
					DEBUG("[KERNEL SHELL] For kernel developpers. Listing raw variables level 5 in memory..." , Affichage, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_ACTION, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.SansDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_AFF, RetourVAR)
					for b as integer = 0 to CPCDOS_INSTANCE.SHELLCCP_INSTANCE.MEMOIRE_CCP.CpcdosCP_Variable_MAXI
						Chaine = "[Index:" & b & "] level 5 : '" & CPCDOS_INSTANCE.SHELLCCP_INSTANCE.MEMOIRE_CCP.CpcdosCP_Variable_Niveau5_nom(b) & "' Data size:" & Len(CPCDOS_INSTANCE.SHELLCCP_INSTANCE.MEMOIRE_CCP.CpcdosCP_Variable_Niveau5_Donnees) & "."

						if NOT CPCDOS_INSTANCE.SHELLCCP_INSTANCE.MEMOIRE_CCP.CpcdosCP_Variable_Niveau5_nom(b) = "" Then
							DEBUG(Chaine, Affichage, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_Normal, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.SansDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_AFF, RetourVAR)
						End if
					Next b
					DEBUG("[KERNEL SHELL] End" , Affichage, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_ACTION, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.SansDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_AFF, RetourVAR)
				End if



			End if

			IF Instr(UCASE(Param), "/DEBUG") > 0 Then
				Dim aDBG_DEBUG 				as Integer
				Dim aDBG_DEBUG_SRVTCP 		as Integer

				IF Instr(UCASE(Param), "/SERVER") > 0 OR Instr(UCASE(Param), "/SERVEUR") > 0 Then
					aDBG_DEBUG_SRVTCP = -1
					IF Instr(UCASE(CPCDOS_INSTANCE.remplacer_Caractere(Param, " ", "")), "=1") > 0 Then aDBG_DEBUG_SRVTCP = 1
					IF Instr(UCASE(CPCDOS_INSTANCE.remplacer_Caractere(Param, " ", "")), "=0") > 0 Then aDBG_DEBUG_SRVTCP = 0
					' ** Idee : Donner possibilite de preciser le No de port ***
					IF Instr(UCASE(Param), ":TCP") > 0 Then
						' Affichage des activites du serveur TCP
						IF aDBG_DEBUG_SRVTCP = -1 Then
							DEBUG(STR(CPCDOS_INSTANCE.RESEAU_INSTANCE.DBG_DEBUG_SRVTCP(1)), Affichage, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_Normal, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.SansDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_AFF, RetourVAR)
						Else
							For Boucle_tcp_serveur as integer = 1 to 63
								CPCDOS_INSTANCE.RESEAU_INSTANCE.DBG_DEBUG_SRVTCP(Boucle_tcp_serveur) = aDBG_DEBUG_SRVTCP
							Next Boucle_tcp_serveur
						End if
						exit _scope_CMD, _scope
					ELSEIF Instr(UCASE(Param), ":FTP") > 0 Then
						' Affichage des activites du serveur FTP
						DEBUG("Serveur FTP non disponible sur cette version / FTP Server not avaiable on this version", Affichage, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_AVERTISSEMENT, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.SansDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_AFF, RetourVAR)
						exit _scope_CMD, _scope
					ELSEIF Instr(UCASE(Param), ":HTTP") > 0 Then
						' Affichage des activites du serveur FTP
						DEBUG("Serveur HTTP non disponible sur cette version / HTTP Server not avaiable on this version", Affichage, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_AVERTISSEMENT, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.SansDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_AFF, RetourVAR)
						exit _scope_CMD, _scope
					END IF
					Message_erreur = ERRAVT("ERR_007", 0)
					IF CPCDOS_INSTANCE.Utilisateur_Langage = 0 Then
						DEBUG("CpcdosC+ : Erreur ERR_007 " & Message_erreur & ". Specifier un protocole.", Affichage, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_AVERTISSEMENT, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.SansDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_AFF, RetourVAR)
					Else
						DEBUG("CpcdosC+ : Error ERR_007" & Message_erreur & ". Protocol name is missing.", Affichage, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_AVERTISSEMENT, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.SansDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_AFF, RetourVAR)
					End if
					exit _scope_CMD, _scope
				End if


'---------------------------------------------- Test_ecran_console --------------------------------------
				IF Instr(UCASE(Param), "/COM") > 0 Then
					Dim NomPort 	as String
					Dim IndexCom 	as Long


					' Initialiser la config des ports en memoire
					IF Instr(UCASE(Param), "/INIT") > 0 Then
						IF CPCDOS_INSTANCE.SYSTEME_INSTANCE.get_DBG_DEBUG() > 0 Then
							IF CPCDOS_INSTANCE.Utilisateur_Langage = 0 Then
								DEBUG("[SERIE/RS232] Initilisation de la configuration des ports COM... ", Affichage, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_ACTION, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.NoCRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.AvecDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_CPCDOS, RetourVAR)
							Else
								DEBUG("[SERIE/RS232] Initialization COM port configuration... ", Affichage, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_ACTION, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.NoCRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.AvecDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_CPCDOS, RetourVAR)
							End if
						End if

						' Incrire en memoire la configuration
						For Boucle as integer = 1 to 4
							CPCDOS_INSTANCE.SYSTEME_INSTANCE.COM_INSTANCE(Boucle).Port_COM_Connecte 		= FALSE
							CPCDOS_INSTANCE.SYSTEME_INSTANCE.COM_INSTANCE(Boucle).Port_COM 					= "COM" & Boucle
							CPCDOS_INSTANCE.SYSTEME_INSTANCE.COM_INSTANCE(Boucle).Port_COM_baud		 		= Val(CPCDOS_INSTANCE.SHELLCCP_INSTANCE.CCP_Lire_Variable("CPC_SYS.COM.BAUD[" & Boucle & "]", 5, _CLE_))
							CPCDOS_INSTANCE.SYSTEME_INSTANCE.COM_INSTANCE(Boucle).Port_COM_parity			= UCASE(CPCDOS_INSTANCE.SHELLCCP_INSTANCE.CCP_Lire_Variable("CPC_SYS.COM.PARITY[" & Boucle & "]", 5, _CLE_))
							CPCDOS_INSTANCE.SYSTEME_INSTANCE.COM_INSTANCE(Boucle).Port_COM_bit_data	 		= Val(CPCDOS_INSTANCE.SHELLCCP_INSTANCE.CCP_Lire_Variable("CPC_SYS.COM.BIT_DATA[" & Boucle & "]", 5, _CLE_))
							CPCDOS_INSTANCE.SYSTEME_INSTANCE.COM_INSTANCE(Boucle).Port_COM_bit_stop	 		= Val(CPCDOS_INSTANCE.SHELLCCP_INSTANCE.CCP_Lire_Variable("CPC_SYS.COM.BIT_STOP[" & Boucle & "]", 5, _CLE_))
							CPCDOS_INSTANCE.SYSTEME_INSTANCE.COM_INSTANCE(Boucle).Port_COM_KeyID		 	= 0
							CPCDOS_INSTANCE.SYSTEME_INSTANCE.COM_INSTANCE(Boucle).Port_COM_IRQ				= UCASE(CPCDOS_INSTANCE.SHELLCCP_INSTANCE.CCP_Lire_Variable("CPC_SYS.COM.IRQ[" & Boucle & "]", 5, _CLE_))
							CPCDOS_INSTANCE.SYSTEME_INSTANCE.COM_INSTANCE(Boucle).Port_COM_IO				= CPCDOS_INSTANCE.SHELLCCP_INSTANCE.CCP_Lire_Variable("CPC_SYS.COM.IO[" & Boucle & "]", 5, _CLE_)
							CPCDOS_INSTANCE.SYSTEME_INSTANCE.COM_INSTANCE(Boucle).Port_COM_TAG				= Ucase(CPCDOS_INSTANCE.SHELLCCP_INSTANCE.CCP_Lire_Variable("CPC_SYS.COM.TAG[" & Boucle & "]", 5, _CLE_))
						Next Boucle


						IF CPCDOS_INSTANCE.SYSTEME_INSTANCE.get_DBG_DEBUG() > 0 Then
							IF CPCDOS_INSTANCE.Utilisateur_Langage = 0 Then
								DEBUG("[OK]", Affichage, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_OK, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.SansDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_CPCDOS, RetourVAR)
							Else
								DEBUG("[OK]", Affichage, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_OK, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.SansDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_CPCDOS, RetourVAR)
							End if
						End if
					End if

					IF Instr(UCASE(Param), "/COM1") > 0 Then NomPort = "COM1" : IndexCom = 1
					IF Instr(UCASE(Param), "/COM2") > 0 Then NomPort = "COM2" : IndexCom = 2
					IF Instr(UCASE(Param), "/COM3") > 0 Then NomPort = "COM3" : IndexCom = 3
					IF Instr(UCASE(Param), "/COM4") > 0 Then NomPort = "COM4" : IndexCom = 4


					IF NomPort = "" Then
						' Checker la liste des port COM
						For Boucle as integer = 1 to 8
							if NOT CPCDOS_INSTANCE.SYSTEME_INSTANCE.COM_INSTANCE(boucle).Port_COM_IRQ = "" Then
								Dim Est_Ouvert as String = "closed"

								' Si c'est connecte
								if CPCDOS_INSTANCE.SYSTEME_INSTANCE.COM_INSTANCE(boucle).Port_COM_Connecte = TRUE Then Est_Ouvert = "Opened by KeyID " & CPCDOS_INSTANCE.SYSTEME_INSTANCE.COM_INSTANCE(boucle).Port_COM_KeyID

								' Afficher la liste des ports COM
								DEBUG(Boucle & " : " & CPCDOS_INSTANCE.SYSTEME_INSTANCE.COM_INSTANCE(boucle).Port_COM _
										& " Baud:" & CPCDOS_INSTANCE.SYSTEME_INSTANCE.COM_INSTANCE(boucle).Port_COM_baud _
										& " data:" & CPCDOS_INSTANCE.SYSTEME_INSTANCE.COM_INSTANCE(boucle).Port_COM_bit_data _
										& " stop:" & CPCDOS_INSTANCE.SYSTEME_INSTANCE.COM_INSTANCE(boucle).Port_COM_bit_stop _
										& " parity:" & CPCDOS_INSTANCE.SYSTEME_INSTANCE.COM_INSTANCE(boucle).Port_COM_parity _
										& " IO:" & CPCDOS_INSTANCE.SYSTEME_INSTANCE.COM_INSTANCE(boucle).Port_COM_IO _
										& " IRQ:" & CPCDOS_INSTANCE.SYSTEME_INSTANCE.COM_INSTANCE(boucle).Port_COM_IRQ _
										& " " & Est_Ouvert _
										& " '" & CPCDOS_INSTANCE.SYSTEME_INSTANCE.COM_INSTANCE(boucle).Port_COM_TAG & "'"_
										, Affichage, CPCDOS_INSTANCE.DEBUG_INSTANCE.Log, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_SURBRILLE, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.SansDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_AFF, RetourVAR)
							End if
						Next Boucle
						exit _scope_CMD, _scope
					Else
						' Fermer un port com
						IF Instr(UCASE(CPCDOS_INSTANCE.remplacer_Caractere(Param, " ", "")), "=0") > 0 Then

							IF CPCDOS_INSTANCE.SYSTEME_INSTANCE.get_DBG_DEBUG() > 0 Then
								IF CPCDOS_INSTANCE.Utilisateur_Langage = 0 Then
									DEBUG("[SERIE/RS232] Fermeture du port '" & NomPort & "' ..." , Affichage, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_ACTION, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.NoCRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.AvecDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_CPCDOS, RetourVAR)
								Else
									DEBUG("[SERIE/RS232] Closing port '" & NomPort & "' ... ", Affichage, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_ACTION, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.NoCRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.AvecDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_CPCDOS, RetourVAR)
								End if
							END IF

							' Verifier si le port est ouvert
							IF CPCDOS_INSTANCE.SYSTEME_INSTANCE.COM_INSTANCE(IndexCom).Port_COM_Connecte 	= TRUE Then

								' Si le port est ouvert, alors on reset le tout
								CPCDOS_INSTANCE.SYSTEME_INSTANCE.COM_INSTANCE(IndexCom).Port_COM_Connecte 		= FALSE
								CPCDOS_INSTANCE.SYSTEME_INSTANCE.COM_INSTANCE(IndexCom).Port_COM_baud		 	= 0
								CPCDOS_INSTANCE.SYSTEME_INSTANCE.COM_INSTANCE(IndexCom).Port_COM_parity			= ""
								CPCDOS_INSTANCE.SYSTEME_INSTANCE.COM_INSTANCE(IndexCom).Port_COM_bit_data	 	= 0
								CPCDOS_INSTANCE.SYSTEME_INSTANCE.COM_INSTANCE(IndexCom).Port_COM_bit_stop	 	= 0
								CPCDOS_INSTANCE.SYSTEME_INSTANCE.COM_INSTANCE(IndexCom).Port_COM_KeyID		 	= 0

								' Et on ferme le port
								Close #IndexCom

								IF CPCDOS_INSTANCE.SYSTEME_INSTANCE.get_DBG_DEBUG() > 0 Then
									IF CPCDOS_INSTANCE.Utilisateur_Langage = 0 Then
										DEBUG("[OK] Port '" & NomPort & "' ferme !", Affichage, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_VALIDATION, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.SansDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_CPCDOS, RetourVAR)
									Else
										DEBUG("[OK] Port '" & NomPort & "' closed !", Affichage, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_VALIDATION, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.SansDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_CPCDOS, RetourVAR)
									End if
								END IF
							Else
								' Avertissement, port deja ferme
								Message_erreur = ERRAVT("AVT_075", 0)
								IF CPCDOS_INSTANCE.Utilisateur_Langage = 0 Then
									DEBUG("[ERREUR] : " & Message_erreur & ".", Affichage, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_AVERTISSEMENT, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.SansDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_AFF, RetourVAR)
								Else
									DEBUG("[ERROR] : " & Message_erreur & ".", Affichage, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_AVERTISSEMENT, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.SansDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_AFF, RetourVAR)
								End if
							End if
						ElseIF Instr(UCASE(CPCDOS_INSTANCE.remplacer_Caractere(Param, " ", "")), "=1") > 0 OR Instr(UCASE(CPCDOS_INSTANCE.remplacer_Caractere(Param, " ", "")), "=2") > 0 Then
							' Ouvrir le port avec les parametres par defauts

							IF Instr(UCASE(CPCDOS_INSTANCE.remplacer_Caractere(Param, " ", "")), "=1") > 0 Then
								IF CPCDOS_INSTANCE.SYSTEME_INSTANCE.get_DBG_DEBUG() > 0 Then
									IF CPCDOS_INSTANCE.Utilisateur_Langage = 0 Then
										DEBUG("[SERIE/RS232] Ouverture du port '" & NomPort & "' en mode lecture ... ", Affichage, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_ACTION, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.NoCRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.AvecDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_CPCDOS, RetourVAR)
									Else
										DEBUG("[SERIE/RS232] Opening port '" & NomPort & "' in reading mode... ", Affichage, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_ACTION, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.NoCRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.AvecDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_CPCDOS, RetourVAR)
									End if
								END IF
								CPCDOS_INSTANCE.SYSTEME_INSTANCE.COM_INSTANCE(IndexCom).Port_COM_ecriture = FALSE
							Else
								IF CPCDOS_INSTANCE.SYSTEME_INSTANCE.get_DBG_DEBUG() > 0 Then
									IF CPCDOS_INSTANCE.Utilisateur_Langage = 0 Then
										DEBUG("[SERIE/RS232] Ouverture du port '" & NomPort & "' in reading and writing mode... ", Affichage, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_ACTION, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.NoCRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.AvecDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_CPCDOS, RetourVAR)
									Else
										DEBUG("[SERIE/RS232] Opening port '" & NomPort & "' in reading and writing mode... ", Affichage, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_ACTION, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.NoCRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.AvecDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_CPCDOS, RetourVAR)
									End if
								END IF
								CPCDOS_INSTANCE.SYSTEME_INSTANCE.COM_INSTANCE(IndexCom).Port_COM_ecriture = TRUE
							End if

							IF CPCDOS_INSTANCE.SYSTEME_INSTANCE.COM_INSTANCE(IndexCom).Port_COM_Connecte 	= FALSE Then
								Dim Resultat as long
								Dim com_BAUD 		as integer = Val(CPCDOS_INSTANCE.SHELLCCP_INSTANCE.CCP_Lire_Variable("CPC_SYS.COM.BAUD[" & IndexCom & "]", 5, _CLE_))
								Dim com_BIT_DATA 	as integer = Val(CPCDOS_INSTANCE.SHELLCCP_INSTANCE.CCP_Lire_Variable("CPC_SYS.COM.BIT_DATA[" & IndexCom & "]", 5, _CLE_))
								Dim com_BIT_STOP 	as integer = Val(CPCDOS_INSTANCE.SHELLCCP_INSTANCE.CCP_Lire_Variable("CPC_SYS.COM.BIT_STOP[" & IndexCom & "]", 5, _CLE_))
								Dim com_KEYID 		as double = 1 '_CLE_ 1:DEBOGGEUR
								Dim com_TAG			as String = UCASE(CPCDOS_INSTANCE.SHELLCCP_INSTANCE.CCP_Lire_Variable("CPC_SYS.COM.TAG[" & IndexCom & "]", 5, _CLE_))
								Dim com_PARITY 		as String = UCASE(CPCDOS_INSTANCE.SHELLCCP_INSTANCE.CCP_Lire_Variable("CPC_SYS.COM.PARITY[" & IndexCom & "]", 5, _CLE_))

								' Si le port est ferme alors on reconfigure le tout
								CPCDOS_INSTANCE.SYSTEME_INSTANCE.COM_INSTANCE(IndexCom).Port_COM_Connecte	= TRUE
								CPCDOS_INSTANCE.SYSTEME_INSTANCE.COM_INSTANCE(IndexCom).Port_COM_baud	 	= com_BAUD
								CPCDOS_INSTANCE.SYSTEME_INSTANCE.COM_INSTANCE(IndexCom).Port_COM_parity 	= com_PARITY
								CPCDOS_INSTANCE.SYSTEME_INSTANCE.COM_INSTANCE(IndexCom).Port_COM_bit_data 	= com_BIT_DATA
								CPCDOS_INSTANCE.SYSTEME_INSTANCE.COM_INSTANCE(IndexCom).Port_COM_bit_stop 	= com_BIT_STOP
								CPCDOS_INSTANCE.SYSTEME_INSTANCE.COM_INSTANCE(IndexCom).Port_COM_KeyID 		= com_KEYID


								' Ouverture du port COM
								Resultat = Open Com(NomPort & ":" & com_BAUD & "," & com_PARITY & "," & com_BIT_DATA & "," & com_BIT_STOP, as #IndexCom)

								' Ouverture impossible
								if Resultat = 0 Then
									IF CPCDOS_INSTANCE.SYSTEME_INSTANCE.get_DBG_DEBUG() > 0 Then
										IF CPCDOS_INSTANCE.Utilisateur_Langage = 0 Then
											DEBUG("[OK]", Affichage, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_VALIDATION, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.SansDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_CPCDOS, RetourVAR)
										Else
											DEBUG("[OK]", Affichage, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_VALIDATION, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.SansDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_CPCDOS, RetourVAR)
										End if
									END IF
								Else
									Message_erreur = ERRAVT("AVT_076", 0)
									IF CPCDOS_INSTANCE.Utilisateur_Langage = 0 Then
										DEBUG("[ERREUR] : " & Message_erreur & ". Numero d'erreur : " & Resultat & ".", Affichage, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_AVERTISSEMENT, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.SansDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_AFF, RetourVAR)
									Else
										DEBUG("[ERROR] : " & Message_erreur & ". Error number  " & Resultat & ".", Affichage, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_AVERTISSEMENT, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.SansDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_AFF, RetourVAR)
									End if
									CPCDOS_INSTANCE.SYSTEME_INSTANCE.COM_INSTANCE(IndexCom).Port_COM_Connecte = FALSE
								End if
							Else
								' Avertissment port deja ouvert
								Message_erreur = ERRAVT("AVT_074", 0)
								IF CPCDOS_INSTANCE.Utilisateur_Langage = 0 Then
									DEBUG("[ERREUR] : " & Message_erreur & ".", Affichage, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_AVERTISSEMENT, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.SansDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_AFF, RetourVAR)
								Else
									DEBUG("[ERROR] : " & Message_erreur & ".", Affichage, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_AVERTISSEMENT, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.SansDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_AFF, RetourVAR)
								End if
							End if
						End if
					End if ' COM1, COM2, COM3, COM4
				End if ' /COM

				IF Instr(UCASE(Param), "/MENU") > 0 Then
					Dim aCPinti_MENU as boolean = CPCDOS_INSTANCE.CONSOLE_INSTANCE.CPinti_MENU
					IF Instr(UCASE(CPCDOS_INSTANCE.remplacer_Caractere(Param, " ", "")), "=1") > 0 Then CPCDOS_INSTANCE.CONSOLE_INSTANCE.CPinti_MENU = TRUE
					IF Instr(UCASE(CPCDOS_INSTANCE.remplacer_Caractere(Param, " ", "")), "=0") > 0 Then CPCDOS_INSTANCE.CONSOLE_INSTANCE.CPinti_MENU = FALSE
					IF CPCDOS_INSTANCE.CONSOLE_INSTANCE.CPinti_DebugMode = -1 then ' Si on met rien alors on affiche la valeur en cours
						CPCDOS_INSTANCE.CONSOLE_INSTANCE.CPinti_MENU = aCPinti_MENU
						DEBUG(str(CPCDOS_INSTANCE.CONSOLE_INSTANCE.CPinti_MENU), Affichage, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_Normal, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.SansDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_AFF, RetourVAR)
					End if
					exit _scope_CMD, _scope
				End if
				IF Instr(UCASE(Param), "/CPINTICORE") > 0 Then
					Dim aCPinti_DebugMode as integer = CPCDOS_INSTANCE.CONSOLE_INSTANCE.CPinti_DebugMode
					CPCDOS_INSTANCE.CONSOLE_INSTANCE.CPinti_DebugMode = -1
					IF Instr(UCASE(CPCDOS_INSTANCE.remplacer_Caractere(Param, " ", "")), "=2") > 0 Then CPCDOS_INSTANCE.CONSOLE_INSTANCE.CPinti_DebugMode = 2' : Screen 0
					IF Instr(UCASE(CPCDOS_INSTANCE.remplacer_Caractere(Param, " ", "")), "=1") > 0 Then CPCDOS_INSTANCE.CONSOLE_INSTANCE.CPinti_DebugMode = 1' : Screen 0
					IF Instr(UCASE(CPCDOS_INSTANCE.remplacer_Caractere(Param, " ", "")), "=0") > 0 Then CPCDOS_INSTANCE.CONSOLE_INSTANCE.CPinti_DebugMode = 0' : Test_ecran_console(1)
					IF CPCDOS_INSTANCE.CONSOLE_INSTANCE.CPinti_DebugMode = -1 then
						CPCDOS_INSTANCE.CONSOLE_INSTANCE.CPinti_DebugMode = aCPinti_DebugMode
						DEBUG(str(CPCDOS_INSTANCE.CONSOLE_INSTANCE.CPinti_DebugMode), Affichage, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_Normal, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.SansDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_AFF, RetourVAR)
					else
						if CPCDOS_INSTANCE.CONSOLE_INSTANCE.CPinti_DebugMode = 2 then ' Mode CPinti Core sans avoir le debug!
							CPCDOS_INSTANCE.CONSOLE_INSTANCE.CPinti_DebugMode = 2
							CPCDOS_INSTANCE.SYSTEME_INSTANCE.set_CPINTI_DEBUG(0)
						else
							CPCDOS_INSTANCE.SYSTEME_INSTANCE.set_CPINTI_DEBUG(1)
						end if
					End if
					IF CPCDOS_INSTANCE.CONSOLE_INSTANCE.CPinti_DebugMode = 1 Then
						CPCDOS_INSTANCE.SYSTEME_INSTANCE.set_CPINTI_DEBUG(1)
						If CPCDOS_INSTANCE.Utilisateur_Langage = 0 then
							DEBUG(" --> Mode debogeur 'CPinti Core' active", Affichage, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_Normal, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.AvecDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_AFF, RetourVAR)
						else
							DEBUG(" --> 'CPinti core' debogger mode enabled", Affichage, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_Normal, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.AvecDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_AFF, RetourVAR)
						End if
					Elseif CPCDOS_INSTANCE.CONSOLE_INSTANCE.CPinti_DebugMode = 0 then
						' CPCDOS_INSTANCE.NOGUI = FALSE
						CPCDOS_INSTANCE.SYSTEME_INSTANCE.set_CPINTI_DEBUG(0)
						If CPCDOS_INSTANCE.Utilisateur_Langage = 0 then
							DEBUG(" --> Mode debogeur 'CPinti Core' desactive", Affichage, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_Normal, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.AvecDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_AFF, RetourVAR)
						else
							DEBUG(" --> 'CPinti core' debogger mode disable", Affichage, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_Normal, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.AvecDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_AFF, RetourVAR)
						End if
					End if
					exit _scope_CMD, _scope
				END IF

				Dim aDebugMode as integer = CPCDOS_INSTANCE.SYSTEME_INSTANCE.get_DBG_DEBUG()
				CPCDOS_INSTANCE.SYSTEME_INSTANCE.set_DBG_DEBUG(-1)
				IF Instr(UCASE(CPCDOS_INSTANCE.remplacer_Caractere(Param, " ", "")), "=0") > 0 Then CPCDOS_INSTANCE.SYSTEME_INSTANCE.set_DBG_DEBUG(0)
				IF Instr(UCASE(CPCDOS_INSTANCE.remplacer_Caractere(Param, " ", "")), "=1") > 0 Then CPCDOS_INSTANCE.SYSTEME_INSTANCE.set_DBG_DEBUG(1)
				IF Instr(UCASE(CPCDOS_INSTANCE.remplacer_Caractere(Param, " ", "")), "=2") > 0 Then CPCDOS_INSTANCE.SYSTEME_INSTANCE.set_DBG_DEBUG(2)
				IF Instr(UCASE(CPCDOS_INSTANCE.remplacer_Caractere(Param, " ", "")), "=3") > 0 Then CPCDOS_INSTANCE.SYSTEME_INSTANCE.set_DBG_DEBUG(3)
				IF CPCDOS_INSTANCE.SYSTEME_INSTANCE.get_DBG_DEBUG() = -1 then
					CPCDOS_INSTANCE.SYSTEME_INSTANCE.set_DBG_DEBUG(aDebugMode)
					DEBUG(str(CPCDOS_INSTANCE.SYSTEME_INSTANCE.get_DBG_DEBUG()), Affichage, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_Normal, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.SansDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_AFF, RetourVAR)
				End if
				exit _scope_CMD, _scope
			END IF

			IF Instr(UCASE(Param), "/BITMAP") > 0 Then

				IF Instr(UCASE(Param), "/GC") > 0 OR Instr(UCASE(Param), "/GARBAGECOLLECTOR") > 0 Then

					' Rechercher les bitmaps non r�f�rences en memoire
					Dim Resultat as String = CPCDOS_INSTANCE.SYSTEME_INSTANCE.Memoire_MAP.GarbageCollector()

					IF NOT Resultat = "" Then
						DEBUG("[OK] -> " & Resultat, Affichage, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_VALIDATION, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.SansDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_AFF, RetourVAR)
					Else
						DEBUG("0", Affichage, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_ERREUR, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.SansDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_AFF, RetourVAR)
					End if

				ElseIF Instr(UCASE(Param), "/RECHARGER") > 0 OR Instr(UCASE(Param), "/RELOAD") > 0 Then

					' Recharger les bitmap depuis les flags "FILE"
					IF CPCDOS_INSTANCE.SYSTEME_INSTANCE.Memoire_MAP.Auto_Reload_FILE() = TRUE Then
						DEBUG("OK", Affichage, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_VALIDATION, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.SansDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_AFF, RetourVAR)
					Else
						DEBUG("ERROR", Affichage, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_ERREUR, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.SansDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_AFF, RetourVAR)
					End if

				ElseIf Instr(UCASE(Param), "/LIST") > 0 OR Instr(UCASE(Param), "/LISTE") > 0 Then

					' Lister les bitmap en memoire (id, handle, nom, offset...)
					DEBUG(CPCDOS_INSTANCE.SYSTEME_INSTANCE.Memoire_MAP.Recuperer_BITMAP_Liste(), Affichage, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_VALIDATION, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.SansDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_AFF, RetourVAR)

				ElseIF Instr(UCASE(Param), "/TAILLE") > 0 OR Instr(UCASE(Param), "/SIZE") > 0 Then

					' Recuperer la taille total de la memoire BITMAP
					DEBUG(str(CPCDOS_INSTANCE.SYSTEME_INSTANCE.Memoire_MAP.Recuperer_BITMAP_Taille()), Affichage, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_Normal, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.SansDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_AFF, RetourVAR)
				ElseIF Instr(UCASE(Param), "/OBTENIR") > 0 OR Instr(UCASE(Param), "/GET") > 0 Then
					If Instr(UCASE(Param), "/PTRBYHANDLE") > 0 Then
						Dim NumeroHandle as integer = Val(Mid(Param, instr(Ucase(Param), "/PTRBYHANDLE") + 13))
						DEBUG("0x" & hex(CPCDOS_INSTANCE.SYSTEME_INSTANCE.Memoire_MAP.Recuperer_BITMAP_ptr_by_Handle(NumeroHandle), 8), Affichage, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_Normal, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.SansDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_AFF, RetourVAR)
					ElseIf Instr(UCASE(Param), "/IDBYHANDLE") > 0 Then
						Dim NumeroHandle as integer = Val(Mid(Param, instr(Ucase(Param), "/IDBYHANDLE") + 12))
						DEBUG(str(CPCDOS_INSTANCE.SYSTEME_INSTANCE.Memoire_MAP.Recuperer_BITMAP_id_by_Handle(NumeroHandle)), Affichage, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_Normal, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.SansDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_AFF, RetourVAR)
					End if
				Else
					' Autrement, simplement afficher le nombre de bitmap en memoire
					DEBUG(CPCDOS_INSTANCE.SYSTEME_INSTANCE.Memoire_MAP.Recuperer_BITMAP_Nombre() & " bitmap(s)", Affichage, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_Normal, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.SansDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_AFF, RetourVAR)
				End if
			End if




			Dim PosParam1 as integer = 0
			' Changer la police d'ecriture du systeme
			IF Instr(UCASE(Param), "/FONT") > 0 Then
				PosParam1 = Instr(UCASE(Param), "/FONT") + 6
			END IF

			IF Instr(UCASE(Param), "/POLICE") > 0 OR PosParam1 > 0 Then

				' Si la version anglaise n'est pas definie
				IF PosParam1 = 0 Then PosParam1 = Instr(UCASE(Param), "/POLICE") + 8

				Dim ListerLesPolices		as Integer

				Dim NomPolice				as String
				Dim Buffer_POLICE_COPIE 	as String
				Dim buff_NomPolice			as String
				Dim buff_REPPolice			as String
				Dim Pos_CRLF 				as Integer = 0
				Dim Pos_EGALE 				as Integer = 0

				' IF Instr(UCASE(Param), "/DESACTIVER") > 0 Then
					' DEBUG("", Affichage, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_Normal, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.SansDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_AFF, RetourVAR)
					' DEBUG("", Affichage, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_Normal, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.SansDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_AFF, RetourVAR)
					' ' CPCDOS_INSTANCE.utf_actif = -1
					' IF CPCDOS_INSTANCE.SYSTEME_INSTANCE.get_DBG_DEBUG() > 0 Then
						' IF CPCDOS_INSTANCE.Utilisateur_Langage = 0 Then
							' DEBUG("[CpcdosC+] Gestionnaire de polices desactiv�", Affichage, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_Normal, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.AvecDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_CPCDOS, RetourVAR) : exit _scope_CMD, _scope
						' Else
							' DEBUG("[CpcdosC+] Font manager disable", Affichage, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_Normal, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.AvecDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_CPCDOS, RetourVAR) : exit _scope_CMD, _scope
						' End if
					' END IF
				' END IF
				' IF Instr(UCASE(Param), "/DISABLE") > 0 Then
					' ' utf_actif = -1
					' IF CPCDOS_INSTANCE.SYSTEME_INSTANCE.get_DBG_DEBUG() > 0 Then
						' IF CPCDOS_INSTANCE.Utilisateur_Langage = 0 Then
							' DEBUG("[CpcdosC+] Gestionnaire de polices deactiv�", Affichage, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_Normal, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.AvecDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_CPCDOS, RetourVAR) : exit _scope_CMD, _scope
						' Else
							' DEBUG("[CpcdosC+] Font manager disable", Affichage, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_Normal, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.AvecDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_CPCDOS, RetourVAR) : exit _scope_CMD, _scope
						' End if
					' END IF
				' End if
				' IF Instr(UCASE(Param), "/ACTIVER") > 0 Then
					' ' utf_actif = 1
					' IF CPCDOS_INSTANCE.SYSTEME_INSTANCE.get_DBG_DEBUG() > 0 Then
						' IF CPCDOS_INSTANCE.Utilisateur_Langage = 0 Then
							' DEBUG("[CpcdosC+] Gestionnaire de polices activ�", Affichage, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_Normal, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.AvecDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_CPCDOS, RetourVAR) : exit _scope_CMD, _scope
						' Else
							' DEBUG("[CpcdosC+] Font manager enable", Affichage, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_Normal, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.AvecDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_AFF, RetourVAR) : exit _scope_CMD, _scope
						' End if
					' End if
				' End if
				' IF Instr(UCASE(Param), "/ENABLE") > 0 Then
					' ' utf_actif = 1
					' IF CPCDOS_INSTANCE.SYSTEME_INSTANCE.get_DBG_DEBUG() > 0 Then
						' IF CPCDOS_INSTANCE.Utilisateur_Langage = 0 Then
							' DEBUG("[CpcdosC+] Gestionnaire de polices activ�", Affichage, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_Normal, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.AvecDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_CPCDOS, RetourVAR) : exit _scope_CMD, _scope
						' Else
							' DEBUG("[CpcdosC+] Font manager enable", Affichage, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_Normal, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.AvecDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_AFF, RetourVAR) : exit _scope_CMD, _scope
						' End if
					' End if
				' End if
				' ' IF utf_actif = 0 Then
					' ' Message_erreur = ERRAVT("AVT_054", 0)
					' ' DEBUG("[CpcdosC+] " & Message_erreur, Affichage, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_AVERTISSEMENT, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.SansDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_AFF, RetourVAR)
					' ' exit _scope_CMD, _scope
				' ' Elseif utf_actif = -1 then
					' ' utf_actif = 0
				' ' End if
				' IF Instr(UCASE(Param), "/LIST") > 0 Then ListerLesPolices = 1
				' IF Instr(UCASE(Param), "/LISTE") > 0 Then ListerLesPolices = 1

				' IF ListerLesPolices = 1 Then
					' IF CPCDOS_INSTANCE.Utilisateur_Langage = 0 Then
						' DEBUG(" Liste des polices install�es  ", Affichage, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_Normal, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.NoCRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.SansDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_AFF, RetourVAR)
					' else
						' DEBUG(" List installed fonts  ", Affichage, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_Normal, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.NoCRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.SansDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_AFF, RetourVAR)
					' End if
				' End if
				' NomPolice = UCASE(MID(Param, PosParam1))
				' Pos_CRLF = 1
				' ' Lire le fichier de configuration des polices pour chercher si elle existe
				' IF CPCDOS_INSTANCE.SYSTEME_INSTANCE.get_DBG_DEBUG() > 0 Then
					' IF CPCDOS_INSTANCE.Utilisateur_Langage = 0 Then
						' DEBUG("[CpcdosC+][CPinti] Appel de l'instance de lecture de fichiers complet depuis FONTS\INDEX.CFG mode:r", Affichage, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_Normal, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.AvecDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_CPCDOS, RetourVAR)
					' Else
						' DEBUG("[CpcdosC+][CPinti] Calling complet file reader instance of FONTS\INDEX.CFG mode:rb", Affichage, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_Normal, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.AvecDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_CPCDOS, RetourVAR)
					' End If
				' End if
				' Dim TailleRetourCHR as integer
				' Dim POLICE_FICHIER_instance as cpinti.cpinti_core
				' ' Recuperer la taille d fichier

				' ' Dim Taille_Du_Fichier as integer = POLICE_FICHIER_instance.CPinti_Taille_Fichier(AllouerString(Param))

				' ' Creation d'un nouveau pointeur
				' Dim Buffer_POLICE as Zstring ptr
				' Buffer_POLICE = Allocate(Taille_Du_Fichier)

				' dim Resultat as integer
				' ' Resultat = POLICE_FICHIER_instance.cpinti_Lire_Fichier_complet(AllouerString("FONTS\INDEX.CFG"), AllouerString("RB"), Buffer_POLICE)

				' IF CPCDOS_INSTANCE.SYSTEME_INSTANCE.get_DBG_DEBUG() > 0 Then
					' IF CPCDOS_INSTANCE.Utilisateur_Langage = 0 Then
						' DEBUG(" - offset depart 0x" & Hex(Buffer_POLICE, 32) & " fin + 0x" & Hex(TailleString(*Buffer_POLICE), 32) & " (" & TailleString(*Buffer_POLICE) & " octets)", Affichage, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_VALIDATION, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.SansDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_CPCDOS, RetourVAR)
					' Else
						' DEBUG(" - offset begin 0x" & Hex(Buffer_POLICE, 32) & " end + 0x" & Hex(TailleString(*Buffer_POLICE), 32) & " (" & TailleString(*Buffer_POLICE) & " bytes", Affichage, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_VALIDATION, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.SansDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_CPCDOS, RetourVAR)
					' End If
				' End if
				' Buffer_POLICE_COPIE = UCASE(*Buffer_POLICE)
				' While((TailleString(Buffer_POLICE_COPIE) > 0)) ' On chercher dans le fichier index.cfg les polices dispo
					' ' Position du "="
					' Pos_EGALE = Instr(Buffer_POLICE_COPIE, "=")
					' ' Recupere le nom de police
					' buff_NomPolice = MID(Buffer_POLICE_COPIE, 1, (Pos_EGALE - 1))
					' ' Recupere la position du CR
					' Pos_CRLF = Instr(Buffer_POLICE_COPIE, CHR(13) & CHR(10))
					' If Pos_CRLF > 0 then
						' TailleRetourCHR = 2
					' Else
						' TailleRetourCHR = 1
						' Pos_CRLF = Instr(Buffer_POLICE_COPIE, CHR(10))
						' IF Pos_CRLF < 0 Then Pos_CRLF = Instr(Buffer_POLICE_COPIE, CHR(13))
					' End if
					' ' Recupere le nom du dossier racine
					' buff_REPPolice = MID(Buffer_POLICE_COPIE, Pos_EGALE + 1, Pos_CRLF - ( Pos_EGALE + 1))
					' ' On resize le contenu du buffer afin de simplifier la boucle et optimiser la memoire
					' Buffer_POLICE_COPIE = MID(Buffer_POLICE_COPIE, Pos_CRLF + TailleRetourCHR)
					' ' Si il n'y avait pas de CR alors c'est la fin du fichier, on vide le buffer!
					' IF Pos_CRLF < 1 Then Buffer_POLICE_COPIE = ""
					' IF Instr(buff_NomPolice, "##") = 0 Then ' Commentaire
						' IF ListerLesPolices = 1 Then
							' DEBUG(CRLF & " -" & LCASE(buff_NomPolice), Affichage, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_Normal, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.NoCRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.SansDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_AFF, RetourVAR)
						' Else
							' IF NomPolice = buff_NomPolice Then ' La police existe!
								' Buffer_POLICE_COPIE = "" ' On vide le buffer
								' init_utf8(buff_NomPolice, buff_REPPolice, 18, 1, RetourVAR) ' Charger la police correspondante dans la RAM instancie seulement dans le SCI
							' END IF
						' END IF
						' if ListerLesPolices = 1 then DEBUG("", Affichage, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_Normal, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.SansDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_CPCDOS, RetourVAR)
					' End if
				' Wend
				' IF CPCDOS_INSTANCE.SYSTEME_INSTANCE.get_DBG_DEBUG() > 0 Then
					' IF CPCDOS_INSTANCE.Utilisateur_Langage = 0 Then
						' DEBUG("[CpcdosC+] Fin de lecture de " & "FONTS\INDEX.CFG", Affichage, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_Normal, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.AvecDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_CPCDOS, RetourVAR)
						' DEBUG("[CpcdosC+] Desallocation memoire 0x" & hex(Buffer_POLICE, 8) & "...", Affichage, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_Normal, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.AvecDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_CPCDOS, RetourVAR)
					' Else
						' DEBUG("[CpcdosC+] End reading " & "FONTS\INDEX.CFG", Affichage, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_Normal, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.AvecDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_CPCDOS, RetourVAR)
						' DEBUG("[CpcdosC+] Memory desallocation 0x" & hex(Buffer_POLICE, 8) & "...", Affichage, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_Normal, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.AvecDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_CPCDOS, RetourVAR)
					' End If
				' End if
				' If Buffer_POLICE <> 0 Then
					' 'memset(Buffer_POLICE, 0, 8)
					' *Buffer_POLICE = ""
					' ' Deallocate(Buffer_POLICE)
					' REM Buffer_POLICE = 0
					' IF CPCDOS_INSTANCE.SYSTEME_INSTANCE.get_DBG_DEBUG() > 0 Then
						' IF CPCDOS_INSTANCE.Utilisateur_Langage = 0 Then
							' DEBUG("[CpcdosC+] Desallocation OK", Affichage, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_Normal, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.AvecDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_CPCDOS, RetourVAR)
						' Else
							' DEBUG("[CpcdosC+] Desallocation OK", Affichage, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_Normal, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.AvecDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_CPCDOS, RetourVAR)
						' End If
					' End if
				' End if
				' exit _scope_CMD, _scope

				' ConsoleCpcdos.ACurClecheOuPas = 0
				' ConsoleCpcdos.Accumulation = ConsoleCpcdos.TailleBase
				Print "Police d'ecriture et UF8 a finir!"
			END IF


			IF Instr(UCASE(Param), "/MEM") > 0 Then
				' Afficher la memoire RAM
				Dim Memoire_DISPO 			as Integer = -1
				Dim MemAPrendre 			as Integer

				MemAPrendre = 0
				' Afficher la memoire utilise
				IF Instr(UCASE(Param), "/MEMU") > 0 Then MemAPrendre = 1
				IF Instr(UCASE(Param), "KB") > 0 OR Instr(UCASE(Param), "KO") > 0 Then
					IF MemAPrendre = 0 THEN
						Memoire_DISPO = (_Memoire_actuel/1024) ' Kilo-octets
					ELSE
						Memoire_DISPO = (_Memoire__krnl_occupe/1024) ' Kilo-octets
					END IF
				END IF
				IF Instr(UCASE(Param), "MB") > 0 OR Instr(UCASE(Param), "MO") > 0 Then
					IF MemAPrendre = 0 THEN
						Memoire_DISPO = (_Memoire_actuel/1024^2) ' Mega-octets
					ELSE
						Memoire_DISPO = (_Memoire__krnl_occupe/1024^2) ' Mega-octets
					END IF
				END IF
				IF Instr(UCASE(Param), "GB") > 0 OR Instr(UCASE(Param), "GO") > 0 Then
					IF MemAPrendre = 0 THEN
						Memoire_DISPO = (_Memoire_actuel/1024^3) ' Giga-octets
					ELSE
						Memoire_DISPO = (_Memoire__krnl_occupe/1024^3) ' Mega-octets
					END IF
				END IF
				IF Instr(UCASE(Param), "TB") > 0 OR Instr(UCASE(Param), "TO") > 0 Then ' Non mais t'as trop cru!
					IF MemAPrendre = 0 THEN
						Memoire_DISPO = (_Memoire_actuel/1024^4) ' Tera-octets
					ELSE
						Memoire_DISPO = (_Memoire__krnl_occupe/1024^4) ' Mega-octets
					END IF
				END IF
				IF Memoire_DISPO = -1 then
					IF MemAPrendre = 0 THEN
						Memoire_DISPO = _Memoire_actuel ' Octets
					ELSE
						Memoire_DISPO = _Memoire__krnl_occupe ' Octets
					END IF
				END IF

				IF Memoire_DISPO > -1 Then
					IF Memoire_DISPO < 1 Then
						DEBUG("1<", Affichage, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_Normal, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.SansDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_AFF, RetourVAR)
					Else
						DEBUG(str(Memoire_DISPO), Affichage, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_Normal, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.SansDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_AFF, RetourVAR)
					End if

				ELSE
					Message_erreur = ERRAVT("ERR_011", 0) ' erreur fatale
					IF CPCDOS_INSTANCE.Utilisateur_Langage = 0 then
						DEBUG("[CpcdosC+] " & Message_erreur & " " & CHR(34) & Commande & CHR(34) & ". Impossible de lire la memoire RAM, veuillez redemarrer votre machine!!.", Affichage, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_ERREUR, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.SansDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_AFF, RetourVAR)
					Else
						DEBUG("[CpcdosC+] " & Message_erreur & " " & CHR(34) & Commande & CHR(34) & ". Problem to access in RAM memory, you must restart your machine!!.", Affichage, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_ERREUR, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.SansDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_AFF, RetourVAR)
					END IF
				END IF
			END IF

			' Executer une FunctionID wrapped
			IF Instr(UCASE(Param), "/WRP") > 0 Then
				Dim FunctionID_INT as integer
				Dim FunctionID_RET as integer
				Dim FunctionID_POS as integer
				Dim FunctionID_STR as string

				FunctionID_POS = Instr(UCASE(Param), "/WRP")
				FunctionID_STR = Mid(Param, FunctionID_POS + 5)
				FunctionID_INT = val(FunctionID_STR)
				IF FunctionID_INT < 1 then
					Message_erreur = ERRAVT("AVT_062", 0) ' Vous devez specifier un numero ID superieur a 0
					IF CPCDOS_INSTANCE.Utilisateur_Langage = 0 then
						DEBUG("[CpcdosC+] " & Message_erreur & " " & CHR(34) & Commande & CHR(34) & ".", Affichage, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_ERREUR, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.SansDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_AFF, RetourVAR)
					Else
						DEBUG("[CpcdosC+] " & Message_erreur & " " & CHR(34) & Commande & CHR(34) & ". ", Affichage, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_ERREUR, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.SansDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_AFF, RetourVAR)
					END IF
					exit _scope_CMD, _scope
				else
					' Pas oublier le doevents!
					Dim ARG_1 as String 	= CCP_Lire_Variable("SYS.WRP(" & FunctionID_INT & ").1", 3, _CLE_)
					Dim ARG_2 as Integer 	= val(CCP_Lire_Variable("SYS.WRP(" & FunctionID_INT & ").2", 3, _CLE_))

					Dim str_arg3 as string = CCP_Lire_Variable("SYS.WRP(" & FunctionID_INT & ").3", 3, _CLE_)
					Dim str_arg4 as string = CCP_Lire_Variable("SYS.WRP(" & FunctionID_INT & ").4", 3, _CLE_)
					Dim str_arg5 as string = CCP_Lire_Variable("SYS.WRP(" & FunctionID_INT & ").5", 3, _CLE_)

					Dim ARG_3 as any ptr 	= cast(ZString ptr, strptr(str_arg3))
					Dim ARG_4 as any ptr 	= cast(ZString ptr, strptr(str_arg4))
					Dim ARG_5 as any ptr 	= cast(ZString ptr, strptr(str_arg5))

					FunctionID_RET = Exec_WRAPPER(FunctionID_INT, _CLE_, ARG_1, ARG_2, ARG_3, ARG_4, ARG_5)


					IF FunctionID_RET = -1 then
						Message_erreur = ERRAVT("AVT_063", 0) ' FunctionID non disponible
						IF CPCDOS_INSTANCE.Utilisateur_Langage = 0 then
							DEBUG("[CpcdosC+] " & Message_erreur & " " & CHR(34) & Commande & CHR(34) & ".", Affichage, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_ERREUR, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.SansDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_AFF, RetourVAR)
						Else
							DEBUG("[CpcdosC+] " & Message_erreur & " " & CHR(34) & Commande & CHR(34) & ". ", Affichage, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_ERREUR, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.SansDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_AFF, RetourVAR)
						END IF
						exit _scope_CMD, _scope
					END IF
				End if
			end if

'------------------------------- ECRAN --------------------------------
			' Gerer l'ecran
			IF Instr(UCASE(Param), "/ECRAN") > 0 OR Instr(UCASE(Param), "/SCREEN") > 0 Then
				IF Instr(UCASE(Param), "/PTR") > 0 Then
					DEBUG(str(CPCDOS_INSTANCE.SYSTEME_INSTANCE.get_EcranPTR()), Affichage, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_Normal, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.SansDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_AFF, RetourVAR)
					exit _scope_CMD, _scope
				ElseIF Instr(UCASE(Param), "/HEXAPTR") > 0 Then
					DEBUG("0x" & Hex(CPCDOS_INSTANCE.SYSTEME_INSTANCE.get_EcranPTR(), 8), Affichage, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_Normal, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.SansDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_AFF, RetourVAR)
					exit _scope_CMD, _scope
				END IF
				' Lister les resolutions compatibles
				IF Instr(UCASE(Param), "/LISTE ") > 0 OR Instr(UCASE(Param), "/LIST ") > 0 Then
					IF Instr(UCASE(Param), " 16") > 0 Then DEBUG(CPCDOS_INSTANCE.SYSTEME_INSTANCE.liste_Resolution(16), Affichage, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_VALIDATION, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.SansDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_AFF, RetourVAR)
					IF Instr(UCASE(Param), " 24") > 0 Then DEBUG(CPCDOS_INSTANCE.SYSTEME_INSTANCE.liste_Resolution(24), Affichage, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_VALIDATION, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.SansDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_AFF, RetourVAR)
					IF Instr(UCASE(Param), " 32") > 0 Then DEBUG(CPCDOS_INSTANCE.SYSTEME_INSTANCE.liste_Resolution(32), Affichage, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_VALIDATION, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.SansDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_AFF, RetourVAR)
					exit _scope_CMD, _scope
				End if

				' Tester une resolution + couleur
				IF Instr(UCASE(Param), "/TEST ") > 0 Then
					Dim PosTestres as integer = Instr(UCASE(Param), "/TEST ")
					Dim CouleurPos as integer = InstrREV(UCASE(Param), "X")
					Dim Couleur as string = MID(Param, CouleurPos + 1)
					Dim Resolution as String = MID(Param, PosTestres + 6, (CouleurPos) - (PosTestres + 6))

					' Couleur mal specifie
					IF val(Couleur) > 32 OR val(Couleur) < 16 then
						Message_erreur = ERRAVT("AVT_058", 0)
						IF CPCDOS_INSTANCE.Utilisateur_Langage = 0 then
							DEBUG("[CpcdosC+] " & Message_erreur & ". Exemple: SYS/ /ECRAN /TEST 1024x768x16. " & CHR(34) & Commande & CHR(34) & ".", Affichage, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_AVERTISSEMENT, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.SansDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_AFF, RetourVAR)
						Else
							DEBUG("[CpcdosC+] " & Message_erreur & ". Example: SYS/ /SCREEN /TEST 1024x768x16. " & CHR(34) & Commande & CHR(34) & ". ", Affichage, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_AVERTISSEMENT, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.SansDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_AFF, RetourVAR)
						END IF
					End if
					DEBUG(str(CPCDOS_INSTANCE.SYSTEME_INSTANCE.test_Resolution(Resolution, val(Couleur))), Affichage, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_Normal, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.SansDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_AFF, RetourVAR)
					exit _scope_CMD, _scope
				End if


				IF Instr(UCASE(Param), "/ECRAN") > 0 Then Param = MID(Param, Instr(UCASE(Param), "/ECRAN") + 6)
				IF Instr(UCASE(Param), "/SCREEN") > 0 Then Param = MID(Param, Instr(UCASE(Param), "/SCREEN") + 7)


				Param = RTRIM(LTRIM(LTRIM(Param), CHR(09)))

				' CHANGER ou AFFICHER une resolution
				IF Param = "" Then
					' Afficher la resolution actuelle
					IF CPCDOS_INSTANCE.SCI_INSTANCE.GUI_Mode = FALSE Then
						' En console
						DEBUG(Str(CPCDOS_INSTANCE.SYSTEME_INSTANCE.get_ResolutionMode()), Affichage, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_Normal, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.SansDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_AFF, RetourVAR)
					Else
						' En graphique
						DEBUG(CPCDOS_INSTANCE.SYSTEME_INSTANCE.get_Resolution_XY(), Affichage, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_Normal, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.SansDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_AFF, RetourVAR)
					End if
				Else
					' Changer la resolution

					' Mode graphique
					IF Instr(Ucase(Param), "X") > 0 Then

						Dim var_SCR_BIT as integer 	= Val(CPCDOS_INSTANCE.SHELLCCP_INSTANCE.CCP_Lire_Variable("SCR_BIT", 4, _CLE_))

						CPCDOS_INSTANCE.SCI_INSTANCE.Initialiser_ECRAN(Param, var_SCR_BIT)

					' Mode console
					ElseIF NOT Val(Param) = 0 OR STR(Param) = "0" Then
						CPCDOS_INSTANCE.SYSTEME_INSTANCE.set_Resolution(Val(Param))
					Else
						' Afficher tout de meme la resolution actuelle
						DEBUG(CPCDOS_INSTANCE.SYSTEME_INSTANCE.get_Resolution_XY(), Affichage, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_Normal, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.SansDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_AFF, RetourVAR)
					End if

				End if
			End if

'-------------------------------


			' Afficher ou configurer les parametres de l'OS

			IF Instr(UCASE(Param), "/WITHOUTOS") > 0 OR Instr(UCASE(Param), "/SANSOS") > 0 Then
				Dim NumeroOS as integer = CPCDOS_INSTANCE._MAX_NOMBRE_OS

				IF CPCDOS_INSTANCE.Utilisateur_Langage = 0 Then
					DEBUG("[CpcdosC+] Switch vers un without OS [OS:" & NumeroOS & " ID parent 0x" & HEX(_CLE_, 8) & "]", Affichage, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_OK, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.AvecDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_AFF, RetourVAR)
				Else
					DEBUG("[CpcdosC+] Switching to without OS [OS:" & NumeroOS & " Parent ID 0x" & HEX(_CLE_, 8) & "]", Affichage, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_OK, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.AvecDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_AFF, RetourVAR)
				End if

				CpcdosCP_SHELL = "SWITCH:OS_ID=#WITHOUT-SANSOS#"

				exit _scope_CMD, _scope
			End if

			IF Instr(UCASE(Param), "/OS") > 0 Then
				Dim UtiliseParametre as boolean = false

				' Mettre a jout la liste des OS present dans le fichier OS.LST
				IF Instr(UCASE(Param), "/UPDATE") > 0 Then
					CPCDOS_INSTANCE.update_OS_LISTE()
					UtiliseParametre = true
				End if

				' Lister les OS presents
				IF Instr(UCASE(Param), "/LIST") > 0 OR Instr(UCASE(Param), " /LISTE") > 0 Then
					DEBUG(CPCDOS_INSTANCE.get_OSPresent(), Affichage, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_SURBRILLE, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.SansDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_AFF, RetourVAR)
					UtiliseParametre = true
				End IF

				' Copter le nombre d'OS presents
				IF Instr(UCASE(Param), "/NB") > 0 Then
					DEBUG(str(CPCDOS_INSTANCE.get_NombreOSPresent()), Affichage, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_SURBRILLE, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.SansDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_AFF, RetourVAR)
					UtiliseParametre = true
				End IF

				' Switcher l'OS id
				if UtiliseParametre = False Then
					IF Mid(Param, Instr(Ucase(Param), "/OS") + 4) <> "" Then
						Dim tmpNomOS as String = Ucase(Ltrim(Rtrim(Mid(Param, Instr(Ucase(Param), "/OS") + 4))))
						IF CPCDOS_INSTANCE.Utilisateur_Langage = 0 Then
							DEBUG("[CpcdosC+] Switch de l'OS id vers " & tmpNomOS & ".", Affichage, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_VALIDATION, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.SansDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_AFF, RetourVAR)
						Else
							DEBUG("[CpcdosC+] OS id switch to " & tmpNomOS & ".", Affichage, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_VALIDATION, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.SansDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_AFF, RetourVAR)
						End if
						CpcdosCP_SHELL = "SWITCH:OS_ID=" & tmpNomOS
						UtiliseParametre = true
					End IF
				End if

				if UtiliseParametre = false then

					Dim NomOSPresent as String = CPCDOS_INSTANCE.get_OSPresent(CPCDOS_INSTANCE.SCI_INSTANCE.get_OSid())

					IF NomOSPresent = "" OR NomOSPresent = "<null>" Then
						IF CPCDOS_INSTANCE.Utilisateur_Langage = 0 Then
							DEBUG("Aucun OS charge", Affichage, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_AVERTISSEMENT, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.SansDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_AFF, RetourVAR)
						Else
							DEBUG("Nothing OS loaded", Affichage, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_AVERTISSEMENT, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.SansDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_AFF, RetourVAR)
						End if
					Else
						DEBUG(NomOSPresent & " OSID:" & CPCDOS_INSTANCE.SCI_INSTANCE.get_OSid(), Affichage, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_Surbrille, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.SansDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_AFF, RetourVAR)
					End if
				End if
				exit _scope_CMD, _scope
			End if

			IF Instr(UCASE(Param), "/STOPK") > 0 Then
				Dim NombreProcessus as uinteger = cpinti.gestionnaire_tache.cpinti_get_nombre_processus()
				Dim NombreThread as uinteger = cpinti.gestionnaire_tache.cpinti_get_nombre_threads()

				' CpcdosCP_SHELL("SYS/ /DEBUG = 1", _CLE_, NIVEAU_CCP, Param_1, Param_2)
				CpcdosCP_SHELL("SYS/ /DEBUG /CPINTICORE = 1", _CLE_, NIVEAU_CCP, Param_1, Param_2)
				CpcdosCP_SHELL("SYS/ /ECRAN 0", _CLE_, NIVEAU_CCP, Param_1, Param_2)
				doevents(10000)


				IF CPCDOS_INSTANCE.Utilisateur_Langage = 0 Then
					DEBUG("[CPCDOSC+] Arret du noyau en cours ...", Affichage, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_AVERTISSEMENT, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.SansDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_AFF, RetourVAR)
				Else
					DEBUG("[CPCDOSC+] Stopping kernel in progress...", Affichage, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_AVERTISSEMENT, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.SansDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_AFF, RetourVAR)
				End if

				doevents(500000)

				IF CPCDOS_INSTANCE.Utilisateur_Langage = 0 Then
					DEBUG("[CPCDOSC+] Fermeture de tous les processus (" & NombreProcessus & ") et thread(s) (" & NombreThread & ")", Affichage, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_ACTION, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.SansDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_AFF, RetourVAR)
				Else
					DEBUG("[CPCDOSC+] Closing all process (" & NombreProcessus & ") and thread(s) (" & NombreThread & ")", Affichage, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_ACTION, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.SansDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_AFF, RetourVAR)
				End if

				For Boucle as uinteger = 0 to NombreProcessus - 1
					IF CPCDOS_INSTANCE.Utilisateur_Langage = 0 Then
						DEBUG("[SHELL] Fermeture " & Boucle & "/" & NombreProcessus, Affichage, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_ACTION, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.SansDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_AFF, RetourVAR)
					Else
						DEBUG("[SHELL] Closing " & Boucle & "/" & NombreProcessus, Affichage, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_ACTION, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.SansDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_AFF, RetourVAR)
					End if
					CpcdosCP_SHELL("FERMER/ /PID:" & NombreProcessus - Boucle, _CLE_, 5, Param_1, Param_2)

				Next Boucle

				IF CPCDOS_INSTANCE.Utilisateur_Langage = 0 Then
					DEBUG("[CPCDOSC+] Tous les signaux d'arret ont ete envoyes a tous les processus & threads !", Affichage, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_VALIDATION, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.SansDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_AFF, RetourVAR)
					DEBUG("[CPCDOSC+] Attente de la fin de fermeture (2 secondes)", Affichage, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_ACTION, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.SansDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_AFF, RetourVAR)
				Else
					DEBUG("[CPCDOSC+] All stopping signal has been sent to all process and thread !", Affichage, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_VALIDATION, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.SansDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_AFF, RetourVAR)
					DEBUG("[CPCDOSC+] Waiting ending closing (2 seconds)", Affichage, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_ACTION, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.SansDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_AFF, RetourVAR)
				End if

				doevents(3000000) ' 3 Secondes d'attente
			End if

			IF Instr(UCASE(Param), "/VERSION") > 0 Then
				DEBUG(_VER_NET_BUILD, Affichage, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_OK, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.SansDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_AFF, RetourVAR)
			End if

			IF Instr(UCASE(Param), "/NETID") > 0 Then
				' Modifier le Net ID
				Dim NetID as String = Mid(Param, Instr(UCASE(Param), "/NETID") + len("/NETID "))

				if NetID = "" then
					dim NetID_ID as String = CPCDOS_INSTANCE.SHELLCCP_INSTANCE.CCP_Lire_Variable("CPC_SYS.NET.ID", 5, _CLE_)
					dim Final_NetID as string = NetID_ID & "_" & Mid(CPCDOS_INSTANCE.UNIQUE, 1, Len(CPCDOS_INSTANCE.UNIQUE) - 3)
					DEBUG("--> CURRENT SERVER NET ID : '" & Final_NetID & "'", Affichage, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_Normal, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.SansDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_AFF, RetourVAR)
					exit _scope_CMD, _scope
				End if

				' 12 Caracteres MAX !
				NetID = Mid(NetID, 1, 12)

				' Filtrer pour eviter les erreur HTTP
				NetID = Rtrim(Rtrim(Ltrim(Rtrim(Rtrim(Ltrim(NetID, CHR(09)), CR), LF)), CHR(09)))
				NetID = CPCDOS_INSTANCE.remplacer_Caractere(NetID, "[", "")
				NetID = CPCDOS_INSTANCE.remplacer_Caractere(NetID, "]", "")
				NetID = CPCDOS_INSTANCE.remplacer_Caractere(NetID, " ", "_")
				NetID = CPCDOS_INSTANCE.remplacer_Caractere(NetID, ":", "_")
				NetID = CPCDOS_INSTANCE.remplacer_Caractere(NetID, "/", "_")
				NetID = CPCDOS_INSTANCE.remplacer_Caractere(NetID, "\", "_")
				NetID = CPCDOS_INSTANCE.remplacer_Caractere(NetID, "#", "_")
				NetID = CPCDOS_INSTANCE.remplacer_Caractere(NetID, "&", "_")
				NetID = CPCDOS_INSTANCE.remplacer_Caractere(NetID, ";", "_")
				NetID = CPCDOS_INSTANCE.remplacer_Caractere(NetID, ",", "_")
				NetID = CPCDOS_INSTANCE.remplacer_Caractere(NetID, "!", "_")
				NetID = CPCDOS_INSTANCE.remplacer_Caractere(NetID, "=", "_")

				if NetID = "" then
					dim Net_ID as String = CPCDOS_INSTANCE.SHELLCCP_INSTANCE.CCP_Lire_Variable("CPC_SYS.NET.ID", 5, _CLE_)
					dim Final_NetID as string = Net_ID & "_" & Mid(CPCDOS_INSTANCE.UNIQUE, 1, Len(CPCDOS_INSTANCE.UNIQUE) - 3)
					DEBUG("--> CURRENT SERVER NET ID : '" & Final_NetID & "' saved!", Affichage, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_OK, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.SansDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_AFF, RetourVAR)
					exit _scope_CMD, _scope
				End if

				' Redefinir la variable
				CpcdosCP_SHELL("SET/ CPC_SYS.NET.ID = [" & NetID & "]", _CLE_, 5, Param_1, Param_2)

				' Ecrire dans le fichier config
				CPCDOS_INSTANCE.Ecrire_fichier_complet("KRNL\CONFIG\ENV_NET\NET_ID.CPC", "CCP/ /SET.LEVEL = 5" & CRLF & "SET/ CPC_SYS.NET.ID = [" & NetID & "]" & CRLF & CRLF, 0)

				' On relit tout
				dim Username as String = CPCDOS_INSTANCE.SHELLCCP_INSTANCE.CCP_Lire_Variable("CPC_SYS.NET.ID", 5, _CLE_)
				dim Final_NetID as string = Username & "_" & Mid(CPCDOS_INSTANCE.UNIQUE, 1, Len(CPCDOS_INSTANCE.UNIQUE) - 3)


				' Et on affiche le resultat
				DEBUG("--> NEW SERVER NET ID : '" & Final_NetID & "' saved!", Affichage, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_OK, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.SansDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_AFF, RetourVAR)
			End if

			' Mettre a jour le noyau
			IF Instr(UCASE(Param), "/UPDATE") > 0 Then
				Dim telecharger_HotRelease as boolean = false

				if Instr(UCASE(Param), "HR") > 0 Then telecharger_HotRelease = true

				Dim Download_flag 			as boolean = false
				Dim Install_flag 			as boolean = false
				Dim Download_Releases_news 	as boolean = false
				Dim Download_AND_Install 	as boolean = false
				Dim Versions_Identiques 	as boolean = false
				dim Old_RetourVAR 			as String = RetourVAR
				Dim URL_ZIP 				as String = ""
				Dim Texte_ReleaseNote 		as String = ""

				if Instr(UCASE(Param), "/UPDATE-NEWS") > 0 Then Download_Releases_news = true : RetourVAR = ""
				if Instr(UCASE(Param), "/UPDATE-GET") > 0 Then Download_flag = true
				if Instr(UCASE(Param), "/UPDATE-INSTALL") > 0 Then Install_flag = true
				if Instr(UCASE(Param), "/UPDATE-GET-INSTALL") > 0 Then Download_AND_Install = true

				DEBUG("[UPDATE] Current LOCAL version '" & _VER_NET_BUILD & "'", Affichage, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_OK, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.SansDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_AFF, RetourVAR)




				Dim Serveur_depot as String = CPCDOS_INSTANCE.SHELLCCP_INSTANCE.CCP_Lire_Variable("CPC_SYS.NET.UPDATE.SERVER", 3, _CLE_)
				Dim TEMP_NET as String = CPCDOS_INSTANCE.SHELLCCP_INSTANCE.CCP_Lire_Variable("CPC_TEMP.NET", 3, _CLE_)

				if len(Serveur_depot) < 2 then
					Serveur_depot = "deposit.cpcdos.net"
					IF CPCDOS_INSTANCE.Utilisateur_Langage = 0 Then
						DEBUG("[CPCDOSC+] Variable %CPC_SYS.NET.UPDATE.SERVER% niveau 3 non definit. Utilisation du serveur par defaut.", Affichage, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_AVERTISSEMENT, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.SansDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_AFF, RetourVAR)
					Else
						DEBUG("[CPCDOSC+] Variable %CPC_SYS.NET.UPDATE.SERVER% level 3 not defined. Using defaut server.", Affichage, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_AVERTISSEMENT, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.SansDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_AFF, RetourVAR)
					End if
				end if

				if Download_Releases_news = true then
					' telecharger et afficher la release notes de la derniere version
					CPCDOS_INSTANCE.SHELLCCP_INSTANCE.CpcdosCP_SHELL("colorf/ 15", _CLE_, 2, 0, RetourVAR)
					CPCDOS_INSTANCE.SHELLCCP_INSTANCE.CpcdosCP_SHELL("colorb/ 1", _CLE_, 2, 0, RetourVAR)
					if telecharger_HotRelease = true Then
						IF CPCDOS_INSTANCE.Utilisateur_Langage = 0 Then
							DEBUG("[UPDATE] Telechargement de la release notes de la derniere version hot-release du noyau depuis le serveur '" & Serveur_depot & "'...", Affichage, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_SURBRILLE, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.SansDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_AFF, RetourVAR)
						Else
							DEBUG("[UPDATE] Checking last release note of hot-release kernel updates from '" & Serveur_depot & "' server ...", Affichage, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_SURBRILLE, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.SansDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_AFF, RetourVAR)
						End if
					else
						IF CPCDOS_INSTANCE.Utilisateur_Langage = 0 Then
							DEBUG("[UPDATE] Telechargement de la release notes de la derniere version du noyau depuis le serveur '" & Serveur_depot & "'...", Affichage, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_SURBRILLE, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.SansDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_AFF, RetourVAR)
						Else
							DEBUG("[UPDATE] Checking last release note of hot-release kernel updates from '" & Serveur_depot & "' server ...", Affichage, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_SURBRILLE, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.SansDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_AFF, RetourVAR)
						End if
					End if

					CPCDOS_INSTANCE.SHELLCCP_INSTANCE.CpcdosCP_SHELL("colorf/ 7", _CLE_, 2, 0, RetourVAR)
					CPCDOS_INSTANCE.SHELLCCP_INSTANCE.CpcdosCP_SHELL("colorb/ 0", _CLE_, 2, 0, RetourVAR)

					' SUPPRIMER LE FICHIER
					CPCDOS_INSTANCE.Supprimer_Fichier(TEMP_NET & "\" & Serveur_depot & "\update.php", false, 0)

					doevents(10000)

					dim pseudo_ID as String = CPCDOS_INSTANCE.SHELLCCP_INSTANCE.CCP_Lire_Variable("CPC_SYS.NET.ID", 5, _CLE_)
					dim Final_NetID as string = pseudo_ID & "_" & Mid(CPCDOS_INSTANCE.UNIQUE, 1, Len(CPCDOS_INSTANCE.UNIQUE) - 3)

					' Chercher une mise a jour disponible
					if telecharger_HotRelease = true Then ' & "&id=" & CPCDOS_INSTANCE.UNIQUE
						CPCDOS_INSTANCE.SHELLCCP_INSTANCE.CpcdosCP_SHELL("download/ http://" & Serveur_depot & "/update.php?command=hotnews&id=" & Final_NetID, _CLE_, 2, 0, RetourVAR)
					Else
						CPCDOS_INSTANCE.SHELLCCP_INSTANCE.CpcdosCP_SHELL("download/ http://" & Serveur_depot & "/update.php?command=news&id=" & Final_NetID, _CLE_, 2, 0, RetourVAR)
					End if

					doevents(1000000)


					' Recuperer l'URL du ZIP
					Texte_ReleaseNote = CPCDOS_INSTANCE.Lire_fichier_complet(TEMP_NET & "\" & Serveur_depot & "\update.php")

					if len(Texte_ReleaseNote) < 100 then
						IF CPCDOS_INSTANCE.Utilisateur_Langage = 0 Then
							DEBUG("[UPDATE] Erreur impossible d'obtenir les informations du serveur.", Affichage, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_Erreur, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.SansDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_AFF, RetourVAR)
						Else
							DEBUG("[UPDATE] Error, unable to check server info.", Affichage, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_Erreur, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.SansDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_AFF, RetourVAR)
						End if
						exit _scope_CMD, _scope
					end if

					RetourVAR = Old_RetourVAR
					DEBUG(Texte_ReleaseNote, Affichage, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_SURBRILLE, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.SansDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_AFF, RetourVAR)

					exit _scope_CMD, _scope
				End if

				' Recherche ET / OU telechargement du ZIP. Install_flag uniquement si le ZIP est dans le dossier
				if Install_flag = false OR Download_AND_Install = true then
					CPCDOS_INSTANCE.SHELLCCP_INSTANCE.CpcdosCP_SHELL("colorf/ 15", _CLE_, 2, 0, RetourVAR)
					CPCDOS_INSTANCE.SHELLCCP_INSTANCE.CpcdosCP_SHELL("colorb/ 1", _CLE_, 2, 0, RetourVAR)

					if telecharger_HotRelease = true Then
						IF CPCDOS_INSTANCE.Utilisateur_Langage = 0 Then
							DEBUG("[UPDATE] Recherche d'une mise a jour hot-release du noyau depuis le serveur '" & Serveur_depot & "'...", Affichage, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_SURBRILLE, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.SansDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_AFF, RetourVAR)
						Else
							DEBUG("[UPDATE] Checking hot-release kernel updates from '" & Serveur_depot & "' server ...", Affichage, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_SURBRILLE, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.SansDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_AFF, RetourVAR)
						End if
					else
						IF CPCDOS_INSTANCE.Utilisateur_Langage = 0 Then
							DEBUG("[UPDATE] Recherche d'une mise a jour publique du noyau depuis le serveur '" & Serveur_depot & "'...", Affichage, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_SURBRILLE, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.SansDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_AFF, RetourVAR)
						Else
							DEBUG("[UPDATE] Checking public kernel updates from '" & Serveur_depot & "' server ...", Affichage, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_SURBRILLE, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.SansDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_AFF, RetourVAR)
						End if
					End if

					CPCDOS_INSTANCE.SHELLCCP_INSTANCE.CpcdosCP_SHELL("colorf/ 7", _CLE_, 2, 0, RetourVAR)
					CPCDOS_INSTANCE.SHELLCCP_INSTANCE.CpcdosCP_SHELL("colorb/ 0", _CLE_, 2, 0, RetourVAR)

					' SUPPRIMER LE FICHIER
					CPCDOS_INSTANCE.Supprimer_Fichier(TEMP_NET & "\" & Serveur_depot & "\update.php", false, 0)

					doevents(10000)

					dim pseudo_ID as String = CPCDOS_INSTANCE.SHELLCCP_INSTANCE.CCP_Lire_Variable("CPC_SYS.NET.ID", 5, _CLE_)
					dim Final_NetID as string = pseudo_ID & "_" & Mid(CPCDOS_INSTANCE.UNIQUE, 1, Len(CPCDOS_INSTANCE.UNIQUE) - 3)

					' Chercher une mise a jour disponible
					if telecharger_HotRelease = true Then ' & "&id=" & CPCDOS_INSTANCE.UNIQUE
						CPCDOS_INSTANCE.SHELLCCP_INSTANCE.CpcdosCP_SHELL("download/ http://" & Serveur_depot & "/update.php?command=hotupdate&older=" & _VER_NET_BUILD & "&id=" & Final_NetID, _CLE_, 2, 0, RetourVAR)
					Else
						CPCDOS_INSTANCE.SHELLCCP_INSTANCE.CpcdosCP_SHELL("download/ http://" & Serveur_depot & "/update.php?command=update&older=" & _VER_NET_BUILD & "&id=" & Final_NetID, _CLE_, 2, 0, RetourVAR)
					End if

					doevents(1000000)

					' Recuperer l'URL du ZIP
					URL_ZIP = CPCDOS_INSTANCE.Lire_fichier_complet(TEMP_NET & "\" & Serveur_depot & "\update.php")

					' Filtrer les parasites!
					URL_ZIP = Rtrim(Rtrim(Ltrim(Rtrim(Rtrim(Ltrim(URL_ZIP, CHR(09)), CR), LF)), CHR(09)))

					if len(URL_ZIP) < 6 then
						IF CPCDOS_INSTANCE.Utilisateur_Langage = 0 Then
							DEBUG("[UPDATE] Erreur impossible d'obtenir les informations du serveur.", Affichage, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_Erreur, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.SansDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_AFF, RetourVAR)
						Else
							DEBUG("[UPDATE] Error, unable to check server info.", Affichage, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_Erreur, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.SansDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_AFF, RetourVAR)
						End if
						exit _scope_CMD, _scope
					end if

					if instr(ucase(URL_ZIP), "HTTP://") > 0 AND instr(URL_ZIP, ".ZIP") Then

						Dim NomFichierZIP as String = Ucase(Mid(URL_ZIP, InstrREV(URL_ZIP, "/") + 1))

						Dim NouvelleUpdate as String = Mid(NomFichierZIP, 1, InstrREV(NomFichierZIP, ".ZIP") - 1)

						DEBUG("[UPDATE] Current SERVER version '" & NouvelleUpdate & "'", Affichage, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_OK, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.SansDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_AFF, RetourVAR)

						if Mid(NouvelleUpdate, 1, Instr(NouvelleUpdate, "_") - 1) > Mid(_VER_NET_BUILD, 1, Instr(_VER_NET_BUILD, "_") - 1) Then
							IF CPCDOS_INSTANCE.Utilisateur_Langage = 0 Then
								DEBUG("[UPDATE] Une nouvelle mise a jour est disponible!", Affichage, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_VALIDATION, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.SansDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_AFF, RetourVAR)
							Else
								DEBUG("[UPDATE] New update is avaiable!", Affichage, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_VALIDATION, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.SansDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_AFF, RetourVAR)
							End if

							if telecharger_HotRelease = true Then
								IF CPCDOS_INSTANCE.Utilisateur_Langage = 0 Then
									DEBUG("[UPDATE] Avertissement, il s'agit d'une version 'hot-release', une version de test non terminee. Vous resterez responsable en cas de problemes.", Affichage, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_AVERTISSEMENT, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.SansDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_AFF, RetourVAR)
								Else
									DEBUG("[UPDATE] Warning, this is a 'hot-release' version, an unfinished test version. You will remain responsible in the event of a problem.", Affichage, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_AVERTISSEMENT, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.SansDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_AFF, RetourVAR)
								End if
							End if

							Versions_Identiques = false
						Else

							Versions_Identiques = true
							IF CPCDOS_INSTANCE.Utilisateur_Langage = 0 Then
								DEBUG("[UPDATE] Vous avez la derniere version du noyau.", Affichage, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_AVERTISSEMENT, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.SansDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_AFF, RetourVAR)
							Else
								DEBUG("[UPDATE] You have the last kernel version.", Affichage, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_AVERTISSEMENT, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.SansDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_AFF, RetourVAR)
							End if
						End if
					else

						IF CPCDOS_INSTANCE.Utilisateur_Langage = 0 Then
							DEBUG("[UPDATE] Erreur impossible d'obtenir les informations de mise a jour.", Affichage, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_Erreur, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.SansDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_AFF, RetourVAR)
						Else
							DEBUG("[UPDATE] Error, unable to check update info.", Affichage, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_Erreur, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.SansDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_AFF, RetourVAR)
						End if
						exit _scope_CMD, _scope
					End if

					' Si on veut telecharger ET installer
					if Download_AND_Install = true then
						Download_flag = true
						Install_flag = true
					end if

				End if ' Install_flag  false

				' Telecharger l'update ZIP
				if Download_flag = true Then

					' Recuperer l'URL du ZIP
					URL_ZIP = CPCDOS_INSTANCE.Lire_fichier_complet(TEMP_NET & "\" & Serveur_depot & "\update.php")

					' Filtrer les parasites!
					URL_ZIP = Rtrim(Rtrim(Ltrim(Rtrim(Rtrim(Ltrim(URL_ZIP, CHR(09)), CR), LF)), CHR(09)))

					if len(URL_ZIP) < 6 then
						IF CPCDOS_INSTANCE.Utilisateur_Langage = 0 Then
							DEBUG("[UPDATE] Erreur impossible d'obtenir les informations du serveur.", Affichage, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_Erreur, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.SansDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_AFF, RetourVAR)
						Else
							DEBUG("[UPDATE] Error, unable to check server info.", Affichage, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_Erreur, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.SansDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_AFF, RetourVAR)
						End if
						exit _scope_CMD, _scope
					end if

					if instr(ucase(URL_ZIP), "HTTP://") > 0 AND instr(URL_ZIP, ".ZIP") Then

						CPCDOS_INSTANCE.SHELLCCP_INSTANCE.CpcdosCP_SHELL("colorf/ 15", _CLE_, 2, 0, RetourVAR)
						CPCDOS_INSTANCE.SHELLCCP_INSTANCE.CpcdosCP_SHELL("colorb/ 1", _CLE_, 2, 0, RetourVAR)

						Dim NomFichierZIP as String = Mid(URL_ZIP, InstrREV(URL_ZIP, "/") + 1)
						Dim PathZIP as String = Serveur_depot & "\" & Mid(URL_ZIP, Instr(URL_ZIP, Serveur_depot) + Len(Serveur_depot) + 1)
						Dim DossierZIP as String = Mid(PathZIP, 1, InstrREV(PathZIP, "/") - 1)

						IF CPCDOS_INSTANCE.Utilisateur_Langage = 0 Then
							DEBUG("[UPDATE] Telechargement en cours [" & URL_ZIP & "]", Affichage, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_Surbrille, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.SansDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_AFF, RetourVAR)
						else
							DEBUG("[UPDATE] Downloading in progress [" & URL_ZIP & "]", Affichage, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_Surbrille, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.SansDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_AFF, RetourVAR)
						End if

						CPCDOS_INSTANCE.SHELLCCP_INSTANCE.CpcdosCP_SHELL("colorf/ 7", _CLE_, 2, 0, RetourVAR)
						CPCDOS_INSTANCE.SHELLCCP_INSTANCE.CpcdosCP_SHELL("colorb/ 0", _CLE_, 2, 0, RetourVAR)

						dim var_progression 	as integer = 0
						dim var_size 			as integer = 0
						dim var_speed 			as integer = 0
						dim var_socket 			as integer = 0

						' Creer les variables niveau 2
						CPCDOS_INSTANCE.SHELLCCP_INSTANCE.CpcdosCP_SHELL("set/ VAR_Progress = 0"	, _CLE_, 2, 0, RetourVAR)
						CPCDOS_INSTANCE.SHELLCCP_INSTANCE.CpcdosCP_SHELL("set/ VAR_Speed = 0"		, _CLE_, 2, 0, RetourVAR)
						CPCDOS_INSTANCE.SHELLCCP_INSTANCE.CpcdosCP_SHELL("set/ VAR_Bytes = 0"		, _CLE_, 2, 0, RetourVAR)
						CPCDOS_INSTANCE.SHELLCCP_INSTANCE.CpcdosCP_SHELL("set/ VAR_Socket = 0"		, _CLE_, 2, 0, RetourVAR)

						' Telecharger le ZIP
						CPCDOS_INSTANCE.SHELLCCP_INSTANCE.CpcdosCP_SHELL("download/ " & URL_ZIP & " /Progression:VAR_Progress /BytesBySec:VAR_Speed /Bytes:VAR_Bytes /socket:VAR_Socket", _CLE_, 2, 0, RetourVAR)


						DEBUG("[UPDATE] 'C' --> STOP", Affichage, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_Surbrille, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.SansDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_AFF, RetourVAR)

						Dim Touche_inkey as String = ""
						' Attendre 1 ms
						' doevents(1000)

						' Attendre jusqu'a 100%
						while var_progression < 100

							Touche_inkey = Inkey

							if ucase(Touche_inkey) = "C" Then
								CPCDOS_INSTANCE.SHELLCCP_INSTANCE.CpcdosCP_SHELL("client/ /send:" & var_socket & " #STOP", _CLE_, 2, 0, RetourVAR)

								DEBUG("", Affichage, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_AVERTISSEMENT, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.SansDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_AFF, RetourVAR)
								IF CPCDOS_INSTANCE.Utilisateur_Langage = 0 Then
									DEBUG("[UPDATE] Telechargement annule", Affichage, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_AVERTISSEMENT, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.SansDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_AFF, RetourVAR)
								else
									DEBUG("[UPDATE] Downloading stopped", Affichage, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_AVERTISSEMENT, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.SansDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_AFF, RetourVAR)
								End if

								' Attendre 10 ms
								doevents(100000)

								exit _scope_CMD, _scope
							End if
							' Recuperer les statistiques
							var_progression 	= val(CPCDOS_INSTANCE.SHELLCCP_INSTANCE.CCP_Lire_Variable("VAR_Progress", 2, _CLE_))
							var_size 			= val(CPCDOS_INSTANCE.SHELLCCP_INSTANCE.CCP_Lire_Variable("VAR_Bytes", 2, _CLE_))
							var_speed 			= val(CPCDOS_INSTANCE.SHELLCCP_INSTANCE.CCP_Lire_Variable("VAR_Speed", 2, _CLE_))
							var_socket 			= val(CPCDOS_INSTANCE.SHELLCCP_INSTANCE.CCP_Lire_Variable("VAR_Socket", 2, _CLE_))

							CPCDOS_INSTANCE.SHELLCCP_INSTANCE.CpcdosCP_SHELL("colorf/ 15", _CLE_, 2, 0, RetourVAR)
							CPCDOS_INSTANCE.SHELLCCP_INSTANCE.CpcdosCP_SHELL("colorb/ 2", _CLE_, 2, 0, RetourVAR)

							DEBUG("[UPDATE] " & NomFichierZIP & " --> " & var_progression & "% ", Affichage, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_Surbrille, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.NoCRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.SansDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_AFF, RetourVAR)

							if cint(var_speed) < CPCDOS_INSTANCE._KILO_OCTETS Then
								DEBUG("(" & cint(var_speed) & " bytes/sec)", Affichage, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_Surbrille, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.NoCRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.SansDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_AFF, RetourVAR)
							elseif cint(var_speed) < CPCDOS_INSTANCE._MEGA_OCTETS Then
								DEBUG("(" & cint(var_speed/CPCDOS_INSTANCE._KILO_OCTETS) & " kb/sec)", Affichage, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_Surbrille, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.NoCRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.SansDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_AFF, RetourVAR)
							elseif cint(var_speed) < CPCDOS_INSTANCE._GIGA_OCTETS Then
								DEBUG("(" & cint(var_speed/CPCDOS_INSTANCE._MEGA_OCTETS) & " mb/sec)", Affichage, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_Surbrille, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.NoCRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.SansDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_AFF, RetourVAR)
							end if

							if cint(var_size) < CPCDOS_INSTANCE._KILO_OCTETS Then
								DEBUG(" - " & cint(var_size) & " bytes downloaded.     ", Affichage, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_Surbrille, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.NoCRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.SansDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_AFF, RetourVAR)
							elseif cint(var_size) < CPCDOS_INSTANCE._MEGA_OCTETS Then
								DEBUG(" - " & cint(var_size/CPCDOS_INSTANCE._KILO_OCTETS) & " kb downloaded.     ", Affichage, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_Surbrille, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.NoCRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.SansDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_AFF, RetourVAR)
							elseif	 cint(var_size) < CPCDOS_INSTANCE._GIGA_OCTETS Then
								DEBUG(" - " & cint(var_size/CPCDOS_INSTANCE._MEGA_OCTETS) & " mb downloaded.     ", Affichage, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_Surbrille, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.NoCRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.SansDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_AFF, RetourVAR)
							end if

							CPCDOS_INSTANCE.SHELLCCP_INSTANCE.CpcdosCP_SHELL("colorf/ 7", _CLE_, 2, 0, RetourVAR)
							CPCDOS_INSTANCE.SHELLCCP_INSTANCE.CpcdosCP_SHELL("colorb/ 0", _CLE_, 2, 0, RetourVAR)

							locate CsrLin, 1

							' Attendre 1 sec
							doevents(500000)
						wend

						DEBUG("", Affichage, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_Surbrille, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.SansDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_AFF, RetourVAR)

						' Tester la taille du fichier
						if CPCDOS_INSTANCE.Taille_Fichier(TEMP_NET & "\" & PathZIP) < 1024 Then
							Dim Contenufichier as String = CPCDOS_INSTANCE.Lire_fichier_complet(TEMP_NET & "\" & DossierZIP)


							if Instr(Contenufichier, "301") > 0 OR Instr(Contenufichier, "302") > 0 Then
								IF CPCDOS_INSTANCE.Utilisateur_Langage = 0 Then
									DEBUG("[UPDATE] ERREUR 301/302 : Redirection non supporte.", Affichage, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_Erreur, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.SansDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_AFF, RetourVAR)
								else
									DEBUG("[UPDATE] 301/302 ERROR : Redirection not supported.", Affichage, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_Erreur, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.SansDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_AFF, RetourVAR)
								End if

								exit _scope_CMD, _scope
							End if

							if Instr(Contenufichier, "400") > 0 Then
								IF CPCDOS_INSTANCE.Utilisateur_Langage = 0 Then
									DEBUG("[UPDATE] ERREUR 400 : Syntaxe de la requette est erronee.", Affichage, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_Erreur, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.SansDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_AFF, RetourVAR)
								else
									DEBUG("[UPDATE] 400 ERROR : Wrong request syntax.", Affichage, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_Erreur, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.SansDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_AFF, RetourVAR)
								End if

								exit _scope_CMD, _scope
							End if

							if Instr(Contenufichier, "401") > 0 OR Instr(Contenufichier, "403") > 0 Then
								IF CPCDOS_INSTANCE.Utilisateur_Langage = 0 Then
									DEBUG("[UPDATE] ERREUR 403 : Acces refuse !", Affichage, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_Erreur, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.SansDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_AFF, RetourVAR)
								else
									DEBUG("[UPDATE] 403 ERROR : Access denied !", Affichage, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_Erreur, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.SansDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_AFF, RetourVAR)
								End if

								exit _scope_CMD, _scope
							End if

							if Instr(Contenufichier, "404") > 0 Then
								IF CPCDOS_INSTANCE.Utilisateur_Langage = 0 Then
									DEBUG("[UPDATE] ERREUR 404 : Fichier introuvable sur le serveur.", Affichage, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_Erreur, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.SansDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_AFF, RetourVAR)
								else
									DEBUG("[UPDATE] 404 ERROR : File is missing.", Affichage, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_Erreur, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.SansDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_AFF, RetourVAR)
								End if

								exit _scope_CMD, _scope
							End if

							if Instr(Contenufichier, "500") > 0 OR Instr(Contenufichier, "503") > 0 Then
								IF CPCDOS_INSTANCE.Utilisateur_Langage = 0 Then
									DEBUG("[UPDATE] ERREUR 500/503 : Erreur serveur", Affichage, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_Erreur, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.SansDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_AFF, RetourVAR)
								else
									DEBUG("[UPDATE] 500/503 ERROR : Server error.", Affichage, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_Erreur, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.SansDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_AFF, RetourVAR)
								End if

								exit _scope_CMD, _scope
							End if

							IF CPCDOS_INSTANCE.Utilisateur_Langage = 0 Then
								DEBUG("[UPDATE] ERREUR : Impossible de telecharger" & CRLF & Contenufichier, Affichage, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_Erreur, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.SansDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_AFF, RetourVAR)
							else
								DEBUG("[UPDATE] ERROR : Unable to update " & CRLF & Contenufichier, Affichage, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_Erreur, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.SansDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_AFF, RetourVAR)
							End if

							exit _scope_CMD, _scope

						End if

						CPCDOS_INSTANCE.SHELLCCP_INSTANCE.CpcdosCP_SHELL("colorf/ 15", _CLE_, 2, 0, RetourVAR)
						CPCDOS_INSTANCE.SHELLCCP_INSTANCE.CpcdosCP_SHELL("colorb/ 2", _CLE_, 2, 0, RetourVAR)
						IF CPCDOS_INSTANCE.Utilisateur_Langage = 0 Then
							DEBUG("[UPDATE] Telechargement termine !", Affichage, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_Surbrille, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.SansDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_AFF, RetourVAR)
						else
							DEBUG("[UPDATE] Downloading ok !", Affichage, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_Surbrille, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.SansDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_AFF, RetourVAR)
						End if

						CPCDOS_INSTANCE.SHELLCCP_INSTANCE.CpcdosCP_SHELL("colorf/ 7", _CLE_, 2, 0, RetourVAR)
						CPCDOS_INSTANCE.SHELLCCP_INSTANCE.CpcdosCP_SHELL("colorb/ 0", _CLE_, 2, 0, RetourVAR)

						DEBUG("[UPDATE] Package '" & TEMP_NET & "\" & PathZIP & "' [OK]", Affichage, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_OK, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.SansDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_AFF, RetourVAR)

					else

						IF CPCDOS_INSTANCE.Utilisateur_Langage = 0 Then
							DEBUG("[UPDATE] Erreur impossible d'obtenir les informations de mise a jour.", Affichage, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_Erreur, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.SansDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_AFF, RetourVAR)
						Else
							DEBUG("[UPDATE] Error, unable to check update info.", Affichage, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_Erreur, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.SansDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_AFF, RetourVAR)
						End if
						exit _scope_CMD, _scope
					End if


				elseif Install_flag = false AND Versions_Identiques = false then
					' Si la commande n'installe pas et que la recheche dit que la version est differente, proposer la commande pour l'installer

					IF CPCDOS_INSTANCE.Utilisateur_Langage = 0 Then
						DEBUG("[UPDATE] Utilisez '/update-get' pour telecharger la mise a jour.", Affichage, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_Surbrille, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.SansDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_AFF, RetourVAR)
					else
						DEBUG("[UPDATE] Please use '/update-get' to download update.", Affichage, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_Surbrille, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.SansDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_AFF, RetourVAR)
					End if
					exit _scope_CMD, _scope
				End if

				' Installer le ZIP
				if Install_flag = true Then

					' Recuperer l'URL du ZIP
					URL_ZIP = CPCDOS_INSTANCE.Lire_fichier_complet(TEMP_NET & "\" & Serveur_depot & "\update.php")

					' Filtrer les parasites!
					URL_ZIP = Rtrim(Rtrim(Ltrim(Rtrim(Rtrim(Ltrim(URL_ZIP, CHR(09)), CR), LF)), CHR(09)))

					if len(URL_ZIP) < 6 then
						IF CPCDOS_INSTANCE.Utilisateur_Langage = 0 Then
							DEBUG("[UPDATE] Erreur impossible d'obtenir les informations du serveur.", Affichage, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_Erreur, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.SansDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_AFF, RetourVAR)
						Else
							DEBUG("[UPDATE] Error, unable to check server info.", Affichage, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_Erreur, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.SansDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_AFF, RetourVAR)
						End if
						exit _scope_CMD, _scope
					end if

					if instr(ucase(URL_ZIP), "HTTP://") > 0 AND instr(URL_ZIP, ".ZIP") Then

						Dim NomFichierZIP as String = Mid(URL_ZIP, InstrREV(URL_ZIP, "/") + 1)
						Dim PathZIP as String = Serveur_depot & "\" & Mid(URL_ZIP, Instr(URL_ZIP, Serveur_depot) + Len(Serveur_depot) + 1)
						Dim DossierZIP as String = Mid(PathZIP, 1, InstrREV(PathZIP, "/") - 1)


						Dim Fichier_Existant as boolean = CPCDOS_INSTANCE.Fichier_Existe(TEMP_NET & "\" & PathZIP)

						If Fichier_Existant = true Then

							CPCDOS_INSTANCE.SHELLCCP_INSTANCE.CpcdosCP_SHELL("colorf/ 15", _CLE_, 2, 0, RetourVAR)
							CPCDOS_INSTANCE.SHELLCCP_INSTANCE.CpcdosCP_SHELL("colorb/ 2", _CLE_, 2, 0, RetourVAR)

							IF CPCDOS_INSTANCE.Utilisateur_Langage = 0 Then
								DEBUG("[UPDATE] Extraction du package en cours [" & TEMP_NET & "\" & PathZIP & "]", Affichage, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_Surbrille, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.SansDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_AFF, RetourVAR)
							else
								DEBUG("[UPDATE] Extracting package in progress [" & TEMP_NET & "\" & PathZIP & "]", Affichage, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_Surbrille, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.SansDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_AFF, RetourVAR)
							End if

							CPCDOS_INSTANCE.SHELLCCP_INSTANCE.CpcdosCP_SHELL("colorf/ 7", _CLE_, 2, 0, RetourVAR)
							CPCDOS_INSTANCE.SHELLCCP_INSTANCE.CpcdosCP_SHELL("colorb/ 0", _CLE_, 2, 0, RetourVAR)

							' Attendre 1 sec
							doevents(1000000)

							CPCDOS_INSTANCE.SHELLCCP_INSTANCE.CpcdosCP_SHELL("decompress/ " & TEMP_NET & "\" & PathZIP & " .", _CLE_, 2, 0, RetourVAR)

							CPCDOS_INSTANCE.SHELLCCP_INSTANCE.CpcdosCP_SHELL("colorf/ 15", _CLE_, 2, 0, RetourVAR)
							CPCDOS_INSTANCE.SHELLCCP_INSTANCE.CpcdosCP_SHELL("colorb/ 2", _CLE_, 2, 0, RetourVAR)

							IF CPCDOS_INSTANCE.Utilisateur_Langage = 0 Then
								DEBUG("[UPDATE] Installation terminee !", Affichage, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_Surbrille, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.SansDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_AFF, RetourVAR)
							else
								DEBUG("[UPDATE] Installation OK !", Affichage, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_Surbrille, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.SansDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_AFF, RetourVAR)
							End if

							CPCDOS_INSTANCE.SHELLCCP_INSTANCE.CpcdosCP_SHELL("colorf/ 7", _CLE_, 2, 0, RetourVAR)
							CPCDOS_INSTANCE.SHELLCCP_INSTANCE.CpcdosCP_SHELL("colorb/ 0", _CLE_, 2, 0, RetourVAR)

							' Remettre le Pseudo ID
							CpcdosCP_SHELL("SYS/ /NETID " & CPCDOS_INSTANCE.SHELLCCP_INSTANCE.CCP_Lire_Variable("CPC_SYS.NET.ID", 5, _CLE_), _CLE_, 5, Param_1, Param_2)

							IF CPCDOS_INSTANCE.Utilisateur_Langage = 0 Then
								DEBUG("[UPDATE] Veuillez redemarrer votre PC", Affichage, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_AVERTISSEMENT, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.SansDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_AFF, RetourVAR)
							else
								DEBUG("[UPDATE] Please to restart your PC", Affichage, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_AVERTISSEMENT, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.SansDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_AFF, RetourVAR)
							End if
						Else
							IF CPCDOS_INSTANCE.Utilisateur_Langage = 0 Then
								DEBUG("[UPDATE] Erreur, package ZIP non trouve. Veuillez relancer le telechargement", Affichage, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_Erreur, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.SansDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_AFF, RetourVAR)
							Else
								DEBUG("[UPDATE] Error, ZIP package not found Please re-launch downloading", Affichage, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_Erreur, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.SansDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_AFF, RetourVAR)
							End if
							exit _scope_CMD, _scope
						End if
					End if
				elseif Versions_Identiques = false then
					IF CPCDOS_INSTANCE.Utilisateur_Langage = 0 Then
						DEBUG("[UPDATE] Utilisez /update-install pour installer la mise a jour.", Affichage, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_Surbrille, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.SansDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_AFF, RetourVAR)
					else
						DEBUG("[UPDATE] Please use /update-install to install update.", Affichage, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_Surbrille, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.SansDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_AFF, RetourVAR)
					End if
					exit _scope_CMD, _scope
				End if
			End if

			IF Instr(UCASE(Param), "/ARRETER") > 0 OR Instr(UCASE(Param), "/SHUTDOWN") > 0 Then

				IF CPCDOS_INSTANCE.Utilisateur_Langage = 0 Then
					DEBUG("[CPCDOSC+] Demande d'arret du systeme ...", Affichage, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_AVERTISSEMENT, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.SansDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_AFF, RetourVAR)
				Else
					DEBUG("[CPCDOSC+] Asking for shutdown system ...", Affichage, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_AVERTISSEMENT, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.SansDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_AFF, RetourVAR)
				End if

				cpinti.gestionnaire_tache._exit()

				CX_APM_MODE = CPCDOS_INSTANCE.SYSTEME_INSTANCE.InterfaceAPM.CX_Shutdown
				CpcdosCP_SHELL("SYS/ /STOPK", _CLE_, 5, Param_1, Param_2)
			ElseIF Instr(UCASE(Param), "/STANDBY") > 0 OR Instr(UCASE(Param), "/VEILLE") > 0 Then
				IF CPCDOS_INSTANCE.Utilisateur_Langage = 0 Then
					DEBUG("[CPCDOSC+] Demande de mise en veille du systeme ...", Affichage, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_AVERTISSEMENT, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.SansDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_AFF, RetourVAR)
				Else
					DEBUG("[CPCDOSC+] Asking for standby mode the system ...", Affichage, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_AVERTISSEMENT, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.SansDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_AFF, RetourVAR)
				End if

				'FIXME: CPCDOS_INSTANCE.SYSTEME_INSTANCE.InterfaceAPM.signal_systeme(CPCDOS_INSTANCE.SYSTEME_INSTANCE.InterfaceAPM.CX_StandbyMode)
			ElseIF Instr(UCASE(Param), "/REBOOT") > 0 OR Instr(UCASE(Param), "/RESTART") > 0 OR Instr(UCASE(Param), "/REDEMARRER") > 0 Then
				IF CPCDOS_INSTANCE.Utilisateur_Langage = 0 Then
					DEBUG("[CPCDOSC+] Demande de redemarrage du systeme ...", Affichage, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_AVERTISSEMENT, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.SansDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_AFF, RetourVAR)
				Else
					DEBUG("[CPCDOSC+] Asking for restarting the system ...", Affichage, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_AVERTISSEMENT, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.SansDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_AFF, RetourVAR)
				End if

				cpinti.gestionnaire_tache._exit()

				CX_APM_MODE = CPCDOS_INSTANCE.SYSTEME_INSTANCE.InterfaceAPM.Restart
				CpcdosCP_SHELL("SYS/ /STOPK", _CLE_, 5, Param_1, Param_2)
			END IF

'-------------------------------

			' Creer un nouveau processus

			IF Instr(UCASE(Param), "/PROCESS") > 0 OR Instr(UCASE(Param), "/PROCESSUS") > 0 Then
				Dim NomProcessus as String
				Dim NumeroPID as integer

				IF Instr(UCASE(Param), "/PROCESSUS") > 0 Then
					NomProcessus = Mid(Param, Instr(UCASE(Param), "/PROCESSUS") + 11)
				ElseIF Instr(UCASE(Param), "/PROCESS") > 0 Then
					NomProcessus = Mid(Param, Instr(UCASE(Param), "/PROCESS") + 9)
				End if

				IF CPCDOS_INSTANCE.SYSTEME_INSTANCE.get_DBG_DEBUG() > 0 Then
					IF CPCDOS_INSTANCE.Utilisateur_Langage = 0 Then
						DEBUG("[CpcdosC+] Demande creation d'un nouveau processus '" & NomProcessus & "' (KernelID:" & Auth_Kernel & " OSID:" & Auth_OS & " UserID:" & Auth_Utilisateur & ") ...", CPCDOS_INSTANCE.DEBUG_INSTANCE.Ecran, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_ACTION, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.AvecDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_CPCDOS, RetourVAR)
					Else
						DEBUG("[CpcdosC+] Asking creation new process  '" & NomProcessus & "' (KernelID:" & Auth_Kernel & " OSID:" & Auth_OS & " UserID:" & Auth_Utilisateur & ") ...", CPCDOS_INSTANCE.DEBUG_INSTANCE.Ecran, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_ACTION, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.AvecDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_CPCDOS, RetourVAR)
					End if
				END IF

				Dim INSTANCE_STRUCT_PROCES as _STRUCT_PROCESSUS_Cpcdos_OSx__

				' Remplir la structure
				INSTANCE_STRUCT_PROCES.Nom 				= NomProcessus			' Nom du processus
				INSTANCE_STRUCT_PROCES.PROC_ID_PARENT	= Auth_PID				' PID du processus parent (qui l'a cree)
				INSTANCE_STRUCT_PROCES.THREAD_ID_PARENT	= Auth_TID				' TID du thread parent (qui l'a cree)
				INSTANCE_STRUCT_PROCES.OS_ID			= Auth_OS				' ID de l'OS
				INSTANCE_STRUCT_PROCES.USER_ID			= Auth_Utilisateur		' ID de l'user

				' Creer le processus
				NumeroPID = CPCDOS_INSTANCE.Creer_processus(INSTANCE_STRUCT_PROCES)


				IF CPCDOS_INSTANCE.SYSTEME_INSTANCE.get_DBG_DEBUG() > 0 Then
					IF CPCDOS_INSTANCE.Utilisateur_Langage = 0 Then
						DEBUG("[CpcdosC+] Le nouveau processus '" & NomProcessus & "' est en execution avec 0 threads (KernelID:" & Auth_Kernel & " OSID:" & Auth_OS & " UserID:" & Auth_Utilisateur & " PID:" & NumeroPID & ")", CPCDOS_INSTANCE.DEBUG_INSTANCE.Ecran, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_OK, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.AvecDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_CPCDOS, RetourVAR)
					Else
						DEBUG("[CpcdosC+] New process '" & NomProcessus & "' is in execution with 0 threads (KernelID:" & Auth_Kernel & " OSID:" & Auth_OS & " UserID:" & Auth_Utilisateur & " PID:" & NumeroPID & ")", CPCDOS_INSTANCE.DEBUG_INSTANCE.Ecran, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_OK, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.AvecDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_CPCDOS, RetourVAR)
					End if
				END IF

				' Retourner le nouveau numero de PID
				DEBUG("" & NumeroPID, CPCDOS_INSTANCE.DEBUG_INSTANCE.Ecran, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_OK, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.SansDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_AFF, RetourVAR)

			End if


			' ===================================================================
			END SCOPE
			exit _scope_CMD, _scope
		End if ' **** SYS/ ****

	_end_scope_CMD

	_scope_CMD

		' ===============================================================
		'  Commande pour afficher du texte a l'ecran
		' ===============================================================
		CommLANG(1) = "couleurc/"
		CommLANG(2) = "colorf/"
		CommLANG(3) = "\\#//"
		CommTrouve = 0 : NoCMD = 0
		for boucle as integer = 1 to 2
			IF OnCherche = CommLANG(boucle) Then
				NoCMD = 0
				exit for
			Else
				NoCMD = 1
			End if
		Next boucle
		IF NoCMD = 1 then CommLANG(1) = "[F.#).|" : CommLANG(2) = "[F.#).|" : CommLANG(3) = "\\#//"

		rem Afficher la liste des commandes avec anglais / francais
		IF AfficherAide = 1 then
			IF CPCDOS_INSTANCE.Utilisateur_Langage = 0 then
				CommandesAide = CommandesAide & CRLF & " couleurc/                  Changer la couleur des caracteres utf-8 ou accii"
			Else
				CommandesAide = CommandesAide & CRLF & " colorf/                    Change fonts colors utf-8 or ascii"
			END IF
		END IF

		IF CommLANG(1) = OnCherche Then CommTrouve = 1
		IF CommLANG(2) = OnCherche Then CommTrouve = 2
		IF CommTrouve > 0 Then
			IF AfficherAide = 2 then
				Mess_Aide = ""
				IF CPCDOS_INSTANCE.Utilisateur_Langage = 0 THEN
					Mess_Aide = Mess_Aide & CRLF & "  'CouleurCaracteres'"
					Mess_Aide = Mess_Aide & CRLF
					Mess_Aide = Mess_Aide & CRLF & "  Fonctionnalit�e :"
					Mess_Aide = Mess_Aide & CRLF & "   Cette commande permet de changer la couleur des caracteres de la console LC2, LC3 et IUG"
					Mess_Aide = Mess_Aide & CRLF
					Mess_Aide = Mess_Aide & CRLF & "  Exemple graphique :"
					Mess_Aide = Mess_Aide & CRLF & "   CouleurC/ R:255 V:100 B:010"
					Mess_Aide = Mess_Aide & CRLF & "   txt/ Je suis de couleur Orange"
					Mess_Aide = Mess_Aide & CRLF
					Mess_Aide = Mess_Aide & CRLF & "   Couleurc/ R:255 V:000 B:000"
					Mess_Aide = Mess_Aide & CRLF & "   txt/ Rouge/#R"
					Mess_Aide = Mess_Aide & CRLF & "   couleurc/ V:255 R:000 B:000"
					Mess_Aide = Mess_Aide & CRLF & "   txt/  Vert/#R"
					Mess_Aide = Mess_Aide & CRLF & "   CouleurC/ B:255 R:000 V:000"
					Mess_Aide = Mess_Aide & CRLF & "   txt/  Bleu/#R"
					Mess_Aide = Mess_Aide & CRLF & "   couleurC/ R:100"
					Mess_Aide = Mess_Aide & CRLF & "   txt/  Violet/#R"
					Mess_Aide = Mess_Aide & CRLF & "   couleurC/ V:255"
					Mess_Aide = Mess_Aide & CRLF & "   txt/  Bleu clair/#R"
					Mess_Aide = Mess_Aide & CRLF & "   CouleurC/ B:255"
					Mess_Aide = Mess_Aide & CRLF & "   txt/  Blanc/#R"
					Mess_Aide = Mess_Aide & CRLF
					Mess_Aide = Mess_Aide & CRLF & "  Exemple console EGA (4 bits) 11 par defaut :"
					Mess_Aide = Mess_Aide & CRLF & "   CouleurC/ 10"
					Mess_Aide = Mess_Aide & CRLF & "   Txt/ Je suis de couleur Bleue clair"
					Mess_Aide = Mess_Aide & CRLF & "   Couleurc/ 15"
					Mess_Aide = Mess_Aide & CRLF & "   txt/ Je suis de couleur blanche"
					Mess_Aide = Mess_Aide & CRLF
					Mess_Aide = Mess_Aide & CRLF & "   0:Noir 1:Bleu 2:Vert 3:Cyan 4:Rouge 5:Magenta 6:Brun 7:Gris clair 8:Gris fonce"
					Mess_Aide = Mess_Aide & CRLF & "   9:Bleu brillant 10:Vert brillant 11:Cyan brillant 12:Rouge brillant"
					Mess_Aide = Mess_Aide & CRLF & "   13:Magenta brillant 14:Jaune 15:Blanc"
					Mess_Aide = Mess_Aide & CRLF
					Mess_Aide = Mess_Aide & CRLF & "  Voir aussi : txt/ , couleurf/"
					Mess_Aide = Mess_Aide & CRLF
				ELSEIF CPCDOS_INSTANCE.Utilisateur_Langage = 1 THEN
					Mess_Aide = Mess_Aide & CRLF & "  'ColorFont'"
					Mess_Aide = Mess_Aide & CRLF
					Mess_Aide = Mess_Aide & CRLF & "  Fonctionnality :"
					Mess_Aide = Mess_Aide & CRLF & "   This command allow to change font color of LC2, LC3 console and IUG(GUI)"
					Mess_Aide = Mess_Aide & CRLF
					Mess_Aide = Mess_Aide & CRLF & "  Graphic example :"
					Mess_Aide = Mess_Aide & CRLF & "   colorf/ R:255 V:100 B:010"
					Mess_Aide = Mess_Aide & CRLF & "   txt/ Je suis de couleur Orange"
					Mess_Aide = Mess_Aide & CRLF
					Mess_Aide = Mess_Aide & CRLF & "   Colorf/ R:255 V:000 B:000"
					Mess_Aide = Mess_Aide & CRLF & "   txt/ Red/#R"
					Mess_Aide = Mess_Aide & CRLF & "   colorF/ V:255 R:000 B:000"
					Mess_Aide = Mess_Aide & CRLF & "   txt/  Green/#R"
					Mess_Aide = Mess_Aide & CRLF & "   colorf/ B:255 R:000 V:000"
					Mess_Aide = Mess_Aide & CRLF & "   txt/  Blue/#R"
					Mess_Aide = Mess_Aide & CRLF & "   colorf/ R:100"
					Mess_Aide = Mess_Aide & CRLF & "   txt/  Purple/#R"
					Mess_Aide = Mess_Aide & CRLF & "   colorf/ V:255"
					Mess_Aide = Mess_Aide & CRLF & "   txt/  light blue/#R"
					Mess_Aide = Mess_Aide & CRLF & "   ColorF/ B:255"
					Mess_Aide = Mess_Aide & CRLF & "   txt/  White/#R"
					Mess_Aide = Mess_Aide & CRLF
					Mess_Aide = Mess_Aide & CRLF & "  EGA Console example (4 bits) 11 by default:"
					Mess_Aide = Mess_Aide & CRLF & "   colorf/ 10"
					Mess_Aide = Mess_Aide & CRLF & "   Txt/ I'm in blue color"
					Mess_Aide = Mess_Aide & CRLF & "   colorf/ 15"
					Mess_Aide = Mess_Aide & CRLF & "   txt/ I in white color"
					Mess_Aide = Mess_Aide & CRLF
					Mess_Aide = Mess_Aide & CRLF & "   0:Black 1:Blue 2:Green 3:Cyan 4:Red 5:Magenta 6:Brun 7:Ligh gray 8:Black gray"
					Mess_Aide = Mess_Aide & CRLF & "   9:Light blue 10:Light green 11:Light cyan 12:Light red 13:Light magenta"
					Mess_Aide = Mess_Aide & CRLF & "   14:Yellow 15:White"
					Mess_Aide = Mess_Aide & CRLF
					Mess_Aide = Mess_Aide & CRLF & "  See also : txt/ , colorb/"
					Mess_Aide = Mess_Aide & CRLF
				END IF
				DEBUG(Mess_Aide, Affichage, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_SURBRILLE, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.SansDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_AFF, RetourVAR)
				testCMD = 0
				AfficherAide = 0
				exit _scope_CMD, _scope
			END IF
			' Tester la syntaxe
			testCMD	= CCP_Verifier_Syntaxe(Commande, CommPosition)
			IF testCMD > 10 Then exit _scope_CMD, _scope
			IF testCMD > 0 then  ' Entre 1-5 = Pas d'affichage via le @, @$ ou @#
				IF testCMD < 6 then
					Affichage = 0
					IF testCMD = 3 Then CpcdosCP_SHELL("FIX/ " & CPCDOS_INSTANCE.DEBUG_INSTANCE.LeRetour & " = \#NULL", _CLE_, NIVEAU_CCP, Param_1, Param_2) : RetourVAR = _CLE_ & "N" & NIVEAU_CCP & "->" & CPCDOS_INSTANCE.DEBUG_INSTANCE.LeRetour
					if testCMD = 2 Then RetourVAR = "$>" & CPCDOS_INSTANCE.DEBUG_INSTANCE.LeRetour ' ajouter une securite ?
				Else
					Affichage = 1
				END IF
			Else
				Affichage = 1
			END IF
			' Recuperer les Parametres
			Param = MID(Commande, CommPosition + TailleComm + 2)
			SCOPE
			' ====================================================================

			Dim couleurC_R				as Integer
			Dim couleurC_V				as Integer
			Dim couleurC_B				as Integer
			Dim Test_CouleurEGA as String
			Param = UCASE(Param)
			' On recherche les couleurs
			couleurC_R = instr(UCASE(Param), "R:")
			couleurC_V = instr(UCASE(Param), "V:")
			IF couleurC_V < 1 Then couleurC_V = instr(UCASE(Param), "G:")
			couleurC_B = instr(UCASE(Param), "B:")
			' Et on attribue
			IF couleurC_R > 0 Then CPCDOS_INSTANCE.SCI_INSTANCE.UTF8_INSTANCE.utf8_CouleurP_R = Val(MID(Param, couleurC_R + 2, 3))
			IF couleurC_V > 0 Then CPCDOS_INSTANCE.SCI_INSTANCE.UTF8_INSTANCE.utf8_CouleurP_V = Val(MID(Param, couleurC_V + 2, 3))
			IF couleurC_B > 0 Then CPCDOS_INSTANCE.SCI_INSTANCE.UTF8_INSTANCE.utf8_CouleurP_B = Val(MID(Param, couleurC_B + 2, 3))

			' Tester si c'est une couleur EGA
			Test_CouleurEGA = MID(LTRIM(RTRIM(LTRIM(Param)), CHR(09)), 1)
			IF NOT Test_CouleurEGA = "" Then
				CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_Normal = Val(Test_CouleurEGA)
			End if

			IF CPCDOS_INSTANCE.SYSTEME_INSTANCE.get_DBG_DEBUG() > 0 Then
				IF CPCDOS_INSTANCE.Utilisateur_Langage = 0 Then
					DEBUG("[CpcdosC+] Couleurs graphiques choisies " & CRLF & " - Rouge " & CPCDOS_INSTANCE.SCI_INSTANCE.UTF8_INSTANCE.utf8_CouleurP_R & CRLF & " - Vert " & CPCDOS_INSTANCE.SCI_INSTANCE.UTF8_INSTANCE.utf8_CouleurP_V & CRLF & " - Bleu " & CPCDOS_INSTANCE.SCI_INSTANCE.UTF8_INSTANCE.utf8_CouleurP_B & CRLF & " - EGA " & CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_Normal, Affichage, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_Normal, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.AvecDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_CPCDOS, RetourVAR)
				Else
					DEBUG("[CpcdosC+] Selected graphic color " & CRLF & " - Red " & CPCDOS_INSTANCE.SCI_INSTANCE.UTF8_INSTANCE.utf8_CouleurP_R & CRLF & " - Green " & CPCDOS_INSTANCE.SCI_INSTANCE.UTF8_INSTANCE.utf8_CouleurP_V & CRLF & " - Blue " & CPCDOS_INSTANCE.SCI_INSTANCE.UTF8_INSTANCE.utf8_CouleurP_B & CRLF & " - EGA " & CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_Normal, Affichage, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_Normal, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.AvecDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_CPCDOS, RetourVAR)
				End if
			END IF
			' Recuperer les Parametres
			'DEBUG(Param, Affichage, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_Normal, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.SansDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_AFF, RetourVAR)

			' ===================================================================
			END SCOPE
			exit _scope_CMD, _scope
		End if ' **** COULEURC ****

	_end_scope_CMD

	_scope_CMD

		' ===============================================================
		'  Commande pour changer la couleur texte du fond
		' ===============================================================
		CommLANG(1) = "couleurf/"
		CommLANG(2) = "colorb/"
		CommLANG(3) = "\\#//"
		CommTrouve = 0 : NoCMD = 0
		for boucle as integer = 1 to 2
			IF OnCherche = CommLANG(boucle) Then
				NoCMD = 0
				exit for
			Else
				NoCMD = 1
			End if
		Next boucle
		IF NoCMD = 1 then CommLANG(1) = "[F.#).|" : CommLANG(2) = "[F.#).|" : CommLANG(3) = "\\#//"

		rem Afficher la liste des commandes avec anglais / francais
		IF AfficherAide = 1 then
			IF CPCDOS_INSTANCE.Utilisateur_Langage = 0 then
				CommandesAide = CommandesAide & CRLF & " couleurf/                  Changer la couleur arriere plan de la console"
			Else
				CommandesAide = CommandesAide & CRLF & " colorb/                    Change background color"

			END IF
		END IF

		IF CommLANG(1) = OnCherche Then CommTrouve = 1
		IF CommLANG(2) = OnCherche Then CommTrouve = 2
		IF CommTrouve > 0 Then
			IF AfficherAide = 2 then
				Mess_Aide = ""
				IF CPCDOS_INSTANCE.Utilisateur_Langage = 0 THEN
					Mess_Aide = Mess_Aide & CRLF & "  'CouleurFond'"
					Mess_Aide = Mess_Aide & CRLF
					Mess_Aide = Mess_Aide & CRLF & "  Fonctionnalit�e :"
					Mess_Aide = Mess_Aide & CRLF & "   Cette commande permet de changer la couleur de fond de la console LC"
					Mess_Aide = Mess_Aide & CRLF
					Mess_Aide = Mess_Aide & CRLF & "  Exemple :"
					Mess_Aide = Mess_Aide & CRLF & "   CouleurC/ R:255 V:100 B:010"
					Mess_Aide = Mess_Aide & CRLF & "   txt/ Je suis de couleur Orange"
					Mess_Aide = Mess_Aide & CRLF
					Mess_Aide = Mess_Aide & CRLF & "   couleurf/ R:255 V:000 B:000"
					Mess_Aide = Mess_Aide & CRLF & "   txt/ Rouge/#R"
					Mess_Aide = Mess_Aide & CRLF & "   couleurf/ V:255 R:000 B:000"
					Mess_Aide = Mess_Aide & CRLF & "   txt/  Vert/#R"
					Mess_Aide = Mess_Aide & CRLF & "   couleurf/ B:255 R:000 V:000"
					Mess_Aide = Mess_Aide & CRLF & "   txt/  Bleu/#R"
					Mess_Aide = Mess_Aide & CRLF & "   couleurf/ R:100"
					Mess_Aide = Mess_Aide & CRLF & "   txt/  Violet/#R"
					Mess_Aide = Mess_Aide & CRLF & "   couleurf/ V:255"
					Mess_Aide = Mess_Aide & CRLF & "   txt/  Bleu clair/#R"
					Mess_Aide = Mess_Aide & CRLF & "   couleurf/ B:255"
					Mess_Aide = Mess_Aide & CRLF & "   txt/  Blanc/#R"
					Mess_Aide = Mess_Aide & CRLF
					Mess_Aide = Mess_Aide & CRLF & "  Exemple console EGA (4 bits) 0 par defaut :"
					Mess_Aide = Mess_Aide & CRLF & "   couleurF/ 10"
					Mess_Aide = Mess_Aide & CRLF & "   Txt/ Je suis de couleur Bleue clair"
					Mess_Aide = Mess_Aide & CRLF & "   couleurf/ 4"
					Mess_Aide = Mess_Aide & CRLF & "   txt/ Je suis de couleur route"
					Mess_Aide = Mess_Aide & CRLF
					Mess_Aide = Mess_Aide & CRLF & "   0:Noir 1:Bleu 2:Vert 3:Cyan 4:Rouge 5:Magenta 6:Brun 7:Gris clair 8:Gris fonce"
					Mess_Aide = Mess_Aide & CRLF & "   9:Bleu brillant 10:Vert brillant 11:Cyan brillant 12:Rouge brillant"
					Mess_Aide = Mess_Aide & CRLF & "   13:Magenta brillant 14:Jaune 15:Blanc"
					Mess_Aide = Mess_Aide & CRLF
					Mess_Aide = Mess_Aide & CRLF & "  Voir aussi : txt/ , couleurc/"
					Mess_Aide = Mess_Aide & CRLF
				ELSEIF CPCDOS_INSTANCE.Utilisateur_Langage = 1 THEN
					Mess_Aide = Mess_Aide & CRLF & "  'ColorBackground'"
					Mess_Aide = Mess_Aide & CRLF
					Mess_Aide = Mess_Aide & CRLF & "  Fonctionnality :"
					Mess_Aide = Mess_Aide & CRLF & "   This command allow to change background console"
					Mess_Aide = Mess_Aide & CRLF
					Mess_Aide = Mess_Aide & CRLF & "  Exemple :"
					Mess_Aide = Mess_Aide & CRLF & "   colorf/ R:255 V:100 B:010"
					Mess_Aide = Mess_Aide & CRLF & "   txt/ Je suis de couleur Orange"
					Mess_Aide = Mess_Aide & CRLF
					Mess_Aide = Mess_Aide & CRLF & "   colorb/ R:255 V:000 B:000"
					Mess_Aide = Mess_Aide & CRLF & "   txt/ Red/#R"
					Mess_Aide = Mess_Aide & CRLF & "   colorb/ V:255 R:000 B:000"
					Mess_Aide = Mess_Aide & CRLF & "   txt/  Green/#R"
					Mess_Aide = Mess_Aide & CRLF & "   colorb/ B:255 R:000 V:000"
					Mess_Aide = Mess_Aide & CRLF & "   txt/  Blue/#R"
					Mess_Aide = Mess_Aide & CRLF & "   colorb/ R:100"
					Mess_Aide = Mess_Aide & CRLF & "   txt/  Purple/#R"
					Mess_Aide = Mess_Aide & CRLF & "   colorb/ V:255"
					Mess_Aide = Mess_Aide & CRLF & "   txt/  light blue/#R"
					Mess_Aide = Mess_Aide & CRLF & "   colorb/ B:255"
					Mess_Aide = Mess_Aide & CRLF & "   txt/  White/#R"
					Mess_Aide = Mess_Aide & CRLF
					Mess_Aide = Mess_Aide & CRLF & "  EGA Console example (4 bits) 0 by default:"
					Mess_Aide = Mess_Aide & CRLF & "   colorb/ 10"
					Mess_Aide = Mess_Aide & CRLF & "   Txt/ I'm in blue color"
					Mess_Aide = Mess_Aide & CRLF & "   colorB/ 4"
					Mess_Aide = Mess_Aide & CRLF & "   txt/ I in red color"
					Mess_Aide = Mess_Aide & CRLF
					Mess_Aide = Mess_Aide & CRLF & "   0:Black 1:Blue 2:Green 3:Cyan 4:Red 5:Magenta 6:Brun 7:Ligh gray 8:Black gray"
					Mess_Aide = Mess_Aide & CRLF & "   9:Light blue 10:Light green 11:Light cyan 12:Light red 13:Light magenta"
					Mess_Aide = Mess_Aide & CRLF & "   14:Yellow 15:White"
					Mess_Aide = Mess_Aide & CRLF
					Mess_Aide = Mess_Aide & CRLF & "  See also : txt/ , colorf/"
					Mess_Aide = Mess_Aide & CRLF
				END IF
				DEBUG(Mess_Aide, Affichage, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_SURBRILLE, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.SansDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_AFF, RetourVAR)
				testCMD = 0
				AfficherAide = 0
				exit _scope_CMD, _scope
			END IF
			' Tester la syntaxe
			testCMD	= CCP_Verifier_Syntaxe(Commande, CommPosition)
			IF testCMD > 10 Then exit _scope_CMD, _scope
			IF testCMD > 0 then  ' Entre 1-5 = Pas d'Affichage via le @, @$ ou @#
				IF testCMD < 6 then
					Affichage = 0
					IF testCMD = 3 Then CpcdosCP_SHELL("FIX/ " & CPCDOS_INSTANCE.DEBUG_INSTANCE.LeRetour & " = \#NULL", _CLE_, NIVEAU_CCP, Param_1, Param_2) : RetourVAR = _CLE_ & "N" & NIVEAU_CCP & "->" & CPCDOS_INSTANCE.DEBUG_INSTANCE.LeRetour
					if testCMD = 2 Then RetourVAR = "$>" & CPCDOS_INSTANCE.DEBUG_INSTANCE.LeRetour ' ajouter une securite ?
				Else
					Affichage = 1
				END IF
			Else
				Affichage = 1
			END IF
			' Recuperer les Parametres
			Param = MID(Commande, CommPosition + TailleComm + 2)
			SCOPE
			' ====================================================================
			Dim couleurC_R				as Integer
			Dim couleurC_V				as Integer
			Dim couleurC_B				as Integer

			Dim Test_CouleurEGA as String
			Param = UCASE(Param)
			' On recherche les couleurs
			couleurC_R = instr(UCASE(Param), "R:")
			couleurC_V = instr(UCASE(Param), "V:")
			IF couleurC_V < 1 Then couleurC_V = instr(UCASE(Param), "G:")
			couleurC_B = instr(UCASE(Param), "B:")
			' Et on attribue
			IF couleurC_R > 0 Then CPCDOS_INSTANCE.SCI_INSTANCE.UTF8_INSTANCE.utf8_CouleurF_R = Val(MID(Param, couleurC_R + 2, 3))
			IF couleurC_V > 0 Then CPCDOS_INSTANCE.SCI_INSTANCE.UTF8_INSTANCE.utf8_CouleurF_V = Val(MID(Param, couleurC_V + 2, 3))
			IF couleurC_B > 0 Then CPCDOS_INSTANCE.SCI_INSTANCE.UTF8_INSTANCE.utf8_CouleurF_B = Val(MID(Param, couleurC_B + 2, 3))

			' Tester si c'est une couleur EGA
			Test_CouleurEGA = MID(LTRIM(RTRIM(LTRIM(Param)), CHR(09)), 1)
			IF NOT Test_CouleurEGA = "" Then
				CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_FOND_caractere = Val(Test_CouleurEGA)
			End if

			IF CPCDOS_INSTANCE.SYSTEME_INSTANCE.get_DBG_DEBUG() > 0 Then
				IF CPCDOS_INSTANCE.Utilisateur_Langage = 0 Then
					DEBUG("[CpcdosC+] Couleurs fond console choisies " & CRLF & " - Rouge " & CPCDOS_INSTANCE.SCI_INSTANCE.UTF8_INSTANCE.utf8_CouleurP_R & CRLF & " - Vert " & CPCDOS_INSTANCE.SCI_INSTANCE.UTF8_INSTANCE.utf8_CouleurP_V & CRLF & " - Bleu " & CPCDOS_INSTANCE.SCI_INSTANCE.UTF8_INSTANCE.utf8_CouleurP_B, Affichage, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_Normal, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.AvecDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_CPCDOS, RetourVAR)
				Else
					DEBUG("[CpcdosC+] Selected console background color " & CRLF & " - Red " & CPCDOS_INSTANCE.SCI_INSTANCE.UTF8_INSTANCE.utf8_CouleurP_R & CRLF & " - Green " & CPCDOS_INSTANCE.SCI_INSTANCE.UTF8_INSTANCE.utf8_CouleurP_V & CRLF & " - Blue " & CPCDOS_INSTANCE.SCI_INSTANCE.UTF8_INSTANCE.utf8_CouleurP_B, Affichage, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_Normal, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.AvecDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_CPCDOS, RetourVAR)
				End if
			END IF
			' Recuperer les Parametres
			'DEBUG(Param, Affichage, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_Normal, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.SansDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_AFF, RetourVAR)

			' ===================================================================
			END SCOPE
			exit _scope_CMD, _scope
		End if ' **** COULEURF/ ****

	_end_scope_CMD

	_scope_CMD

		' ===============================================================
		'  Commande pour declarer une fonction CpcdosC+
		' ===============================================================
		CommLANG(1) = "declarer/"
		CommLANG(2) = "declare/"
		CommLANG(3) = "\\#//"
		CommTrouve = 0 : NoCMD = 0
		for boucle as integer = 1 to 2
			IF OnCherche = CommLANG(boucle) Then
				NoCMD = 0
				exit for
			Else
				NoCMD = 1
			End if
		Next boucle
		IF NoCMD = 1 then CommLANG(1) = "[F.#).|" : CommLANG(2) = "[F.#).|" : CommLANG(3) = "\\#//"
		rem Afficher la liste des commandes avec anglais / francais
		IF AfficherAide = 1 then
			IF CPCDOS_INSTANCE.Utilisateur_Langage = 0 then
				CommandesAide = CommandesAide & CRLF & " declarer/                  Declare une fonction CpcdosC+ a un niveau choisis"
			Else
				CommandesAide = CommandesAide & CRLF & " declare/                   Declare CpcdosC+ function with a level"
			END IF
		END IF

		IF CommLANG(1) = OnCherche Then CommTrouve = 1
		IF CommLANG(2) = OnCherche Then CommTrouve = 2

		IF CommTrouve > 0 Then
			IF AfficherAide = 2 then
				Mess_Aide = ""
				IF CPCDOS_INSTANCE.Utilisateur_Langage = 0 THEN
					Mess_Aide = Mess_Aide & CRLF & "  'DECLARER'"
					Mess_Aide = Mess_Aide & CRLF
					Mess_Aide = Mess_Aide & CRLF & "  Fonctionnalit�e :"
					Mess_Aide = Mess_Aide & CRLF & "   Cette commande permet de declarer une fonction CpcdosC+ avec un niveau de"
					Mess_Aide = Mess_Aide & CRLF & "    visibilite (publicite) personnalisable."
					Mess_Aide = Mess_Aide & CRLF
					Mess_Aide = Mess_Aide & CRLF & "  Exemple 1 (Visible partout) :"
					Mess_Aide = Mess_Aide & CRLF & "   declarer/ Un_Exemple() : niveau(5)"
					Mess_Aide = Mess_Aide & CRLF & "   Fonction/ Un_exemple()"
					Mess_Aide = Mess_Aide & CRLF & "      retour/ Toto!"
					Mess_Aide = Mess_Aide & CRLF & "   Fin/ fonction"
					Mess_Aide = Mess_Aide & CRLF & "   Txt/ /F:Un_Exemple()"
					Mess_Aide = Mess_Aide & CRLF
					Mess_Aide = Mess_Aide & CRLF & "  Affiche : Toto!"
					Mess_Aide = Mess_Aide & CRLF
					Mess_Aide = Mess_Aide & CRLF & "  Exemple 2(Visible que pour l'application) :"
					Mess_Aide = Mess_Aide & CRLF & "   declarer/ Un_Exemple() : niveau(2)"
					Mess_Aide = Mess_Aide & CRLF & "   Fonction/ Un_exemple()"
					Mess_Aide = Mess_Aide & CRLF & "      txt/ Je suis dans ma fonction!"
					Mess_Aide = Mess_Aide & CRLF & "      retour/ Voila c'est finis!"
					Mess_Aide = Mess_Aide & CRLF & "   Fin/ fonction"
					Mess_Aide = Mess_Aide & CRLF & "   Txt/ /F:Un_Exemple()"
					Mess_Aide = Mess_Aide & CRLF
					Mess_Aide = Mess_Aide & CRLF & "  Affiche : Je suis dans ma fonction!"
					Mess_Aide = Mess_Aide & CRLF & "            Voila c'est finis!"
					Mess_Aide = Mess_Aide & CRLF
					' Mess_Aide = Mess_Aide & CRLF & "  Exemple 3 (Declarer depuis l'exterieur)"
					' Mess_Aide = Mess_Aide & CRLF & "   ccp/ /fix.niveau = 2"
					' Mess_Aide = Mess_Aide & CRLF & "   declarer/ Un_Exemple():MonProgramme.cpc"
					' Mess_Aide = Mess_Aide & CRLF & "   Txt/ /F:Un_Exemple()"
					' Mess_Aide = Mess_Aide & CRLF
					' Mess_Aide = Mess_Aide & CRLF & "  Exemple 4 (Avec 2 arguments)"
					' Mess_Aide = Mess_Aide & CRLF & "   ccp/ /fix.niveau = 2"
					' Mess_Aide = Mess_Aide & CRLF & "   declarer/ Additionner(Valeur1, Valeur2)"
					' Mess_Aide = Mess_Aide & CRLF & "   Fonction/ Additionner(Valeur1, Valeur2)"
					' Mess_Aide = Mess_Aide & CRLF & "      retour/ /C(Valeur1 + Valeur2)"
					' Mess_Aide = Mess_Aide & CRLF & "   Fin/ fonction"
					' Mess_Aide = Mess_Aide & CRLF & "   Txt/ Resultat /F:Additionner(5, 2)"
					Mess_Aide = Mess_Aide & CRLF
					Mess_Aide = Mess_Aide & CRLF & "  Affiche : Resultat 7"
					Mess_Aide = Mess_Aide & CRLF
					Mess_Aide = Mess_Aide & CRLF & "  Voir aussi : txt/ , ccp/"
					Mess_Aide = Mess_Aide & CRLF
				ELSEIF CPCDOS_INSTANCE.Utilisateur_Langage = 1 THEN
					Mess_Aide = Mess_Aide & CRLF & "  Fonctionnality :"
					Mess_Aide = Mess_Aide & CRLF & "   This command allow to declare CpcdosC+ function"
					Mess_Aide = Mess_Aide & CRLF
					Mess_Aide = Mess_Aide & CRLF & "  Exemple 1 (public method) :"
					Mess_Aide = Mess_Aide & CRLF & "   declare/ My_Exemple() : level(5)"
					Mess_Aide = Mess_Aide & CRLF & "   Function/ My_Exemple()"
					Mess_Aide = Mess_Aide & CRLF & "      Return/ Foo!"
					Mess_Aide = Mess_Aide & CRLF & "   End/ Function"
					Mess_Aide = Mess_Aide & CRLF & "   Txt/ /F:My_Exemple()"
					Mess_Aide = Mess_Aide & CRLF
					Mess_Aide = Mess_Aide & CRLF & "  Display : Foo!"
					Mess_Aide = Mess_Aide & CRLF
					Mess_Aide = Mess_Aide & CRLF & "  Exemple 2(Public for current application only) :"
					Mess_Aide = Mess_Aide & CRLF & "   ccp/ /set.level = 2"
					Mess_Aide = Mess_Aide & CRLF & "   declare/ My_Exemple() : level(2)"
					Mess_Aide = Mess_Aide & CRLF & "   Fonction/ My_Exemple()"
					Mess_Aide = Mess_Aide & CRLF & "      txt/ I'm in my function!"
					Mess_Aide = Mess_Aide & CRLF & "      return/ tada!!"
					Mess_Aide = Mess_Aide & CRLF & "   Fin/ fonction"
					Mess_Aide = Mess_Aide & CRLF & "   Txt/ /F:My_Exemple()"
					Mess_Aide = Mess_Aide & CRLF
					Mess_Aide = Mess_Aide & CRLF & "  Affiche : I'm in my function!"
					Mess_Aide = Mess_Aide & CRLF & "            tada!!"
					Mess_Aide = Mess_Aide & CRLF
					' Mess_Aide = Mess_Aide & CRLF & "  Exemple 3 (Declarer from extern)"
					' Mess_Aide = Mess_Aide & CRLF & "   ccp/ /set.level = 2"
					' Mess_Aide = Mess_Aide & CRLF & "   declare/ My_Exemple():MyProgram.cpc"
					' Mess_Aide = Mess_Aide & CRLF & "   Txt/ /F:My_Exemple()"
					' Mess_Aide = Mess_Aide & CRLF
					' Mess_Aide = Mess_Aide & CRLF & "  Exemple 4 (With 2 arguments)"
					' Mess_Aide = Mess_Aide & CRLF & "   ccp/ /set.level = 2"
					' Mess_Aide = Mess_Aide & CRLF & "   Declare/ Addition(Value1, Value2)"
					' Mess_Aide = Mess_Aide & CRLF & "   Fonction/ Addition(Value1, Value2)"
					' Mess_Aide = Mess_Aide & CRLF & "      retourner/ /C(Value1 + Value2)"
					' Mess_Aide = Mess_Aide & CRLF & "   End/ function"
					' Mess_Aide = Mess_Aide & CRLF & "   Txt/ Results /F:Addition(5, 2)"
					Mess_Aide = Mess_Aide & CRLF
					Mess_Aide = Mess_Aide & CRLF & "  Affiche : Results 7"
					Mess_Aide = Mess_Aide & CRLF
					Mess_Aide = Mess_Aide & CRLF & "  See also : txt/ , ccp/"
					Mess_Aide = Mess_Aide & CRLF
				END IF
				DEBUG(Mess_Aide, Affichage, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_SURBRILLE, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.SansDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_AFF, RetourVAR)
				testCMD = 0
				AfficherAide = 0
				exit _scope_CMD, _scope
			END IF
			' Tester la syntaxe
			testCMD	= CCP_Verifier_Syntaxe(Commande, CommPosition)
			IF testCMD > 10 Then exit _scope_CMD, _scope
			IF testCMD > 0 then  ' Entre 1-5 = Pas d'affichage via le @, @$ ou @#
				IF testCMD < 6 then
					Affichage = 0
					IF testCMD = 3 Then CpcdosCP_SHELL("FIX/ " & CPCDOS_INSTANCE.DEBUG_INSTANCE.LeRetour & " = \#NULL", _CLE_, NIVEAU_CCP, Param_1, Param_2) : RetourVAR = _CLE_ & "N" & NIVEAU_CCP & "->" & CPCDOS_INSTANCE.DEBUG_INSTANCE.LeRetour
					if testCMD = 2 Then RetourVAR = "$>" & CPCDOS_INSTANCE.DEBUG_INSTANCE.LeRetour ' ajouter une securite ?
				Else
					Affichage = 1
				END IF
			Else
				Affichage = 1
			END IF
			' Recuperer les Parametres
			Param = MID(Commande, CommPosition + TailleComm + 2)
			SCOPE
			' ====================================================================

			Dim NIVEAU_CCP_FONCT		as integer = 2 ' Par defaut
			Dim Position_Fonction 		as integer = 1
			Dim Position_1erParenthese 	as integer = Instr(Param, "(")
			Dim Position_2emParenthese	as integer = Instr(Param, ")")

			Dim NomFonction 			as string = Mid(Param, Position_Fonction, (Position_1erParenthese) - Position_Fonction)

			Dim Arguments 				as string = Mid(Param, Position_1erParenthese + 1, Position_2emParenthese - (Position_1erParenthese + 1))

			Dim Boucle as integer
			For Boucle = 1 to this.MEMOIRE_CCP._MAX_FONCTION_PUBLIC
				IF this.MEMOIRE_CCP.TAB_FONCTION_CCP_NOM(Boucle) = "" Then
					exit for
				End if
			Next Boucle

			this.MEMOIRE_CCP.TAB_FONCTION_CCP_NOM(Boucle) = Ucase(NomFonction)

			' On recupere le nombre d'arguments
			Dim Pos_Virgule_DEBUT 	as integer = 0
			Dim Pos_Virgule_FIN 	as integer = 0

			For Boucle_ARGS 		as integer = 0 to this.MEMOIRE_CCP._MAX_FONCTION_ARGS
				' Recuperer les positions
				Pos_Virgule_DEBUT = Pos_Virgule_FIN + 1
				Pos_Virgule_FIN = Instr(Pos_Virgule_DEBUT, Arguments, ",")

				' Verifier la presence d'une vigule
				IF Pos_Virgule_FIN = 0 Then
					IF Boucle_ARGS = 0 Then exit for ' Aucun arguments
					' Ah .. C'est finis mon gros ;)
					this.MEMOIRE_CCP.TAB_FONCTION_CCP_ARG(Boucle) = Boucle_ARGS
					exit for
				End if
			Next Boucle_ARGS

			' Il y a 1 argument
			IF NOT Arguments = "" Then this.MEMOIRE_CCP.TAB_FONCTION_CCP_ARG(Boucle) = this.MEMOIRE_CCP.TAB_FONCTION_CCP_ARG(Boucle) + 1

			' ON recupere le chemin d'acces de la fonction
			this.MEMOIRE_CCP.TAB_FONCTION_CCP_SRC(Boucle) = Gest_variables_LIRE("_EXE_PATH_", 2, Auth_Kernel, Auth_OS, Auth_Utilisateur, Auth_PID, Auth_TID)

			' On recherche le niveau de publicite.
			'  REMARQUE: Niveau 2 et 1 ne peuvent etre definit puisse que par defaut
			'				les fonctions sont d�j� au niveau 2 et le 1 le voit.
			IF instr(Param, ":") < Instr(Ucase(Param), "NIVEAU(5)") OR instr(Param, ":") < Instr(Ucase(Param), "LEVEL(5)") Then
				this.MEMOIRE_CCP.TAB_FONCTION_CCP_NIV(Boucle) = 5
			ElseIF instr(Param, ":") < Instr(Ucase(Param), "NIVEAU(4)") OR instr(Param, ":") < Instr(Ucase(Param), "LEVEL(4)") Then
				this.MEMOIRE_CCP.TAB_FONCTION_CCP_NIV(Boucle) = 4
			ELSEIF instr(Param, ":") < Instr(Ucase(Param), "NIVEAU(3)") OR instr(Param, ":") < Instr(Ucase(Param), "LEVEL(3)") Then
				this.MEMOIRE_CCP.TAB_FONCTION_CCP_NIV(Boucle) = 3
			ELSEIF instr(Param, ":") < Instr(Ucase(Param), "NIVEAU(2)") OR instr(Param, ":") < Instr(Ucase(Param), "LEVEL(2)") Then ' par defaut
				this.MEMOIRE_CCP.TAB_FONCTION_CCP_NIV(Boucle) = 2
			ELSEIF instr(Param, ":") < Instr(Ucase(Param), "NIVEAU(1)") OR instr(Param, ":") < Instr(Ucase(Param), "LEVEL(1)") Then ' Inutile!
				this.MEMOIRE_CCP.TAB_FONCTION_CCP_NIV(Boucle) = 3
				Message_erreur = ERRAVT("AVT_064", 0)
				IF CPCDOS_INSTANCE.Utilisateur_Langage = 0 Then
					DEBUG("[CpcdosC+] " & Message_erreur & ". Definition automatique sur niveau 3. Nom de la fonction : " & NomFonction & ".", CPCDOS_INSTANCE.DEBUG_INSTANCE.Ecran, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_AVERTISSEMENT, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.SansDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_AFF, RetourVAR)
				Else
					DEBUG("[CpcdosC+] " & Message_erreur & ". Automatic definition to level 3. Function name : " & NomFonction & ".", CPCDOS_INSTANCE.DEBUG_INSTANCE.Ecran, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_AVERTISSEMENT, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.SansDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_AFF, RetourVAR)
				End if
			End if

			IF CPCDOS_INSTANCE.SYSTEME_INSTANCE.get_DBG_DEBUG() > 0 Then
				IF CPCDOS_INSTANCE.Utilisateur_Langage = 0 Then
					DEBUG("[CpcdosC+] Inscription de la fonction '" & this.MEMOIRE_CCP.TAB_FONCTION_CCP_NOM(Boucle) & "()' en memoire. " & this.MEMOIRE_CCP.TAB_FONCTION_CCP_ARG(Boucle) & " argument(s). Niveau : " & this.MEMOIRE_CCP.TAB_FONCTION_CCP_NIV(Boucle) & ". Source d'importation : '" & this.MEMOIRE_CCP.TAB_FONCTION_CCP_SRC(Boucle) & "'. [OK]", CPCDOS_INSTANCE.DEBUG_INSTANCE.Ecran, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_VALIDATION, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.SansDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_CPCDOS, "")
				Else
					DEBUG("[CpcdosC+] Registration function '" & this.MEMOIRE_CCP.TAB_FONCTION_CCP_NOM(Boucle) & "()' in memory. " & this.MEMOIRE_CCP.TAB_FONCTION_CCP_ARG(Boucle) & " argument(s). Level : " & this.MEMOIRE_CCP.TAB_FONCTION_CCP_NIV(Boucle) & ". Importation source : '" & this.MEMOIRE_CCP.TAB_FONCTION_CCP_SRC(Boucle) & "'. [OK]", CPCDOS_INSTANCE.DEBUG_INSTANCE.Ecran, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_VALIDATION, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.SansDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_CPCDOS, "")
				End if
				DEBUG("(" & Auth_Kernel & ", " & Auth_OS & ", " & Auth_Utilisateur & ", " & Auth_PID & ", " & Auth_TID & ")", CPCDOS_INSTANCE.DEBUG_INSTANCE.Ecran, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_VALIDATION, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.SansDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_CPCDOS, "")
			End if

			' ===================================================================
			END SCOPE
			exit _scope_CMD, _scope
		End if ' **** DECLARER/ ****

	_end_scope_CMD

	_scope_CMD

		' ===============================================================
		'  Commande pour executer une application DOS
		' ===============================================================
		CommLANG(1) = "dos/"
		CommLANG(2) = "dos/"
		CommLANG(3) = "\\#//"
		CommTrouve = 0 : NoCMD = 0
		for boucle as integer = 1 to 2
			IF OnCherche = CommLANG(boucle) Then
				NoCMD = 0
				exit for
			Else
				NoCMD = 1
			End if
		Next boucle
		IF NoCMD = 1 then CommLANG(1) = "[F.#).|" : CommLANG(2) = "[F.#).|" : CommLANG(3) = "\\#//"

		rem Afficher la liste des commandes avec anglais / francais
		IF AfficherAide = 1 then
			IF CPCDOS_INSTANCE.Utilisateur_Langage = 0 then
				CommandesAide = CommandesAide & CRLF & " dos/                       Lancer un fichier/une commande DOS"
			Else
				CommandesAide = CommandesAide & CRLF & " dos/                       Launch a DOS file/Command"
			END IF
		END IF
		IF CommLANG(1) = OnCherche Then CommTrouve = 1
		IF CommLANG(2) = OnCherche Then CommTrouve = 2
		IF CommTrouve > 0 Then
		IF AfficherAide = 2 then
				Mess_Aide = ""
				IF CPCDOS_INSTANCE.Utilisateur_Langage = 0 THEN
					Mess_Aide = Mess_Aide & CRLF & "  Fonctionnalit�e :"
					Mess_Aide = Mess_Aide & CRLF & "   Cette commande permet d'executer un fichier ou une commande DOS"
					Mess_Aide = Mess_Aide & CRLF
					Mess_Aide = Mess_Aide & CRLF & "  Exemple simple :"
					Mess_Aide = Mess_Aide & CRLF & "   DOS/ EDIT.COM"
					Mess_Aide = Mess_Aide & CRLF & "   DOS/ Echo Coucou"
					Mess_Aide = Mess_Aide & CRLF & "   DOS/ MonProg.bat"
					Mess_Aide = Mess_Aide & CRLF
					Mess_Aide = Mess_Aide & CRLF & "  Voir aussi : "
					Mess_Aide = Mess_Aide & CRLF
				ELSEIF CPCDOS_INSTANCE.Utilisateur_Langage = 1 THEN
					Mess_Aide = Mess_Aide & CRLF & "  Fonctionnality :"
					Mess_Aide = Mess_Aide & CRLF & "   This command allow to launch a DOS command or file."
					Mess_Aide = Mess_Aide & CRLF
					Mess_Aide = Mess_Aide & CRLF & " Simple example:"
					Mess_Aide = Mess_Aide & CRLF & "   DOS/ EDIT.COM"
					Mess_Aide = Mess_Aide & CRLF & "   DOS/ Echo Coucou"
					Mess_Aide = Mess_Aide & CRLF & "   DOS/ MonProg.bat"
					Mess_Aide = Mess_Aide & CRLF
					Mess_Aide = Mess_Aide & CRLF & "  See also : "
					Mess_Aide = Mess_Aide & CRLF
				END IF
				DEBUG(Mess_Aide, Affichage, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_SURBRILLE, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.SansDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_AFF, RetourVAR)
				testCMD = 0
				AfficherAide = 0
				exit _scope_CMD, _scope
			END IF
			' Tester la syntaxe
			testCMD	= CCP_Verifier_Syntaxe(Commande, CommPosition)
			IF testCMD > 10 Then exit _scope_CMD, _scope
			IF testCMD > 0 then  ' Entre 1-5 = Pas d'affichage via le @, @$ ou @#
				IF testCMD < 6 then
					Affichage = 0
					IF testCMD = 3 Then CpcdosCP_SHELL("FIX/ " & CPCDOS_INSTANCE.DEBUG_INSTANCE.LeRetour & " = \#NULL", _CLE_, NIVEAU_CCP, Param_1, Param_2) : RetourVAR = _CLE_ & "N" & NIVEAU_CCP & "->" & CPCDOS_INSTANCE.DEBUG_INSTANCE.LeRetour
					if testCMD = 2 Then RetourVAR = "$>" & CPCDOS_INSTANCE.DEBUG_INSTANCE.LeRetour ' ajouter une securite ?
				Else
					Affichage = 1
				END IF
			Else
				Affichage = 1
			END IF
			' Recuperer les Parametres
			Param = MID(Commande, CommPosition + TailleComm + 2)
			SCOPE
			' ===================================================================

			CpcdosCP_SHELL("/F:Before_DOS()", _CLE_, NIVEAU_CCP, Param_1, Param_2)
			SHELL(Param)
			CpcdosCP_SHELL("/F:After_DOS()", _CLE_, NIVEAU_CCP, Param_1, Param_2)

			' ===================================================================
			END SCOPE
			exit _scope_CMD, _scope
		End if ' **** DOS/ ****



	_end_scope_CMD


	_end_scope


	' =========================================================
	' ========================= F I N =========================
	' =========================================================


	IF LEN(CommandesAide) > 1 then
	REM IF CommandesAide <> "" then
		DEBUG(CommandesAide, CPCDOS_INSTANCE.DEBUG_INSTANCE.Ecran, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.couleur_normal, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.SansDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_AFF, RetourVAR)

		CommandesAide = ""
	else
		IF VerifierLabel = 0 then ' Si ce n'est pas non plus un label
			IF CommTrouve = 0 then
				Message_erreur = ERRAVT("ERR_009", 0)
				IF Numero_de_Ligne > 0 Then Message_erreur = "(lgn:" & Numero_de_Ligne & ") " & Message_erreur
				DEBUG("[CpcdosC+] " & Message_erreur & " " & CHR(34) & Commande & CHR(34) & ".", CPCDOS_INSTANCE.DEBUG_INSTANCE.Ecran, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_ERREUR, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.SansDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_AFF, RetourVAR)

				' IF CPCDOS_INSTANCE.SCI_INSTANCE.GUI_Exec = TRUE AND CPCDOS_INSTANCE.SCI_INSTANCE.GUI_Mode = TRUE then
					' CpcdosCP_SHELL("Msgbox/ " & Message_erreur & " " & CHR(34) & Commande & CHR(34) & ". /TITLE:ERR_009 : " & Nom_Fichier_DBG & ":" & Numero_de_Ligne & " - CpcdosC+ Shell /ERROR:3", _CLE_, NIVEAU_CCP, Param_1, Param_2)
				' End if

				CpcdosCP_SHELL = "ERR_009"
			End if
		End if
	END IF
	IF testCMD > 10 Then
		Message_erreur = ERRAVT("ERR_010", 0)
		IF Numero_de_Ligne > 0 Then Message_erreur = "(" & Nom_Fichier_DBG & ":" & Numero_de_Ligne & ") " & Message_erreur
		DEBUG("[SHELL CC+] > " & Message_erreur & " " & CHR(34) & _COMMANDE_ & CHR(34) & " -> '" & CHR(testCMD - 10) & "'.", CPCDOS_INSTANCE.DEBUG_INSTANCE.Ecran, CPCDOS_INSTANCE.DEBUG_INSTANCE.NonLog, CPCDOS_INSTANCE.DEBUG_INSTANCE.Couleur_Erreur, 0, CPCDOS_INSTANCE.DEBUG_INSTANCE.CRLF, CPCDOS_INSTANCE.DEBUG_INSTANCE.AvecDate, CPCDOS_INSTANCE.DEBUG_INSTANCE.SIGN_AFF, RetourVAR)

		' IF CPCDOS_INSTANCE.SCI_INSTANCE.GUI_Exec = TRUE AND CPCDOS_INSTANCE.SCI_INSTANCE.GUI_Mode = TRUE then
			' CpcdosCP_SHELL("Msgbox/ " & Message_erreur & " " & CHR(34) & _COMMANDE_ & CHR(34) & " -> '" & CHR(testCMD - 10) & " /TITLE:ERR_010:" & Nom_Fichier_DBG & ":" & Numero_de_Ligne & " - CpcdosC+ Shell /ERROR:3", _CLE_, NIVEAU_CCP, Param_1, Param_2)
		' End if

		CpcdosCP_SHELL = "ERR_010"
	End if

	exit function
	' *** E R R O R   I N T E R C E P T I O N ***
	Intercept_Error:
		cpinti.signals.panic(Err, Erl, cptr(ZString ptr, Ermn), cptr(ZString ptr, Erfn))

End Function
